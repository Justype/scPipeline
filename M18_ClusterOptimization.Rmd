---
title: "Cluster Optimization"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("scMiko", "Seurat", "sctransform", "clustree", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "ddpcr", "readxl", "MAST", 
                   "future", "cluster", "doParallel", "parallel", "foreach")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))


```


```{r parameter specification}



# Query input
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "R34_M27_NM2_0_01ds_p4789_allGBM_120820.Rdata"
input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"

# Rapid marker finding (logical flag)
quick_markers <- TRUE 

# specify cluster resolution
# cluster_resolution <- c(0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
cluster_resolution <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.75, 1)
# cluster_resolution <- c(0.01, 0.15, 0.45, 0.7, 1)

# log fold change threshold
lfc.threshold <- 0.5

# p.value threshold <- p.threshold
p.threshold <- 0.01

# print inline
print.inline <- FALSE

# markers to visualize on cluster tree (set as NA if none specified)
cluster.tree.markers <- NA
# cluster.tree.markers <- c("cd68", "cd3", "cd45", "cd279", "cd81", "cd80", "cd27", "Gpnmb", "Sox6", "Ptprz1", "Cd133")
# cluster.tree.markers <- c("Bnc2", "Ptgs2", "Unc5b", "Twist2", "Efs", "Plxnb3", "Gjb3", "Lancl3", "Gas1", "Pdpn", "Stc2")

# 
which.species <- "Mm"

# Data subsampling
subsample_factor <- 0.5 # OPTIONAL; range 0 to 1 (default = 1)

# specify number of workers (for parallelization)
n.workers <- list(
  clustering = 4, # data clustering
  deg = 4         # DEG analysis
)

# which markers to return
only.pos <- T # 

# DEG test
DEG.test <- "MAST" #options: wilcox, bimod, roc, t, poisson, negbinom, LR, MAST, DESeq2

# save PDF
save.pdf <- T


```


```{r analysis log}

# Module
df.log <- initiateLog("18, Cluster Optimization")

df.log <- addLogEntry("Input File (.Rdata)", input.file, df.log, "input.file")
df.log <- addLogEntry("Log FC Threshold", lfc.threshold, df.log, "lfc.threshold")
df.log <- addLogEntry("p value Threshold", p.threshold, df.log, "p.threshold")
df.log <- addLogEntry("Rapid Marker Find", quick_markers, df.log, "quick_markers")
df.log <- addLogEntry("Positive Markers Only", only.pos, df.log, "only.pos")
df.log <- addLogEntry("DEG test", DEG.test, df.log, "DEG.test")
df.log <- addLogEntry("Cluster Resolution", cluster_resolution, df.log, "cluster_resolution")
df.log <- addLogEntry("Subsample Factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Figures Printed in Notebook", unlist(print.inline), df.log, "print.inline")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")


```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= NULL, subset = NULL, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "corr", "gsva", "deg"), rmv.pattern = "so", 
                         scale.reprocessed = T, neighbors.reprocessed = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r cluster data}

# initiate list to store cluster plots
plt.umap_by_cluster <- list()
cluster.name <- c()

# get cluster identify pattern
assay.names <- names(so.query@assays)
assay.holder <- DefaultAssay(so.query)
if ("integrated" %in% assay.names){
  DefaultAssay(so.query) <- "integrated"
} 
current.assay <- DefaultAssay(so.query)
assay.pattern <- paste0(current.assay, "_snn_res.")

# start cluster
if (n.workers$clustering > length(cluster_resolution)) n.workers$clustering <-length(cluster_resolution)
cl <- parallel::makeCluster(n.workers$clustering)
doParallel::registerDoParallel(cl)

# ensure neighbors computed
if (length(so.query@graphs) == 0){
  pca.prop <- propVarPCA(so.query)
  target.pc <- max(pca.prop$pc.id[pca.prop$pc.cum_sum<0.9])+1
  so.query <- FindNeighbors(so.query, verbose = F, reduction = "pca", dims = 1:target.pc)
}

# iterate through each input file
cluster.membership <- foreach(i = 1:length(cluster_resolution), .packages = c("Seurat"))  %dopar% {
  so.query <- FindClusters(object = so.query, resolution = cluster_resolution[i], verbose = 0, algorithm = 1, modularity.fxn = 1)
  return(so.query@meta.data[[paste0(assay.pattern, cluster_resolution[i])]])
}

# stop workers
parallel::stopCluster(cl)


# retrieve data
for (i in 1:length(cluster_resolution)) {
  
  # get cluster name
  current.cluster <- paste0(assay.pattern, cluster_resolution[i])
  so.query@meta.data[[current.cluster]] <- cluster.membership[[i]]
  cluster.name[i] <- paste(DefaultAssay(so.query),"_snn_res.", cluster_resolution[i], sep = "")

  # enforce correct cluster order
  ordered.clusters <- getOrderedGroups(so.query, which.group = cluster.name[i], is.number = T)
  so.query@meta.data[[cluster.name[i]]] <- factor(so.query@meta.data[[cluster.name[i]]], levels = ordered.clusters)
  
  # generate plot
  plt.umap_by_cluster[[i]] <- cluster.UMAP( so.query, group.by = cluster.name[i],
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = T, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = paste("Resolution: ", cluster_resolution[i], sep = ""))
  
  if (print.inline){
    print(plt.umap_by_cluster[[i]])
  }
}

# clean baggage
rm(cluster.membership)


# generate additional UMAPs....
auxillary.groups <- c()
if ("Barcode" %in% names(so.query@meta.data)){
  plt.umap_by_barcode <- cluster.UMAP( so.query, group.by = "Barcode",
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = F, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = "Barcodes")
plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_barcode
auxillary.groups <- c(auxillary.groups, "Barcodes")
}

if ("group" %in% names(so.query@meta.data)){
  plt.umap_by_group <- cluster.UMAP( so.query, group.by = "group",
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = F, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = "group")
plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_group
auxillary.groups <- c(auxillary.groups, "group")
}

if ("dataset" %in% names(so.query@meta.data)){
  plt.umap_by_dataset <- cluster.UMAP( so.query, group.by = "dataset",
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = F, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = "dataset")
plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_dataset
auxillary.groups <- c(auxillary.groups, "dataset")
}

if ("subset_group" %in% names(so.query@meta.data)){
  plt.umap_by_subset <- cluster.UMAP( so.query, group.by = "subset_group",
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = F, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = "subset_group")
plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_subset
auxillary.groups <- c(auxillary.groups, "subset_group")
}

DefaultAssay(so.query) <- assay.holder
cr_names <- c(cluster_resolution, auxillary.groups)
```


```{r function for long to wide annotation table}

long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster_membership ~ predicted_labels, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster_membership)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster_membership
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```




```{r check gene rep and convert if necessary}

# check.gene_rep <- function(cur_gene.list, cur_rep)
# so.temp <- so.query
current.assay <- DefaultAssay(so.query)
gene.rep <- checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
if (gene.rep == "ensembl"){
  so.query <- ens2sym.so(so.query, gNames.list)
}

```


```{r find query markers}

# initiate list to store cluster markers
query_markers.list <- list()

# store current identities
cur_idents <- Idents(so.query)
so.markers <- so.query

# start cluster
cl <- parallel::makeCluster(n.workers$deg)
doParallel::registerDoParallel(cl)

# iterate through each input file
marker.list <- foreach(i = 1:length(cluster.name), .packages = c("scMiko", "Seurat"))  %dopar% {
  
  Idents(so.markers) <- so.markers@meta.data[[cluster.name[i]]]
  
  if (quick_markers == TRUE){
    qm.res <- FindAllMarkers(so.markers, 
                             assay = DefaultAssay(so.markers),
                             slot = "data",
                             only.pos = only.pos, 
                             min.pct = 0.25,
                             test.use = DEG.test,
                             logfc.threshold = lfc.threshold, 
                             max.cells.per.ident = 200,
                             return.thresh = p.threshold,
                             verbose = F)
  } else if (quick_markers == FALSE){
    qm.res <-  FindAllMarkers(so.markers, 
                              assay = DefaultAssay(so.markers),
                              slot = "data",
                              only.pos = only.pos, 
                              min.pct = 0.01, 
                              test.use = DEG.test,
                              logfc.threshold = 0.01,
                              verbose = F)
  } else {
    qm.res <- NULL
  }
  
  return(qm.res)
  
}

# stop workers
parallel::stopCluster(cl)

# unpackage results
query_markers.list <- marker.list
names(query_markers.list) <- cluster.name

# remove baggage
rm(marker.list)
rm(so.markers)

```

```{r make wide function}


make.wide <- function(u_clusters, top_markers, n_top_markers, rename_clusters = TRUE){
  top_markers_wide <- data.frame()
  
  top_marker_clusters <- as.vector(top_markers$cluster)
  
  u_clusters <- as.numeric(as.character(u_clusters))
  u_clusters <- u_clusters[order(u_clusters)]
  for (i in 1:length(u_clusters)){
    
    top_markers_current <- top_markers$gene[top_marker_clusters == u_clusters[i]]
    n_markers_cur <- length(top_markers_current)
    
    if (!(n_markers_cur >= n_top_markers)){
      top_markers_current <- c(top_markers_current, rep(NaN, n_top_markers-n_markers_cur))
    }
    
    top_markers_wide[seq(1, n_top_markers), c(paste("c", u_clusters[i], sep = ""))] <- as.data.frame(top_markers_current)
    if (!rename_clusters){
      colnames(top_markers_wide)[i] <- u_clusters[i]
    }
  }
  
  return(top_markers_wide)
}

```


```{r get top markers function}



# function to get top cluster-specific markers
get.topmarkers <- function(query.markers, n_top_markers = 10, cluster_res_label = "", rename_clusters = TRUE){
  
  top_markers <- query.markers %>% 
    dplyr::group_by(cluster) %>% 
    dplyr::arrange(desc(avg_logFC)) 
  
  top_markers_filter <- top_markers[ , c("cluster", "gene")]
  
  top_marker.tally <- top_markers_filter %>%
    dplyr::group_by(cluster) %>%
    dplyr::tally()
  max.n <- max(top_marker.tally$n)
  
  # cl <- unique(as.numeric(as.character(top_markers_filter$cluster)))
  top_markers_filter$cluster <- as.numeric(as.character(top_markers_filter$cluster))
  # top_markers_filter$cluster <- factor((as.character(top_markers_filter$cluster)), levels = order(cl))
  
  top_markers$cluster <- paste("c", as.character(top_markers$cluster), sep = "")
  top_markers$p_val <- signif( top_markers$p_val, 3)
  top_markers$p_val_adj <- signif( top_markers$p_val_adj, 3)
  top_markers$avg_logFC <- signif( top_markers$avg_logFC, 3)
  
  top_markers_50 <- query.markers %>% 
    dplyr::group_by(cluster) %>% 
    dplyr::arrange(desc(avg_logFC)) %>%
    dplyr::top_n(n = 50, wt = avg_logFC)
  
  top_markers_50 <- top_markers_50[ , c("cluster", "gene")]
  
  
  
  u_clusters <- as.vector(unique(top_markers_filter$cluster))
  u_clusters <- u_clusters[order(u_clusters)]
  
  top_markers_wide <- make.wide(u_clusters, 
                                top_markers = top_markers_filter, 
                                n_top_markers = max.n, 
                                rename_clusters = rename_clusters)
  
  top_markers_50_wide <- make.wide(u_clusters, top_markers = top_markers_50, n_top_markers = 50, rename_clusters = rename_clusters)
  
  top5_markers <- query.markers %>% 
    dplyr::group_by(cluster) %>% 
    dplyr::arrange(desc(avg_logFC)) %>%
    dplyr::top_n(n = 50, wt = avg_logFC)
  
  
  # assign outputs to list and return
  output <- list(top_markers, top_markers_50, top_markers_wide, top_markers_50_wide, top5_markers)
  names(output) <- c("top_markers_res",
                     "top_markers_50_res",
                     "top_markers_wide_res",
                     "top_markers_50_wide_res",
                     "top5_markers_res")
  return(output)
}

```


```{r, get top cluster markers, warning = FALSE }

# get top markers
which.res2rmv <- c()
top_markers_res.list <- list()         
top_markers_50_res.list <- list()      
top_markers_wide_res.list <- list()    
top_markers_50_wide_res.list <- list() 
top5_markers_res.list <- list()  

for (i in 1:length(query_markers.list)){
  if (length( query_markers.list[[i]]) == 0) {
    which.res2rmv <- c(which.res2rmv, cluster_resolution[i])
    next
  }
  output.markers <- get.topmarkers(query.markers = query_markers.list[[i]], cluster_res_label = cluster_resolution[i])
  
  top_markers_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_res"]])     
  top_markers_50_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_res"]])     
  top_markers_wide_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_wide_res"]])   
  top_markers_50_wide_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_wide_res"]])
  top5_markers_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top5_markers_res"]])
  # quiet(list2env(output.markers, env = environment()), all = TRUE)  
}

# omit resolution where no DEGs were observed
cr_original <- cluster_resolution
cluster_resolution <-cluster_resolution[!(cluster_resolution  %in% which.res2rmv)]

```

```{r down sample cells function}


# downsample data if necessary
downsample_cells <- function(so.query, clust.name, n.downsample = 500){
  
  cluster_id <- as.vector(so.query@meta.data[[clust.name]])
  u_clusters <- unique(cluster_id)
  
  n_per_cluster <- round(n.downsample / length(u_clusters))
  
  cells_to_plot <- c()
  for (i in 1:length(u_clusters)){
    
    cell_to_sample <- Cells(so.query)[cluster_id == u_clusters[i]]
    if (length(cell_to_sample) < n_per_cluster){
      cells_to_plot <-  c(cells_to_plot, cell_to_sample)
    } else {
      cells_to_plot <-  c(cells_to_plot, sample(Cells(so.query)[cluster_id == u_clusters[i]], n_per_cluster, replace = FALSE))
    }
    
  }

  so.query_small <- subset(so.query, cells = cells_to_plot)

  return(so.query_small)
}
```

```{r heatmap, message=FALSE, warning=FALSE, include = FALSE, fig.height= 10, fig.width=10}


n2show <- 500 # number of cells to represent per cluster
plt.heatmap <- list()
sil.list <- list()
df.os.all <- NULL

# generate heatmap
for (i in 1:length(cluster_resolution)){
  
  # CELL HEATMAP ###############################################################
  
  cur.cluster.name <- paste(assay.pattern, cluster_resolution[i], sep = "")
  cluster.name[i] <- cur.cluster.name
  Idents(so.query) <- so.query@meta.data[[cluster.name[i]]]
  so.query_small <- downsample_cells(so.query = so.query, clust.name = cluster.name[i], n.downsample = n2show)
  
  # get expression matrix for top markers
  exp.mat <- so.query_small@assays[[DefaultAssay(so.query_small)]]@scale.data
  umap.coord <- so.query_small@reductions[["umap"]]@cell.embeddings
  heatmap.genes <- unique(top5_markers_res.list[[as.character(cluster_resolution[i])]]$gene)
  match.ind <- (rownames(exp.mat) %in% heatmap.genes)
  exp.mat.filtered <- exp.mat[match.ind, ]
  
  # specify hierarchial cluster parameters
  cur.cluster.id <- as.numeric((so.query_small@meta.data[[cur.cluster.name]]))
  
  # set scale limits
  scale.lim <- 2 
  exp.mat.filtered[exp.mat.filtered > scale.lim] <- scale.lim
  exp.mat.filtered[exp.mat.filtered < (-1*scale.lim)] <- (-1*scale.lim)
  my.breaks <- seq((-1*scale.lim), scale.lim, by = 0.05)
  my.col <- colorRampPalette(c(scales::muted("blue"), "white",scales::muted("red")))(length(my.breaks))
  
  # get cell annotations
  col.ann <- data.frame(cluster = so.query_small@meta.data[[cur.cluster.name]], row.names = colnames(so.query_small))
  
  # generate heatmap
  plt.heat.scaled <- pheatmap::pheatmap(exp.mat.filtered,
                                        breaks = my.breaks,
                                        color = my.col,
                                        show_rownames = F,
                                        show_colnames = F,
                                        annotation_col = col.ann,
                                        main = paste0("Resolution: ", as.character(cluster_resolution[i]), 
                                                      "\nx=cells, y=genes, z=scaled expression"))
  
  # get cluster order to compute mixing metric
  col.ann$order <-  plt.heat.scaled[["tree_col"]][["order"]]
  df.os <- col.ann %>%
    dplyr::group_by(cluster) %>%
    dplyr::summarize(oos = mad(order))
  df.os$eos <-  mad(seq(1,n2show/(length(unique(col.ann$cluster)))))
  df.os$s.ratio <- df.os$oos / df.os$eos
  df.os$resolution <- cluster_resolution[i]
  df.os.all <- bind_rows(df.os.all, df.os)
  
  # cast heatmap to ggplot
  plt.heat.scaled <- ggplotify::as.ggplot(plt.heat.scaled)
  plt.heatmap[[as.character(cluster_resolution[i])]] <- plt.heat.scaled
  
  # SILHOUETTE #################################################################
  
  cluster.id <- as.integer(as.character(so.query_small@meta.data[[cur.cluster.name]]))
  
  # run hierarchial clustering and generate silhouette object
  ar <- agnes(t(exp.mat.filtered))
  sil.list[[as.character(cluster_resolution[i])]] <- silhouette(cluster.id, daisy(t(exp.mat.filtered)))
  # sil.list[[as.character(cluster_resolution[i])]] <- silhouette(cluster.id, daisy(t(plt.heatmap.parameters[[i]][["exp.mat"]])))
  
  sil.temp <- sil.list[[as.character(cluster_resolution[i])]]
  
  df.umap <- data.frame(cluster = cur.cluster.id,
                        x = umap.coord[ ,1],
                        y = umap.coord[ ,2])
  
  # Calculate Silhouette based on UMAP coordinates. 
  df.umap$a <- NA
  df.umap$b <- NA
  for (j in 1:nrow(df.umap)){
    
    df.cur.cluster <- df.umap[df.umap$cluster[j] == df.umap$cluster, ]
    df.umap$a[j] <- sum(sqrt(((df.umap$x[j] - df.cur.cluster$x)^2) + ((df.umap$y[j] - df.cur.cluster$y)^2))) / (nrow(df.cur.cluster) - 1)
    
    df.cur.other <- df.umap[df.umap$cluster[j] != df.umap$cluster, ]
    u.other <- unique(df.cur.other$cluster)
    other.dist <- c()
    for (k in 1:length(u.other)){
      df.cur.other.sub <-  df.cur.other[u.other[k] == df.cur.other$cluster, ]
      other.dist[k] <- sum(sqrt(((df.umap$x[j] - df.cur.other.sub$x)^2) + ((df.umap$y[j] - df.cur.other.sub$y)^2))) / (nrow(df.cur.other.sub))
    }
    df.umap$b[j] <- min(other.dist)
    df.umap$maxab[j] <- max(c( df.umap$a[j], df.umap$b[j]))
    df.umap$neighbour[j] <- u.other[which( df.umap$b[j] == other.dist)]
  }
  
  df.umap$s <- (df.umap$b - df.umap$a) / df.umap$maxab
  
  sil.temp[ ,1] <- df.umap$cluster - 1
  sil.temp[ ,2] <- df.umap$neighbour - 1
  sil.temp[ ,3] <- df.umap$s
  
  sil.list[[as.character(cluster_resolution[i])]]  <- sil.temp
  
  if (print.inline){
    print(plt.heat.scaled)
  }
}


```

```{r cluster discrimination metric}

plt.clust.disc <- df.os.all %>%
  dplyr::group_by(resolution) %>%
  ggplot(aes(x = factor(resolution), y = s.ratio, label = cluster)) + 
  geom_hline(yintercept = 1, linetype = "dashed") + 
  geom_boxplot(aes(x = factor(resolution), y = s.ratio, fill = mean(s.ratio)), alpha = 0.5) + 
  geom_text() + 
  theme_miko() + 
  labs(title = "Cluster Discrimination Metric", subtitle = "D = 1 indicates perfect clustering; higher values indicate reduced cluster discrimination") + 
  ylab("Cluster Discrimination, D\n(observed mixing / expected mixed)") + 
  xlab("Cluster Resolution")

if (print.inline) print(plt.clust.disc)
```




```{r cluster-level heatmap, include = FALSE}


plt.heatmap.cluster <- list()
es.mat <- so.query@assays[[DefaultAssay(so.query)]]@scale.data

# generate heatmap
for (i in 1:length(cluster_resolution)){
  
  query.res <- paste(assay.pattern, cluster_resolution[i], sep = "")
  
  sc.meta <- so.query@meta.data[[query.res]]
  u.clust <- getOrderedGroups(so.query, which.group = query.res, is.number = T)
  
  # initiate empty matrices
  s.mat <- matrix(nrow = nrow(es.mat), ncol = length(u.clust))
  
  
  # get cluster-level aggregate scores
  for (j in 1:length(u.clust)){
    which.cells <- sc.meta %in% u.clust[j]
    
    # scaled data
    s1 <- rowMeans(es.mat[, which.cells])
    s.mat[ ,j] <- s1
    
  }
  
  # assign col and row names
  colnames(s.mat) <- u.clust
  rownames(s.mat) <-  rownames(es.mat)
  
  # cast to data.frame
  df.s.wide <- data.frame(gene = rownames(es.mat), as.data.frame(s.mat)); colnames(df.s.wide) <- c("gene", u.clust)
  
  # scaled expression plots
  df.s4plt <- as.matrix(df.s.wide %>% dplyr::select(-c("gene")))
  
  # subset 
  heatmap.genes <- unique(top5_markers_res.list[[as.character(cluster_resolution[i])]]$gene)
  match.ind <- (rownames(df.s4plt) %in% heatmap.genes)
  df.s4plt <- df.s4plt[match.ind, ]
  
  # get scale limits
  scale.lim <- 2 
  df.s4plt[df.s4plt > scale.lim] <- scale.lim
  df.s4plt[df.s4plt < (-1*scale.lim)] <- (-1*scale.lim)
  
  my.breaks <- seq((-1*scale.lim), scale.lim, by = 0.2)
  my.col <- colorRampPalette(c(scales::muted("blue"), "white",scales::muted("red")))(length(my.breaks))
  
  plt.heat.cluster.scaled <- pheatmap::pheatmap(df.s4plt,
                                                breaks = my.breaks,
                                                color = my.col,
                                                show_rownames = F,
                                                main = "Scaled Expression\nx=clusters, y=genes, z=scaled expression")
  
  plt.heat.cluster.scaled <- ggplotify::as.ggplot(plt.heat.cluster.scaled)
  
  
  plt.heatmap.cluster[[as.character(cluster_resolution[i])]] <- plt.heat.cluster.scaled
  
}



```





```{r create silhouette plots}

sil.plot <- list()


mean.silw <- c()
for (i in 1:length(sil.list)){
  
  sil.plot[[ names(sil.list)[i]]] <- factoextra::fviz_silhouette(sil.list[[i]], print.summary = F) 
  
  gtitle <-  sil.plot[[names(sil.list)[i]]][["labels"]][["title"]]
  mean.silw[i] <- as.numeric(gsub("Clusters silhouette plot \n Average silhouette width: ", "", gtitle))  
  gtitle <- gsub("Clusters silhouette plot", paste("resolution: ", names(sil.list)[i], sep = ""), gtitle)
  
  
  sil.plot[[ names(sil.list)[i]]] <- sil.plot[[ names(sil.list)[i]]] + ggtitle(gtitle)
  
  if (print.inline) print(sil.plot[[ names(sil.list)[i]]])
}


```


```{r silhouette summaries}

df.silw <- NULL
for (i in 1:length(sil.plot)){
  df.silw <- bind_rows(df.silw, data.frame(
    cluster.resolution = as.character(cluster_resolution[i]),
    sil.width = sil.plot[[as.character(cluster_resolution[i])]][["data"]][["sil_width"]]
  ))
}

plt.silw.dep <- df.silw %>%
  ggplot(aes(x = cluster.resolution, y = sil.width, color = cluster.resolution)) + 
  geom_boxplot() + 
  theme_classic() + 
  theme(legend.position = "none") + 
  xlab("Cluster Resolution") + 
  ylab("Silhouette Width") + 
  ggtitle("Cluster Resolution vs. Silouhette Width")

if (length(cluster_resolution) > 2){
  
  plt.silw.line <- df.silw %>%
    dplyr::group_by(cluster.resolution) %>%
    dplyr::summarize(width.mean = mean(sil.width, na.rm = T)) %>% 
    ggplot(aes(x = cluster.resolution, y = width.mean,group = 1)) + 
    geom_point(size = 3) + 
    geom_line() + 
    xlab("Cluster Resolution") + 
    ylab("Silhouette Width") + 
    ggtitle("Cluster Resolution vs. Silouhette Width") + 
    theme_miko()
  
  
} else {
  plt.silw.line <- NULL
}

if (print.inline) print(plt.silw.line)
if (print.inline) print(plt.silw.dep)


```

```{r res vs n clust curve}

# get resolutions
clust.names <- names(query_markers.list)
current.assay <- DefaultAssay(so.query)
clust.res <- as.numeric(gsub(assay.pattern, "",clust.names))

# get cluster number
clust.n <- purrr::map_dbl(query_markers.list, function(x) length(unique(x[["cluster"]])))

# get number of degs per cluster
n.deg <- purrr::map(query_markers.list, function(x){
  if (nrow(x) > 0){
    df.sum <- x %>%
      dplyr::group_by(cluster) %>%
      dplyr::summarize(
        sig.deg = sum(p_val_adj < 0.05)
      )
  } else {
    NULL
  }
  
})

# compute deg statistics
n.deg.summary <- purrr::map(n.deg, function(x){
  if (!is.null(x)){
    df.sum <- data.frame(
      min.n = min(x$sig.deg, na.rm = T),
      max.n = max(x$sig.deg, na.rm = T),
      mean.n =mean(x$sig.deg, na.rm = T),
      sd.n = sd(x$sig.deg, na.rm = T),
      median.n = median(x$sig.deg, na.rm = T),
      n.clust = length(x$sig.deg)
    )
  } else {
    df.sum <- data.frame(
      min.n = NA,
      max.n = NA,
      mean.n = NA,
      sd.n = NA,
      median.n = NA,
      n.clust = NA
    )
  }
})

# which.val <- which(!(lapply(n.deg.summary, is.null)))

df.clust.n <- data.frame(clust.res = clust.res, 
                         n.clust = clust.n,
                         deg.meanN = purrr::map_dbl(n.deg.summary, function(x) x$mean.n),
                         deg.medianN = purrr::map_dbl(n.deg.summary, function(x) x$median.n),
                         deg.minN = purrr::map_dbl(n.deg.summary, function(x) x$min.n),
                         deg.maxN = purrr::map_dbl(n.deg.summary, function(x) x$max.n))

df.clust.mean <- df.clust.n[ ,c("clust.res", "deg.meanN")]; df.clust.mean$type = "mean"; colnames(df.clust.mean) <- c("res", "val", "type")
df.clust.min <- df.clust.n[ ,c("clust.res", "deg.minN")]; df.clust.min$type = "min"; colnames(df.clust.min) <- c("res", "val", "type")
df.clust.max <- df.clust.n[ ,c("clust.res", "deg.maxN")]; df.clust.max$type = "max"; colnames(df.clust.max) <- c("res", "val", "type")

df.clust.long <- bind_rows(df.clust.mean, df.clust.min, df.clust.max)

plt.deg.n <- df.clust.long %>%
  ggplot(aes(res, val, color = type)) + 
  geom_point(size = 3) + 
  geom_line() + 
  theme_miko(legend = T) + 
  ggthemes::scale_color_ptol() + 
  xlab("Cluster Resolution") + 
  ylab("DEG Number per Cluster") + 
  labs(title = "Cluster Resolution vs. Number of DEGs",
       subtitle = "DEGs = differentially-expressed genes") 
                         

plt.clust.n <- df.clust.n %>%
  ggplot(aes(clust.res, n.clust)) + 
  geom_line() + 
  geom_point(size = 3) + 
  theme_miko() + 
  xlab("Cluster Resolution") + 
  ylab("Cluster Number") + 
  labs(title = "Cluster Resolution vs. Number of Cell Populations")

if (print.inline){
  print(plt.clust.n)
  print(plt.deg.n)
}
```



```{r hierarchial deg, fig.width = 12, fig.height = 8}

# prep cluster data ############################################################
meta.cols <- names(so.query@meta.data)
#
meta.clust.entries <- paste0(assay.pattern, cluster_resolution)
df.meta <- so.query@meta.data
df.meta <- df.meta[, meta.cols %in% meta.clust.entries]
df.meta[ ,paste0(assay.pattern, 0)] <- 0
df.meta$umap.x <- so.query@reductions[["umap"]]@cell.embeddings[ ,1]
df.meta$umap.y <- so.query@reductions[["umap"]]@cell.embeddings[ ,2]

so.query@meta.data[[paste0(assay.pattern, 0)]] <- 0

# plot cluster trees ###########################################################
plt.clusttree <- NULL
try({
  plt.clusttree <- clustree(so.query, prefix = assay.pattern, layout = "tree")
}, silent = T)
if (print.inline) print(plt.clusttree)

plt.umap.tree <- NULL
try({
  plt.umap.tree <- clustree_overlay(df.meta, prefix =  assay.pattern, 
                                  x_value = "umap.x", y_value = "umap.y", ) + 
  xlab("UMAP 1") + ylab("UMAP 2") + labs(title = "UMAP with cluster-splits") + theme_miko(legend = T)
}, silent = T)
if (print.inline) print(plt.umap.tree)
```

```{r get specificity markers}

pct.threshold <- 0.05
pct.dif.threshold <- 0.3

markers4tree <- c()
for (i in 1:length(top_markers_res.list)){
  df.deg <- top_markers_res.list[[i]]
  df.deg$pct.dif <- df.deg$pct.1 - df.deg$pct.2
  df.deg <- df.deg[(abs(df.deg$pct.dif) > pct.dif.threshold) & ((df.deg$pct.1 < pct.threshold) | (df.deg$pct.2 < pct.threshold)), ]
  markers4tree <- c(markers4tree, (df.deg %>%
    dplyr::group_by(cluster) %>%
    dplyr::top_n(1, abs(pct.dif)))$gene)
}

markers4tree <- unique(markers4tree)

```


```{r cluster tree with markers of interest, fig.width = 12, fig.height = 8}

if (!exists("cluster.tree.markers")) cluster.tree.markers <- NA
cluster.tree.markers <- c(cluster.tree.markers, markers4tree)
cluster.tree.markers <- cluster.tree.markers[!is.na(cluster.tree.markers)]

species <- unique(so.query@meta.data[["Organism"]])
if (length(species) == 1 && !is.na(cluster.tree.markers)){
  if (species  == "Hs"){
    cluster.tree.markers <- toupper(cluster.tree.markers)
  } else {
    cluster.tree.markers <- firstup(cluster.tree.markers)
  }
}


plt.clusttree.markers <- list()

if (!is.na(cluster.tree.markers)){
  for (i in 1:length(cluster.tree.markers)){
    
    plt.clusttree.markers[[cluster.tree.markers[i]]] <- NULL
    try({
      plt.clusttree.markers[[cluster.tree.markers[i]]] <- clustree(so.query, prefix =  assay.pattern, 
                                                                   node_colour = cluster.tree.markers[i], node_colour_aggr = "mean") + 
        labs(title = cluster.tree.markers[i]) + viridis::scale_color_viridis(cluster.tree.markers[i], option = "B", begin = 0.3)
      if (print.inline) print( plt.clusttree.markers[[cluster.tree.markers[i]]])
    }, silent = T)
  }
}


```



```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M18", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M18_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```



UMAP
===================================== 

Row {.tabset}
-------------------------------------

```{r plt.umap_by_all_clusters, message=FALSE, warning=FALSE}

out <- lapply(seq_along(cr_names), function(i) {
  
  a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res = ", cr_names[i], sep = ""))) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("clust_umap", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.umap_by_cluster[[%d]])",i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pdf plt.umap_by_all_clusters }

for (i in 1:length(cr_names)){
  if ( cr_names[i] == "barcodes"){
    suffix <- ".pdf"
  } else {
    suffix = "resolution.pdf"
  }
  plot.name <- paste0("M18_umap_", gsub(".", "_", cr_names[i], fixed = T), suffix)
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.umap_by_cluster[[i]], 
        fig.width = 6, fig.height = 5, save.flag = save.pdf)
}

```

Cluster Tree
===================================== 

Row {.tabset}
-------------------------------------

### Cluster Tree

```{r tree, fig.width = 12, fig.height = 8}

print(plt.clusttree)

savePDF(file.name = paste0(output.path, "PDF/", "cluster_tree.pdf"), plot.handle =  plt.clusttree, 
        fig.width = 12, fig.height = 8, save.flag = save.pdf)

```

### UMAP Tree

```{r umap tree, fig.width = 12, fig.height = 8}

print(plt.umap.tree)

savePDF(file.name = paste0(output.path, "PDF/", "cluster_tree_UMAP.pdf"), plot.handle =  plt.umap.tree, 
        fig.width = 12, fig.height = 8, save.flag = save.pdf)

```


```{r plot tree markers, message=FALSE, warning=FALSE}

out <- NULL

if (length(plt.clusttree.markers) > 0){
  out <- lapply(seq_along(plt.clusttree.markers), function(i) {
    
    a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", names(plt.clusttree.markers)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=12, fig.height=8 , message=FALSE, warning=FALSE}", paste("clustreTreeMark_", i, sep = ""))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.clusttree.markers[[ names(plt.clusttree.markers)[%d]]])",i)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save cluster tree markers}

if (length(plt.clusttree.markers) > 0){
  invisible({
    for (i in 1:length(plt.clusttree.markers)){
      
      plot.name <- paste0("M18_specificMarker_clusterTree_", names(plt.clusttree.markers)[i], ".pdf")
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
              plot.handle =  plt.clusttree.markers[[i]], 
              fig.width = 12, fig.height = 8, save.flag = save.pdf)
    }
  })
}

```


Heatmap (cell-level)
===================================== 

Row {.tabset}
-------------------------------------

```{r ph3,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(plt.heatmap), function(i) {
  
  s1 <- paste("res = ", names(plt.heatmap)[i], sep = "")
  s2 <- paste0("plt.heatmap[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("hm", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`

```{r pdf ph3, include = FALSE}

invisible({
  for (i in 1:length(plt.heatmap)){
    
    plot.name <- paste0("M18_cellHeatmap_", gsub(".", "_", names(plt.heatmap)[i], fixed = T), "resolution.pdf")
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle =  plt.heatmap[[i]], 
            fig.width = 13, fig.height = 6, save.flag = save.pdf)
  }
})

```


Heatmap (cluster-level)
===================================== 

Row {.tabset}
-------------------------------------

```{r ph3-cluster,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat_cluster <- lapply(seq_along(plt.heatmap.cluster), function(i) {
  
  s1 <- paste("res = ",  names(plt.heatmap.cluster)[i], sep = "")
  s2 <- paste0("plt.heatmap.cluster[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("hm-cluster", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat_cluster, collapse = '\n')))`

```{r pdf ph3-cluster, include = FALSE}

invisible({
  for (i in 1:length(plt.heatmap.cluster)){
    
    plot.name <- paste0("M18_clusterHeatmap_", gsub(".", "_", names(plt.heatmap.cluster)[i], fixed = T), "resolution.pdf")
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle =  plt.heatmap.cluster[[i]], 
            fig.width = 13, fig.height = 6, save.flag = save.pdf)
  } 
})


```

Silhouette
===================================== 

Row {.tabset}
-------------------------------------

```{r plt.Silhouette, message=FALSE, warning=FALSE}

out <- lapply(seq_along(sil.plot), function(i) {
  
  a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res = ", names(sil.list)[i], sep = ""))) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("sil.plt", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(sil.plot[[ names(sil.list)[%d]]])",i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pdf plt.Silhouette }

for (i in 1:length(sil.plot)){
  plot.name <- paste0("M18_silhouette_", gsub(".", "_", names(sil.list)[i], fixed = T), "resolution.pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  sil.plot[[i]], 
        fig.width = 5, fig.height = 5, save.flag = save.pdf)
}

```

Metrics
===================================== 

Row {.tabset}
-------------------------------------


### Overview
```{r plt.Silhouette cont, message=FALSE, warning=FALSE, fig.width=8, fig.height=8}


cowplot::plot_grid(plt.clust.disc, plt.silw.line, plt.clust.n, plt.deg.n, ncol = 2)

savePDF(file.name = paste0(output.path, "PDF/", "M18_resolution_evaluation_metrics.pdf"), 
        plot.handle =  cowplot::plot_grid(plt.silw.line, plt.clust.n, plt.deg.n, ncol = 3), 
        fig.width = 8, fig.height = 8, save.flag = save.pdf)

```

### Silhouette Summary
```{r pplt.silw.dep, message=FALSE, warning=FALSE}

print(plt.silw.dep)

savePDF(file.name = paste0(output.path, "PDF/", "M18_resolution_vs_silwidth.pdf"), 
        plot.handle = plt.silw.dep, 
        fig.width = 5, fig.height = 5, save.flag = save.pdf)

```


Cluster Markers (1)
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(top_markers_wide_res.list), function(i) {
  
  s1 <- paste("top_markers_wide_res.list[[", i, "]]", sep = "")
  
  # table.name <- names(top_markers_wide_res.list)[i]
  table.name <- paste("res=", names(top_markers_wide_res.list)[i], "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`

```{r csv cm1}

for (i in 1:length(top_markers_wide_res.list)){
  table.name <- paste0("markerList_", gsub(".", "_", names(top_markers_wide_res.list)[i], fixed = T), "resolution.csv")
    write.csv(top_markers_wide_res.list[[i]], file = paste0(output.path, "Tables/", table.name), 
    row.names = F) 
}

```

Cluster Markers (2)
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output v2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(top_markers_res.list), function(i) {
  
  s1 <- paste("top_markers_res.list[[", i, "]]", sep = "")
  
  table.name <- paste("res=", names(top_markers_res.list)[i], "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v2", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`

```{r csv cm2}

for (i in 1:length(top_markers_res.list)){
  table.name <- paste0("markerStatistics_", gsub(".", "_", names(top_markers_res.list)[i], fixed = T), "resolution.csv")
    write.csv(top_markers_res.list[[i]], file = paste0(output.path, "Tables/", table.name), 
    row.names = F) 
}

```

```{r save analysis log and Rdata results, message=FALSE, warning=FALSE}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_18 <- df.log



```

```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 18)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_18)

```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_18, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}


```


