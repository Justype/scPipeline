---
title: "Cluster Optimization"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    source_code: embed
    theme: flatly
    navbar:
      - { title: "scPipeline", href: "https://github.com/NMikolajewicz/scPipeline" }
      - { title: "scMiko", href: "https://github.com/NMikolajewicz/scMiko" }  
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", 
        paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", 
      paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("scMiko", "Seurat",
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                    "zoo",    "future", "cluster", "doParallel", "parallel", "foreach",  "igraph", "presto")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))


```


```{r parameter specification}

# M18
parameter.list <- list(
  input.file = "R443_M02_NM2_p9_GBM_PR_integrated_SCTrerun_110521.Rdata",
  cluster.resolution = c(0.1, 0.15, 0.2,0.3,0.35, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, seq(1.2, 3, by = 0.2)),
  lfc.threshold = 0.5, # log fold change threshold (0.5 recommended)
  fdr.threshold = 0.01,
  print.inline = FALSE, # print inline
  subsample_factor = 1, # OPTIONAL; range 0 to 1 (default = 1)
  n.workers =list(  # specify number of workers (for parallelization)
    clustering = 8, # data clustering
    deg = 8         # DEG analysis
  ),
  only.pos = T, # which markers to return
  save.pdf = T, # save PDF
  update.log = T
)


# Query input
# input.file <- "R6_M02_BC2_allGBM_271020.Rdata"
# input.file <- "R416_M02_NM2_p12_meso_integrated_170421.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "R34_M27_NM2_0_01ds_p4789_allGBM_120820.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file <- "R291_M01_NM2_Rambow_Melanoma_221120.Rdata"

# specify cluster resolution
# cluster.resolution <- c(0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
# cluster.resolution <- c(0.1, 0.15, 0.2,0.3,0.35, 0.4, 0.5, 0.6)
# # cluster.resolution <- c(1, 1.5, 2)

```


```{r analysis log}
message("Updating analysis log...")
# Module
df.log <- initiateLog("18, Cluster Optimization")
df.log <- addLogEntry("Input File", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Log FC Threshold", parameter.list$lfc.threshold, df.log, "lfc.threshold")
df.log <- addLogEntry("p value Threshold", parameter.list$fdr.threshold, df.log, "fdr.threshold")
df.log <- addLogEntry("Positive Markers Only", parameter.list$only.pos, df.log, "only.pos")
df.log <- addLogEntry("DEG test", "wilcoxon.auc" , df.log, "DEG.test")
df.log <- addLogEntry("Cluster Resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Figures Printed in Notebook", parameter.list$print.inline, df.log, "print.inline")
df.log <- addLogEntry("PDF saved", parameter.list$save.pdf, df.log, "save.pdf")


```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

message("Importing data...")
if ((!grepl(".Rdata|.RData", parameter.list$input.file)) & !(grepl(".rds", parameter.list$input.file))){
  parameter.list$input.file <- paste0(parameter.list$input.file, ".Rdata")
} 
if (grepl(".Rdata|.RData", parameter.list$input.file)){
  load(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""));
} else if (grepl(".rds", parameter.list$input.file)) {
  so <- readRDS(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""))
}

if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())


if ("integrated" %in% names(so@assays)){
  terms2drop <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "sct")
} else {
  terms2drop <- c("ica", "tsne", "nmf", "corr", "gsva", "deg")
}

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = NULL, resolution= NULL, subset = NULL, 
                             subsample = 1, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = terms2drop, rmv.pattern = "so", 
                         scale.reprocessed = F, neighbors.reprocessed = T) # scale.reprocessed default = T

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})
# parameter.list$species <- detectSpecies(so.query)

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r cluster data}

message("Clustering data...")

# initiate list to store cluster plots
plt.umap_by_cluster <- list()
cluster.name <- c()

# get cluster identify pattern
assay.names <- names(so.query@assays)
assay.holder <- DefaultAssay(so.query)
if ("integrated" %in% assay.names){
  DefaultAssay(so.query) <- "integrated"
} 
current.assay <- DefaultAssay(so.query)
assay.pattern <- paste0(current.assay, "_snn_res.")

# start cluster
if (parameter.list$n.workers$clustering > length(parameter.list$cluster.resolution)) n.workers$clustering <-length(parameter.list$cluster.resolution)
cl <- parallel::makeCluster(parameter.list$n.workers$clustering)
doParallel::registerDoParallel(cl)

# ensure neighbors computed
if (length(so.query@graphs) == 0){
  pca.prop <- propVarPCA(so.query)
  target.pc <- max(pca.prop$pc.id[pca.prop$pc.cum_sum<0.9])+1
  so.query <- FindNeighbors(so.query, verbose = F, reduction = "pca", dims = 1:target.pc)
}

# iterate through each input file
cluster.membership <- foreach(i = 1:length(parameter.list$cluster.resolution), .packages = c("Seurat"))  %dopar% {
  so.query <- FindClusters(object = so.query, resolution = parameter.list$cluster.resolution[i], verbose = 0, algorithm = 1, modularity.fxn = 1)
  return(so.query@meta.data[[paste0(assay.pattern, parameter.list$cluster.resolution[i])]])
}

# stop workers
parallel::stopCluster(cl)


# retrieve data
for (i in 1:length(parameter.list$cluster.resolution)) {
  
  # get cluster name
  current.cluster <- paste0(assay.pattern, parameter.list$cluster.resolution[i])
  so.query@meta.data[[current.cluster]] <-cluster.membership[[i]]
  cluster.name[i] <- paste(DefaultAssay(so.query),"_snn_res.", parameter.list$cluster.resolution[i], sep = "")

  # enforce correct cluster order
  ordered.clusters <- getOrderedGroups(so.query, which.group = cluster.name[i], is.number = T)
  so.query@meta.data[[cluster.name[i]]] <- factor(so.query@meta.data[[cluster.name[i]]], levels = ordered.clusters)
  
  # generate plot
  plt.umap_by_cluster[[current.cluster]] <- cluster.UMAP( so.query, group.by = cluster.name[i],
  x.label = "UMAP 1", y.label = "UMAP 2", plot.name = "UMAP", include.labels = T, reduction = "umap") + theme_miko(legend = T) + 
  labs(title = "UMAP", subtitle = paste("Resolution: ", parameter.list$cluster.resolution[i], sep = ""))
  
  if (parameter.list$print.inline){
    print(plt.umap_by_cluster[[current.cluster]])
  }
}

# clean baggage
rm(cluster.membership)

DefaultAssay(so.query) <- assay.holder
cr_names <- as.character(parameter.list$cluster.resolution)




# plt.umap_by_cluster
```


```{r calculate cluster purity}

message("Calculating purity scores...")
cluster.graph <- NA
graph.present <- F

suppressMessages({
  suppressWarnings({
    try({
      cluster.graph <- so.query@commands[["FindClusters"]]@params[["graph.name"]]
      cluster.graph <- gsub("_s", "_", cluster.graph)
      graph.present <- cluster.graph %in% names(so.query@graphs)
    }, silent = T)
    
    if (!graph.present){
      try({
        cluster.graph <- paste0(current.assay, "_nn")
        graph.present <- cluster.graph %in% names(so.query@graphs)
      }, silent = T)  
    }
if (!graph.present) stop("Could not find valid KNN graph")

df.purity <- NULL
purity.umap.list <- list()
for (i in 1:length(parameter.list$cluster.resolution)) {
   current.cluster <- paste0(assay.pattern, parameter.list$cluster.resolution[i])
  so.query <- neighborPurity(object = so.query, graph = cluster.graph, cluster.field = current.cluster) 
  
  purity.umap.list[[current.cluster]] <- FeaturePlot(so.query, "purity") + 
    theme_miko(legend = T) + 
    viridis::scale_color_viridis() + 
    labs(title = "Purity Score", subtitle = paste0("Resolution: ", parameter.list$cluster.resolution[i])) + 
    labs(x = "UMAP 1", y = "UMAP 2", color = "Purity")

  df.purity <- bind_rows(df.purity, 
                         data.frame(resolution = as.numeric(parameter.list$cluster.resolution[i]), 
                                    name = current.cluster,
                                    cluster = so.query@meta.data[ ,current.cluster],
                                    purity = so.query@meta.data[ ,"purity"]))
}
  })
})
df.purity.sum <- df.purity %>%
  dplyr::group_by(resolution) %>%
  dplyr::summarize(purity.mean = mean(purity, na.rm = T), .groups = 'drop')
plt.cluster.purity <- df.purity %>%
  ggplot(aes(x = as.character(resolution), y = purity)) + 
  geom_violin(fill = "grey") + 
  geom_point(data = df.purity.sum, aes(x = as.character(resolution), y = purity.mean), size = 3) + 
  geom_line(data = df.purity.sum, aes(x = as.character(resolution), y = purity.mean, group = 1)) + 
  theme_miko() + 
  labs(x = "Resolution", y = "Purity Score", title = "Cluster Purity Scores")

if (parameter.list$print.inline) {
  print(plt.cluster.purity)
}

```


```{r subsample data here, warning = FALSE}
if ("subsample_factor" %in% names(parameter.list)){
  if ((parameter.list$subsample_factor < 1) |( parameter.list$subsample_factor > 0)){
    so.query = subset(so.query, cells = sample(Cells(so.query), round(ncol(so.query)*parameter.list$subsample_factor)))
  }
}

```

```{r function for long to wide annotation table}

long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster_membership ~ predicted_labels, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster_membership)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster_membership
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```




```{r check gene rep and convert if necessary, warning = FALSE}

current.assay <- DefaultAssay(so.query)
gene.rep <- checkGeneRep(gNames.list, as.vector(rownames(so.query)))
if (gene.rep == "ensembl"){
  so.query <- ens2sym.so(so.query, gNames.list)
}

```


```{r find DEG markers, warning=FALSE}


message("Differential expression analysis...")

# initiate list to store cluster markers
query_markers.list <- list()

# store current identities
cur_idents <- Idents(so.query)
so.markers <- so.query

# start cluster
if (parameter.list$n.workers$deg > length(cluster.name)) parameter.list$n.workers$deg <- length(cluster.name)
cl <- parallel::makeCluster(parameter.list$n.workers$deg)
doParallel::registerDoParallel(cl)

# iterate through each input file
marker.list <- foreach(i = 1:length(cluster.name), .packages = c("scMiko", "Seurat", "presto", "dplyr"))  %dopar% {
  
  Idents(so.markers) <- so.markers@meta.data[[cluster.name[i]]]
  
  if (length(unique(Idents(so.markers))) < 2){
    qm.res <- NULL
  } else {
      qm.res <- presto::wilcoxauc(X = so.markers, group_by = cluster.name[i], assay = "data", seurat_assay = DefaultAssay(so.markers))
      qm.res$pct_dif <- qm.res$pct_in - qm.res$pct_out    
  }

  return(qm.res)
  
}

# stop workers
parallel::stopCluster(cl)

# unpackage results
query_markers.list <- marker.list
names(query_markers.list) <- cluster.name

# remove baggage
rm(marker.list)
rm(so.markers)


all.deg.list <- query_markers.list

for (i in 1:length(query_markers.list)){
  
  set.name <- names(query_markers.list)[i]
  qm.res <-  query_markers.list[[set.name]]
  
  if (parameter.list$only.pos){
    qm.res <- qm.res %>% dplyr::filter(logFC > 0, padj <= parameter.list$fdr.threshold, abs(logFC) > parameter.list$lfc.threshold)
  } else {
    qm.res <- qm.res %>% dplyr::filter(padj <= parameter.list$fdr.threshold, abs(logFC) > parameter.list$lfc.threshold)
  }
  
  query_markers.list[[set.name]] <- qm.res
}

```


```{r auc distribution curves, fig.width=12, fig.height=5, warning=FALSE}


message("Assessing marker specificities...")
auc.bins <- c(seq(0.5, 1, by = 0.01))

high.spec.threshold <- 0.8

qm.res.sum.sum.all <- NULL
hs.cells.all <- c()
for (i in 1:length(all.deg.list)){
  
  set.name <- names(all.deg.list)[i]
  qm.res <-  all.deg.list[[set.name]]
  
  qm.res.hs <- qm.res %>% dplyr::filter(auc > high.spec.threshold)
  hs.cluster <- unique(qm.res.hs$group)

hs.cells <- c()
 hs.cells <-  colnames(so.query)[which(so.query@meta.data[[set.name]] %in% hs.cluster)]
 hs.cells.all <- c(hs.cells.all, hs.cells)
  
    qm.res.sum.all <- NULL
  for (j in 1:(length(auc.bins))){
    qm.res.sum <- qm.res %>%
      dplyr::group_by(group) %>%
      dplyr::summarize(n.deg = sum((auc > auc.bins[j])),
                       bin = auc.bins[j], .groups = 'drop')
    qm.res.sum.all <- bind_rows(qm.res.sum.all, qm.res.sum)
    
  }
    
    qm.res.sum.all <- qm.res.sum.all %>%
      dplyr::group_by(group) %>%
      dplyr::mutate(p.deg = n.deg/sum(n.deg))
    n.clust <- ulength(qm.res.sum.all$group)
    qm.res.sum.sum <- qm.res.sum.all %>%
      dplyr::group_by(bin) %>%
      dplyr::summarize(n.clust = sum(n.deg > 0 ), .groups = 'drop')
     qm.res.sum.sum$p.clust <- qm.res.sum.sum$n.clust/ n.clust
    qm.res.sum.sum$res <- set.name
    qm.res.sum.sum.all <- bind_rows(qm.res.sum.sum.all, qm.res.sum.sum)

}


df.hs.cell <- data.frame(table(hs.cells.all))
colnames(df.hs.cell) <- c("var", "n.hs")

missing.cells <- colnames(so.query)[!(colnames(so.query) %in% df.hs.cell$var)]
if (length(missing.cells) != 0) df.hs.cell <- bind_rows(df.hs.cell, data.frame(var = missing.cells, n.hs = 0))

df.hs.cell$p.hs <- df.hs.cell$n.hs / length(all.deg.list)

df.umap.hs <- getUMAP(so.query)[["df.umap"]]
df.umap.hs <- merge(df.umap.hs, df.hs.cell)

df.umap.hs <- df.umap.hs[sample(seq(1,nrow(df.umap.hs)), nrow(df.umap.hs)) ,]

plt.specificity.umap <- df.umap.hs %>% 
  # dplyr::arrange()
  ggplot(aes(x = x, y = y, color = p.hs)) + 
  geom_point(size = 0.5) + 
  viridis::scale_color_viridis() + 
  theme_miko(legend = T) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
  labs(title = "Specificity Map", 
       color = "Prop. of\nresolutions", 
       subtitles = paste0("Proportion of resolutions in which cells have high specificity marker (AUC>", high.spec.threshold, ")"))

qm.res.sum.sum.all$res2 <- as.character(gsub(assay.pattern, "", qm.res.sum.sum.all$res))
plt.clust.spec <- qm.res.sum.sum.all %>% 
  ggplot(aes(x = bin, y = p.clust, color = res2)) + 
  geom_path() + 
  theme_miko(legend = T) + 
  xlab("AUC") + 
  ylab("Proportion of Clusters (>=1 DEG exceeding target AUC)") + 
  geom_vline(xintercept = 0.5, linetype = "dashed") + 
  labs(title = "Cluster Marker Specificity", subtitle = "Proportion of clusters with atleast one DEG exceeding target AUC",
       color = "Resolution", caption = "DEG: differentially-expressed gene; AUC: area under curve")


plt.spec.res <- cowplot::plot_grid(plt.clust.spec, plt.specificity.umap)
if (parameter.list$print.inline){
  print(plt.spec.res)
}

u.res <- unique(qm.res.sum.sum.all$res2)


# auc.sp
df.auc.spec <- NULL
for (i in 1:length(u.res)){
  qm.res.sum.sum.cur <- qm.res.sum.sum.all %>% dplyr::filter(res2 %in% u.res[i])
  x = qm.res.sum.sum.cur$bin
  y = qm.res.sum.sum.cur$p.clust
  id <- order(x)
  
  auc.spec <- sum(diff(x[id])*rollmean(y[id],2))
  
  df.auc.spec <- bind_rows(df.auc.spec, 
                           data.frame(
                             res = u.res[i],
                             auc = auc.spec
                           ))
}

plt.auc.spec <- df.auc.spec %>%
  ggplot(aes(x = res, y = auc)) + 
  geom_point(size = 3) + 
  geom_line(aes(group = 1)) + 
  theme_miko() + 
  labs(x = "Resoluton", y = "Area under marker specificity curve", title = "Marker Specificity")

if (parameter.list$print.inline){
  print(plt.auc.spec)
}

```


```{r make wide helper function}


make.wide <- function(u_clusters, top_markers, n_top_markers, rename_clusters = TRUE){
  top_markers_wide <- data.frame()
  
  top_marker_clusters <- as.vector(top_markers$group)
  
  u_clusters <- as.numeric(as.character(u_clusters))
  u_clusters <- u_clusters[order(u_clusters)]
  for (i in 1:length(u_clusters)){
    
    top_markers_current <- top_markers$feature[top_marker_clusters == u_clusters[i]]
    n_markers_cur <- length(top_markers_current)
    
    if (!(n_markers_cur >= n_top_markers)){
      top_markers_current <- c(top_markers_current, rep(NaN, n_top_markers-n_markers_cur))
    }
    
    top_markers_wide[seq(1, n_top_markers), c(paste("c", u_clusters[i], sep = ""))] <- as.data.frame(top_markers_current)
    if (!rename_clusters){
      colnames(top_markers_wide)[i] <- u_clusters[i]
    }
  }
  
  return(top_markers_wide)
}

```


```{r get top markers function}



# function to get top cluster-specific markers
get.topmarkers <- function(query.markers, n_top_markers = 10, cluster_res_label = "", rename_clusters = TRUE){
  
  top_markers <- query.markers %>% 
    dplyr::group_by(group) %>% 
    dplyr::arrange(desc(auc)) 
  
  top_markers_filter <- top_markers[ , c("group", "feature")]
  
  top_marker.tally <- top_markers_filter %>%
    dplyr::group_by(group) %>%
    dplyr::tally()
  max.n <- max(top_marker.tally$n)
  top_markers_filter$group <- as.numeric(as.character(top_markers_filter$group))

  top_markers$group <- paste("c", as.character(top_markers$group), sep = "")
  top_markers$pval <- signif( top_markers$pval, 3)
  top_markers$padj <- signif( top_markers$padj, 3)
  top_markers$logFC <- signif( top_markers$logFC, 3)
  
  top_markers_50 <- query.markers %>% 
    dplyr::group_by(group) %>% 
    dplyr::arrange(desc(auc)) %>%
    dplyr::top_n(n = 50, wt = auc)
  
  top_markers_50 <- top_markers_50[ , c("group", "feature")]
  
  
  
  u_clusters <- as.vector(unique(top_markers_filter$group))
  u_clusters <- u_clusters[order(u_clusters)]
  
  top_markers_wide <- make.wide(u_clusters, 
                                top_markers = top_markers_filter, 
                                n_top_markers = max.n, 
                                rename_clusters = rename_clusters)
  
  top_markers_50_wide <- make.wide(u_clusters, top_markers = top_markers_50, n_top_markers = 50, rename_clusters = rename_clusters)
  
  top5_markers <- query.markers %>% 
    dplyr::group_by(group) %>% 
    dplyr::arrange(desc(auc)) %>%
    dplyr::top_n(n = 50, wt = auc)
  
  
  # assign outputs to list and return
  output <- list(top_markers, top_markers_50, top_markers_wide, top_markers_50_wide, top5_markers)
  names(output) <- c("top_markers_res",
                     "top_markers_50_res",
                     "top_markers_wide_res",
                     "top_markers_50_wide_res",
                     "top5_markers_res")
  return(output)
}

```


```{r get top cluster markers, warning = FALSE }

# get top markers
which.res2rmv <- c()
top_markers_res.list <- list()         
top_markers_50_res.list <- list()      
top_markers_wide_res.list <- list()    
top_markers_50_wide_res.list <- list() 
top5_markers_res.list <- list()  

for (i in 1:length(query_markers.list)){
  if (length( query_markers.list[[i]]) == 0) {
    which.res2rmv <- c(which.res2rmv, parameter.list$cluster.resolution[i])
    next
  }
  output.markers <- get.topmarkers(query.markers = query_markers.list[[i]], cluster_res_label = parameter.list$cluster.resolution[i])
  
  top_markers_res.list[[as.character(parameter.list$cluster.resolution[i])]] <- as.data.frame(output.markers[["top_markers_res"]])     
  top_markers_50_res.list[[as.character(parameter.list$cluster.resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_res"]])     
  top_markers_wide_res.list[[as.character(parameter.list$cluster.resolution[i])]] <- as.data.frame(output.markers[["top_markers_wide_res"]])   
  top_markers_50_wide_res.list[[as.character(parameter.list$cluster.resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_wide_res"]])
  top5_markers_res.list[[as.character(parameter.list$cluster.resolution[i])]] <- as.data.frame(output.markers[["top5_markers_res"]])
  # quiet(list2env(output.markers, env = environment()), all = TRUE)  
}

# omit resolution where no DEGs were observed
cr_original <- parameter.list$cluster.resolution
parameter.list$cluster.resolution <-parameter.list$cluster.resolution[!(parameter.list$cluster.resolution  %in% which.res2rmv)]

```

```{r down sample cells function}


# downsample data if necessary
downsample_cells <- function(so.query, clust.name, n.downsample = 500, seed.value = 1023){
  
  set.seed(seed.value)
  
  cluster_id <- as.vector(so.query@meta.data[[clust.name]])
  u_clusters <- unique(cluster_id)
  
  n_per_cluster <- round(n.downsample / length(u_clusters))
  
  cells_to_plot <- c()
  for (i in 1:length(u_clusters)){
    
    cell_to_sample <- Cells(so.query)[cluster_id == u_clusters[i]]
    if (length(cell_to_sample) < n_per_cluster){
      cells_to_plot <-  c(cells_to_plot, cell_to_sample)
    } else {
      cells_to_plot <-  c(cells_to_plot, sample(Cells(so.query)[cluster_id == u_clusters[i]], n_per_cluster, replace = FALSE))
    }
    
  }

  so.query_small <- subset(so.query, cells = cells_to_plot)

  return(so.query_small)
}
```


```{r heatmap new}

plt.heat.scaled.list <- list()
for (i in 1:length(all.deg.list)){
  
  u.clust <- getOrderedGroups(so.query, which.group = names(all.deg.list)[i], is.number = T)
  df.prest <- all.deg.list[[names(all.deg.list)[i]]]
e.mat <- pivot_wider(df.prest %>% dplyr::select(feature, group, avgExpr), names_from = group, values_from = avgExpr)
e.mat <- col2rowname(e.mat, "feature"); e.mat <- as.matrix(e.mat[ ,order(as.numeric(colnames(e.mat)))])
df.e.wide <- data.frame(gene = rownames(e.mat), as.data.frame(e.mat)); colnames(df.e.wide) <- c("gene", u.clust)

# deg.gene <- query_markers.list[[names(all.deg.list)[i]]]$feature

  var.features <- so.query@assays[[DefaultAssay(so.query)]]@var.features
  
  # scaled expression plots
  df.s4plt <- as.matrix(df.e.wide %>% dplyr::select(-c("gene")))
  df.s4plt <- df.s4plt[rownames(df.s4plt) %in% unique(var.features), ]
  
  # df.s4plt <- (apply(df.s4plt, 2, function(x) (x-mean(x))/sd(x)))
  df.s4plt <- t(apply(df.s4plt, 1, function(x) (x-mean(x, na.rm = T))/sd(x, na.rm = T)))
  
  scale.lim <- 2 
  df.s4plt[df.s4plt > scale.lim] <- scale.lim
  df.s4plt[df.s4plt < (-1*scale.lim)] <- (-1*scale.lim)
  
  my.breaks <- seq((-1*scale.lim), scale.lim, by = 0.01)
  # my.col <- colorRampPalette(c(scales::muted("blue"), "white",scales::muted("red")))(length(my.breaks))
  
  df.s4plt <- df.s4plt[!(apply(df.s4plt, 1, function(x) all(is.na(x)))), ]
  
  plt.heat.scaled <- pheatmap::pheatmap(df.s4plt,
                                        breaks = my.breaks,
                                        color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(my.breaks)),
                                        show_rownames = F,
                                        main = "Scaled Expression\nx=cluster, y=gene, z=scaled expression", silent = T)
  
  plt.heat.scaled <- ggplotify::as.ggplot(plt.heat.scaled)
  
  rm(df.s4plt);
  
  plt.heat.scaled.list[[ names(all.deg.list)[i]]] <- plt.heat.scaled
  
}


```




```{r silhouette analysis}

sil.plot <- list()

df.umap <- getUMAP(so.query)[["df.umap"]]

umap.dist <- dist(x = (df.umap[,c("x", "y")]), method = "euclidean", diag = FALSE, upper = FALSE, p = 2)
mean.silw <- c()
for (i in 1:length(all.deg.list)){
  
  set.name <- names(all.deg.list)[i]
  sil <- cluster::silhouette(
    x = as.numeric(as.character(so.query@meta.data[,set.name] )),
    dist = umap.dist
  )
  
  sil.plot[[ set.name]] <- factoextra::fviz_silhouette(sil, print.summary = F) 
  
   gtitle <-  sil.plot[[set.name]][["labels"]][["title"]]
  mean.silw[i] <- as.numeric(gsub("Clusters silhouette plot \nAverage silhouette width: ", "", gtitle))  
  gtitle <- gsub("Clusters silhouette plot", paste("resolution: ", gsub(assay.pattern, "", set.name), sep = ""), gtitle)
  
  
  sil.plot[[set.name]] <- sil.plot[[set.name]] + ggtitle(gtitle)
  
}


```


```{r silhouette summaries}

df.silw <- NULL
for (i in 1:length(sil.plot)){
  set.name <- names(sil.plot)[i]
  clust.id <- as.numeric(gsub(assay.pattern, "", set.name))
  df.silw <- bind_rows(df.silw, data.frame(
    cluster.resolution = as.character(clust.id),
    sil.width = sil.plot[[set.name]][["data"]][["sil_width"]]
  ))
}

df.silw.sum <- df.silw %>% 
  dplyr::group_by(cluster.resolution) %>%
  dplyr::summarize(sil.mean = mean(sil.width, na.rm = T), .groups = 'drop')
plt.silw.dep <- df.silw %>%
  ggplot(aes(x = cluster.resolution, y = sil.width)) + 
  geom_violin(fill = "grey") + 
  geom_point(data = df.silw.sum, aes(x = cluster.resolution, y = sil.mean), size = 3) + 
  geom_line(data = df.silw.sum, aes(x = cluster.resolution, y = sil.mean, group = 1)) + 
  theme_miko() + 
  labs(x = "Resolution", y = "Silhouette Width", title = "Silhouette Width")

if (parameter.list$print.inline) print(plt.silw.dep)

```

```{r res vs n clust curve}

# get resolutions
clust.names <- names(query_markers.list)
current.assay <- DefaultAssay(so.query)
clust.res <- as.numeric(gsub(assay.pattern, "",clust.names))

# get cluster number
clust.n <- purrr::map_dbl(query_markers.list, function(x) length(unique(x[["group"]])))

# get number of degs per cluster
n.deg <- purrr::map(query_markers.list, function(x){
  if (nrow(x) > 0){
    df.sum <- x %>%
      dplyr::group_by(get("group")) %>%
      dplyr::summarize(
        sig.deg = sum(padj < 0.05), .groups = 'drop'
      )
  } else {
    NULL
  }
  
})

# compute deg statistics
n.deg.summary <- purrr::map(n.deg, function(x){
  if (!is.null(x)){
    df.sum <- data.frame(
      min.n = min(x$sig.deg, na.rm = T),
      max.n = max(x$sig.deg, na.rm = T),
      mean.n =mean(x$sig.deg, na.rm = T),
      sd.n = sd(x$sig.deg, na.rm = T),
      median.n = median(x$sig.deg, na.rm = T),
      n.clust = length(x$sig.deg)
    )
  } else {
    df.sum <- data.frame(
      min.n = NA,
      max.n = NA,
      mean.n = NA,
      sd.n = NA,
      median.n = NA,
      n.clust = NA
    )
  }
})

df.clust.n <- data.frame(clust.res = clust.res, 
                         n.clust = clust.n,
                         deg.meanN = purrr::map_dbl(n.deg.summary, function(x) x$mean.n),
                         deg.medianN = purrr::map_dbl(n.deg.summary, function(x) x$median.n),
                         deg.minN = purrr::map_dbl(n.deg.summary, function(x) x$min.n),
                         deg.maxN = purrr::map_dbl(n.deg.summary, function(x) x$max.n))

df.clust.mean <- df.clust.n[ ,c("clust.res", "deg.meanN")]; df.clust.mean$type = "mean"; colnames(df.clust.mean) <- c("res", "val", "type")
df.clust.min <- df.clust.n[ ,c("clust.res", "deg.minN")]; df.clust.min$type = "min"; colnames(df.clust.min) <- c("res", "val", "type")
df.clust.max <- df.clust.n[ ,c("clust.res", "deg.maxN")]; df.clust.max$type = "max"; colnames(df.clust.max) <- c("res", "val", "type")

df.clust.long <- bind_rows(df.clust.mean, df.clust.min, df.clust.max)

plt.deg.n <- df.clust.long %>%
  ggplot(aes(res, val, color = type)) + 
  geom_point(size = 3) + 
  geom_line() + 
  theme_miko(legend = T) + 
  ggthemes::scale_color_ptol() + 
  labs(title = "Number of Differentially-Expressed Genes (DEG)", x = "Resolution", y = "N DEG/Cluster", color = "Statistic") 
                         

plt.clust.n <- df.clust.n %>%
  ggplot(aes(clust.res, n.clust)) + 
  geom_line() + 
  geom_point(size = 3) + 
  theme_miko() + 
  xlab("Resolution") + 
  ylab("Cluster Number") + 
  labs(title = "Cluster Resolution vs. Number of Cell Populations")

if (parameter.list$print.inline){
  print(plt.clust.n)
  print(plt.deg.n)
}
```


```{r resolution-specific performance metrics, fig.width=15, fig.height=5}

marker.spec.list <- list()
u.res <- unique(qm.res.sum.sum.all$res)
for (i in 1:length(u.res)){
  
  qm.res.sum.sum.cur <- qm.res.sum.sum.all
  qm.res.sum.sum.cur$is.res <- qm.res.sum.sum.cur$res %in% u.res[i]
  qm.res.sum.sum.cur <- qm.res.sum.sum.cur %>% dplyr::arrange(is.res)
  u.res2 <- unique(as.character(qm.res.sum.sum.cur$res))
  qm.res.sum.sum.cur$res <- factor(qm.res.sum.sum.cur$res, levels = u.res2)
  marker.spec.list[[u.res[i]]] <- qm.res.sum.sum.cur %>% 
    dplyr::arrange(is.res) %>%
  ggplot(aes(x = bin, y = p.clust, color = is.res)) + 
  geom_path(aes(group = res)) + 
  theme_miko(legend = F) +
    scale_color_manual(values = c("TRUE" = "tomato", "FALSE" = "grey")) + 
  xlab("target AUC") + 
  ylab("Proportion of Clusters\n(>=1 DEG exceeding target AUC)") + 
  geom_vline(xintercept = 0.5, linetype = "dashed") + 
  labs(title = "Marker Specificity", 
       color = "Resolution", caption = paste0("red curve: resolution = ", gsub(assay.pattern, "", u.res[i]), "; grey curve: other resolutions" ))

}


res.specific.list <- list()
for (i in 1:length(query_markers.list)){
  
  set.name <- names(query_markers.list)[i]
  set.name2 <- gsub(assay.pattern, "", set.name)
  
  avg.sil  <- signif(mean((df.silw %>% dplyr::filter(cluster.resolution == set.name2) )$sil.width, na.rm = T), 3)
  
  # A: silhoutte
  p1 <- sil.plot[[set.name]] + 
    theme_set(theme_get() + theme(text = element_text(family = 'Open Sans'))) +
            theme_miko(legend = T) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) + 
    labs(x = "Cell Index", y = "Silhouette Width") + 
    labs(title = "Silhoutte Plot", subtitle = NULL) + 
    labs(subtitle = paste0("Resolution = ", set.name2), caption = paste0("Average silhouette width = ", avg.sil))
  
  # B: purity score UMAP
  avg.pur <- signif(mean(purity.umap.list[[set.name]]$data$purity, na.rm = T), 3)
  p2 <- purity.umap.list[[set.name]] + labs(subtitle = paste0("Resolution = ", set.name2), 
                                            caption = paste0("Average purity score = ", avg.pur))  
  
  # C: marker specificity score
  p3 <- marker.spec.list[[set.name]] + labs(subtitle = paste0("Resolution = ", set.name2))
  
  res.specific.list[[set.name]] <- cowplot::plot_grid(p1, p2, p3, nrow = 1, align = "h", axis = "tb", labels = c("H", "I", "J"))
  
}

```




```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
if (parameter.list$update.log){
  try({
    run.id <-  updateCentralLog(Module = "M18", input.data = parameter.list$input.file, input.subset = NA, pdf.flag = parameter.list$save.pdf)
    clog.update.success <-  T
  }, silent = F) 
}

if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M18_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (parameter.list$save.pdf) dir.create(paste0(output.path, "PDF/"))

```



Results
===================================== 

Sidebar {.sidebar data-width=400}
-------------------------------------

**Description**: A range of resolutions are used to cluster cells by unsupervised Louvain community detection. At each resolution, i) cluster-level UMAP and heatmap representations are generated, ii) resolution-specific performance metrics are derived, and iii) cluster-specific differential expression analysis is performed. 

**Figure Legends**:\
**A|** Resolution-specific UMAP representation of cell clusters.\
**B|** Resolution-specific heatmap of top variable genes. Mean expression values are scaled row-wise.\
**C|** Resolution-specific silhouette widths. *Range* = [-1,1]\
**D|** Resolution-specific purity scores. *Range* = [0,1]\
**E|** Resolution-specific marker specificity scores. *Range* = [0,0.5]\
**F|** Resolution-specific number of cell clusters.\
**G|** Resolution-specific number of differentially-expressed genes per cluster. Minimum, mean, and max values are shown.\
**H|** Silhouette plot.\
**I|** Purity scores overlaid on a UMAP. See notes for details. \
**J|** Marker specificity curve. See notes for details. *Red curve*: specified resolution; *grey curves*: all other resolutions.\

**Definitions**:\
**res**: Clustering resolution\
**UMAP**: Uniform manifold approximation and projection

**Notes**:\
**1. Purity Score**: For a given cell *i*, the purity score is defined as the proportion of cells within cell *i*'s K-nearest neighborhood (KNN) that belong to the most represented cluster within that KNN. The purity score ranges between 0 to 1. Neighborhoods in which cells belong to many different clusters are considered "*impure*" (low purity score) whereas neighborhoods in which cells belong to a single cluster are "*pure*" (high purity score). The purity score, together with the silouhette width, provides a measure of cluster consistency and is used in the selection of the optimal clustering resolution.\
**2. Marker Specificity**: The marker specificity score is a =measure of how well differentially-expressed genes (DEG) can discriminate (i.e., classify) clusters at a given resolution. To derive the specificity score, DEG analysis-derived AUC (DEG-AUC; see DEG Table) estimates are used to construct a *marker specificity curve* (Panel J). The x axis represents DEG-AUC values ranging from 0.5 to 1. The y axis represents the proportion of clusters that have at least 1 DEG exceeding the target DEG-AUC (on the x axis). The area under the marker specificity curve represents the *marker specificity score* and can range from 0 (no clusters have a specific DEG) to 0.5 (each cluster has a specific DEG). The marker specificity score can be compared across different clustering resolutions to determine at which resolution clusters have specific DEGs.\

**Sample Overview**:\
Cells, n: `r ncol(so.query)`\
Genes, n: `r nrow(so.query)`\
Variable genes, n: `r length(VariableFeatures(so.query))`\

UMI/cell, median: `r round(median(so.query@meta.data[["nCount_RNA"]]))`\
genes/cell, median: `r round(median(so.query@meta.data[["nFeature_RNA"]]))`\
Species: `r parameter.list$species`


Row {.tabset}
-------------------------------------

```{r plt.umap_by_all_clusters, message=FALSE, warning=FALSE, fig.width=12, fig.height=5}


plt.clust.ov <- list()
for (i in 1:length(plt.umap_by_cluster)){
  set.name <- names(plt.umap_by_cluster)[i]
  plt.clust.ov[[set.name]] <- cowplot::plot_grid(plt.umap_by_cluster[[set.name]], plt.heat.scaled.list[[set.name]], labels = "AUTO")
}


out <- lapply(seq_along(plt.clust.ov), function(i) {
  
  
  set.name <- gsub(assay.pattern, "", names(plt.clust.ov)[i])
  set.name2 <- names(plt.clust.ov)[i]
  
  a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res = ", set.name, sep = ""))) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width=12, fig.height=5}", 
                                          paste("clust_umap", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.clust.ov[['%s']])",set.name2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pdf plt.umap_by_all_clusters }

try({
  for (i in 1:length(plt.clust.ov)){
    set.name <- gsub(assay.pattern, "", names(plt.clust.ov)[i])
    suffix = "resolution.pdf"
    plot.name <- paste0("M18_umap_", gsub(".", "_", set.name, fixed = T), suffix)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.clust.ov[[i]], 
            fig.width = 12, fig.height = 5, save.flag = parameter.list$save.pdf)
  }
}, silent = T)


```



Row {.tabset}
-------------------------------------

### Metrics
```{r opt stat, message=FALSE, warning=FALSE, fig.width=25, fig.height=5}

plt.opt.stat <- cowplot::plot_grid( plt.silw.dep + geom_hline(yintercept = c(-1,1), linetype = "dashed"), 
                                    plt.cluster.purity + geom_hline(yintercept = c(0,1), linetype = "dashed"), 
                                    plt.auc.spec + geom_hline(yintercept = c(0,0.5), linetype = "dashed"),
                                    plt.clust.n + labs(title = "Number of Clusters"), 
                                     plt.deg.n + labs(title = "Number of DEGs"), nrow = 1, labels = c("C", "D", "E", "F", "G"), rel_widths = c(1,1,1,1,1.2))


print(plt.opt.stat)

try({
savePDF(file.name = paste0(output.path, "PDF/", "M18_optimization_metrics.pdf"), 
        plot.handle =  plt.opt.stat, 
         fig.width=25, fig.height=5, save.flag = parameter.list$save.pdf)
}, silent = T)

```

```{r plt.Silhouette, message=FALSE, warning=FALSE, fig.width=15, fig.height=5}

out <- lapply(seq_along(res.specific.list), function(i) {
  
  res.val <- gsub(assay.pattern, "", names(res.specific.list)[i])
  a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res = ", res.val, sep = ""))) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width=15, fig.height=5}", 
                                          paste("sil.plt", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(res.specific.list[[ names(res.specific.list)[%d]]])",i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pdf plt.Silhouette }

try({
  for (i in 1:length(res.specific.list)){
    res.val <- gsub(assay.pattern, "", names(res.specific.list)[i])
    plot.name <- paste0("M18_performance_metrics_", gsub(".", "_",res.val, fixed = T), "resolution.pdf")
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  res.specific.list[[i]], 
            fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
  }
}, silent = T)

```


DEG Table
===================================== 


Sidebar {.sidebar}
-------------------------------------

**Description**: Differentially-expressed genes (DEG) across different cluster resolutions. 

**Definitions**:\
**gene**: Gene symbol\
**cluster**: Cluster name\
**avgExpr**: Average cluster-level gene expression.\
**logFC**: Log fold-change between gene expression within and outside of cluster.\
**auc**: Area under receiver operator curve. Also referred to as DEG-AUC, the AUC measures a gene's ability to distinguish between clusters. AUC values range 0 to 1, where 0.5 represents classification performance equal to random chance, and 1 represents perfect cluster classification.\
**pval**: Nominal p value.\
**padj**: Benjamini-hochberg adjusted p-value (i.e. FDR)\
**pct_in**: Percentage of cells within cluster with non-zero gene expression.\
**pct_out**: Percentage of cells outside cluster with non-zero gene expression.\
**pct_dif**: Difference between pct_in and pct_out.\


Row {.tabset}
-------------------------------------

```{r detailed table output v2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

for (i in 1:length(top_markers_res.list)){
  df.deg <- top_markers_res.list[[i]]
  df.deg[ ,c("avgExpr", "logFC", "auc", "pval", "padj", "pct_in", "pct_out", "pct_dif")] <- signif(df.deg[ ,c("avgExpr", "logFC", "auc", "pval", "padj", "pct_in", "pct_out", "pct_dif")])
  df.deg <- df.deg %>% dplyr::select(c("feature", "group", "avgExpr", "logFC", "auc", "pval", "padj", "pct_in", "pct_out", "pct_dif"))
  colnames(df.deg) <- c("gene", "cluster", "avgExpr", "logFC", "auc", "pval", "padj", "pct_in", "pct_out", "pct_dif")
  top_markers_res.list[[i]] <- df.deg
}


out_heat <- lapply(seq_along(top_markers_res.list), function(i) {
  s1 <- paste("top_markers_res.list[[", i, "]]", sep = "")
  table.name <- paste("res=", names(top_markers_res.list)[i], "")
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v2", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})



```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`

```{r csv cm2}

for (i in 1:length(top_markers_res.list)){
  table.name <- paste0("markerStatistics_", gsub(".", "_", names(top_markers_res.list)[i], fixed = T), "resolution.csv")
    write.csv(top_markers_res.list[[i]], file = paste0(output.path, "Tables/", table.name), 
    row.names = F) 
}

```

```{r save analysis log and Rdata results, message=FALSE, warning=FALSE}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_18 <- df.log



```

```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 18)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_18)

```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_18, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

