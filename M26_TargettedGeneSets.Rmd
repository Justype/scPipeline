---
title: "Module26_targetGenePanel"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
params:
  print.flag: FALSE
---

```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = ls())
gc()

# initiate timer
start.time <- proc.time()

# load packages

library(ComplexHeatmap)
library(viridis)
library(scMiko)
# modulePackages()
    packages2load <- c("Seurat", "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "gridExtra",
                       "DT", "flexdashboard", "ggpmisc", "ggExtra", "grid", "ggrepel", "ddpcr",
                       "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "plotly", "ggplot2", "reactome.db")

    # load packages
    lapply(packages2load, library, character.only = TRUE)

```



```{r}



cluster.resolution <- c(neftel = 1,
                        p4.gbm = 1,
                        p9.pr = 1,
                        p9.ct2a = 1)
query.files <- list(neftel = "Module1_Neftel_10x_160120.Rdata",
                    p4.gbm = "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata",
                    p9.pr = "Module1_p9_GBM_PRpaired_all_240620.Rdata",
                    p9.ct2a = "Module1_p9_CT2A_250620.Rdata"
                    )
which.species <- c(neftel = "Hs",
                   p4.gbm = "Hs",
                   p9.pr = "Hs",
                    p9.ct2a = "Hs")


# cluster.resolution <- c(p4.gbm = 1,
#                     p7.gbm = 1,
#                     p9.ct2a = 1,
#                     p8.gl261 = 1,
#                     p9.ct2a = 1,
#                     p9.pr = 1)
# 
# query.files <- list(p4.gbm = "Module1_pilot4_GL261_CT2A_scaleAll_080120",
#                     p7.gbm = "Module1_p7_GBM_080720.Rdata",
#                     p9.ct2a = "Module1_p8_CT2A_tumor_090720.Rdata",
#                     p8.gl261 = "Module1_p8_GL261_tumor_090720.Rdata",
#                     p9.ct2a = "Module1_p9_CT2A_250620.Rdata",
#                     p9.pr = "Module1_p9_GBM_PR_noFilter_270620.Rdata"
#                     )
# 
# which.species <- c(p4.gbm = "Hs",
#                     p7.gbm = "Hs",
#                     p9.ct2a = "Hs",
#                     p8.gl261 = "Hs",
#                     p9.ct2a = "Hs",
#                     p9.pr = "Hs"
#                     )


# query.files <- list(p4.gbm = "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata",
#                     p9.CT2A = "Module1_p9_CT2A_250620.Rdata")





n.workers <- list(
  import = 6,
  recluster = 1
)


dir.preprocessed <- "Preprocessed_Datasets/"


train.set <-0.8
downsample.factor <-0.5 # 1 if unspecified
# downsample.n <- 900 # overrides downsample.factor. Set to NULL if unspecified.
downsample.n <- NULL

# include sex-specific and cell-cycle markers
additional.markers <- c(
  c("XIST", "EIF2S3Y", "KDM5D", "DDX3Y"),
  c(cc.genes$s.genes, cc.genes$g2m.genes))
add.which.goi <- c("u.hybrid.g250", "u.hybrid.g500", "u.hybrid.g1000", "s.hybrid.f10")



print.inline <- F

```



```{r analysis log}

df.log <- initiateLog("26, targetted gene panel")

# Query File
df.log <- addLogEntry("Query File", unlist(query.files), df.log, "query.file")
# Directory
df.log <- addLogEntry("Directory", dir.preprocessed, df.log, "dir.preprocessed")
# Downsample factor
df.log <- addLogEntry("Downsample factor", downsample.factor, df.log, "downsample.factor")
# Downsample Number
df.log <- addLogEntry("Downsample Cell Number", downsample.n, df.log, "downsample.n")
# which.species
df.log <- addLogEntry("Species", which.species, df.log, "which.species")
# additional custom genes
df.log <- addLogEntry("Custom Gene Selection", additional.markers, df.log, "additional.markers")
# custom genes added to which geneseset
df.log <- addLogEntry("Custom Gene Selection Add to Sets", add.which.goi, df.log, "add.which.goi")
# Cluster resolution
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
# print.inline
df.log <- addLogEntry("Print inline", print.inline, df.log, "print.inline")


# get prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```




```{r import seurat object}

# import and preprocess data ############

# intitiate lists
import.list <- list()

# start cluster
library(foreach)
n.datasets <- length(query.files)
cl <- parallel::makeCluster(if (n.workers$import > n.datasets) n.datasets else n.workers$import)
doParallel::registerDoParallel(cl)

# iterate through each input file
import.list <- foreach(i = 1:length(query.files), .packages = c("scMiko"))  %dopar% {
  
  load(getLoadPath(query.files[[i]], dir.preprocessed))
  
  list(
    so = prepSeurat(so),
    gNames.list = gNames.list
  )
}

# stop workers
parallel::stopCluster(cl)

# unpack results
so.list <- list()
gNames.lists <- list()

for (i in 1:n.datasets){
  input.label <- names(query.files)[i]
  so.list[[input.label]] <- import.list[[i]]$so
  gNames.lists[[input.label]] <- import.list[[i]]$gNames.list
}

# remove baggage
rm(import.list)

```

```{r get clusters and assay}

# get current assay
current.assays <- lapply(so.list, DefaultAssay)
current.assay <- unique(unlist(current.assays))

# get cluster
for (i in 1:length(so.list)){
  so.list[[i]] <- setResolution( so.list[[i]], cluster.resolution[i])
}


```



```{r prior log history}
# get prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r convert to symbol}

for (i in 1:length(so.list)){
  
  # convert ENSEMBL to GENE names in Seurat object
  gene.rep <-  checkGeneRep (gNames.lists[[i]], as.vector(rownames(so.list[[i]]@assays[[current.assays[[i]]]]@scale.data)))
  
  if (gene.rep == "ensembl"){
    so.list[[i]] <- ens2sym.so(so = so.list[[i]], gNames.list = gNames.lists[[i]])
    gene.rep <-  checkGeneRep( gNames.lists[[i]], as.vector(rownames(so.list[[i]]@assays[[current.assays[[i]]]]@scale.data)))
    stopifnot(gene.rep == "symbol")
  } 
  
}

```

```{r fix dim}


updateAssayDim <- function(so, gNames.list){
  a.meta <- so@assays[["RNA"]]@meta.features
  gene.rep <- checkGeneRep(gNames.list, rownames(so))
  if (is.null(so@assays[["RNA"]]@counts@Dimnames[[1]])){
    if (gene.rep == "symbol"){
      so@assays[["RNA"]]@counts@Dimnames[[1]] <- so@assays[["RNA"]]@data@Dimnames[[1]] <- a.meta$SYMBOL
    } else if (gene.rep == "ensembl"){
      so@assays[["RNA"]]@counts@Dimnames[[1]] <- so@assays[["RNA"]]@data@Dimnames[[1]]  <- a.meta$ENSEMBL
    }
  }
  
  return(so)
}


for (i in 1:length(so.list)){
  
  so.list[[i]] <- updateAssayDim(so.list[[i]], gNames.lists[[i]])
}


```

```{r get clusters and set assay}

# get default assay

current.assays <- c()
for (i in 1:length(so.list)){
  if (DefaultAssay(so.list[[i]]) == "integrated") DefaultAssay(so.list[[i]]) <- "SCT"
  current.assays[i] =  DefaultAssay(so.list[[i]])
}

current.assay <- unique(current.assays)

# ensure only one type of assay is available
stopifnot(length(current.assay) == 1)
if (current.assay != "SCT") warning("default assay is not SCT")

```

```{r}

# so.list.orig <- so.list
```


```{r downsample Seurat}

# downsample data if necessary
if (exists("downsample.factor") & exists("downsample.n")) {
  
  for (i in 1:length(so.list)){
    so.list[[i]] <- downsampleSeurat(so.list[[i]], subsample.factor = downsample.factor, subsample.n = downsample.n)
  }
  
}

```

```{r split train-test sets}

so.train <- list()
so.test <- list()

for (i in 1:length(so.list)){
  
  # get setname
  set.name <- names(so.list)[i]
  
  # get number of cells for training
  n.cells <- ncol(so.list[[set.name]])
  train.n <- round(train.set*n.cells)
  
  # get train and test cell indices
  all.ind <- seq(1,n.cells)
  train.ind <- sample( all.ind,train.n)
  test.ind <- all.ind[!(all.ind %in% train.ind)]
  
  # split seurat into train and test sets
  so.train[[set.name]] <- UpdateSeuratObject(subset(so.list[[set.name]], cells = train.ind)) 
  so.test[[set.name]] <- UpdateSeuratObject(subset(so.list[[set.name]], cells = test.ind))
  
}

so.list <- so.train
rm(so.train)


```



```{r import markers}

# get unique species
u.species <- unique(which.species)

genelist.csv <- list(u.L1000 = "Gene_Sets/L1000_Subramanian2017.csv")

goi.length <- c()
goi.list <- list()
for (i in 1:length(genelist.csv)){
  # import markers
  set.name <- names(genelist.csv)[i]
  output.markers  <- m9.importMarkers(query.format = 2, 
                                      input.file = genelist.csv[[set.name]], 
                                      which.col = "first",
                                      which.species = u.species[1])
  
  # remove nuisance prefixes
  names( output.markers[["markers.of.interest"]]) <- rmvCSVprefix(  names( output.markers[["markers.of.interest"]]))
  output.markers[["marker_set_name"]] <- rmvCSVprefix( output.markers[["marker_set_name"]] )
  
  goi.list[[set.name]] <- output.markers[["markers.of.interest"]][,1]

}

# get avg goi length
goi.length <- 1000

```



```{r exp helper func}

# help function to get avg exp
get.exp <- function(so, which.center, which.data){
  
  # get expressing fraction
  is.success <- F
  
  try({
    df.fg.cur <- avgGroupExpression(
      so,
      which.data = which.data,
      which.center = which.center,
      which.group = "noGroup", 
      do.parallel = F
    )
    is.success <- T
  })
  
  if (!is.success){
    df.fg.cur <- avgGroupExpression(
      so,
      which.data = which.data,
      which.center = which.center,
      which.group = "noGroup", 
      do.parallel = T
    )
  }
  
  
  return(df.fg.cur)
}
```



```{r get expression data}


df.fg.all <- NULL
df.eg.all <- NULL
df.sd.all <- NULL

df.fg.list <-list()
df.eg.list <-list()
df.sd.list <-list()
goi.stats.list <- list()

# initiate gene ranking list
gene.rank.list <- list()

for (i in 1:length(so.list)){
  
  # get current dataset
  cur.group <- names(so.list)[i]
  so.list[[cur.group]]@meta.data[["noGroup"]] <- "0"
  
  # get expressing fraction
  df.fg.cur <- get.exp(so.list[[cur.group]], which.center = "fraction", which.data = "data")
  df.eg.cur <- get.exp(so.list[[cur.group]], which.center = "mean", which.data = "data")
  # df.sd.cur <- get.exp(so.list[[cur.group]], which.center = "sd", which.data = "data")
  
  # get variable genes
  var.genes <- VariableFeatures(so.list[[cur.group]])
  
    if (DefaultAssay(so.list[[cur.group]]) == "SCT") {
    gene.var.df <- so.list[[cur.group]]@assays[["SCT"]]@meta.features
    gene.var.df$genes <- rownames(gene.var.df)
  } 
  
  # ensure gene symbols are properly represented
  if (length(u.species) > 1){
    df.fg.cur$genes <- toupper(df.fg.cur$genes)
    df.eg.cur$genes <- toupper(df.eg.cur$genes)
    var.genes <- toupper(var.genes)
    try({gene.var.df$genes <- toupper(gene.var.df$genes)}, silent = T)
    # cur.goi.list <- lapply(cur.gene.list, toupper)
  } else {
    if (which.species[i] == "Mm"){
      df.fg.cur$genes <- firstup(df.fg.cur$genes)
      df.eg.cur$genes <- firstup(df.eg.cur$genes)
      var.genes <- firstup(var.genes)
      try({gene.var.df$genes <- firstup(gene.var.df$genes)}, silent = T)
      # cur.goi.list <- lapply(cur.gene.list, firstup)
    } else if (which.species[i] == "Hs"){
      df.fg.cur$genes <- toupper(df.fg.cur$genes)
      df.eg.cur$genes <- toupper(df.eg.cur$genes)
      var.genes <- toupper(var.genes)
      try({gene.var.df$genes <- toupper(gene.var.df$genes)}, silent = T)
      # cur.goi.list <- lapply(cur.gene.list, toupper)
    } 
  }
  
  gene.rank.df <- merge(df.fg.cur, df.eg.cur, by = "genes")
  colnames(gene.rank.df) <- c("genes", "exp.fraction", "exp.mean")
  try({
    gene.var.df <- gene.var.df[ , c("sct.residual_variance", "genes")]
    gene.rank.df <- merge(gene.rank.df, gene.var.df, by = "genes")
    }, silent = T)

  
  # rename data.frame columns
  colnames(df.fg.cur) <- c("genes", cur.group)
  colnames(df.eg.cur) <- c("genes", cur.group)
  
  # store stats
  goi.stats.list[[cur.group]] <- list(data = cur.group,
                                      n.total = nrow(df.fg.cur),
                                      total = df.fg.cur$genes,
                                      n.captured = length(df.fg.cur$genes[df.fg.cur[ ,2] > 0]),
                                      captured = df.fg.cur$genes[df.fg.cur[ ,2] > 0],
                                      capture.efficiency = length(df.fg.cur$genes[df.fg.cur[ ,2] > 0]) / nrow(df.fg.cur),
                                      var = var.genes,
                                      n.var = length(var.genes))
  
  
  # merge data
  if (is.null(df.fg.all)){
    # df.fg <- df.fg.goi.cur
    df.fg.all <- df.fg.cur
    df.fg.list[[cur.group]] <- list(data = df.fg.cur)
    
    # df.eg <- df.eg.goi.cur
    df.eg.all <- df.eg.cur
    df.eg.list[[cur.group]] <- list(data = df.eg.cur)
  } else {
    # df.fg <- merge(df.fg, df.fg.goi.cur, "genes")
    df.fg.all <- merge(df.fg.all, df.fg.cur, "genes")
    df.fg.list[[cur.group]] <- list(data = df.fg.cur)
    
    # df.eg <- merge(df.eg, df.eg.goi.cur, "genes")
    df.eg.all <- merge(df.eg.all, df.eg.cur, "genes")
    df.eg.list[[cur.group]] <- list(data = df.eg.cur)
  }
  
  # watch this step carefully...removing duplicates based off GENE name and fraction expressed
  # gene.rank.df <- gene.rank.df %>% dplyr::distinct(genes, exp.fraction, .keep_all = TRUE)
  gene.rank.df <- gene.rank.df %>% 
    group_by(genes) %>% 
    summarise_at(c("exp.fraction", "exp.mean", "sct.residual_variance"), mean, na.rm = TRUE)
  
  gene.rank.list[[cur.group]] <- gene.rank.df
  
}

```

```{r characterize umi hogs}

# library(topGO)

do.hog.enrich <- F
df.read.hog <- NULL
plt.cRead.list <- list()
if (!exists("enrich.results")) enrich.results <- list()

gene.hog.list <- list()
c.reads.list <- list()

umi.results.list <- list()

for (i in 1:length(so.list)){
  
  sample.name <- names(so.list)[i]
  
  # get count matrix
  c.mat <- tryCatch({
    c.mat <- so.list[[sample.name]]@assays[["RNA"]]@data
  }, error = function(e){
    c.mat <- so.list[[sample.name]]@assays[["SCT"]]@counts
    return(c.mat)
  })
  
  
  # ensure gene names are avaialble
  try({
    if (is.null(rownames(c.mat))) rownames(c.mat) <- so.list[[sample.name]]@assays[["RNA"]]@meta.features[["SYMBOL"]]
  }, silent = T)
  
  # cast as dataframe
  c.df <- as.data.frame(c.mat)
  
  # compute sum of read counts for each gene #####################
  c.rsum <- apply(c.df, 1, sum)
  c.rsum.df <- data.frame(genes = toupper(names(c.rsum)), count = c.rsum)
  c.rsum.df <- c.rsum.df %>% group_by(genes) %>% summarise_at(c("count"), sum, na.rm = TRUE)
  c.rsum.df$fraction <- c.rsum.df$count/sum(c.rsum.df$count)
  c.rsum.df <- c.rsum.df[c.rsum.df$fraction != 0, ]
  c.rsum.df$rank <- rank(c.rsum.df$fraction)
  
  # add read fraction to gene rank list
  c.rsum.fonly <- c.rsum.df[ ,c("genes", "fraction")]
  colnames(c.rsum.fonly) <- c("genes", "read.fraction")
  # cur.c.df <- cur.c.df %>% group_by(genes) %>% summarise_at("fraction", mean, na.rm = TRUE)
  c.rsum.fonly <- c.rsum.fonly %>% group_by(genes) %>% summarise_at("read.fraction", sum, na.rm = TRUE)
  # c.rsum.fonly <- c.rsum.fonly %>% dplyr::distinct(genes, read.fraction, .keep_all = TRUE)
  
  if (which.species[i] == "Hs"){
    gene.rank.list[[sample.name]]$genes <- toupper(gene.rank.list[[sample.name]]$genes)
    c.rsum.fonly$genes <- toupper(c.rsum.fonly$genes)
  } else {
        gene.rank.list[[sample.name]]$genes <- firstup(gene.rank.list[[sample.name]]$genes)
    c.rsum.fonly$genes <- firstup(c.rsum.fonly$genes)
  }
  gene.rank.list[[sample.name]] <- merge(gene.rank.list[[sample.name]], c.rsum.fonly, by = "genes")
  
  c.rsum.df <- c.rsum.df %>% 
    arrange(rank) %>% 
    mutate(csum = cumsum(fraction))
  
  # cumulative read count
  top.50 <- sum(c.rsum.df$csum > 0.5)
  top.50.f <- 100*signif(top.50/nrow(c.rsum.df), 2)
  
  # compute filtering threshold
  filter.thres <- 2.58 #95%: 19.6, 98%: 2.33, 99%: 2.58
  f.log.mean <- mean(log10(c.rsum.df$fraction), na.rm = T)
  f.log.sd <- sd(log10(c.rsum.df$fraction), na.rm = T)
  f.log.ciup <- f.log.mean + 2*f.log.sd
  f.mad <- mad((c.rsum.df$fraction), na.rm = T)
  f.median <- median((c.rsum.df$fraction), na.rm = T)
  f.mean <- 10^f.log.mean 
  f.ciup <- 10^f.log.ciup
  # f.ciup <- f.median + 2*f.mad
  
  # OutVals = boxplot(c.rsum.df$fraction, plot=FALSE)$out
  
  # get filtered genes
  omitted.hog.genes <- c.rsum.df$genes[c.rsum.df$fraction >= f.ciup]
  retained.hog.genes <- c.rsum.df$genes[c.rsum.df$fraction < f.ciup]
  

  gene.hog.list[[sample.name]] <- omitted.hog.genes
  
  umi.omitted <- signif(sum(c.rsum.df$fraction[c.rsum.df$fraction > f.ciup])/sum(c.rsum.df$fraction), 2)
  genes.omitted <- signif(length(omitted.hog.genes) / nrow(c.rsum.df), 2)
  
    umi.results.list[[sample.name]] <- list(
    omit.genes = omitted.hog.genes,
    f.mean = f.mean,
    f.median = f.median,
    f.threshold = f.ciup,
    umi.fraction.omitted = umi.omitted
  )
  
  # generate plots
  plt.dist.log <- c.rsum.df %>%
    filter(fraction != 0) %>%
    ggplot(aes(x = fraction)) + 
    geom_density(fill = "grey") +
    geom_vline(xintercept = f.median, color = "black", linetype = "dashed") + 
    geom_vline(xintercept = f.ciup, color = "red") +
    xlab("Read Consumption (UMI Fraction, log10)") + 
    ylab("Density") + 
    theme_bw() + 
    labs(title = (paste0("UMI Fraction Density: ", sample.name)),
         subtitle = paste0("red line: filter threshold, black line: median\n", 
                           100*umi.omitted, "% UMI filtered out")) +
    scale_x_continuous(trans = 'log10') + annotation_logticks(sides = "b")
  
  plt.dist.cum <- c.rsum.df %>%
    ggplot(aes(x = rank, y = csum)) + 
    geom_line() +
    xlab("Gene Rank") + 
    ylab("Cumulative Fraction of Read Counts") + 
    theme_bw() + 
    labs(title = paste0("Cumulative Read Counts: ", sample.name),
         subtitle = paste0(top.50, " genes (", top.50.f, "% genes) = 50% reads (black line)\n", 
                           length(omitted.hog.genes)," genes (", 100*genes.omitted, "% genes) omitted = ", 
                           100*umi.omitted,  "% reads (red lines)")) + 
    geom_hline(yintercept = 0.5, linetype = "dashed") + 
    geom_hline(yintercept = 1-umi.omitted, color = "red") + 
    geom_vline(xintercept = nrow(c.rsum.df) - length(omitted.hog.genes), color = "red")
  
  
  plt.cRead.list[[sample.name]] <- cowplot::plot_grid(plt.dist.log, plt.dist.cum)
  
  # enrich top hoggers #######################
  # get query and background genes
  if ((!(sample.name %in% names(enrich.results))) & (do.hog.enrich)){
    g.query <- c.rsum.df$genes[c.rsum.df$csum > 0.5]
    g.universe <- c.rsum.df$genes
    
    if (which.species[sample.name] == "Mm"){
      g.query <- firstup(g.query); g.universe <- firstup(g.universe)
    } else if (which.species[sample.name] == "Hs"){
      g.query <- toupper(g.query); g.universe <- toupper(g.universe)
    }
    
    # ensure unique representaiton
    g.query <- unique(g.query)
    g.universe <- unique(g.universe)
    
    # go enrichment
    enrich.results[[sample.name]] <- enrichGO.fisher(gene.candidates = (g.query),
                                                     gene.universe = (g.universe),
                                                     which.species = which.species[sample.name],                                        
                                                     p.threshold = 0.05, padj.threshold = 0.05, topGO.object = NULL)
  }
 
 # get number of reads for suspect gene sets ############################
 
 # mitochondrial reads
 mt.reads <- sum(c.rsum.df$fraction[grepl("mt.", tolower(c.rsum.df$genes))])
 
 # ribosomal reads
 rp.reads <- sum(c.rsum.df$fraction[grepl("Rpl", firstup(c.rsum.df$genes)) | 
                                      grepl("Mrps", firstup(c.rsum.df$genes)) |
                                      grepl("Rpl", firstup(c.rsum.df$genes)) |
                                      grepl("Mrpl", firstup(c.rsum.df$genes))])
 
 # Misc reads
 gm.reads <- sum(c.rsum.df$fraction[grepl("Gm", firstup(c.rsum.df$genes))])
 ric.reads <- sum(c.rsum.df$fraction[grepl("ric", tolower(c.rsum.df$genes))])
 
 # housekeeping reads
 msig.df<- msigdbr::msigdbr(category = "C2")
 hkg <- msig.df$gene_symbol[msig.df$gs_name %in% "HSIAO_HOUSEKEEPING_GENES"]
 hkg.reads <- sum(c.rsum.df$fraction[tolower(c.rsum.df$genes) %in% tolower(hkg)])
 
 # cell cycle reads
 ccg <- c(cc.genes$s.genes, cc.genes$g2m.genes)
 cc.reads <- sum(c.rsum.df$fraction[tolower(c.rsum.df$genes) %in% tolower(ccg)])
 
 # sex.specific markers
 sx <- c("XIST", "EIF2S3Y", "KDM5D", "DDX3Y")
 sx.reads <- sum(c.rsum.df$fraction[tolower(c.rsum.df$genes) %in% tolower(sx)])
 
 # consolidate data
 df.rh.cur <- data.frame(sample = sample.name,
                         value = c(mt.reads, rp.reads, gm.reads, ric.reads, hkg.reads, cc.reads, sx.reads),
                         type = c("mitochondrial", "ribosomal", "Gm", "Ric", "housekeeping", "cell cycle", "sex markers"))
 
 df.read.hog <- bind_rows(df.read.hog, df.rh.cur)
 
 c.reads.list[[sample.name]] <- c.rsum.df
}

plt.read.hog <-df.read.hog %>%
  ggplot(aes(x = type, y = value, fill = sample)) + 
  geom_bar(stat = "identity", position = "dodge") + 
  xlab("Sample") + 
  ylab("Fraction of Readcounts") + 
  ggtitle("Suspect Read Consumption") + 
  ylim(c(0,1)) + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) 

if (print.inline){
  print(plt.read.hog)
  print(plt.cRead.list)
}

```


```{r gene rankings for literature-based genesets}

tp.file <-  "Gene_Sets/targetedPanel_geneSets_020620.xlsx"

df.uni <- readxl::read_excel(tp.file, "universal")
df.uni.long <- pivot_longer(df.uni, colnames(df.uni))
df.uni.tally <- data.frame(table(toupper(df.uni.long$value)))
colnames(df.uni.tally) <- c("genes", "n")

df.imm <- readxl::read_excel(tp.file, "immune")
df.imm.long <- pivot_longer(df.imm, colnames(df.imm))
df.imm.tally <- data.frame(table(toupper(df.imm.long$value)))
colnames(df.imm.tally) <- c("genes", "n")

df.can <- readxl::read_excel(tp.file, "cancer")
df.can.long <- pivot_longer(df.can, colnames(df.can))
df.can.tally <- data.frame(table(toupper(df.can.long$value)))
colnames(df.can.tally) <- c("genes", "n")

for (i in 1:length(gene.rank.list)){
  
  sample.name <- names(gene.rank.list)[i]
  gr.df <- gene.rank.list[[sample.name]]
  
  # aggregate duplicate genes
  c.gr.name <- colnames(gr.df)
  c.gr.name <- c.gr.name[c.gr.name != "genes"]
  gr.df <- gr.df %>% group_by(genes) %>% summarise_at(c.gr.name, mean, na.rm = TRUE)
  
  n.input <- nrow(gr.df)
  
  if (which.species[sample.name] == "Mm"){
    df.uni.tally$genes <- firstup(df.uni.tally$genes )
    df.imm.tally$genes <- firstup(df.imm.tally$genes )
    df.can.tally$genes <- firstup(df.can.tally$genes )
    
    # gr.df <- gr.df[complete.cases(gr.df), ]
    
  } else if (which.species[sample.name] == "Hs"){
    df.uni.tally$genes <- toupper(df.uni.tally$genes )
    df.imm.tally$genes <- toupper(df.imm.tally$genes )
    df.can.tally$genes <- toupper(df.can.tally$genes )
  }
  
  
  df.uni.tally.cur <- bind_rows(data.frame(genes = unique(gr.df$genes[!(gr.df$genes %in% df.uni.tally$genes)]), 
                                           n = 0), 
                                df.uni.tally)
  colnames(df.uni.tally.cur) <- c("genes", "universal.n")
  df.uni.tally.cur <- df.uni.tally.cur[df.uni.tally.cur$genes %in% gr.df$genes, ]
  
  df.imm.tally.cur <- bind_rows(data.frame(genes = unique(gr.df$genes[!(gr.df$genes %in% df.imm.tally$genes)]), 
                                           n = 0), 
                                df.imm.tally)
  colnames(df.imm.tally.cur) <- c("genes", "immune.n")
  df.imm.tally.cur <- df.imm.tally.cur[df.imm.tally.cur$genes %in% gr.df$genes, ]
  
  df.can.tally.cur <- bind_rows(data.frame(genes = unique(gr.df$genes[!(gr.df$genes %in% df.can.tally$genes)]), 
                                           n = 0), 
                                df.can.tally)
  colnames(df.can.tally.cur) <- c("genes", "cancer.n")
  df.can.tally.cur <- df.can.tally.cur[df.can.tally.cur$genes %in% gr.df$genes, ]
  
  gr.df <- merge(gr.df, df.uni.tally.cur, by = "genes")
  gr.df <- merge(gr.df, df.imm.tally.cur, by = "genes")
  gr.df <- merge(gr.df, df.can.tally.cur, by = "genes")
  
  stopifnot(nrow(gr.df) == n.input)
  
   gene.rank.list[[sample.name]] <- gr.df
}

# gene.rank.list[[cur.group]] <- gene.rank.df

plt.re.fraction.list <- list()
for (i in 1:length(gene.rank.list)){
  sample.name <- names(gene.rank.list)[i]
  cur.grdf <-  gene.rank.list[[sample.name]]
 plt.re.fraction.list[[sample.name]] <- cur.grdf %>%
  ggplot(aes(x = exp.fraction, y= log10(read.fraction))) + 
  geom_point() + 
   ggtitle(sample.name) + 
   xlab("Fraction of Expression Cells") + 
   ylab("Fraction of total UMI (log10)") + 
   theme_bw()
}

if (print.inline){
  print(cowplot::plot_grid(plotlist = plt.re.fraction.list, ncol = 3))
}

```


```{r gene rankings, fig.width=8,fig.height=6}


grank.gene.list <- list()
grank.plt.list <- list()
grank.df.list <- list()

no.class.color <- "black"
omit.class.color = "tomato"
set.class.color <- "forestgreen"

for (i in 1:length(gene.rank.list)){
  
  sample.name <- names(gene.rank.list)[i]
  
  gr.df <- gene.rank.list[[sample.name]]
  gr.df <- gr.df[complete.cases(gr.df), ]
  
  granks.df <- data.frame(
    genes = gr.df$genes,
    read.fraction = gr.df$read.fraction,
    fraction.rank = rank(-gr.df$exp.fraction),
    variance.rank = rank(-gr.df$sct.residual_variance),
    read.rank = rank(gr.df$read.fraction),
    universal.rank = rank(-gr.df$universal.n),
    immune.rank = rank(-gr.df$immune.n),
    cancer.rank = rank(-gr.df$cancer.n))
  
  
  which.ranks <- c("fraction.rank", "variance.rank", "read.rank", "universal.rank", "cancer.rank")
  granks.df$overall.rank <- apply(granks.df[, which.ranks],1, function(x) prod(x)^(1/length(x)))
  granks.df$overall.rank.var <- apply(granks.df[, which.ranks],1, sd)
  granks.df$overall.p.rank <- granks.df$overall.rank/max(granks.df$overall.rank)
  
  # apply umi consumption filter
  granks.df$gene.class <- no.class.color
  granks.df$gene.class[toupper(granks.df$genes) %in% toupper(umi.results.list[[sample.name]][["omit.genes"]])] <- omit.class.color
  granks.df$read.fraction.omithogs <- granks.df$read.fraction
  granks.df$read.fraction.omithogs[granks.df$gene.class == omit.class.color] <- 0
  
  # get final list based off overall ranking
  granks.df <- granks.df %>%
    arrange(overall.rank) %>%
    mutate(c.reads = cumsum(read.fraction.omithogs))
  
  granks.df$gene.class[(granks.df$gene.class != omit.class.color) & (granks.df$c.reads <= 0.1)] <- set.class.color

  
  # table(granks.df$gene.class)

plt.alpha = 0.1

  # geom_vline(xintercept = umi.results.list[[sample.name]][["f.threshold"]], linetype = "dashed", color = "tomato") + 
plt.rank.list <- list()

plt.fr <- granks.df %>%
  ggplot(aes(x = fraction.rank, y = overall.rank)) +
  geom_point(alpha = plt.alpha, color = granks.df$gene.class) +
  geom_smooth() + 
  xlab("Expressing Fraction of Cells (Rank)") + 
  ylab("Overall Rank") + 
  theme_bw()

plt.rank.list[[1]] <- plt.fr

plt.vr <- granks.df %>%
  ggplot(aes(x = variance.rank, y = overall.rank)) +
  geom_point(alpha = plt.alpha, color = granks.df$gene.class) +
  geom_smooth() + 
  xlab("Gene Variance (Rank)") + 
  ylab("Overall Rank") + 
  theme_bw()

plt.rank.list[[2]] <- plt.vr

plt.rr <- granks.df %>%
  ggplot(aes(x = read.rank, y = overall.rank)) +
  geom_point(alpha = plt.alpha, color = granks.df$gene.class) +
  geom_smooth() + 
  xlab("Fraction of UMI Reads (Rank)") + 
  ylab("Overall Rank") + 
  theme_bw()

plt.rank.list[[3]] <- plt.rr

if ("universal.rank" %in% which.ranks){
  plt.ubias <- granks.df %>%
  ggplot(aes(x = universal.rank, y = overall.rank)) +
  geom_point(alpha = plt.alpha, color = granks.df$gene.class) +
  geom_smooth() + 
  xlab("Universal Set (Rank)") + 
  ylab("Overall Rank") + 
  theme_bw()
  plt.rank.list[[length(plt.rank.list) + 1]] <- plt.ubias
}

if ("cancer.rank" %in% which.ranks){
plt.cbias <- granks.df %>%
  ggplot(aes(x = cancer.rank, y = overall.rank)) +
  geom_point(alpha = plt.alpha, color = granks.df$gene.class) +
  geom_smooth() + 
  xlab("Cancer Set (Rank)") + 
  ylab("Overall Rank") + 
  theme_bw()
plt.rank.list[[length(plt.rank.list) + 1]] <- plt.cbias
}



plt.grank.summary <- cowplot::plot_grid(plotlist = plt.rank.list, ncol = 3)

g.title <- cowplot::ggdraw() + 
  cowplot::draw_label(
    "Hybrid Geneset Scoring\nGreen: hybrid set, Red: omitted, Black: other\nlow ranks ~ high priority",
    fontface = 'bold',
    x = 0,
    hjust = 0
  ) +
  theme(
    # add margin on the left of the drawing canvas,
    # so title is aligned with left edge of first plot
    plot.margin = margin(7, 0, 0, 10)
  )

plt.grank.summary <- cowplot::plot_grid(
  g.title, plt.grank.summary,
  ncol = 1,
  # rel_heights values control vertical title margins
  rel_heights = c(0.17, 1.05)
)


grank.plt.list[[sample.name]] <- plt.grank.summary


if (print.inline){
  print(grank.plt.list[[sample.name]])
  # grank.plt.list
}


grank.df.list[[sample.name]] <- granks.df
grank.gene.list[[sample.name]] <- granks.df$genes[(granks.df$gene.class == set.class.color)]

  
}


gr.m.df <- NULL
c.m.df <- NULL
for (i in 1:length(grank.gene.list)){
  sample.name <- names(grank.gene.list)[i]
  cur.m.df <- grank.df.list[[sample.name]][ , c("genes", "overall.p.rank")]
  cur.c.df <- c.reads.list[[sample.name]][ , c("genes", "fraction")]
   cur.c.df <- cur.c.df %>% group_by(genes) %>% summarise_at("fraction", mean, na.rm = TRUE)
  colnames(cur.m.df) <- c("genes", sample.name)
  colnames(cur.c.df) <- c("genes", sample.name)
  if (is.null(gr.m.df)){
    gr.m.df <- cur.m.df
    c.m.df <- cur.c.df
  } else {
    gr.m.df <- merge(gr.m.df, cur.m.df)
    c.m.df <- merge(c.m.df, cur.c.df)
  }
}


hybrid.gene.list <- list()

# gr.m.df$h.rank <- apply(gr.m.df[ ,names(grank.gene.list)], 1, mean)
# c.m.df$h.fraction <- apply(c.m.df[ ,names(grank.gene.list)], 1, mean)

gr.m.df$h.rank <- apply(gr.m.df[ ,names(grank.gene.list)], 1, function(x) prod(x)^(1/length(x)))
c.m.df$h.fraction <- apply(c.m.df[ ,names(grank.gene.list)], 1, function(x) prod(x)^(1/length(x)))

gr.m.df <- merge(gr.m.df, c.m.df[, c("genes", "h.fraction")], by = "genes")

gr.m.df <- gr.m.df %>% dplyr::arrange(h.rank)
gr.m.df$f.csum <- cumsum(gr.m.df$h.fraction)
gr.m.df$f.csum.norm <- gr.m.df$f.csum/max(gr.m.df$f.csum)

u.hybrid.set <- list()

gr.m.df.sub <- gr.m.df[!(toupper(gr.m.df$genes) %in% toupper(additional.markers)), ]

# a <- (gr.m.df.sub %>% top_n(250, -h.rank))$genes
# b <- (gr.m.df %>% top_n(250, -h.rank))$genes
# d <- unique(c(a, b))
u.hybrid.set[["g250"]] <- (gr.m.df.sub %>% top_n(250 - length(additional.markers), -h.rank))$genes
u.hybrid.set[["g500"]] <- (gr.m.df.sub %>% top_n(500- length(additional.markers), -h.rank))$genes
u.hybrid.set[["g1000"]] <- (gr.m.df.sub %>% top_n(1000- length(additional.markers), -h.rank))$genes


gr.rank.cor <- gr.m.df[ ,c(names(grank.gene.list), "h.rank")]
colnames(gr.rank.cor) <- c(names(grank.gene.list), "u.hybrid")
plt.rank.cor <- GGally::ggpairs(gr.rank.cor, title="correlogram with ggpairs()", 
                                 lower = list(continuous = GGally::wrap("points", alpha = 0.01), 
                                              combo = GGally::wrap("dot_no_facet", alpha = 0.01))) +
  theme_bw() + 
  ggtitle("Hybrid Geneset Rank Correlations")

if (print.inline){
  print(plt.rank.cor)
  # print(grank.plt.list)
}


```



```{r sample-specific genesets}

# specfiy UMI target (fraction of input)
umi.target <- 0.1


# random geneset ###############################

gene.rand.list <- list()
g2f.map <- list()
for (i in 1:length(goi.stats.list)){
  
  # sample name
  sample.name <- names(goi.stats.list)[i]
  
  # shuffle genes (randomize)
  rand.candidate <- sample(goi.stats.list[[sample.name]][["captured"]], length(goi.stats.list[[sample.name]][["captured"]]))
  
  # get gene to fraction of umi mapping
  c.reads.cur <- c.reads.list[[sample.name]]
  c.reads.cur <- c.reads.cur[c.reads.cur$genes %in% rand.candidate, ]
  c.reads.cur <- c.reads.cur[complete.cases(c.reads.cur), ]
  c.reads <- c.reads.cur$fraction
  names(c.reads) <- c.reads.cur$genes
  
  which.ind <- which(!is.na(c.reads[rand.candidate]))
  
  # match target umi
c.reads.rand <- data.frame(genes = as.vector(rand.candidate)[which.ind], 
                             fraction = c.reads[rand.candidate][which.ind])
  c.reads.rand <- c.reads.rand[complete.cases(c.reads.rand), ]
  c.reads.rand$c.sum <- cumsum(c.reads.rand$fraction)
  
  # store gene set
  gene.rand.list[[sample.name]] <- c.reads.rand$genes[c.reads.rand$c.sum < umi.target]
  
  # store gene to fraction mapping 
  g2f.map[[sample.name]] <- c.reads
}


# top var geneset ###############################
gene.var.1000.list <- list()
gene.var.umiLimit.list <- list()

for (i in 1:length(so.list)){
  try({
    sample.name <- names(so.list)[i]
    df.meta <- so.list[[sample.name]]@assays[["SCT"]]@meta.features
    df.meta$rank <- rank(-df.meta$sct.residual_variance)
    df.meta$genes <- rownames(df.meta)
    df.meta <- df.meta %>% arrange(rank)
    
    # match target umi
    c.reads <- g2f.map[[sample.name]] 
    c.reads.var <- data.frame(genes = df.meta$genes, fraction = c.reads[df.meta$genes])
    c.reads.var <- c.reads.var[complete.cases(c.reads.var), ]
    c.reads.var$c.sum <- cumsum(c.reads.var$fraction)
    
    # get top var
    top.var <- df.meta$genes[df.meta$rank <= goi.length]
    
    # store gene set
    gene.var.umiLimit.list[[sample.name]] <- c.reads.var$genes[c.reads.var$c.sum < umi.target]
    gene.var.1000.list[[sample.name]] <- top.var
    
  }, silent = T)
}


```





```{r finalize master genelist,  include=FALSE}


# consolidate genesets ###############################
master.set <- list()
plt.overlap.list <- list()
for (i in 1:length(so.list)){
  
  sample.name <- names(so.list)[i]
  
  cur.gene.list <- list()
  if (!is.null( gene.rand.list[[sample.name]])) cur.gene.list[["s.rand.f10"]] <- gene.rand.list[[sample.name]]
  # if (!is.null( gene.var.1000.list[[sample.name]])) cur.gene.list[["s.var.g1000"]] <- gene.var.1000.list[[sample.name]]
  # if (!is.null( gene.var.umiLimit.list[[sample.name]])) cur.gene.list[["s.var.f10"]] <- gene.var.umiLimit.list[[sample.name]]
  # if (!is.null( gene.deg.1000.list[[sample.name]])) cur.gene.list[["s.deg.g1000"]] <- gene.deg.1000.list[[sample.name]]
  # if (!is.null( gene.deg.p.umiLimit.list[[sample.name]])) cur.gene.list[["s.deg.f10"]] <- gene.deg.p.umiLimit.list[[sample.name]]
  # if (!is.null( grank.gene.list[[sample.name]])) cur.gene.list[["s.hybrid.f10"]] <- grank.gene.list[[sample.name]]
  if (!is.null( u.hybrid.set[["g250"]])) cur.gene.list[["u.hybrid.g250"]] <- u.hybrid.set[["g250"]]
  if (!is.null( u.hybrid.set[["g500"]])) cur.gene.list[["u.hybrid.g500"]] <- u.hybrid.set[["g500"]]
  if (!is.null(  u.hybrid.set[["g1000"]])) cur.gene.list[["u.hybrid.g1000"]] <- u.hybrid.set[["g1000"]]
  
  
  # include imported genesets
  for (j in 1:length(goi.list)){
    goi.name <- names(goi.list)[j]
      cur.gene.list[[names(goi.list)[j]]] <- goi.list[[j]]
  }
  
  # add supplemental cur.gene.list
  for (j in 1:length(cur.gene.list)){
    goi.name <- names(cur.gene.list)[j]
    if (goi.name %in% add.which.goi){
      cur.gene.list[[goi.name]] <- c(cur.gene.list[[goi.name]], additional.markers)
    }
  }
  
  # ensure gene symbols are properly represented
  if (length(u.species) > 1){
    cur.gene.list <- lapply(cur.gene.list, toupper)
  } else {
    if (which.species[i] == "Mm"){
      cur.gene.list <- lapply(cur.gene.list, firstup)
    } else if (which.species[i] == "Hs"){
      cur.gene.list <- lapply(cur.gene.list, toupper)
    } 
  }
  
    # enforce unique entries
  for (j in 1:length(cur.gene.list)){
    goi.name <- names(cur.gene.list)[j]
      cur.gene.list[[goi.name]] <- unique( cur.gene.list[[goi.name]])
  }
  
  
  # generate plots and store results##########################

  plt.upset <- upset.Plot(cur.gene.list, row.title = "Genesets")
  
  j.mat <- jaccardSimilarityMatrix(cur.gene.list)
  plt.hm <- pheatmap::pheatmap(j.mat, show_colnames = F, main = "Jaccard Similarity")
  plt.hm <- ggplotify::as.ggplot(plt.hm)
 plt.overlap.list[[sample.name]] <- cowplot::plot_grid(grid.grabExpr(draw(plt.upset)), plt.hm)

  # store gene sets
  master.set[[sample.name]] <- cur.gene.list
  
  # store expression data
  df.fg.list[[sample.name]][["goi"]] <- cur.gene.list
  df.eg.list[[sample.name]][["goi"]] <- cur.gene.list
  
}

```


```{r plot upset and venn, fig.width=15, fig.height=5}

# print upset and venn plots
if (print.inline){
print(plt.overlap.list)
}

```

```{r consolidate fraction/expression data, fig.width = 10, fig.height = 5}

df.eg.merge <- NULL
df.fg.merge <- NULL

df.av.merge <- NULL
df.cov.merge <- NULL

for (i in 1:length(so.list)){
  
  # sample name
  sample.name <- names(so.list)[i]
  
  # goi set for current sample
  goi.cur <- df.eg.list[[sample.name]]$goi
  df.eg.cur <- df.eg.list[[sample.name]]$data
  df.fg.cur <- df.fg.list[[sample.name]]$data
  
  for (j in 1:length(goi.cur)){
    
    set.name <- names(goi.cur)[j]
    gene.cur <- goi.cur[[set.name]]
    
    df.eg.sub <- df.eg.cur[df.eg.cur$genes %in% gene.cur, ]
    colnames(df.eg.sub) <- c("genes", "value")
    df.fg.sub <- df.fg.cur[df.fg.cur$genes %in% gene.cur, ]
    colnames(df.fg.sub) <- c("genes", "value")
    
    df.eg.sub$sample <- sample.name
    df.eg.sub$set <- set.name
    
    df.fg.sub$sample <- sample.name
    df.fg.sub$set <- set.name
    
    df.eg.merge <- bind_rows(df.eg.merge, df.eg.sub)
    df.fg.merge <- bind_rows(df.fg.merge, df.fg.sub)
  }
}

plt.frac.exp <- df.fg.merge %>%
  ggplot(aes(set, value, fill = sample)) + 
  geom_boxplot() + 
  ylab("+ Fraction of Cells") + 
  xlab("Sample") + 
  theme_bw() + 
  ggtitle("Fraction of Expressing Cells") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9)

plt.mean.exp <- df.eg.merge %>%
  ggplot(aes(set, log10(value + 1e-5), fill = sample)) + 
  geom_boxplot() + 
  ylab("Mean Expression (log)") + 
  xlab("Sample") + 
  theme_bw() + 
  ggtitle("Mean Expression") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9)

# u.set.ext <-  names(genelist.csv)
# df.goi.fg <- df.fg.merge[df.fg.merge$set %in% u.set.ext, ]
df.av <- NULL
df.var <- NULL
for (i in 1:length(so.list)){
  
  sample.name <- names(so.list)[i]
  total.cur <- goi.stats.list[[sample.name]][["captured"]]
  var.cur <- goi.stats.list[[sample.name]][["var"]]
  
  cur.set <- master.set[[sample.name]]
  
  for (j in 1:length(cur.set)){
    
    set.name <- names(cur.set)[j]
    set.genes <- df.fg.merge$genes[df.fg.merge$set %in% set.name & df.fg.merge$sample %in% sample.name]
    
    n.av <- sum(set.genes %in% total.cur)
    n.mis <- sum(!(set.genes %in% total.cur))
    f.av <- n.av/length(set.genes)
    f.miss <- n.mis/length(set.genes)
    
    
    df.av.cur <- data.frame(sample = sample.name, 
                            set = set.name, 
                            value = c(f.av, f.miss),
                            availability = c("available", "missing"))
    
    df.av <- bind_rows(df.av, df.av.cur)
    
    n.set.var <- sum(set.genes %in% var.cur)
    n.set.novar <- length(set.genes) - n.set.var
    f.set.var <- n.set.var / length(set.genes)
    f.set.novar <- n.set.novar / length(set.genes)
    
    df.var.cur <- data.frame(sample = sample.name, 
                             set = set.name, 
                             value = c(f.set.var, f.set.novar),
                             dispersion = c("variable", "constant"))   
    
    
    df.var <- bind_rows(df.var, df.var.cur)
  }
}


df.av$availability <- factor(df.av$availability, levels = c("available", "missing"))
df.var$dispersion <- factor(df.var$dispersion, levels = c("variable", "constant"))


plt.gene.rep <- df.av %>%
  ggplot(aes(x = set, y = value, fill = availability)) + 
  geom_bar(stat = "identity") + 
  xlab("Sample") + 
  ylab("N Genes") + 
  ggtitle("Gene Availability") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  facet_wrap(~sample)

plt.var.rep <-  df.var %>%
  ggplot(aes(x = set, y = value, fill = dispersion)) + 
  geom_bar(stat = "identity") + 
  xlab("Sample") + 
  ylab("Geneset composition") + 
  ggtitle("Variable Gene Coverage") + 
  theme_bw() + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  facet_wrap(~sample)


plt.summary <- cowplot::plot_grid(plt.frac.exp, plt.mean.exp, plt.gene.rep, plt.var.rep, ncol = 2)
if (print.inline){
  print(plt.summary)
}




```




```{r}


scRecluster <- function(so, goi, gNames.list, sample.name, which.species, cluster.res, method = "SCT", impute.data = F){
  
  # assertions
  stopifnot(class(so) == "Seurat")
  if (!(which.species %in% c("Mm", "Hs"))) stop("Species must be either 'Mm' or 'Hs'")
  stopifnot(class(cluster.res) == "numeric")
  
  
  suppressWarnings({
    
    # sample name
    cur.group <-sample.name
    
    # downsample original count matrix
    orig.mat <- so@assays[["RNA"]]@data
    
    # get gene names
    if (!is.null(rownames(so@assays[["RNA"]]))){
      gene.names <- rownames(so@assays[["RNA"]])
      if (which.species == "Mm"){
        gene.names <- firstup(gene.names)
      } else if (which.species == "Hs"){
        gene.names <- toupper(gene.names)
      } 
    } else {
      if ("gene_name" %in% names(so@assays[["RNA"]]@meta.features)){
        gene.names <- so.list[[i]]@assays[["RNA"]]@meta.features[["gene_name"]]
      } else if ("SYMBOL" %in% names(so@assays[["RNA"]]@meta.features)){
        gene.names <- so@assays[["RNA"]]@meta.features[["SYMBOL"]]
      }
    }
    
    stopifnot(nrow(orig.mat) == length(gene.names))
    
    if (is.null(orig.mat@Dimnames[[1]])) orig.mat@Dimnames[[1]] <- gene.names
    
    # goi.cur <- speciesConvert.m26(goi, u.species, which.species)
    
    if (which.species == "Mm"){
      gene.names <- firstup(gene.names)
      goi.cur <- firstup(goi)
    } else if (which.species == "Hs"){
      gene.names <- toupper(gene.names)
      goi.cur <- toupper(goi)
    } 
    
    # aggregate duplicate genes in matrix
    orig.mat.sub <- orig.mat[gene.names %in% goi.cur, ]
    
    if (length(unique(gene.names)) < length(gene.names)){
      orig.mat.sub@Dimnames[[1]] <- make.unique(orig.mat.sub@Dimnames[[1]])
      df.mat <- as.data.frame(orig.mat.sub)
      df.mat <- bind_cols(data.frame(genes = gene.names[gene.names %in% goi.cur]), df.mat)
      df.mat <- aggregate(df.mat[,-1], list(Gene=df.mat[,1]), FUN = sum)
      input.mat <- as.matrix(df.mat)
      rownames(input.mat) <- input.mat[,1]
      input.mat <- input.mat[ ,2:ncol(input.mat)]
    } else {
      df.mat <- as.data.frame(orig.mat.sub)
      input.mat <- as.matrix(df.mat)
    }
      

    
    # create new seurat object
    so.new <- CreateSeuratObject(counts=input.mat,
                                 project=cur.group,min.cells=0,min.features=0,names.field=2,names.delim="." )

    norm.method <- NA


      so.new <- tryCatch({
        so.new <- scNormScale(so.new, gNames.list, method) 
      }, error = function(e){
        so.new<- scNormScale(so.new, gNames.list, "NFS")  
        return(so.new)
      }) 
    # }
    
    if (DefaultAssay(so.new) == "RNA"){
      norm.method <- "NFS"
    } else if (DefaultAssay(so.new) == "SCT"){
      norm.method <- "SCT"
    }
    
    # if (impute.data) norm.method <- paste0(norm.method, "-ALRA")
    
    
    
      
      # PCA
      
      # note that PCA is computed on ENTIRE reduced gene panel. Orginally computed on subset of variable genes. 
      so.new <- tryCatch({
        so.new <- RunPCA(so.new, verbose = FALSE, features = goi.cur)
      }, warning = function(w) {
        so.new <- RunPCA(so.new, verbose = FALSE, approx = F, features = goi.cur)
        return(so.new)
      }, error = function(e){
        so.new <- RunPCA(so.new, verbose = FALSE, approx = F, features = goi.cur)
        return(so.new)
      })
      
      n.dim <- ncol(so.new@reductions[["pca"]])
      if (n.dim > 30) n.dim <- 30
      
      so.new <- FindNeighbors(object = so.new, reduction = "pca", dims = 1:n.dim)
      so.new <- FindClusters(object = so.new, resolution = cluster.res, verbose = 0, algorithm = 1)
      so.new <- RunUMAP(so.new, dims = 1:n.dim)
    # }, silent = T)
    # if (!is.success) next
    
    plt.umap.original <- DimPlot(so, reduction = "umap", label = T)  + ggtitle(label = "Total Gene Set") +
     theme(legend.position = "none") + xlab("UMAP 1") + ylab("UMAP 2") 
    
    plt.umap.new <- DimPlot(so.new, reduction = "umap", label = T)  + ggtitle(label = "Reduced Gene Set (Targeted)") +
       theme(legend.position = "none")
    
    if (norm.method == "SCT"){
      plt.umap.new <- plt.umap.new +  xlab("UMAP 1 (SCT)") + ylab("UMAP 2 (SCT)") 
    } else if (norm.method == "NFS"){
      plt.umap.new <- plt.umap.new +  xlab("UMAP 1 (NFS)") + ylab("UMAP 2 (NFS)") 
    } else if (norm.method == "NFS-ALRA"){
      plt.umap.new <- plt.umap.new +  xlab("UMAP 1 (NFS-ALRA)") + ylab("UMAP 2 (NFS-ALRA)") 
    }
    
    # get number of clusters
    n.orig.clusters <- getOrderedGroups(so, which.group = "seurat_clusters", is.number = T)
    n.goi.clusters <- getOrderedGroups(so.new, which.group = "seurat_clusters", is.number = T)


    df.cluster.old <- as.character(so@meta.data[["seurat_clusters"]])
    df.cluster.new <- as.character(so.new@meta.data[["seurat_clusters"]])
    df.clust.pair <- data.frame(old = df.cluster.old, new = df.cluster.new)
    df.clust.pair$pair <- paste0(df.clust.pair$old, "-",df.clust.pair$new)
    
    # store results
    output <- list(
      sample.name = cur.group,
      so.goi = so.new,
      n.orig.clusters = n.orig.clusters,
      n.goi.clusters = n.goi.clusters,
      plt.umap.original = plt.umap.original,
      plt.umap.new = plt.umap.new,
      original.membership = df.cluster.old,
      new.membership = df.cluster.new,
      normalization.method = norm.method
    )
    
    # return
    return(output)
    
    
  })
}

master.set.orig <- master.set

```


```{r recluster data}

# ptm <- proc.time()
plt.umap.orig.list <- list()
plt.umap.new.list <- list()
co.mat.list <- list()
co.mat.norm.list <- list()

n.orig.clusters <- list()
n.goi.clusters <- list()

master.reclust <- list()
master.umap <- list()

for (i in 1:length(so.test)){
  
  sample.name <- names(so.test)[i]
  cur.gene.list <- master.set[[sample.name]]
  
  cur.gene.list <- c(list(reference = rownames(so.test[[i]])), cur.gene.list)
  
  master.set[[sample.name]] <- cur.gene.list
  
  
  cur.recluster.list <- list()
  cur.plt.list <- list()
  
  # co.mat.list.cur <- list()
  # co.mat.norm.list.cur <- list()
  
  for (j in 1:length(cur.gene.list)){
    # get gene list
    goi.name <- names(cur.gene.list)[j]
    cur.goi <- cur.gene.list[[goi.name]]
    
    # recluster
    
    reclust.results <- tryCatch({
            reclust.results <- scRecluster(so = so.test[[sample.name]], 
                                     goi =cur.goi, 
                                     gNames.list = gNames.lists[[sample.name]], 
                                     sample.name = sample.name, 
                                     which.species = which.species, 
                                     cluster.res = cluster.resolution[sample.name],
                                     method = "SCT", 
                                     impute.data = F)  
    }, error = function(e){
      reclust.results <- NULL
      return(reclust.results)
    })
    
    if (is.null(reclust.results)) next


    # store reclustered results
    cur.recluster.list[[goi.name]] <- reclust.results
    
    # get number of clusters
    n.orig.clusters[[sample.name]] <- reclust.results$n.orig.clusters
    n.goi.clusters[[sample.name]] <- reclust.results$n.goi.clusters
    
    # store plots and matrices
    # if (j == 1) cur.plt.list[["original"]] <- reclust.results$plt.umap.original + ggtitle(paste0("Reference"))
    cur.plt.list[[goi.name]] <- reclust.results$plt.umap.new + ggtitle(paste0("Reduced Gene Set\n", goi.name))

  master.reclust[[sample.name]] <- cur.recluster.list
  master.umap[[sample.name]] <- cur.plt.list
  
  gc()
  }
}


# master.umap

# cur.plt.list
# master.umap[["p4.gbm"]]

```


```{r avg line helper func}

StatMeanLine <- ggproto("StatMeanLine", Stat,
                        compute_group = function(data, scales) {
                          transform(data, yintercept=mean(y))
                        },
                        required_aes = c("x", "y")
)

stat_mean_line <- function(mapping = NULL, data = NULL, geom = "hline",
                           position = "identity", na.rm = FALSE, show.legend = NA, 
                           inherit.aes = TRUE, ...) {
  layer(
    stat = StatMeanLine, data = data, mapping = mapping, geom = geom, 
    position = position, show.legend = show.legend, inherit.aes = inherit.aes,
    params = list(na.rm = na.rm, ...)
  )
}

```


```{r nclusters}

# compute rand index
df.clust.n <- NULL
for (i in 1:length(so.list)){
  
  # get current sample
  sample.name <- names(so.list)[i]
  cur.reclust.list <- master.reclust[[sample.name]]
  
  u.orig.clust <- unique(as.numeric(master.reclust[[sample.name]][["reference"]]$original.membership))
  n.orig <- length(u.orig.clust)
  
  for (j in 1:length(cur.reclust.list)){
    
    # get gene set
    set.name <- names(cur.reclust.list)[j]
    reclust.results <- cur.reclust.list[[set.name]]
    
    
    u.new.clust <- unique(as.numeric(reclust.results$new.membership))
    
    
    n.new <- length(u.new.clust)
    
    df.n.cur <- data.frame(
      sample = NA,
      geneset = NA,
      n.clust.orig = NA,
      n.clust.reduced = NA
    )
    
    
    try({df.n.cur$sample = sample.name}, silent = T)
    try({df.n.cur$geneset = set.name}, silent = T)
    try({df.n.cur$n.clust.orig = n.orig}, silent = T)
    try({df.n.cur$n.clust.reduced = n.new}, silent = T)

    df.clust.n <- bind_rows(df.clust.n, df.n.cur)
  }

}


plt.clust.n <- df.clust.n %>%
  ggplot(aes(x = reorder(geneset, -n.clust.reduced), y= n.clust.reduced, fill = sample)) +
  geom_bar(position = "dodge", stat = "identity") +
  stat_mean_line(data = df.clust.n[df.clust.n$geneset == "reference", ], color = "black", linetype = "dashed")  + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) +
  theme_bw() +
  ggtitle("Number of Discernable Cell Populations") +
  ylab("N Populations") + 
  xlab("Gene Set") + facet_wrap(~sample) + theme(axis.text.x = element_text(angle = 25, hjust = 1)) 

if (print.inline){
  print(plt.clust.n)
}


```

```{r UMI per cell}

# get UMI per cell in reclusters seurat objects - i.e., idea is to maximize infromation content per UMI
df.umi <- NULL
for (i in 1:length(master.reclust)){
  
  sample.name <- names(master.reclust)[i]
  cur.recluster <- master.reclust[[sample.name]]
  
  for (j in 1:length(cur.recluster)){
    set.name <- names(cur.recluster)[j]
    
    df.umi.cur <- data.frame(sample = sample.name,
                             set = set.name,
                             n.umi.reduced = cur.recluster[[set.name]][["so.goi"]]@meta.data[["nCount_RNA"]],
                             n.umi.original = so.test[[sample.name]]@meta.data[["nCount_RNA"]])
    
    df.umi <- bind_rows(df.umi, df.umi.cur)
  }
}


df.umi$f.umi <- df.umi$n.umi.reduced / df.umi$n.umi.original

df.umi.sum <- df.umi %>%
  group_by(sample, set) %>%
  summarize(total.umi.reduced = sum(n.umi.reduced),
            total.umi.original = sum(n.umi.original))
df.umi.sum$total.umi.saved = df.umi.sum$total.umi.original - df.umi.sum$total.umi.reduced
df.umi.sum$f.umi = df.umi.sum$total.umi.reduced/df.umi.sum$total.umi.original
df.umi.sum$f.umic = 1-df.umi.sum$f.umi 

df.umi.total <- bind_rows(data.frame(set = df.umi.sum$set,
                                     sample = df.umi.sum$sample,
                                     value = df.umi.sum$f.umi,
                                     which.frac = "reduced"),
                          data.frame(set = df.umi.sum$set,
                                     sample = df.umi.sum$sample,
                                     value = df.umi.sum$f.umic,
                                     which.frac = "omitted"))

df.umi.total$which.frac <- factor(df.umi.total$which.frac, levels = c("omitted", "reduced"))

# sc-level umi counts
plt.umi.cell <- df.umi %>%
  ggplot(aes(reorder(set, f.umi), f.umi, fill = sample)) + 
  geom_boxplot() + 
  ylab("Fraction of UMI retained") + 
  xlab("Sample") + 
  theme_bw() + 
  ggtitle("Effects of reduced genesets on UMI/cell") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9)

# total umi counts
plt.umi.total <- df.umi.total %>%
  ggplot(aes(x = set, y = value, fill = which.frac)) + 
  geom_bar(stat = "identity") + 
  ylab("UMI fraction") + 
  xlab("Sample") + 
  theme_bw() + 
  ggtitle("Effects of reduced genesets on UMI/cell") + 
  theme(axis.text.x = element_text(angle = 25, hjust = 1)) + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  facet_wrap(~sample)

if (print.inline){
  cowplot::plot_grid(plt.umi.cell, plt.umi.total, ncol = 1, align = "hv")
}

```





```{r compute performance indices and add labels to umap, fig.width=15, fig.height=15}

# compute rand index
df.rand.ind <- NULL
df.ri.clust <- NULL

for (i in 1:length(so.test)){
  
  # get current sample
  sample.name <- names(so.test)[i]
  cur.reclust.list <- master.reclust[[sample.name]]
  cur.gene.sets <- master.set[[sample.name]]
  # deg.gene <- deg.list.all[[sample.name]] 
  
  
  # get reference cluster info
  orig.clust <- as.numeric(cur.reclust.list[["reference"]]$new.membership)
  uo.clust <- unique(orig.clust)
  uo.clust <- uo.clust[order(uo.clust)]
  
  for (j in 1:length(cur.reclust.list)){
    
    # get gene set
    set.name <- names(cur.reclust.list)[j]
    reclust.results <- cur.reclust.list[[set.name]]
    set.list <- cur.gene.sets[[set.name]]
    
    # get cluster memberships
    # orig.clust <- as.numeric(reclust.results$original.membership)
    new.clust <- as.numeric(reclust.results$new.membership)
    
    # cluster size adjusted rand ind

    df.ri.clust.cur <- NULL
    for (k in 1:length(uo.clust)){
      
      # cluster-corrected rand indices
      clust.ind <- which(orig.clust %in% uo.clust[k])
      ri.cur <- fossil::rand.index(orig.clust[clust.ind], new.clust[clust.ind])

          df.ri.clust.cur <- bind_rows(df.ri.clust.cur, 
                                   data.frame(sample = sample.name, set = set.name, 
                                              cluster = uo.clust[k], 
                                              cluster.size = length(clust.ind),
                                              rand.ind = ri.cur))
    }
    
    # get performance measures
    rand.ind <- fossil::rand.index(orig.clust, new.clust)
    rand.adj <- fossil::adj.rand.index(orig.clust, new.clust)
    rand.clust <- mean(df.ri.clust.cur$rand.ind, na.rm = T)
    rand.clust.sd <- sd(df.ri.clust.cur$rand.ind, na.rm = T)
    rand.clust.cv <- signif(100*rand.clust.sd/rand.clust, 3)
    
    umi.red <- df.umi.total$value[(df.umi.total$set %in% set.name) & 
                                    (df.umi.total$sample %in% sample.name) & 
                                    (df.umi.total$which.frac %in% "reduced")]
    cost.red <- signif(1/umi.red, 2)
    umi.red <- signif(umi.red, 2)
    
    # store performance measures
    df.rc.cur <- data.frame(sample = sample.name, geneset = set.name, 
                            rand.ind = rand.ind, rand.adj = rand.adj, 
                            rand.clust = rand.clust, rand.clust.sd = rand.clust.sd, rand.clust.cv = rand.clust.cv,
                            umi.red = umi.red, cost.red = cost.red
)
    df.rand.ind <- bind_rows(df.rand.ind, df.rc.cur)
    df.ri.clust <- bind_rows(df.ri.clust, df.ri.clust.cur)
    
    # annotate UMAP plots
    master.umap[[sample.name]][[set.name]] <- master.umap[[sample.name]][[set.name]] + 
      labs(title = paste0(set.name, " (", length(master.set[[sample.name]][[set.name]]), " genes)"),
           subtitle = paste0("r.ind=", signif(rand.ind, 2), "; r.adj=", signif(rand.adj, 2), "; r.clust=", signif(rand.clust, 2),
                             "\nUMI required: ", 100*umi.red, "% (", cost.red, "x cost-reduction)"))
  }
  
  if (print.inline){
    print(cowplot::plot_grid(plotlist = master.umap[[sample.name]]))
  }
}

 # master.umap[[sample.name]][[set.name]] 

```



```{r rand index calculations, fig.width=15, fig.height=6}

# generate rand index plots
plt.rand.adj <- df.rand.ind %>% 
  ggplot(aes(x = reorder(geneset, -rand.adj), y = rand.adj, fill = sample)) + 
  geom_bar(stat = "identity", position = "dodge") + 
  theme_bw()  + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  labs(title = "Clustering Similarities",
       subtitle = "Chance-adjusted Rand Index") + 
  ylab("Adjusted Rand Index") + 
  xlab("Gene Set") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# plt.rand.clust
plt.rand.clust <- df.ri.clust %>% 
  ggplot(aes(x = reorder(set, -rand.ind), y = rand.ind, fill = sample)) + 
  geom_boxplot() + 
  theme_bw()  + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  labs(title = "Clustering Similarities",
       subtitle = "Cluster-adjusted Rand Index") + 
  ylab("Cluster-adjusted Rand Index") + 
  xlab("Gene Set") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


plt.exp.per.1 <- df.ri.clust %>% 
  ggplot(aes(x = cluster.size, y = rand.ind, color  = sample, fill = sample)) + 
  geom_point() + 
  geom_smooth(formula = y~x, method = 'loess') + 
  theme_bw()  + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  scale_color_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  labs(title = "Cluster Size vs. Clustering Performance",
       subtitle = "Cluster-adjusted Rand Index") + 
  ylab("Cluster-adjusted Rand Index") + 
  xlab("Cluster Size (N Cells)") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  scale_x_continuous(trans = 'log10') + annotation_logticks(sides = "b")  + 
  coord_cartesian(ylim=c(0, 1)) + 
  facet_wrap(~set)


# geom_smooth(method = "lm", formula = y~x) + 
plt.exp.per.2 <- df.ri.clust %>% 
  ggplot(aes(x = n.deg.adj, y = rand.ind, color  = sample, fill = sample)) + 
  geom_point() + 
  geom_smooth(formula = y~x, method = 'loess') + 
  theme_bw()  + 
  scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  scale_color_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
  labs(title = "Number of DEGs vs. Clustering Performance",
       subtitle = "Cluster-adjusted Rand Index") + 
  ylab("Cluster-adjusted Rand Index") + 
  xlab("Number of Differentially-Expressed Genes (N DEGs)") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  scale_x_continuous(trans = 'log10') + annotation_logticks(sides = "b")   + 
  coord_cartesian(ylim=c(0, 1)) + 
  facet_wrap(~set)

# cowplot::plot_grid(plt.exp.per.1, plt.exp.per.2)

if (print.inline){
  # print(cowplot::plot_grid(plt.exp.per.1, plt.exp.per.2))
  print(cowplot::plot_grid(plt.rand.adj, plt.rand.clust))
}

```

```{r}

# compute stanardized score
sd.helper <- function(x){
  sx <- (x-mean(x, na.rm = T)) / sd(x, na.rm = T)
  return(sx)
}
```


```{r performance summary}


df.clust.n$clust.dif <- abs(df.clust.n$n.clust.reduced - df.clust.n$n.clust.orig)


# p.mat <- matrix(nrow = length(master.set), ncol = )
df.perf <- NULL
df.perf.list <- list()
df.perf.rank.list <- list()
plt.p.summary.list <- list()
df.perf.ranked <- NULL
df.rank.merge <- NULL
for (i in 1:length(master.set)){
  cur.sample <- names(master.set)[i]
  cur.sets <- master.set[[cur.sample]]
  
  df.perf <- NULL
  for (j in 1:length(cur.sets)){
    cur.set <- names(cur.sets)[j]
    

        df.p.cur <- data.frame(sample = NA,
                           set = NA,
                           cost.reduction = NA,
                           UMI.retained = NA,
                           rand.ind = NA,
                           rand.adj = NA,
                           rand.cluster = NA,
                           rand.sd = NA,
                           n.clusters = NA)
        
        try({df.p.cur$sample = cur.sample}, silent = T)
        try({df.p.cur$set = cur.set}, silent = T)
        try({df.p.cur$cost.reduction = df.rand.ind$cost.red[df.rand.ind$sample == cur.sample & 
                                                              df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$UMI.retained = df.rand.ind$umi.red[df.rand.ind$sample == cur.sample & 
                                                           df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$rand.ind = df.rand.ind$rand.ind[df.rand.ind$sample == cur.sample & 
                                                        df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$rand.adj = df.rand.ind$rand.adj[df.rand.ind$sample == cur.sample & 
                                                        df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$rand.cluster = df.rand.ind$rand.clust[df.rand.ind$sample == cur.sample & 
                                                              df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$rand.sd = df.rand.ind$rand.clust.sd[df.rand.ind$sample == cur.sample & 
                                                            df.rand.ind$geneset == cur.set]}, silent = T)
        try({df.p.cur$n.clusters = df.clust.n$clust.dif[df.clust.n$sample == cur.sample & 
                                                          df.clust.n$geneset == cur.set]}, silent = T)
        # try({df.p.cur$set.type.score = set.type.score}, silent = T)
    
    df.perf <- bind_rows(df.perf, df.p.cur)
  }
  
  # rank measures
  
  rank.method <- "rank" #options: 1) rank, 2) z, 3) norm
    df.perf.ranked <- df.perf
    
    if (rank.method == "rank"){
      
      df.perf.ranked$cost.reduction <- rank(-df.perf.ranked$cost.reduction)
      df.perf.ranked$UMI.retained <- rank(df.perf.ranked$UMI.retained)
      # df.perf.ranked$rand.ind <- rank(-df.perf.ranked$rand.ind)
      df.perf.ranked$rand.adj <- rank(-df.perf.ranked$rand.adj)
      df.perf.ranked$rand.cluster <- rank(-df.perf.ranked$rand.cluster)
      df.perf.ranked$rand.sd <- rank(df.perf.ranked$rand.sd)
      df.perf.ranked$n.clusters <- rank(df.perf.ranked$n.clusters)    
    } else if (rank.method == "z"){
      df.perf.ranked <- df.perf
      df.perf.ranked$cost.reduction <- sd.helper(-df.perf.ranked$cost.reduction)
      df.perf.ranked$UMI.retained <- sd.helper(df.perf.ranked$UMI.retained)
      # df.perf.ranked$rand.ind <- sd.helper(-df.perf.ranked$rand.ind)
      df.perf.ranked$rand.adj <- sd.helper(-df.perf.ranked$rand.adj)
      df.perf.ranked$rand.cluster <- sd.helper(-df.perf.ranked$rand.cluster)
      df.perf.ranked$rand.sd <- sd.helper(df.perf.ranked$rand.sd)
      df.perf.ranked$n.clusters <- sd.helper(df.perf.ranked$n.clusters)      
    } else if (rank.method == "norm"){
      df.perf.ranked <- df.perf
      df.perf.ranked$cost.reduction <- rescaleValues(-df.perf.ranked$cost.reduction)
      df.perf.ranked$UMI.retained <- rescaleValues(df.perf.ranked$UMI.retained)
      # df.perf.ranked$rand.ind <- rescaleValues(-df.perf.ranked$rand.ind)
      df.perf.ranked$rand.adj <- rescaleValues(-df.perf.ranked$rand.adj)
      df.perf.ranked$rand.cluster <- rescaleValues(-df.perf.ranked$rand.cluster)
      df.perf.ranked$rand.sd <- rescaleValues(df.perf.ranked$rand.sd)
      df.perf.ranked$n.clusters <- rescaleValues(df.perf.ranked$n.clusters)      
    }
  
  # aggregate similar measures to ensure they are not overweighted
  df.perf.ranked$cost.rank <- apply(df.perf.ranked[ ,c("cost.reduction", "UMI.retained")], 1, mean, na.rm = T)
  # df.perf.ranked$clusterSimilarity.rank <- apply(df.perf.ranked[ ,c("rand.adj", "rand.cluster")], 1, mean, na.rm = T)
  df.perf.ranked$ARI.rank <- df.perf.ranked$rand.adj
  df.perf.ranked$CRI.rank <-df.perf.ranked$rand.cluster
  df.perf.ranked$clusterBias.rank <-  df.perf.ranked$rand.sd
  df.perf.ranked$clusterNumber.rank <- df.perf.ranked$n.clusters
  # df.perf.ranked$setTypeScore.rank <- df.perf.ranked$set.type.score
  
  df.perf.ranked$overall.rank <- apply(df.perf.ranked[ ,c("cost.rank", "ARI.rank", "CRI.rank",
                                                          "clusterBias.rank", "clusterNumber.rank")], 1, mean, na.rm = T)
  
  
  pr.mat <- as.matrix(df.perf.ranked[ ,c("cost.rank", "clusterBias.rank", "ARI.rank", "CRI.rank",
                                         "clusterNumber.rank", "overall.rank") ])
  rownames(pr.mat) <- df.perf.ranked$set
  
  pr.mat <- pr.mat[order(df.perf.ranked$overall.rank), ]
  pr.mat <- signif(pr.mat, 2)
  
  plt.p.summary <- pheatmap::pheatmap(pr.mat, 
                                      cluster_rows = F,
                                      cluster_cols = F,
                                      display_numbers = pr.mat, 
                                      color = colorRampPalette(rev(brewer.pal(n = 7, name = "Greens")))(100),
                                      main = paste0("Ranked Performance Summary: ", cur.sample), silent = T)
  plt.p.summary <- ggplotify::as.ggplot(plt.p.summary)
  
  plt.p.summary.list[[cur.sample]] <- plt.p.summary
  
  # if (print.inline){
  #   print(plt.p.summary)
  # }
  
  df.perf.list[[cur.sample]] <- df.perf
  df.perf.rank.list[[cur.sample]] <- df.perf.ranked
  
  df.rank.merge <- bind_rows(df.rank.merge, df.perf.ranked)
  
}

# get overall summary
df.rank.sum <- df.rank.merge %>%
  group_by(set) %>%
  summarise_at(c("cost.rank", "clusterBias.rank", "ARI.rank", "CRI.rank",
                 "clusterNumber.rank", "overall.rank"), mean, na.rm = TRUE)

pr.mat.overall <- as.matrix(df.rank.sum[, c("cost.rank", "clusterBias.rank", "ARI.rank", "CRI.rank",
                                            "clusterNumber.rank", "overall.rank")])
rownames(pr.mat.overall) <- df.rank.sum$set

pr.mat.overall <- pr.mat.overall[order(df.rank.sum$overall.rank), ]
pr.mat.overall <- signif(pr.mat.overall, 2)

plt.p.summary <- pheatmap::pheatmap(pr.mat.overall, 
                                    cluster_rows = F,
                                    cluster_cols = F,
                                    display_numbers = pr.mat.overall, 
                                    color = colorRampPalette(rev(brewer.pal(n = 7, name = "Greens")))(100),
                                    main = paste0("Ranked Performance Summary: OVERALL"), silent = T)
plt.p.summary <- ggplotify::as.ggplot(plt.p.summary)

plt.p.summary.list[["overall"]] <- plt.p.summary
# plt.p.summary.list


  if (print.inline){
    print(plt.p.summary.list)
  }

```



```{r GSVA scoring}

# pathActivity.Tempora()
# 
# df.paths <- NULL
# 
# gsva.all.list <- list()
# 
# for (i in 1:length(master.set)){
#   cur.sample <- names(master.set)[i]
#   cur.sets <- master.set[[cur.sample]]
#   
#   if (which.species[i] == "Hs"){
#     gmt.path <- "http://download.baderlab.org/EM_Genesets/July_01_2020/Human/symbol/Human_GOBP_AllPathways_no_GO_iea_July_01_2020_symbol.gmt"
#   } else if (which.species[i] == "Mm"){
#     gmt.path <- "http://download.baderlab.org/EM_Genesets/July_01_2020/Mouse/symbol/Mouse_GOBP_AllPathways_no_GO_iea_July_01_2020_symbol.gmt"
#   }
#   
#   exprMatrix <- as.matrix(as.data.frame(so.test[[i]]@assays[["SCT"]]@data))
#   exprMatrix_bycluster <- list()
#   pathwaygmt <- GSEABase::getGmt(gmt.path)
#   
#   for (k in sort(unique(so.test[[cur.sample]]@meta.data[["seurat_clusters"]]))) {
#     exprMatrix_bycluster[[k]] <- rowMeans(exprMatrix[, which(colnames(exprMatrix) %in%
#                                                                rownames(so.test[[cur.sample]]@meta.data)[which(so.test[[cur.sample]]@meta.data[["seurat_clusters"]] ==
#                                                                                                                  k)])])
#   }
#   
#   names(exprMatrix_bycluster) <- sort(unique(so.test[[cur.sample]]@meta.data[["seurat_clusters"]]))
#   exprMatrix_bycluster <- do.call(cbind, exprMatrix_bycluster)
#   colnames(exprMatrix_bycluster) <- sort(unique(so.test[[cur.sample]]@meta.data[["seurat_clusters"]]))
#   rownames(exprMatrix_bycluster) <- rownames(exprMatrix)
#   
#   gsva.list <- list()
#   for (j in 1:length(cur.sets)){
#     
#     cur.set <- names(cur.sets)[j]
#     gene.set <- cur.sets[[cur.set]]
#     
#     e.mat.cur <- exprMatrix_bycluster[rownames(exprMatrix_bycluster) %in% gene.set, ]
#     
#     try({
#       gsva.list[[cur.set]] <- GSVA::gsva(as.matrix(e.mat.cur),
#                                          pathwaygmt, method="zscore", min.sz = 5, max.sz = 200,
#                                          parallel.sz = 1, verbose = F)
#       
#       
# 
#       
#       
#   gsva_bycluster_pca <- prcomp(t(gsva.list[[cur.set]] ), scale = T,
#                                center = T)
#   
#         plot(gsva_bycluster_pca[["sdev"]]/sum(gsva_bycluster_pca[["sdev"]]))
#         
#         pc.df <- as.data.frame(gsva_bycluster_pca[["rotation"]])
#       
#       colnames(gsva.list[[cur.set]]) <- colnames(e.mat.cur)
#     }, silent = T)
# 
#     
#   }
#   
#   # gsva.list <-  gsva.all.list[[cur.sample]]
#   gsva.all.list[[cur.sample]] <- gsva.list
#   
#   
#   n.paths <- purrr::map_dbl(gsva.list, nrow)
#   df.paths <- bind_rows(df.paths, 
#                         data.frame(
#                           sample = cur.sample,
#                           set = names(n.paths),
#                           n.paths = n.paths
#                         ))
#   
#   
#   ref.scores <- gsva.list[["reference"]]
#   
#   
#   for (k in 1:length()){
#     
#     k <- 1
#     
#     mean.x <- mean(ref.scores[ ,k], na.rm = T)
#     ci.width.x <- 1.96 * sd(ref.scores[ ,k], na.rm = T)
#     
#     # get top scores
#     cur.scores <- ref.scores[ ,k]
#     which.sig <- cur.scores > (mean.x + ci.width.x)
#     n.sig <- sum(which.sig)
#     
#     # get top pathways
#     top.paths <- rownames(ref.scores)[which.sig]
#     
#     
#     gsva.top <-  lapply(gsva.list, function(x) x[rownames(x) %in% top.paths,k])
#     gsva.top <- lapply(gsva.top, function(x) data.frame(paths = names(x), 
#                                                         score = x))
#     
#     gsva.top.df <- NULL
#     cor.df <- NULL
#     for (map.i in 1:length(gsva.top)){
#       if (is.null(gsva.top.df)){
#         if ("reference" == names(gsva.top)[map.i]) next
#         x.cur <- gsva.top$reference; colnames(x.cur) <- c("path", "x")
#         y.cur <- gsva.top[[map.i]]; colnames(y.cur) <- c("path", "y")
#         gsva.top.df <- merge(x.cur, y.cur, by = "path")
#         
#         cor.cur <- cor(gsva.top.df[ ,"x"], gsva.top.df[ , "y"])
#         
#         
#         
#         
#         # print(gsva.top.df %>%
#         #   ggplot(aes(x, y)) + 
#         #   geom_point() + 
#         #   theme_miko(legend = F) + 
#         #             geom_abline(slope = 1) )
#       # } else {
#       #   y.cur <- gsva.top[[map.i]]; colnames(y.cur) <- c("path", names(gsva.top)[map.i])
#       #   gsva.top.df <- merge(gsva.top.df, y.cur, by = "path")
#       # }
#       
#       }
#     }
#     
#     a <- cor(gsva.top.df[ ,names(gsva.top)])
#     
#   }
#   
#   
# }
# 
# 
# plt.gsva.pathN <- df.paths %>%
#   ggplot(aes(x = reorder(set, -n.paths), y  = n.paths, fill = sample)) + 
#   geom_bar(stat = "identity") + 
#   facet_wrap(~sample) + 
#   theme_miko(legend = T) + 
#     theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
#   scale_fill_viridis(discrete = T, option = "E", begin = 0.2, end = 0.9) + 
#   xlab("Gene Set") + 
#   ylab("Number of Scored Pathways")
# 
# 
# 
# # 
# # 
# #   warning("Calculating cluster average gene expression profile...")
# #   exprMatrix <- as.matrix(as.data.frame(so.test[[i]]@assays[["SCT"]]@data))
# #   exprMatrix_bycluster <- list()
# #   pathwaygmt <- GSEABase::getGmt(gmt_path)
# # 
# #   for (k in sort(unique(object@meta.data$Clusters))) {
# #     exprMatrix_bycluster[[k]] <- rowMeans(exprMatrix[, which(colnames(exprMatrix) %in%
# #                                                                rownames(object@meta.data)[which(object@meta.data$Clusters ==
# #                                                                                                   k)])])
# #   }
# # 
# #   names(exprMatrix_bycluster) <- sort(unique(object@meta.data$Clusters))
# #   exprMatrix_bycluster <- do.call(cbind, exprMatrix_bycluster)
# #   colnames(exprMatrix_bycluster) <- sort(unique(object@meta.data$Clusters))
# #   rownames(exprMatrix_bycluster) <- rownames(exprMatrix)
# # 
# #   warning("\\nCalculating cluster pathway enrichment profiles...\\n")
# #   gsva_bycluster <- GSVA::gsva(as.matrix(exprMatrix_bycluster),
# #                                pathwaygmt, method = method, min.sz = min.sz, max.sz = max.sz,
# #                                parallel.sz = parallel.sz, verbose = verbose)
# # 
# #   colnames(gsva_bycluster) <- colnames(exprMatrix_bycluster)
# #   object@cluster.pathways <- gsva_bycluster
# # 
# #   gsva_bycluster_pca <- prcomp(t(gsva_bycluster), scale = T,
# #                                center = T)

```

1) Overview
===================================== 


Row {.tabset}
-------------------------------------

### Expression and Coverage

```{r summary stats, fig.width=10, fig.height=5}

print(plt.summary)
```

### UMI: Cumulative Read Counts

```{r crc, fig.width=6, fig.height=10}

cowplot::plot_grid(plotlist = plt.cRead.list, ncol = 1)
```

### UMI: Nuisance Reads

```{r src}

print(plt.read.hog)
```

### Hybrid Geneset Ranks

```{r hybrid ranks}

  print(plt.rank.cor)

```

### Performance: Reduced UMI 

```{r umi assess, fig.width=15, fig.height=8}

cowplot::plot_grid(plt.umi.cell, plt.umi.total, ncol = 1, align = "hv")

```

### Performance: Rand Ind

```{r rand ind plot, fig.width=10, fig.height=4}

try({
  cowplot::plot_grid(plt.rand.adj, plt.rand.clust)
}, silent = T)

```


### Performance: Discernable Populations
```{r n subpop}
print(plt.clust.n + theme(axis.text.x = element_text(angle = 25, hjust = 1)) )

# print(plt.clust.n)
```


2) UMAP
===================================== 

Row {.tabset}
-------------------------------------

```{r umap plots}

# out <- flex.multiTabPlot(plt.clustermarkers_by_umap, "plt.clustermarkers_by_umap", fig.width = 11, fig.height = 5)
out <- NULL

try({
  
  out <- lapply(seq_along(master.umap), function(i) {
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(master.umap)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=15, fig.height=15}", paste(i, "umap"))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\nprint(cowplot::plot_grid(plotlist = master.umap[[%d]]))", i)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
  
}, silent = T)

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

3) Geneset Overlaps
===================================== 

Row {.tabset}
-------------------------------------

```{r puv}

# generate multi-tab plot output
try({

  out <- lapply(seq_along(plt.overlap.list), function(i) {

    a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.overlap.list)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=15, fig.height=5}", paste(i, "puv"))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n print(plt.overlap.list[[%d]])", i))
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator

  })

}, silent = T)


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

4) Performance Summary
===================================== 

Row {.tabset}
-------------------------------------

```{r psp}

# generate multi-tab plot output
try({

  out <- lapply(seq_along(plt.p.summary.list), function(i) {

    a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.p.summary.list)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste(i, "p.sum.plot"))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n print(plt.p.summary.list[[%d]])", i))
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator

  })

}, silent = T)

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


5) Hybrid GeneSet Scoring
===================================== 

Row {.tabset}
-------------------------------------

```{r hsp}

# generate multi-tab plot output
try({

  out <- lapply(seq_along(grank.plt.list), function(i) {

    a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(grank.plt.list)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=8, fig.height=6}", paste(i, "hybrid score plots"))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n print(grank.plt.list[[%d]])", i))
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator

  })

}, silent = T)

 # print(grank.plt.list[[sample.name]])

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


6) Geneset Tables
===================================== 

Row {.tabset}
-------------------------------------

```{r geneset tables}

# reformat list
df.master.list <- list()
for (i in 1:length(master.set)){
  sample.name <- names(master.set)[i]
 df.master.list[[sample.name]] <- namedList2wideDF(master.set[[sample.name]]) 
}

# generate data.table output
out <- NULL

try({
  out <- flex.multiTabTables(df.master.list, "df.master.list")
}, silent = T)

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`






```{r save results}


# gene list
df.log <- addLogEntry("Gene List", genelist.csv, df.log, "genelist.csv")

# df.log <- addLogEntry("Gene List Size", length(goi), df.log, "length(goi)")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log_Module_26 <- df.log

# }, silent = T)

```

```{r ph10,  echo = FALSE, eval = TRUE}

try({
  out1 <- flex.multiTabLogs(module.logs)
}, silent = T)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 26)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_26)
```
