---
title: "Decorate Seurat"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---

```{r Description}

# DECORATE SEURAT ##############################################################

# Purpose: #####################################################################
# Generate intermediary results that are computationally expensive and 
# frequently required in difference analyses. This includes: 
#
# 1) ICA
# 2) TSNE
# 3) rho association matrix
# 4) cell cycle scoring
# 5) NMF
# 6) GSVA
# 7) Differential gene expression analysis (DEG)
# 8) unweighted PCA (for rare cell populations)

# Output: ######################################################################
# Seurat object with precomputed intermediate results. 


```


```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

  library(NNLM)
  library(foreach)

# list of packages to load
packages2load <- c('viridis', 'scMiko', 'ggpubr', 'dplyr', 'WGCNA', 'cowplot', 'schex', 'Seurat', 'sctransform', 'plyr', 'tidyr', 'reshape2', 'Matrix', 'RColorBrewer', 'ggplot2', 'gridExtra', 'DT', 'flexdashboard', 'future', 'gplots', 'NNLM')

# load packages
invisible(lapply(packages2load, library, character.only = TRUE, quietly = TRUE))

```


```{r parameter specifications}

################################################################################
# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

# Query input
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
input.file <- "Module2_integrated_p4789_allGBM_210720.Rdata"
# input.file <- "R32_M02_NM2_M02_testSet_rPCA_120820.Rdata"

################################################################################
# override
override.input <- F # if true, output.file is ignored and input.file is overwritten

# output file (required only if override input = F)
output.file <- "p4789_allGBM_uwPCA_130820.Rdata" # note that run id, module number and user name will automatically be appended as prefix. 

# cluster resolution
cluster.resolution <- 0.45

# print inline
print.inline <- F

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)

# specify species
which.species <- "Mm"

# If applicable, switch integrated to RNA assay (always set as T)
do.assay.switch <- F

# save pdf
save.pdf <- T

# specify decorations
decoration.list <- list(
  uPCA = T,
  ICA = F,
  TSNE = F,
  NMF = F,
  rho.matrix = F,
  cell.cycle.scoring = F,
  DEG = F,
  GSVA = F
)


```


```{r load data, message=FALSE, warning=FALSE}

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}
if (!exists("input.file")) stop("input.file is not specified")

# load query dataset
warning("Importing dataset...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))

if (!exists("gNames.list")) gNames.list <- prepGeneList(so.query, objects())

# get original so size
o.size <- utils::object.size(so)

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, cr= NULL, subset = subset.df, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv")

# unpack results
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell



# so <- prepSeurat(so)
# so.query <- so; rm(so)

# current.assay <- DefaultAssay(so.query)

# subsample 
# stopifnot(exists("subsample_factor"))
# if (subsample_factor < 1){
#   so.query <- downsampleSeurat(so.query, subsample.factor = subsample_factor)
# }
# 
# # subset data
# if (exists("subset.df")){
#   so.query <- subsetSeurat(so.query, subset.df)
# }

# 
# 
# # number of cells provided
# n.cells <- ncol(so.query)


```


```{r analysis log}

# Module
df.log <- initiateLog("27, Seurat Decoration")
df.log <- addLogEntry("Query File (.Rdata)", (input.file), df.log, "input.file")
df.log <- addLogEntry("Default Assay", (current.assay), df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", (cluster.resolution), df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", (subsample_factor), df.log, "subsample_factor")
df.log <- addLogEntry("Override input", (override.input), df.log, "override.input")
df.log <- addLogEntry("Cell Number", n.cells, df.log, "n.cells")

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r prep gene list}
# 
# # prep gene list
# if (!exists("gNames.list")) gNames.list <- prepGeneList( so.query, objects())
# 
# # ensure gene list is available
# stopifnot(exists("gNames.list"))
```


```{r convert to symbol}

# gene.rep <-  checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
# 
# if (gene.rep == "ensembl"){
#   warning("converting ENSEMBL to SYMBOL...")
#   so.query <- ens2sym.so(so = so.query, gNames.list = gNames.list, convert.RNA = TRUE)
#   gene.rep <-  checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
# }


```



```{r unweighted PCA}

# overrides original pca, clustering and umap; This is a destructive process. 
if (decoration.list$uPCA){
  
  if (input.file == output.file) stop("Ensure that output file and input file are different so that original input is not overwritten with recomputed PCA and UMAP reductions.")

  pca.var.threshold <- 0.9
  pca.prop <- propVarPCA(so.query)
  target.pc <- max(pca.prop$pc.id[pca.prop$pc.cum_sum<pca.var.threshold])+1
  
  # get new pca
  warning("Computing PCA...\n")
  so.query <-  RunPCA(
    so.query,
    assay = NULL,
    npcs = 50,
    rev.pca = FALSE,
    weight.by.var = F,
    verbose = F,
    ndims.print = 1:5,
    nfeatures.print = 30,
    reduction.key = "PC_",
    seed.use = 42,
    approx = TRUE,
  )
  
  so.query <- FindNeighbors(object = so.query, reduction = "pca", dims = 1:target.pc)
  
  warning("Computing clusters...\n")
  so.query <- FindClusters(object = so.query, resolution = cluster.resolution, verbose = 0, algorithm = 1, modularity.fxn = 1)
  
  warning("Computing UMAP...\n")
  so.query <- RunUMAP(so.query, dims = 1:target.pc)
  
  df.log <- addLogEntry("unweighted PCA computed", TRUE, df.log, "")
  
} else {
  df.log <- addLogEntry("unweighted PCA computed", FALSE, df.log, "")
}


```


```{r get clusters}


# compute clusters

if (!(decoration.list$uPCA)){
  warning("Computing clusters...\n")
  so.query <- FindClusters(object = so.query, 
                         resolution = cluster.resolution, 
                         verbose = 0, algorithm = 1, modularity.fxn = 1)
}



# prep query parameters with assertions
cur.cluster.field <- paste(DefaultAssay(so.query), "_snn_res.", cluster.resolution, sep = "")
stopifnot(cur.cluster.field %in% names(so.query@meta.data))

# get umap
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", label = TRUE)  + 
  labs(title = "UMAP", subtitle = paste0("cluster resolution = ", cluster.resolution)) +
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

if (print.inline){
  plt.umap_by_cluster
}

```
```{r set assay for downstream analysis}

# once PCA has been processed and clusters computed, ensure that correct assay is set as default for downstream analysis


if (do.assay.switch && DefaultAssay(so.query) == "integrated"){
  DefaultAssay(so.query) <- "RNA"
  so.query <-NormalizeData(so.query, verbose = FALSE)
  so.query <- ScaleData(so.query, verbose = FALSE)
  so.query <- FindVariableFeatures(so.query, selection.method = "vst", nfeatures = 3000)
} 

```


```{r TSNE, fig.width = 10, fig.height =4}

# tsne #####################

if (decoration.list$TSNE){
  plt.tsne.combo <- tryCatch({
    nDim <- 30
    warning("Running TSNE")
    so.query <-RunTSNE(so.query, dims = 1:nDim)
    
    # generate plots
    plt.tsne_by_cluster <- DimPlot(so.query, reduction = "tsne", label = TRUE)  + ggtitle(label = "TSNE") +
      xlab("TSNE 1") + ylab("TSNE 2")
    
    plt.tsne <- DimPlot(so.query, reduction = "tsne",group.by = "Barcode")  + ggtitle(label = "TSNE") +
      xlab("TSNE 1") + ylab("TSNE 2")
    
    # combine plots
    plt.tsne.combo <- cowplot::plot_grid(plt.tsne_by_cluster, plt.tsne, ncol = 2)
  }, error = function(e){
    plt.tsne.combo <- NULL
    return(plt.tsne.combo)
  })
  
  # log 
  df.log <- addLogEntry("TSNE computed", TRUE, df.log, "")
  
} else {
  plt.tsne.combo <- NULL
  df.log <- addLogEntry("TSNE computed", FALSE, df.log, "")
}

# visualize
if (print.inline & !is.null(plt.tsne.combo)){
  print(plt.tsne.combo)
}


```


```{r ICA, fig.width = 10, fig.height =4}

# ICA ########################

if (decoration.list$ICA){
  warning("Running ICA...")
  so.query <- RunICA(so.query, verbose = F)
  
  # generate plots
  plt.ica_by_cluster <- DimPlot(so.query, reduction = "ica", label = TRUE)  + ggtitle(label = "ICA") +
    xlab("ICA 1") + ylab("ICA 2")
  
  plt.ica <- DimPlot(so.query, reduction = "ica",group.by = "Barcode")  + ggtitle(label = "ICA") +
    xlab("ICA 1") + ylab("ICA 2")
  
  # combine plots
  plt.ica.combo <- cowplot::plot_grid(plt.ica_by_cluster, plt.ica, ncol = 2)
  
  # log 
  df.log <- addLogEntry("ICA computed", TRUE, df.log, "")
  
} else {
  plt.ica.combo <- NULL
  df.log <- addLogEntry("ICA computed", FALSE, df.log, "")
}

# visualize
if (print.inline & !is.null(plt.ica.combo)){
  print(plt.ica.combo)
}


```


```{r DEG}

# DEG #####################

if (decoration.list$DEG){
  
  # log fold change threshold
  lfc.threshold <- 0.5
  
  # p.value threshold <- p.threshold
  p.threshold <- 0.01
  
  # which markers to return
  only.pos <- T # 
  
  # DEG test
  DEG.test <- "MAST" #options: wilcox, bimod, roc, t, poisson, negbinom, LR, MAST, DESeq2
  
  # get number of clusters
  # n.clusters <- length(unique(so.query@meta.data[["seurat_clusters"]]))
  # if (n.workers$deg > n.clusters) n.workers$deg <- n.clusters
  
  warning("Identifying differentally expressed genes...")
  #FindAllMarkers.Parallel()
  DEG.results <- FindAllMarkers(so.query, 
                                assay = DefaultAssay(so.query),
                                slot = "data",
                                only.pos = only.pos, 
                                min.pct = 0.25,
                                test.use = DEG.test,
                                logfc.threshold = lfc.threshold, 
                                max.cells.per.ident = 200,
                                return.thresh = p.threshold,
                                verbose = F)
  
  DEG.results$cluster.resolution <- cluster.resolution
  DEG.results$lfc.threshold <- lfc.threshold
  DEG.results$p.threshold <- p.threshold
  DEG.results$only.pos <- only.pos
  DEG.results$DEG.test <- DEG.test
  
  # store results
  so.query@misc$deg <- DEG.results
  
  # log
  df.log <- addLogEntry("DEGs computed", TRUE, df.log, "")
  df.log <- addLogEntry("DEG lfc.threshold", lfc.threshold, df.log, "lfc.threshold")
  df.log <- addLogEntry("DEG p.threshold", p.threshold, df.log, "p.threshold")
  df.log <- addLogEntry("DEG only.pos", only.pos, df.log, "only.pos")
  df.log <- addLogEntry("DEG test", DEG.test, df.log, "DEG.test")
  
} else {
  df.log <- addLogEntry("DEGs computed", FALSE, df.log, "")
}

```


```{r cell cycle scoring, fig.width=14, fig.height = 4}

# cell cycle scoring #####################

if (decoration.list$cell.cycle.scoring){
  
  # get cell cycle genes
  s.genes <- cc.genes$s.genes
  g2m.genes <- cc.genes$g2m.genes
  
  input.species <- unique(so.query@meta.data[["Organism"]])
  
  if (length(unique(input.species)) > 1){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
  } else if (unique(input.species) == "Mm"){
    s.genes <-  firstup(s.genes)
    g2m.genes <-  firstup(g2m.genes)
  } else if (unique(input.species) == "Hs"){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
  }
  
  # cell cycle scoring and umap
  plt.cc.umap <- tryCatch({
    warning("Scoring cell cycle...")
    so.query <- CellCycleScoring(so.query, s.features = s.genes, g2m.features = g2m.genes, set.ident = F)
    
    plt.cc.umap <- cluster.UMAP(
      so.query,
      group.by = "Phase",
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = "Cell Cycle Classifications",
      include.labels = F)
    
  }, error = function(e){
    plt.cc.umap <- NULL
    return(plt.cc.umap)
  })
  
  # cluster-level composition
  plt.cc <- NULL
  if ("Phase" %in% names(so.query@meta.data)){
    df.cc <- data.frame(clusters =  so.query@meta.data[["seurat_clusters"]], phase =  so.query@meta.data[["Phase"]])
    
    df.cc.tally <- df.cc %>%
      group_by(clusters, phase) %>%
      tally()
    
    plt.cc.compo <- df.cc.tally %>%
      ggplot(aes(x = clusters, y = n, fill = phase)) + 
      geom_bar(position="fill", stat="identity") + 
      theme_miko(legend = T) + 
      labs(title = "Cluster Composition by Cell Cycle") + 
      xlab("Cluster ID") + ylab("Relative Frequency")
    
    plt.cc <- cowplot::plot_grid(plt.umap_by_cluster, plt.cc.umap, plt.cc.compo, ncol = 3)
  } 
  
  
  if (print.inline) {
    print(plt.cc)
  }
  
  # log
  df.log <- addLogEntry("cell cycle scores computed", TRUE, df.log, "")
  
} else {
  plt.cc <- NULL
  df.log <- addLogEntry("cell cycle scores computed", FALSE, df.log, "")
}

# visualize
if (print.inline & !is.null(plt.cc)){
  print(plt.cc)
}


```

```{r rho matrix}

# rho association constant #####################

if (decoration.list$rho.matrix){
  
  # external panels ######################################
  warning("Getting external gene panel for correlation matrix...\n")
  # get L1000 panel
  uni.panels <- geneSets[["universal_literaturePanel"]]
  L1000.panel <- uni.panels$Subramanian2017_L1000_Universal
  L1000.panel <- L1000.panel[!is.na(L1000.panel)]
  
  # get cell cycle marker panel
  s.genes <- cc.genes$s.genes
  g2m.genes <- cc.genes$g2m.genes
  
  # ensure proper representation
  input.species <- unique(so.query@meta.data[["Organism"]])
  
  if (length(unique(input.species)) > 1){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
    L1000.panel <-  toupper(L1000.panel)
  } else if (unique(input.species) == "Mm"){
    s.genes <-  firstup(s.genes)
    g2m.genes <-  firstup(g2m.genes)
    L1000.panel <-  firstup(L1000.panel)
  } else if (unique(input.species) == "Hs"){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
    L1000.panel <-  toupper(L1000.panel)
  }
  
  # combine external panels
  ext.panel <- unique(c(s.genes, g2m.genes, L1000.panel))
  
  # internal panel ######################################
  warning("Getting internal gene panel for correlation matrix...\n")
  # get top variable genes
  top.n.var.genes <- 8000
  df.var.meta <- so.query@assays[[DefaultAssay(so.query)]]@meta.features
  df.var.meta$genes <- rownames(df.var.meta)
  if (DefaultAssay(so.query) == "SCT"){
  df.var.meta <- df.var.meta %>% arrange(-sct.residual_variance)  
  } else if (DefaultAssay(so.query) == "RNA"){
  df.var.meta <- df.var.meta %>% arrange(-vst.variance.standardized)    
  }
  
  int.panel <- df.var.meta$genes[1:top.n.var.genes]
  
  # append integration anchors if data were integrated as well
  if ("integrated" %in% names(so.query@assays)){
    try({int.panel <- unique(c(int.panel, so.query@assays[["integrated"]]@var.features))}, silent = T)
  }
  
  # combine internal and external panels
  query.panel <- unique(c(ext.panel, int.panel))
  
  which.cor <- "rho_p"
  
  warning("Computing similarity matrix (scale)...")
  # scale matrix
  exp.mat.s <- getExpressionMatrix(so.query, which.data = "scale")
  exp.mat.s <- exp.mat.s[rownames(exp.mat.s) %in% query.panel, ]
  exp.mat.s <- t(exp.mat.s)
  exp.mat.s <- as.matrix(exp.mat.s)
  if (min(exp.mat.s) < 0) exp.mat.s <- exp.mat.s + abs(min(exp.mat.s))
  SubGeneNames=colnames(exp.mat.s)
  s.mat.s <-  dismay::dismay(exp.mat.s, metric = which.cor)
  rm(exp.mat.s)
  
  # warning("Computing similarity matrix (data)...")
  # # data matrix
  # exp.mat.d <- getExpressionMatrix(so.query, which.data = "data")
  # exp.mat.d <- exp.mat.d[rownames(exp.mat.d) %in% query.panel, ]
  # exp.mat.d <- t(exp.mat.d)
  # 
  # # a <- as.matrix(as.data.frame(exp.mat.d))
  # exp.mat.d <- as.matrix((exp.mat.d))
  # SubGeneNames=colnames(exp.mat.d)
  # s.mat.d <-  dismay::dismay(exp.mat.d, metric = which.cor)
  # rm(exp.mat.d)
  
  
  # omit duplicates
  s.mat.s <- s.mat.s[!duplicated(rownames(s.mat.s)), !duplicated(colnames(s.mat.s))]
  # s.mat.d <- s.mat.d[!duplicated(rownames(s.mat.d)), !duplicated(colnames(s.mat.d))]
  
  # cor.list <- list(
  #   similarity.matrix = s.mat.d,
  #   metric = which.cor,
  #   slot = "data",
  #   assay = DefaultAssay(so.query),
  #   top.n.var.genes = top.n.var.genes,
  #   internal.panel = "variable genes",
  #   external.panel = c("L1000", "cell cycling genes"),
  #   internal.panel.genes = int.panel,
  #   external.panel.genes = ext.panel,
  #   all.genes = query.panel
  # )
  
  # store results
  # so.query@misc$similarity.data <- cor.list
  
  cor.list <- list(
    similarity.matrix = s.mat.s,
    metric = which.cor,
    slot = "scale",
    assay = DefaultAssay(so.query),
    top.n.var.genes = top.n.var.genes,
    internal.panel = "variable genes",
    external.panel = c("L1000", "cell cycling genes"),
    internal.panel.genes = int.panel,
    external.panel.genes = ext.panel,
    all.genes = query.panel
  )
  
  # store results
  so.query@misc$similarity.scale <- cor.list
  
  # log
  df.log <- addLogEntry("similarity matrix computed", TRUE, df.log, "")
  df.log <- addLogEntry("similarity matrix metric", which.cor, df.log, "which.cor")
  df.log <- addLogEntry("similarity matrix assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")
  df.log <- addLogEntry("similarity matrix var gene n", top.n.var.genes, df.log, "top.n.var.genes")
  
} else {
  
  df.log <- addLogEntry("similarity matrix computed", FALSE, df.log, "")
  
}

```

```{r NMF, include = FALSE}
# library(NMF)

# NMF #####################
if (decoration.list$NMF){
  
  # https://mran.microsoft.com/snapshot/2017-01-23/web/packages/NNLM/vignettes/Fast-And-Versatile-NMF.html 

  # external panels ######################################
  # get L1000 panel
  uni.panels <- geneSets[["universal_literaturePanel"]]
  L1000.panel <- uni.panels$Subramanian2017_L1000_Universal
  L1000.panel <- L1000.panel[!is.na(L1000.panel)]
  
  # get cell cycle marker panel
  s.genes <- cc.genes$s.genes
  g2m.genes <- cc.genes$g2m.genes
  
  # ensure proper representation
  input.species <- unique(so.query@meta.data[["Organism"]])
  
  if (length(unique(input.species)) > 1){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
    L1000.panel <-  toupper(L1000.panel)
  } else if (unique(input.species) == "Mm"){
    s.genes <-  firstup(s.genes)
    g2m.genes <-  firstup(g2m.genes)
    L1000.panel <-  firstup(L1000.panel)
  } else if (unique(input.species) == "Hs"){
    s.genes <-  toupper(s.genes)
    g2m.genes <-  toupper(g2m.genes)
    L1000.panel <-  toupper(L1000.panel)
  }
  
  # combine external panels
  ext.panel <- unique(c(s.genes, g2m.genes, L1000.panel))
  
  # internal panel ######################################
  # get top variable genes
  top.n.var.genes <- 8000
  df.var.meta <- so.query@assays[[DefaultAssay(so.query)]]@meta.features
  df.var.meta$genes <- rownames(df.var.meta)
    if (DefaultAssay(so.query) == "SCT"){
  df.var.meta <- df.var.meta %>% arrange(-sct.residual_variance)  
  } else if (DefaultAssay(so.query) == "RNA"){
  df.var.meta <- df.var.meta %>% arrange(-vst.variance.standardized)    
  }

  int.panel <- df.var.meta$genes[1:top.n.var.genes]

    # append integration anchors if data were integrated as well
  if ("integrated" %in% names(so.query@assays)){
    try({int.panel <- unique(c(int.panel, so.query@assays[["integrated"]]@var.features))}, silent = T)
  }
  
  # combine internal and external panels
  query.panel <- unique(c(ext.panel, int.panel))
  
  
  # entire matrix
  which.data <- "data"
  exp.mat.complete <- getExpressionMatrix(so.query, which.data = "data")
  
  # filter matrix
  exp.mat <- exp.mat.complete[rownames(exp.mat.complete) %in% query.panel, ]
  rm(exp.mat.complete)
  exp.mat.sub <- exp.mat
  rm(exp.mat); invisible(gc());
  
  # find optimal rank (k) ######################################
  #cols <- c(1:10)
  cols <- c(1:3)
  k <- seq(2, 30, 1)
  
  warning("Searching for optimal NMF rank...")
  mse.grid <- c()
  for (i in 1:length(k)){
    
    B <- exp.mat.sub[ ,sample(ncol(exp.mat.sub), round(0.2*ncol(exp.mat.sub)))]
    subset.n <- 0.5 * ncol(B) * nrow(B)
    index2 <- sample(which(!is.na(B)), subset.n);
    nsclc3 <- B;
    nsclc3[index2] <- NA;
    
    mean.z <- c()
    for (j in 1:length(cols)){
      z <- nnmf(as.matrix(nsclc3), k[i], verbose = T, max.iter = 50, n.threads = 0);
      mean.z[j] <- mean((with(z, W%*%H)[index2] - B[index2])^2)
    }
    
    if (length(cols) > 5){
      mse.grid[i] <- median(mean.z)
    } else {
      mse.grid[i] <- mean(mean.z)
    }
    
    # only continue running of improved error is observed
    if (i > 4){
      if ((mse.grid[i-2] > mse.grid[i-3]) & (mse.grid[i-1] > mse.grid[i-2]) & (mse.grid[i] > mse.grid[i-1])) break
    }  
    
  }
  # clean baggage
  rm(z); rm(B); rm(nsclc3);
  
  k <- k[1:length(mse.grid)]
  k.opt <- k[which.min(mse.grid)]
  df.k <- data.frame(k = k, mse = mse.grid)
  
  plt.kopt <- df.k %>%
    ggplot(aes(k, mse)) + 
    geom_point() + 
    geom_line() + 
    geom_vline(xintercept = k.opt, color = "tomato", linetype = "dashed") + 
    theme_miko() + 
    labs(title = "NMF Rank Optimization", subtitle = paste0("Optimal Rank = ", k.opt)) + 
    ylab("MSE") + xlab("Rank, k")
  
  warning("Computing NMF...")
  #  Compute optimal NMF
  nmf.opt  <- nnmf(as.matrix(exp.mat.sub), k = k.opt, 
                   max.iter = 500,
                   method = "scd", 
                   loss = "mse", 
                   rel.tol = 1e-4, 
                   n.threads = 0, 
                   verbose = 2);
  
  plt.wmat <- pheatmap::pheatmap(nmf.opt$W, show_rownames = F, main = "NMF 'W' Matrix\nrows=genes; columns=gene modules")
  plt.wmat <- ggplotify::as.ggplot(plt.wmat)
  
  plt.hmat <- pheatmap::pheatmap(nmf.opt$H, show_colnames = F, main = "NMF 'H' Matrix\nrows=gene modules; columns=cells")
  plt.hmat <- ggplotify::as.ggplot(plt.hmat)
  
  # store results
  so.query@misc$nmf <- list(
    nmf = nmf.opt,
    ranks.tested = k,
    rank.optimal = k.opt,
    w.mat.plot = plt.wmat,
    h.mat.plot = plt.hmat,
    optimization.curve = plt.kopt
  )
  
  # log
  df.log <- addLogEntry("NMF computed", TRUE, df.log, "")
  df.log <- addLogEntry("NMF optimal rank", k.opt, df.log, "k.opt")
  df.log <- addLogEntry("N runs per rank", length(cols), df.log, " ")
  
} else {
  plt.wmat <- NULL
  plt.hmat <- NULL
  plt.kopt <- NULL
  df.log <- addLogEntry("NMF computed", FALSE, df.log, "")
}

```



```{r GSVA}

# GSVA ###########################################################

if (decoration.list$GSVA){
  
  # extract expression matrices
  data.mat <- getExpressionMatrix(so.query, which.data = "data")
  scale.mat <- getExpressionMatrix(so.query, which.data = "scale")
  
  # gmt path for GSVA scoring
  # check current release at: http://download.baderlab.org/EM_Genesets/current_release/
  if (which.species == "Hs"){
    gmt.path <- paste0("http://download.baderlab.org/EM_Genesets/current_release/Human/symbol/Human_GOBP_AllPathways_no_GO_iea_",  
                       format(Sys.Date(), "%B_01_%Y"), "_symbol.gmt")
  } else if (which.species == "Mm"){
    gmt.path <- paste0("http://download.baderlab.org/EM_Genesets/current_release/Mouse/symbol/Mouse_GOBP_AllPathways_no_GO_iea_", 
                       format(Sys.Date(), "%B_01_%Y"), "_symbol.gmt")
  }
  
  # get pathways
  pathwaygmt <- GSEABase::getGmt(gmt.path)
  
  # score pathways
  warning("Computing GSVA using corrected counts...")
  data.scores <- GSVA::gsva(as.matrix(data.mat),
                            pathwaygmt, method = "gsva", min.sz = 5, max.sz = 200,
                            parallel.sz = 1, verbose = F)
  
  warning("Computing GSVA using scaled counts...")
  scale.scores <- GSVA::gsva(as.matrix(scale.mat),
                             pathwaygmt, method = "gsva", min.sz = 5, max.sz = 200,
                             parallel.sz = 1, verbose = F)
  
  so.query@misc$gsva <- list(
    gsva.scale = scale.scores,
    gsva.data = data.scores
  )
  
   df.log <- addLogEntry("GSVA computed", TRUE, df.log, "")
  
} else {
  df.log <- addLogEntry("GSVA computed", FALSE, df.log, "")
}
```


```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M27", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M27_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```

```{r save results}

if (override.input){
  output.file <- input.file
}

output.file <- paste0(run.id, "_", output.file)

so <- so.query
rm(so.query)

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

n.size <- utils::object.size(so)
df.log <- addLogEntry("original size", o.size, df.log, "o.size")
df.log <- addLogEntry("updated size", n.size, df.log, "n.size")

df.log <- addLogEntry("Integrated to RNA assay switch permitted", do.assay.switch, df.log, "do.assay.switch")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log <- addLogEntry("output file", output.file, df.log, "output.file")
df.log_Module_27 <- df.log

save.filename <- paste(data.path, dir.preprocessed , output.file, sep = "")

if (exists("df.log_Module_1")){
  save(so, gNames.list, df.log_Module_1, df.log_Module_27, file = save.filename)
} else if (exists("df.log_Module_2")){
  save(so, gNames.list, df.log_Module_2, df.log_Module_27, file = save.filename)
} 


so.query <- so
rm(so);
invisible(gc())


```

```{r save DEG and GSVA matrices if available}

# Save GSVA matrices
if (exists("scale.scores")){
   write.csv(data.frame(scale.scores), file = paste0(output.path, "Tables/", "GSVA_scaled_input.csv"),
          row.names = T) 
}

if (exists("data.scores")){
   write.csv(data.frame(data.scores), file = paste0(output.path, "Tables/", "GSVA_data_input.csv"),
          row.names = T) 
}

# Save DEG results
if (exists("DEG.results")){
   write.csv(DEG.results, file = paste0(output.path, "Tables/", "DEG.csv"),
          row.names = T) 
}


```


UMAP
===================================== 
### Uniform Manifold Approximation and Projection
```{r}

plt.umap_by_cluster <- plt.umap_by_cluster + theme_miko(legend = T)  
print(plt.umap_by_cluster)
savePDF(file.name = paste0(output.path, "PDF/", "M27_UMAP.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)

```

TSNE
===================================== 
### T-Distributed Stochastic Neighbor Embedding
```{r tsne plots, fig.width = 10, fig.height = 5}
if (!is.null(plt.tsne.combo)){
  print(plt.tsne.combo)
}

```

```{r save tsne}

if (!is.null(plt.tsne.combo)){
  savePDF(file.name = paste0(output.path, "PDF/", "M27_TSNE.pdf"), plot.handle = plt.tsne.combo, 
          fig.width = 10, fig.height = 5, save.flag = save.pdf)
}

```


ICA
===================================== 
### Independent Component Analysis
```{r ica plots, fig.width = 10, fig.height = 5}

if (!is.null(plt.ica.combo)){
  print(plt.ica.combo)
}

```

```{r save ica}

if (!is.null(plt.ica.combo)){
  savePDF(file.name = paste0(output.path, "PDF/", "M27_ICA.pdf"), plot.handle = plt.ica.combo, 
          fig.width = 10, fig.height = 5, save.flag = save.pdf)
  write.csv(data.frame(so.query@reductions[["ica"]]@cell.embeddings), file = paste0(output.path, "Tables/", "ICA_cell_embedding.csv"),
            row.names = T)
  write.csv(data.frame(so.query@reductions[["ica"]]@feature.loadings), file = paste0(output.path, "Tables/", "ICA_feature_loading.csv"),
            row.names = T)
}

```

Cell Cycle
===================================== 
```{r cell cycle plots, fig.width = 14, fig.height = 4}

if (!is.null(plt.cc)){
  print(plt.cc)
  savePDF(file.name = paste0(output.path, "PDF/", "M27_cell_cycle.pdf"), plot.handle = plt.cc, 
          fig.width = 14, fig.height = 4, save.flag = save.pdf)
}

```


NMF
===================================== 

Row {.tabset}
-------------------------------------

### NMF Rank Optimization
```{r nmf plot 1}

if (!is.null(plt.kopt)){
  print(plt.kopt)
  savePDF(file.name = paste0(output.path, "PDF/", "M27_NMF_rank_optimization.pdf"), plot.handle = plt.kopt, 
          fig.width = 5, fig.height = 5, save.flag = save.pdf)
}

```



### W Matrix
```{r wmat plot}

if (!is.null(plt.wmat)){
  print(plt.wmat)
  savePDF(file.name = paste0(output.path, "PDF/", "M27_NMF_W_Matrix.pdf"), plot.handle = plt.wmat, 
          fig.width = 5, fig.height = 5, save.flag = save.pdf)
  write.csv(data.frame(nmf.opt[["W"]]), file = paste0(output.path, "Tables/", "NMF_W_Matrix.csv"),
          row.names = T)
}

```

### H Matrix
```{r hmat plot}

if (!is.null(plt.hmat)){
  print(plt.hmat)
  savePDF(file.name = paste0(output.path, "PDF/", "M27_NMF_H_Matrix.pdf"), plot.handle = plt.hmat, 
          fig.width = 5, fig.height = 5, save.flag = save.pdf)
  write.csv(data.frame(nmf.opt[["H"]]), file = paste0(output.path, "Tables/", "NMF_H_Matrix.csv"),
          row.names = T)
}

```

```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_27, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    pdf.list <- pdf.list[validUTF8(pdf.list)]
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}

```
