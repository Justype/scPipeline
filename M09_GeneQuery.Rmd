---
title: "Gene Query Analysis"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---

```{r Module Description}

################################################################################
# Given a gene or gene panel query, M09 will evaluate the pattern of expression, and determine whether it is deferentially-expressed between clusters. Moreover, query correlations are computed and genes subsequently ranked by correlation prior to running GSEA to generate
# 1) Expression
# 2) Differential expression
# 3) Correlations
# 4) Associated pathways (via GSEA)
################################################################################

```


```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", "grid",
                   "DT", "flexdashboard", "ggpmisc", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db",
                   "schex", "RColorBrewer", "cowplot", "viridis", "viridisLite", "presto", "variancePartition", "lme4", "ggdendro")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```


```{r parameter specification}


# INPUT FILE ###################################################################
# input.file <- "M01_NM2_R1_test_300720.Rdata"
input.file <- "R416_M02_NM2_p12_meso_integrated_170421.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "Module1_p7_mesoderm_110620.Rdata"
# input.file <- "Module1_m27_p7_mesoderm_070420.Rdata"
# input.file <- "Module1_p7_mesoderm_update_170620.Rdata"
# input.file <- "R4_M02_BC2_M02_p467891011_Mm_allGBM_010920.Rdata"
# input.file <- "R6_M02_BC2_allGBM_271020.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file = "Module1_p9_GBM_PR_noFilter_270620.Rdata"
# input.file <- "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata"
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
# input.file <- "Module1_p9_GBM_PR_noFilter_270620.Rdata"
# input.file <- "R291_M01_NM2_Rambow_Melanoma_221120.Rdata"


# QUERY SPECIFICATION ##########################################################
which.input <- list(
  
  # gene list input format options:
  #   0: Manual input; vector of genes (e.g., which.gene.set = c("cd70", "cd34"))
  #   1: M09_type1_queries.csv; gene.sets.type1 
  #   2: M09_type2_queries.csv; gene.sets.type2; .csv file
  #   3: cluster DEG
  #   4: top N cluster markers
  #   5: M09_type5_queries.csv; GO/Reactome genesets
  #   6: scMiko internal geneset
  query_input_format = 3,
  do.module = NA, #options: T, F, NA; if NA, takes default, otherwise overides. 
  
  # specify gene set (only if query_input_format == 1 | 2 | 5 | 6)
  which.gene.set =c('MesoList_240421') # character (e.g., sex.specific)
)

# cgr8_cluster_markers

# PARAMETER SPECIFICATION ######################################################

parameter.list <- list(
  # General parameters #########################################################
  general.cluster.resolution = 0.5,    # Numeric [0, Inf]
  general.subsample.factor = 1,      # Numeric (0,1]
  general.subset = "no.subset",
  # general.subset = data.frame(field = "seurat_clusters", subgroups = c(0:7, 9:20)),   # 'no.subset' if unspecified
  general.species = "Hs",            # Options: 'Mm', 'Hs'
  general.clean.clusters = F,        # Logical. 
  general.save.pdf = F,              # Logical. 
  general.print.inline = F,          # Logical. 
  general.barcode.recode = list(     # new names (list names); old names (list entires). Empty list if no recoding.
  D0 = "D0",
  D1 = "D1",
  D2 = "D2",
  D3 = "D3",
  D4 = "D4",
   D5 = "D5",
  D6 = "D6"
  ),
  
  # Correlation parameters #####################################################
  cor.method = "spearman",           # Options: 'pearson', 'spearman', 'rho_p'
  cor.top.n = 70,
  cor.which.data = "data",
  cor.check.existing = T,            # Logical. 
  cor.min.expr = 0.05,               # min expressing fraction to be included in correlation
  cor.recompute.existing.if.query.missing = T,
  
  # GSEA parameters #############################################################
  gsea.top.n = 20,
  gsea.threshold = 2 ,               # Options: 1: padj < 0.1; 2: p<0.01 & |NES| > 1; 3: top 3 pathways (sorted by NES)
  gsea.database = "Bader",           # Options: 'Reactome', 'GO', 'Bader'
  gsea.ontology = c("BP"),           # Options: "BP", "MF", "CC"
  gsea.n.workers = 12,               # Numeric [1,n.available.cores]
  
  # Variance decomposition parameters ##########################################
  vd.n.workers = 8,                 # Numeric [1,n.available.cores]
  vd.covariates = c("seurat_clusters", "percent.mt", "bc", "Phase", "seq.coverage"),
  vd.interactions = c("bc:seurat_clusters"),
  
  # General parameters #########################################################
  expression.do.hex = F              # Logical. Specify whether to generate hex UMAPs (schex package)
)

    # GL261 = "GL261",
    # CT2A = "CT2A"

    # WT = "WT",
    # C15 = "C15",
    # C2 = "C2", 
    # C68 = "C68", 
    # C76 = "C76", 
    # C50 = "C50"
```

```{r assertions, include = FALSE}

# check if all parameters specified
expected.parameters <- c('general.cluster.resolution', 'general.subsample.factor', 'general.subset', 'general.species', 'general.clean.clusters', 'general.save.pdf', 'general.print.inline', 'general.barcode.recode', 'cor.method', 'cor.top.n', 'cor.which.data', 'cor.check.existing', 'cor.recompute.existing.if.query.missing', 'gsea.top.n', 'gsea.threshold', 'gsea.database', 'gsea.ontology', 'gsea.n.workers', 'vd.n.workers', 'vd.covariates', 'vd.interactions', 'expression.do.hex', "cor.min.expr")

which.parameters.missing <- names(parameter.list)[!(names(parameter.list) %in% expected.parameters)]
if (length(which.parameters.missing) > 0){
  stop(paste0(paste(which.parameters.missing, collapse = ", "), " parameters are not specified."))
}

# ensure all input specifications are met. 
stopifnot(is.numeric(parameter.list$general.cluster.resolution))
stopifnot(parameter.list$general.cluster.resolution > 0)
stopifnot(is.numeric(parameter.list$general.subsample.factor))
stopifnot(parameter.list$general.subsample.factor > 0)
stopifnot(parameter.list$general.subsample.factor <=  1)
stopifnot(("data.frame" %in% class(parameter.list$general.subset)) || parameter.list$general.subset == "no.subset")
stopifnot(parameter.list$general.species %in% c("Mm", "Hs"))
stopifnot(class(parameter.list$general.clean.clusters) == "logical")
stopifnot(class(parameter.list$general.save.pdf) == "logical")
stopifnot((class(parameter.list$general.barcode.recode)) == "list")
stopifnot(parameter.list$cor.method %in% c('pearson', 'spearman', 'rho_p'))
stopifnot(is.numeric(parameter.list$cor.top.n))
stopifnot(parameter.list$cor.top.n > 0)
stopifnot(parameter.list$cor.which.data == "data")
stopifnot(class(parameter.list$cor.check.existing) == "logical")
stopifnot(class(parameter.list$cor.recompute.existing.if.query.missing) == "logical")
stopifnot(is.numeric(parameter.list$gsea.top.n))
stopifnot(parameter.list$gsea.top.n > 0)
stopifnot(parameter.list$gsea.threshold %in% c(1,2,3))
stopifnot(parameter.list$gsea.database %in% c("Bader", "GO", "Reactome"))
stopifnot(parameter.list$gsea.ontology %in% c("BP", "MF", "CC"))
stopifnot(is.numeric(parameter.list$gsea.n.workers))
stopifnot(parameter.list$gsea.n.workers > 0)
stopifnot(parameter.list$gsea.n.workers <= parallel::detectCores())
stopifnot(is.numeric(parameter.list$vd.n.workers))
stopifnot(parameter.list$vd.n.workers > 0)
stopifnot(parameter.list$vd.n.workers <= parallel::detectCores())
stopifnot(class(parameter.list$expression.do.hex) == "logical")


```


```{r import appropriate csv files, include = FALSE}

if (which.input$query_input_format==1){
  gene.sets.type1 <- read.csv("M09_type1_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type1) <- rmvCSVprefix(colnames(gene.sets.type1))
} else if (which.input$query_input_format==2){
  gene.sets.type2.df <- read.csv("M09_type2_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type2.df) <- rmvCSVprefix(colnames(gene.sets.type2.df))
  gene.sets.type2 <- list()
  for (i in 1:nrow(gene.sets.type2.df)){
    gene.sets.type2[[gene.sets.type2.df$name[i]]] <- list(file = gene.sets.type2.df$file[i],
                                           directory = gene.sets.type2.df$directory[i],
                                           # prefix.label = gene.sets.type2.df$prefix.label[i],
                                           module = gene.sets.type2.df$module[i])
  }
} else if (which.input$query_input_format==5){
  gene.sets.type5 <- read.csv("M09_type5_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type5) <- rmvCSVprefix(colnames(gene.sets.type5))
}

```

```{r meta module helper function, include = FALSE}

meta.module.helper <- function(do.module, default.set){
  if (is.na(do.module)){
    return(default.set)
  } else if (do.module == TRUE) {
    return(T)
  } else if (do.module == FALSE) {
    return(F)
  }
}

```


```{r input subtype data specification, include = FALSE}

which.gene.set <- as.character(which.input$which.gene.set)

if (which.input$query_input_format==0){
  
  markers_of_interest <- which.gene.set
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
} else if (which.input$query_input_format==1){
  stopifnot(which.gene.set %in% names(gene.sets.type1))
  markers_of_interest <- gene.sets.type1[[which.gene.set]] # REQUIRED if query_input_format == 1
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
} else if(which.input$query_input_format==2){
  stopifnot(which.gene.set %in% names(gene.sets.type2))
  input_spreadsheet <- gene.sets.type2[[which.gene.set]][["file"]]
  dir.geneset <- gene.sets.type2[[which.gene.set]][["directory"]]
  meta.module.flag <- meta.module.helper( which.input$do.module,gene.sets.type2[[which.gene.set]][["module"]])
  prefix.label <- gene.sets.type2[[which.gene.set]][["prefix.label"]]
} else if ((which.input$query_input_format==3)) {
  meta.module.flag <- meta.module.helper( which.input$do.module,F)
} else if ((which.input$query_input_format==4)) {
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
} else if (which.input$query_input_format==5){
  stopifnot(which.gene.set %in% gene.sets.type5$term)
  markers_of_interest <- id2geneset(gene.sets.type5$id[gene.sets.type5$term %in% which.gene.set ], 
                                    my.species = parameter.list$general.species) # REQUIRED if query_input_format == 1
   markers_of_interest <- as.data.frame(unique(markers_of_interest))
   colnames(markers_of_interest) <- which.gene.set
   
  meta.module.flag <- meta.module.helper( which.input$do.module,F)
} else if (which.input$query_input_format==6){
  scMiko.geneSets <- scMiko::geneSets
  stopifnot(which.gene.set %in% names(scMiko.geneSets))
  markers_of_interest <- as.data.frame(scMiko.geneSets[[which.gene.set]])
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
}


if (exists("markers_of_interest") && "data.frame" %in% class(markers_of_interest)){
  markers_of_interest <- janitor::clean_names(markers_of_interest, "screaming_snake")
}

# annotation specifications
which.annotation.db <- parameter.list$gsea.database
which.ontology <- parameter.list$gsea.ontology


```


```{r load data, warning = FALSE, include = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
message("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species = parameter.list$general.species, resolution= parameter.list$general.cluster.resolution, 
                         subset.data =  parameter.list$general.subset, 
                         subsample = parameter.list$general.subsample.factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = T)


# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

# clean clusters
if (parameter.list$general.clean.clusters) so.query <- cleanCluster(so.query, return.plots = F)

```

```{r recode barcodes, include = FALSE}

# recode barcodes ##############################################################
bc.list <- parameter.list$general.barcode.recode

df.meta <- so.query@meta.data
if (length(bc.list) == 0){
  df.meta$bc <- df.meta$Barcode
} else {
  df.meta$bc <- NA
  for (i in 1:length(bc.list)){
    df.meta$bc[grepl(bc.list[[i]], df.meta$Barcode)] <- names(bc.list)[i]
  }
  df.meta$bc[is.na(df.meta$bc)] <- "Other"
}
so.query@meta.data <- df.meta


```



```{r prepare query gene list (input type 1 or 2), message=FALSE, warning=FALSE, include = FALSE}

message("Preparing geneset(s)...")

# import marker sets
if (which.input$query_input_format == 1){
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      markers.of.interest = markers_of_interest,
                                      which.species = parameter.list$general.species)
} else if (which.input$query_input_format == 2){
  
  if (meta.module.flag){
    which.col <- "all"
  } else {
    which.col <- "first"
  }
  
  input_file <- paste(data.path,dir.geneset, input_spreadsheet, sep = "")
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      input.file = input_file, 
                                      which.col = which.col,
                                      which.species = parameter.list$general.species)
} else if (which.input$query_input_format == 0){
  
  if (parameter.list$general.species == "Hs") {
    markers_of_interest <- toupper(markers_of_interest)
  } else if (parameter.list$general.species == "Mm") {
    markers_of_interest <- firstup(markers_of_interest)
  }
}

if (exists("output.markers")) markers_of_interest <- output.markers[[1]]


```


```{r prior log history, warning = FALSE, include = FALSE}
# get prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r define grouping var, warning = FALSE, include = FALSE}

# group by options:
#   1: clusters ID (seurat_clusters)
#   2: barcodes (Barcode)
#   3: Groups (in vivo)
group.by <- 1

# specify grouping variable
if (group.by == 1){
  grouping_var <- "seurat_clusters"
  group_name <- "Clusters"
} else if (group.by == 2){
  grouping_var <- "Barcode"
  group_name <- "Barcodes"
} else if (group.by == 3){
  grouping_var <- "Group"
  group_name <- "Group"
}

# determine unique groups
u_groups <- as.vector(unique(so.query@meta.data[[grouping_var]]))

# determine number of unique groups
n_group_members <- length(u_groups)
```



```{r analysis log, warning = FALSE, include = FALSE}

message("Updating analysis logs...")
df.log <- initiateLog("9, Query Marker Exploration")

df.log <- addLogEntry("Query File", input.file, df.log, "input.file")
df.log <- addLogEntry("Gene Set Name", which.gene.set, df.log, "which.gene.set")
df.log <- addLogEntry("Compute geneset module score", meta.module.flag, df.log, "meta.module.flag")
df.log <- addLogEntry("Species", parameter.list$general.species, df.log, "general.species")

if ("data.frame" %in% class(parameter.list$general.subset)){
  df.log <- addLogEntry("Which Subset Field", parameter.list$general.subset$field, df.log, "field")
  df.log <- addLogEntry("Which Subset Groups", parameter.list$general.subset$subgroups, df.log, "subgroups")    
} else if ("character" %in% class(parameter.list$general.subset)){
  df.log <- addLogEntry("Which Subset Groups", parameter.list$general.subset, df.log, "subset.df")    
}



df.log <- addLogEntry("Min expr. fraction for cor. analysis", parameter.list$cor.min.expr, df.log, "cor.min.expr")

df.log <- addLogEntry("Clusters cleaned", parameter.list$general.clean.clusters, df.log, "general.clean.clusters")
df.log <- addLogEntry("Cluster Resolution", parameter.list$general.cluster.resolution, df.log, "general.cluster.resolution")
df.log <- addLogEntry("Grouping Variable", group_name, df.log, "group_name")
df.log <- addLogEntry("N Groups", n_group_members, df.log, "n_group_members")
df.log <- addLogEntry("Top N GSEA", parameter.list$gsea.top.n, df.log, "gsea.top.n")
df.log <- addLogEntry("Top N correlations", parameter.list$corr.top.n, df.log, "corr.top.n")
df.log <- addLogEntry("Annotation database", parameter.list$gsea.database, df.log, "gsea.database")
df.log <- addLogEntry("subsample_factor", parameter.list$general.subsample.factor, df.log, "general.subsample.factor")
if (parameter.list$gsea.database == "GO"){
  df.log <- addLogEntry("GO ontology", parameter.list$gsea.ontology, df.log, "gsea.ontology")
}
df.log <- addLogEntry("schex used for UMAPs", parameter.list$expression.do.hex, df.log, "expression.do.hex")
df.log <- addLogEntry("PDF saved", parameter.list$general.save.pdf, df.log, "general.save.pdf")
if (parameter.list$gsea.threshold == 1){
  df.log <- addLogEntry("GSEA threshold", "padj<0.1" , df.log, "gsea.threshold")
} else if (parameter.list$gsea.threshold == 2) {
  df.log <- addLogEntry("GSEA threshold", "p<0.05 & |NES| > 1" , df.log, "gsea.threshold")
} else if (parameter.list$gsea.threshold == 3) {
  df.log <- addLogEntry("GSEA threshold", "top 3 (sorted by NES)" , df.log, "gsea.threshold")
}

df.log <- addLogEntry("Variance Decomposition, Covariates", parameter.list$vd.covariates , df.log, "vd_covariates")
df.log <- addLogEntry("Variance Decomposition, Interactions", parameter.list$vd.interactions , df.log, "vd.interactions")

df.log <- addLogEntry("correlation data", parameter.list$cor.which.data , df.log, "cor.which.data")
df.log <- addLogEntry("Check for precomputed corr mat", parameter.list$cor.check.existing , df.log, "cor.check.existing")
df.log <- addLogEntry("corr mat recomputed if query missing", parameter.list$cor.recompute.existing.if.query.missing , df.log, "cor.recompute.existing.if.query.missing")


```


```{r keep available markers, warning = FALSE, include = FALSE}

if (exists("markers_of_interest")){
  if (is.character(markers_of_interest)){
    which.available <- unlist(lapply(markers_of_interest, function(x) isGeneAvailable(so.query,x,gNames.list)))
    genes.not.found <- markers_of_interest[!which.available]
    try({genes.not.found <- genes.not.found[genes.not.found != ""]}, silent = T)
    markers_of_interest <- unique(markers_of_interest[which.available])
    markers_of_interest <- rmvCSVprefix(markers_of_interest)
    if (length(markers_of_interest) == 0) stop("None of queried genes found in seurat object. M09 run terminated.")
  } else if (is.data.frame(markers_of_interest)){
    colnames(markers_of_interest) <- rmvCSVprefix(colnames(markers_of_interest))
  }
}


```



```{r TYPE3 - prepare query gene list, warning = FALSE, include = FALSE}

if (which.input$query_input_format == 3){
  message("Running differential gene analysis...")
  orig.ident <-  Idents(so.query) 
  Idents(so.query) <- grouping_var
  # deg.gene <- FindAllMarkers(so.query, 
  #                            assay = DefaultAssay(so.query),
  #                            slot = "data",
  #                            only.pos = F, 
  #                            min.pct = 0,
  #                            test.use = "MAST",
  #                            logfc.threshold = 0.15, 
  #                            max.cells.per.ident = 200,
  #                            return.thresh = 1, #1 ensures all genes are returned
  #                            verbose = F)
  
  
  deg.gene <- presto::wilcoxauc(so.query, group_by = grouping_var, seurat_assay = DefaultAssay(so.query))
  Idents(so.query) <- orig.ident
} 

```


```{r TYPE3 - reformat DEG, warning = FALSE, include = FALSE}

if (which.input$query_input_format == 3){
  
  top.n.deg <- 10
  # p.threshold <- 0.05
  # lfc.threshold <- 0.25
  # pct.threshold <- 0.25
  
  deg.gene <- deg.gene %>% dplyr::arrange(auc)
  deg.gene.top <- deg.gene %>%
    dplyr::group_by(group) %>%
    dplyr::top_n(top.n.deg, auc)
  
  # filter by threshold
  # deg.gene.sig <- deg.gene[ (deg.gene$p_val_adj<p.threshold) & 
  #                             (abs(deg.gene$avg_log2FC)>lfc.threshold) & 
  #                             (deg.gene$pct.1 > pct.threshold) & 
  #                             (deg.gene$pct.2 > pct.threshold), ]
  # 
  # # subset and label (up vs down), merge after
  # deg.gene.sig.up <- deg.gene.sig[deg.gene.sig$avg_log2FC>0, ]
  # deg.gene.sig.up$cluster <- as.character(paste("c", deg.gene.sig.up$cluster, ".up", sep = ""))
  # deg.gene.sig.down <- deg.gene.sig[deg.gene.sig$avg_log2FC<0, ]
  # deg.gene.sig.down$cluster <- as.character(paste("c", deg.gene.sig.down$cluster, ".down", sep = ""))
  # deg.gene.sig.all <- bind_rows(deg.gene.sig.up, deg.gene.sig.down)
  # 
  # # pivot to wide (accomodate uneven col numbers)
  # deg.gene.sig.all.subset <- unique(data.frame(cluster = deg.gene.sig.all$cluster, gene = deg.gene.sig.all$gene))
  # deg.gene.sig.all.subset$cluster <- as.character(deg.gene.sig.all.subset$cluster)
  # deg.all.wide <- deg.gene.sig.all.subset %>%
  #   group_by(cluster) %>%
  #   mutate(row = row_number()) %>%
  #   tidyr::pivot_wider(names_from = cluster, values_from = gene) %>%
  #   dplyr::select(-row)
  
  # markers_of_interest <- as.data.frame(deg.all.wide)
  markers_of_interest <- unique(as.character(deg.gene.top$feature))
  
  
} else if (which.input$query_input_format == 4){
  top.n.genes <- 50
  
  gene.scale.name <- unique(rownames(so.query))
  df.avg.exp <- DotPlot(so.query, assay = DefaultAssay(so.query), features = gene.scale.name, group.by = "seurat_clusters")[["data"]]
  df.avg.exp.sub <- df.avg.exp[ , c("features.plot", "avg.exp", "id")]
  colnames(df.avg.exp.sub) <- c("genes", "exp", "cluster")
  df.avg.exp.sub$cluster <- paste("c", df.avg.exp.sub$cluster, sep = "")
  
  
  df.exp.all.top.wide <- df.avg.exp.sub %>%
    dplyr::group_by(cluster) %>%
    dplyr::top_n(n = top.n.genes, wt = exp) %>%
    dplyr::select(c("genes", "cluster")) %>%
    group_by(cluster) %>%
    mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = cluster, values_from = genes) %>%
    dplyr::select(-row)
  
  markers_of_interest <- as.data.frame(df.exp.all.top.wide)
}

```



```{r umap by cluster, warning = FALSE, include = FALSE}

message("Generating UMAP plots...")
# get GGplot handle for cluster umap
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = "seurat_clusters", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Clusters") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = "Barcode", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Barcodes") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

if (parameter.list$general.print.inline) plt.umap_by_cluster

```

```{r meta module , warning = FALSE}

# pool genesets if modular activity is query of interest ##########################

if(!exists("moi.df")) moi.df <- (markers_of_interest)
if (meta.module.flag == T){
  message("Computing modular activity...")
  
  gNames <- gNames.list
  plt.clustermarkers_by_umap <- list()
  available_markers <- c()
  
  markers_of_interest <- names(moi.df)
  
  exp.mat.new <- NULL
  
  all.list <- list()
  for (i in 1:length(markers_of_interest)){
    
    # get meta module name
    cur.marker <- markers_of_interest[i]
    
    # clean dataset and include only those available in seurat object
    cur.features <- as.character(moi.df[,i][moi.df[,i] != ""])
    cur.features <- cleanFilterGenes(cur.features, so.query, parameter.list$general.species)
    
    if (length(cur.features) == 0) next
    
      module.name <- cur.marker

    so.query.try = NA
    so.query.try <-  try(AddModuleScore(so.query,  
                                        features = list(cur.features),
                                        ctrl = 50,
                                        name = "new.module",
                                        nbin = 5), silent = T)
    
    if (is.na(so.query.try)) next
    
    
    # assign name to modlue score
    names(so.query.try@meta.data)[names(so.query.try@meta.data) %in% paste("new.module", 1, sep = "")] <- module.name
    so.query@meta.data[[module.name]] <- so.query.try@meta.data[[module.name]]
    
    # concat scores to dataframe
    cur.module.df <- as.data.frame(so.query@meta.data[[module.name]])
    colnames(cur.module.df) <- module.name
    exp.mat.new <- bind_cols(exp.mat.new, cur.module.df)
    
    available_markers[i] <- module.name
    all.list[[module.name]] <- cur.features
    
  }
  
  # get all scores and cast as matrix
  exp.mat.new.mat.t <- t(as.matrix(exp.mat.new))
  
  # concat scores to seurat objects
  exp.mat.1 <-so.query@assays[[DefaultAssay(so.query)]]@data
  colnames(exp.mat.new.mat.t) <- colnames(exp.mat.1)
  exp.mat.1 <- rbind(exp.mat.1, exp.mat.new.mat.t)
  so.query@assays[[DefaultAssay(so.query)]]@data <- exp.mat.1
  markers_of_interest <- available_markers[!is.na(available_markers)]
  
}

if (exists("so.query.try")) rm("so.query.try")
```



```{r bin cells, warning = FALSE, include = FALSE}

if (parameter.list$expression.do.hex){
  
  n.cells <- ncol(so.query)
  cells.per.bin <- 30
  
  if (round(n.cells/cells.per.bin) > 100){
    nhexbins <- 100
  } else {
    round(n.cells/cells.per.bin)
  }
  so.query <- schex::make_hexbin(so.query, nbins = round(n.cells/cells.per.bin), 
                                 dimension_reduction = "UMAP")
}

```


```{r umap expression plots, message=FALSE, warning=FALSE, include = FALSE}

suppressMessages({
  
  # initialize variables
  plt.umap.1 <- list()
  plt.umap.2 <- list()
  gNames <- gNames.list
  available_markers <- c()
  
  message("UMAP expression plots...")
  # check if point size adjustment is necessary
  if (ncol(so.query)> 50000) {
    aps <- F
    pt.size <- autoPointSize(ncol(so.query))
  } else {
    aps <- T
    pt.size <- 1
  }
  
  if (class(markers_of_interest) == "data.frame") markers_of_interest <- as.vector(markers_of_interest[,1])
  if (group.by == 1)u_groups <- as.character(as.numeric(u_groups)[order(as.numeric(u_groups))])
  
  query_genes_by_group <- data.frame(u_groups)
  input.marker.list <- markers_of_interest
  
  # sort genes by group
  for (i in 1:length(markers_of_interest)){
    query_genes_by_group[ ,ncol(query_genes_by_group)+1] <- rep(markers_of_interest[i], nrow(query_genes_by_group))
  }
  
  # plot top differentially expressed genes per cluster and compare to cluster membership
  for (i in c(1:(length(markers_of_interest)))) {
    
    # empty list where plts will be stored
    all_plts <- list()
    
    # highlight cluster plot
    all_plts[[1]]  <- DimPlot(so.query, reduction = "umap", pt.size = aps, group.by = grouping_var, 
                              label = TRUE, repel = TRUE)  + 
      ggtitle(label = "UMAP") + xlab("UMAP 1") +  ylab("UMAP 2")
    
    # marker plot (try mouse and human formats)
    
    if (meta.module.flag){
      cur.marker <- markers_of_interest[i]
    } else {
      cur.marker <-  speciesConvert(markers_of_interest[i], 
                                    rownames(so.query@assays[[DefaultAssay(so.query)]]@data), 
                                    parameter.list$general.species)
    }
    
    markers_of_interest[i] <- cur.marker
    
    if (!is.na(cur.marker)){
      
      if (parameter.list$expression.do.hex){
        all_plts[[length(all_plts)+1]] <- schex::plot_hexbin_feature(so.query, feature=cur.marker, 
                                                                     action="mean", xlab="UMAP1", ylab="UMAP2", 
                                                                     title=cur.marker,
                                                                     mod = DefaultAssay(so.query),
                                                                     type = "data")
      } else {
        
        # only use nebulosa for single gene expression profiles.
        if (meta.module.flag){
          all_plts[[length(all_plts)+1]] <- scExpression.UMAP(
            so.query,
            cur.marker,
            x.label = "UMAP 1",
            y.label = "",
            plot.name = NULL,
            adjust.pt.size = aps) +
            theme_miko(legend = T) +
            viridis::scale_color_viridis(option = "A") +
            labs(title = "", subtitle =cur.marker)
        } else {
          
          is.success.plot <- F
          do.nebullosa <- F
          
          if (do.nebullosa){
            try({
              all_plts[[length(all_plts)+1]] <- Nebulosa::plot_density(
                object = so.query,
                features = cur.marker,
                slot = "data",
                joint = FALSE,
                reduction = "umap",
                dims = c(1, 2),
                method = c("ks", "wkde"),
                adjust = 1,
                size = pt.size,
                shape = 16,
                combine = TRUE,
                pal = "inferno"
              )  +
                theme_miko(legend = T) +
                viridis::scale_color_viridis(option = "A") +
                labs(title = "", subtitle =cur.marker)
              
              is.success.plot <- T
            }, silent = T)            
          }
          
          
          
          if (!is.success.plot){
            all_plts[[length(all_plts)+1]] <- scExpression.UMAP(
              so.query,
              cur.marker,
              x.label = "UMAP 1",
              y.label = "",
              plot.name = NULL,
              adjust.pt.size = aps) +
              theme_miko(legend = T) +
              viridis::scale_color_viridis(option = "A") +
              labs(title = "", subtitle =cur.marker)
          }
          
        }
      }
      
    }
    
    if (length(all_plts) == 2){
      
      current.ind <- length(plt.umap.1)+1
      plt.umap.1[[current.ind]] <- all_plts[[1]]
      plt.umap.2[[current.ind]] <- all_plts[[2]]
      available_markers[length(available_markers)+1] <- markers_of_interest[i]
      
      if (parameter.list$general.print.inline) print((CombinePlots(all_plts, ncol = length(all_plts), legend = 'none')))
    }
  }
  
  # remove NA entries
  available_markers <- available_markers[!is.na(available_markers)]
  
  # assign names marker names to each plot
  names(plt.umap.1) <- names(plt.umap.2) <- available_markers
  
  
})

```

```{r remove genes with zero variance}

message("Omitting zero variance genes...")

v.mat <- so.query@assays[[DefaultAssay(so.query)]]@data
v.mat <- v.mat[rownames(v.mat) %in% available_markers, ]
# check if all genes have variance
if( ! is(v.mat, "sparseMatrix")){
  # check if values are NA
  countNA = sum(is.nan(v.mat)) + sum(!is.finite(v.mat))
  if( countNA > 0 ){
    stop("There are ", countNA, " NA/NaN/Inf values in exprObj\nMissing data is not allowed")
  }
  if (is.numeric(v.mat)){
    rv = var(v.mat)
  } else {
    rv = apply(v.mat, 1, var)
  }
  
} else{
  rv = c()
  for( i in seq_len(nrow(v.mat)) ){
    rv[i] = var(v.mat[i,])
  }
}
if( any( rv == 0) ){
  omit.which = rownames(v.mat)[which(rv == 0)]
  available_markers <- available_markers[!(available_markers %in% omit.which)]
}

```

```{r single cell expression, fig.width=10, fig.height=4, include = FALSE, warning = FALSE}

message("Violin plots...")
# clean up
try({ rm(exp.mat); rm(exp.mat.2); rm(exp.mat.complete) }, silent = T)

e.mat <- exp.mat.complete <- so.query@assays[[DefaultAssay(so.query)]]@data
e.mat.log <- log1p(e.mat)

f.mat.clust <- avgGroupExpression(
  so.query,
  which.data = "data",
  which.center = "fraction",
  which.group = "seurat_clusters"
)
try({rownames(f.mat.clust) <- rownames(e.mat.log)}, silent = T)

invisible({gc()})

f.mat.bc <- avgGroupExpression(
  so.query,
  which.data = "data",
  which.center = "fraction",
  which.group = "bc"
)
try({rownames(f.mat.bc) <- rownames(e.mat.log)}, silent = T)

# plot clustered violin plot
plt.sgExp.all <- list()
for (i in 1:length(available_markers)){
  
  plt.sgExp.clust <- expression.Plot(so = so.query, e.mat = e.mat.log, f.mat = f.mat.clust, 
                                         which.gene = available_markers[i], which.group = "seurat_clusters", 
                                         which.data = "data", x.label = "Cluster") + 
    labs(title = "Violin Plots", subtitle = "Clusters", caption = "violin = normalized expression\ndot = expression mean\nbar = expressin fraction")  
  
  is.success <- F
  try({
    plt.sgExp.barcode <- expression.Plot(so = so.query, e.mat = e.mat.log, f.mat = f.mat.bc, 
                                             which.gene = available_markers[i], which.group = "bc", which.data = "data",
                                              x.label = "Sample", x.label.angle = 25) +  
      labs(title = "", subtitle = "Samples", caption = "violin = normalized expression\ndot = expression mean\nbar = expressin fraction")  
      
    is.success <- T
  })
  
  if (is.success){
    plt.sgExp <- cowplot::plot_grid(plotlist = list(plt.sgExp.clust, plt.sgExp.barcode), ncol = 2)
  } else {
    plt.sgExp <-plt.sgExp.clust
  }
  
  plt.sgExp.all[[available_markers[i]]] <- plt.sgExp
  
  if (parameter.list$general.print.inline){
    print(plt.sgExp.all[[available_markers[i]]])
  }
}


# plt.sgExp.all
```


```{r symbol2entrez, warning = FALSE, message = FALSE, include = FALSE}

# get symbol to entrez mapping
my.symbol <- as.vector(rownames(so.query))
my.entrez <- sym2entrez(my.symbol, my.species = parameter.list$general.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

```



```{r get correlations, message=FALSE, warning=FALSE}

message("Computing correlations...")
which.data <- parameter.list$cor.which.data
stopifnot(which.data %in% c("data", "scale"))

if (which.data == "data"){
  query.cor <- "similarity.data"
} else if (which.data == "scale"){
  query.cor <- "similarity.scale"
}

# check for pre-computed matrix
if (!meta.module.flag && parameter.list$cor.check.existing && (query.cor %in% names(so.query@misc))){
  # get existing cor mat
  query.cor.mat <- so.query@misc[[query.cor]][["similarity.matrix"]]
  parameter.list$cor.method <- so.query@misc[[query.cor]][["metric"]]
  
  # check if pre-computed cor mat includes query genes
  n.query <- length(available_markers)
  n.included <- sum(rownames(query.cor.mat) %in% available_markers)
  if (n.query != n.included) {
    if (n.included == 0){
      warning("None of queried features are avaialble in precomputed corr matrix")
    } else {
      warning("Only subset of queried features are avaialble in precomputed corr matrix")
    }
    
    if (parameter.list$cor.recompute.existing.if.query.missing){
      compute.cor <- T
      query.cor.mat <- NULL
    } else {
      compute.cor <- F
    }
  } else {
    compute.cor <- F
  }
} else {
  compute.cor <- T
} 

# compute correlation matrix
if (compute.cor) {
  
  # entire matrix
  exp.mat.complete <- getExpressionMatrix(so.query, which.data = which.data)
  
  # variable gene only matrix
  use.var <- T
  
  n.var <- 3000 # specify number of variable genes
  if (use.var){

    
    is.exp <- exp.mat.complete > 0
    p.exp <- rowMeans(is.exp)
    # p.exp <- apply(exp.mat.complete, 1, function(x) mean(x > 0))
    which.keep <- rownames(exp.mat.complete)[which(p.exp > parameter.list$cor.min.expr)]
    which.keep2 <-  rownames(exp.mat.complete)[rownames(exp.mat.complete) %in% available_markers]
    exp.mat <- exp.mat.complete[rownames(exp.mat.complete) %in% unique(c(which.keep, which.keep2)), ]
  } else {
    exp.mat <- exp.mat.complete
  }
  
  # ensure no negative values (necessary condition for proportionality association metrics)
  if ((min(exp.mat.complete) < 0) & (parameter.list$cor.method == "rho_p")) {
    exp.mat <- exp.mat + abs(min(exp.mat.complete))
    exp.mat.complete <- exp.mat.complete + abs(min(exp.mat.complete))
  }
  
  df.cor.list <- NULL
  
  query.cor.list <- list()

    which.missing <- c()
  
  if (which.data == "data"){
    t.exp.mat <- scMiko::sparse2dense(exp.mat, block.size = 10000, transpose = T)    
  } else {
    t.exp.mat <- t(exp.mat)
  }
  
  if (parameter.list$cor.method == "rho_p"){
    query.cor.object <-  propr::perb(t.exp.mat, select = colnames(t.exp.mat))
    query.cor.mat <- query.cor.object@matrix
  } else if (parameter.list$cor.method == "spearman"){
    
    exp.map.av <- t.exp.mat[ , toupper(colnames(t.exp.mat)) %in% toupper(available_markers)]
    query.cor.mat <-  cor(t.exp.mat, exp.map.av, method = "spearman")
   
    # query.cor.mat <-  dismay::dismay(t.exp.mat, metric = parameter.list$cor.method)
  } else if (parameter.list$cor.method == "pearson"){
    exp.map.av <- t.exp.mat[ , colnames(t.exp.mat) %in% available_markers]
    query.cor.mat <-  cor(t.exp.mat, exp.map.av)    
  }
}

 if ((dim(query.cor.mat)[2] == 1) & length(available_markers) == 1) colnames(query.cor.mat) <- available_markers

# !(rownames(query.cor.mat) %in% available_markers)
query.cor.mat.all <- query.cor.mat[,colnames(query.cor.mat) %in% available_markers]

if (!is.null(dim(query.cor.mat.all)) && ncol(query.cor.mat.all) == 0) stop("Correlation matrix is missing query features. If precomputed cor mat (M27) was used, try recomputing in current module (M09)")

# assign results
df.cor.list <- as.data.frame(query.cor.mat.all)
if (ncol(df.cor.list) == 1) {
  
  df.cor.list$genes<-  rownames(query.cor.mat)[!(rownames(query.cor.mat) %in% available_markers)]
  colnames(df.cor.list)[1] <- available_markers[1]
} else {
  df.cor.list$genes <- rownames(df.cor.list)
}

if (!("genes" %in% colnames(df.cor.list)))  df.cor.list$genes <- rownames(df.cor.list)
which.available.markers <- available_markers[available_markers %in% colnames(df.cor.list)]
df.cor.list <- df.cor.list[ ,c("genes", which.available.markers)]

# set auto-correlations to zero
for (i in 1:ncol(df.cor.list)){
  if (colnames(df.cor.list)[i] == "genes") next
  current.gene <- colnames(df.cor.list)[i]
  which.match <- df.cor.list$genes %in% colnames(df.cor.list)[i]
  df.cor.list[which.match,current.gene] <- NA
}


```


```{r Variance Decomposition}

message("Performing variance decomposition...")

# prep covariate list ##########################################################
vd_covariates <- parameter.list$vd.covariates
vd_interactions <- parameter.list$vd.interactions

# sequence coverage correction
if (DefaultAssay(so.query) == "RNA"){
  seq.coverage <- "nCount_RNA"
} else if ((DefaultAssay(so.query) == "SCT")) {
  seq.coverage <- "nCount_SCT"
}

vd_covariates <- unique(c(vd_covariates, seq.coverage))

# variance decomp pipeline #####################################################

# step 1: model formulation
vd_model.list <- vd_Formula(object = so.query, 
                            covariates = vd_covariates, 
                            interactions = vd_interactions)

# step 2: prep model inputs
vd_inputs.list <- vd_Inputs(so.query, vd_model.list = vd_model.list, features = which.available.markers, 
                            pct.min =  0, variable.features = F, subsample.factor = 1)

# step 3: run variance decomposition
vd.workers <- parameter.list$vd.n.workers
if (vd.workers > length(which.available.markers)) vd.workers <- length(which.available.markers)
vd_results.list <- vd_Run(vd_inputs.list, n.workers = vd.workers)

# remove results that are no longer required
rm(vd_inputs.list)
rm(vd_model.list)
invisible({gc()})

# visualize results ############################################################
vd.df <- as.data.frame(vd_results.list[["varPart.format2"]])
rownames(vd.df) <- vd.df$gene
vd.df <- vd.df %>% dplyr::select(-c("gene"))


plt.vd.list <- list()
for (i in 1:nrow(vd.df)){
  
  gene.name <- rownames(vd.df)[i]
  vd.df.t <- as.data.frame(t(vd.df[i, ]))
  colnames(vd.df.t) <- "x"
  vd.df.t$cov <- rownames(vd.df.t)
  
  residual.var <- signif(vd.df.t$x[vd.df.t$cov == "Residuals"], 3) * 100
    plt.vd.list[[gene.name]] <- vd.df.t %>%
    dplyr::filter(cov != "Residuals") %>%
    ggplot(aes(x = x*100, y = reorder(cov, x))) + 
    theme_miko(legend = F) + 
    geom_bar(stat = "identity", color = "black", fill = "grey50")   + 
    labs(title = "Variance Decomposition", subtitle = paste0("Unexplained Variance = ", residual.var, "%")) +
    xlab("Variance Explained (%)") +
    ylab("Explanatory Covariates")
}

```



```{r prep ranking lists, warning = FALSE}

message("Preparing data for GSEA...")

# Rank by LFC if DEG
# 
# if (which.input$query_input_format == 3){
#   deg.gene.enrich <- deg.gene[ ,c("cluster", "avg_log2FC", "gene")]
#   colnames(deg.gene.enrich) <- c("cluster", "avg_log2FC", "genes")
#   deg.gene.enrich$cluster <- paste("c", deg.gene.enrich$cluster , sep = "")
#   deg.gene.enrich.wide <- pivot_wider(deg.gene.enrich, names_from = cluster, values_from = avg_log2FC)
#   
#   df2enrich <- as.data.frame(deg.gene.enrich.wide)
#   
#   # Rank by Correlations if query genes
# } else 
  
if (which.input$query_input_format == 4){
  
  exp.gene.enrich.wide <- pivot_wider(df.avg.exp.sub, names_from = cluster, values_from = exp)
  df2enrich <- as.data.frame(exp.gene.enrich.wide)
  
} else if (!is.null(df.cor.list)) {
  
  # query has r = 1 with itself; set to next top cor value (+1e-3) to ensure query does not dominate rankings
  df.cor.list.genes <- df.cor.list$genes
  df.cor.list.cor <- df.cor.list %>% dplyr::select(-c("genes"))
  mat.cor.list.cor <- as.matrix(df.cor.list.cor)
  filter.cor <- 0.9999999999
  for (i in 1:ncol(mat.cor.list.cor)){
    mat.cor.list.cor[mat.cor.list.cor[,i] > filter.cor, i] <- max(mat.cor.list.cor[mat.cor.list.cor[,i] < filter.cor, i], na.rm = T) + 1e-3
  }
  
  mat.cor.list.cor <- signif(mat.cor.list.cor, 4)
  df.cor.list <- bind_cols(data.frame(genes = df.cor.list.genes), as.data.frame(mat.cor.list.cor))
  
  df2enrich <- as.data.frame(df.cor.list)
} else {
  df2enrich <- NULL
}

# ensure no duplicate exist
if (!is.null(df2enrich)){
  df2enrich <- df2enrich[!duplicated(df2enrich$genes), ]
  enrich.groups <- colnames(df2enrich)
  enrich.groups <- enrich.groups[enrich.groups != "genes"]
  }

```

```{r get pathways, warning = FALSE}

message("Retrieving pathway genesets...")

# all.genes <-df2enrich$genes
all.genes <- rownames(so.query)

match.ind <- match(all.genes, my.entrez$SYMBOL)
all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind]) 

pathways.subset <- getAnnotationPathways(all.genes.entrez, 
                                         db = parameter.list$gsea.database, 
                                         ontology = parameter.list$gsea.ontology, 
                                         species = parameter.list$general.species)

```


```{r gsea enrichment, warning = FALSE}

message("Running GSEA...")

# get pathways relevant to current gene set
gse.pathway.combined <- NULL
gse.pathway.list <- list()

single.path.of.interest <- NULL

plt.enrichment <- list()

# specify analysis parameters
if (parameter.list$general.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (parameter.list$general.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

# start cluster

if (parameter.list$gsea.n.workers > length(enrich.groups)) parameter.list$gsea.n.workers <- length(enrich.groups)
cl <- parallel::makeCluster(parameter.list$gsea.n.workers)
doParallel::registerDoParallel(cl)

score.results <- foreach(i = 1:length(enrich.groups), .packages = c("fgsea", "plyr"))  %dopar% {

  gene.list <- (df2enrich[, enrich.groups[i]])
  names(gene.list) <- df2enrich$genes
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  
  suppressMessages({gse.pathway <- fgsea(pathways.subset, gene.list.clean, nperm=1000, maxSize=500) })
  
  if (nrow(gse.pathway) == 0) {
    return(list(out1 = NULL,
                out2 = NULL))
  } else {
    
    gse.pathway$query <- enrich.groups[i]

    if(parameter.list$gsea.threshold == 1){
      gse.pathway.filtered <- gse.pathway[gse.pathway$padj < 0.1, ]
    } else if (parameter.list$gsea.threshold == 2){
      gse.pathway.filtered <- gse.pathway[((gse.pathway$pval < 0.05) & (abs(gse.pathway$NES) > 0.8)), ]
    } else if (parameter.list$gsea.threshold == 3){
      gse.pathway.filtered <- gse.pathway %>% top_n(3, NES)
    }

    # make human readable (map entrez to symbol)
    gse.pathway.filtered.orig <- gse.pathway.filtered
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$leadingEdge, 
                                       mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$set, paste,collapse = ", ")
    gse.pathway.filtered$query <- enrich.groups[i]
    
    
    # sig figs for numerics
    gse.pathway.filtered$ES <- signif(gse.pathway.filtered$ES, 3)
    gse.pathway.filtered$NES <- signif(gse.pathway.filtered$NES, 3)
    gse.pathway.filtered$pval <- gse.pathway.filtered$pval
    gse.pathway.filtered$padj <- signif(gse.pathway.filtered$padj, 3)
    
    # filter and rearrange columns
    gse.pathway.cur <- gse.pathway.filtered[ ,c("query", "pathway", "size", "ES", "NES", "pval", "padj", "set")]
    
    return(list(out1 = gse.pathway.cur,
                out2 = gse.pathway))
  }
  
} 

# stop workers
parallel::stopCluster(cl)

stopifnot(length(enrich.groups) == length(score.results))

for (i in 1:length(enrich.groups)){
  gse.pathway.list[[enrich.groups[i]]] <- score.results[[i]]$out1
  gse.pathway.combined <- bind_rows(gse.pathway.combined, score.results[[i]]$out2)
}

```

```{r gsea barplot, warning = FALSE}

message("GSEA plots...")

plt.top.gsea <- list()
for (i in 1:length(available_markers)){
  
  current.paths <- gse.pathway.list[[available_markers[i]]]
  
  if (is.null(current.paths)) {
    plt.top.gsea[[available_markers[i]]] <- NULL
    next
  }
  
  current.paths <- current.paths %>% dplyr::arrange(-abs(NES))
  current.paths <- current.paths[!duplicated(current.paths$set), ]
  
  if (is.null(current.paths)) {
    plt.top.gsea[[available_markers[i]]] <- NULL
    next
  }
 
 df.set1 <- current.paths %>% dplyr::filter(NES > 0) %>% dplyr::arrange(log10(pval))
  df.set2 <- current.paths %>% dplyr::filter(NES < 0) %>% dplyr::arrange(log10(pval))
 current.paths <- bind_rows(df.set1[1:parameter.list$gsea.top.n, ] %>% dplyr::arrange(-NES),
                            df.set2[1:parameter.list$gsea.top.n, ] %>% dplyr::arrange(NES))

 current.paths$pathway <- stringr::str_trunc(current.paths$pathway, 40)
 
 plt.top.gsea[[available_markers[i]]] <- current.paths %>%
   ggplot(aes(x = reorder(pathway, -log10(pval) * sign(NES)), y = -log10(pval) * sign(NES), size = abs(NES), fill = abs(NES))) + 
   geom_point(pch = 21) + 
   coord_flip() + 
   xlab("Pathways") + ylab("-log(p)") + 
   labs(title = "GSEA", subtitle = paste0(available_markers[i], " corr. ranking"), caption = "x-axis = -log(p), color = |NEs|, size = |NEs|") + 
   geom_hline(yintercept = 0, linetype = "dashed") + 
   viridis::scale_fill_viridis(option = "B", limits = c(min(abs(current.paths$NES)),max(abs(current.paths$NES))))
 
 
 if (parameter.list$general.print.inline){
   plt.top.gsea[[available_markers[i]]]
 }
}


```


```{r common enrichments, warning = FALSE, include = FALSE}

gse.pathway.combined.tally <- NULL
try({
  

# summarize enrichments
  gse.pathway.combined.label <- gse.pathway.combined

  if (!is.null(gse.pathway.combined.label)){

    which.enrich <- gse.pathway.combined.label$NES > 0
    which.enrich[is.na(which.enrich)] <- FALSE
    which.deplete <- gse.pathway.combined.label$NES < 0
    which.deplete[is.na(which.deplete)] <- FALSE
    gse.pathway.combined.label$pathway[which.enrich] <- paste("Enriched-", gse.pathway.combined.label$pathway[which.enrich], sep = "")
    gse.pathway.combined.label$pathway[which.deplete] <- paste("Depleted-", gse.pathway.combined.label$pathway[which.deplete], sep = "")

    gse.pathway.combined.tally <- gse.pathway.combined.label %>%
      dplyr::filter(pval < 0.01, abs(NES) > 1) %>%
      dplyr::group_by(pathway) %>%
      summarise(queries = list(query))

    gse.pathway.combined.tally$n <- lapply(gse.pathway.combined.tally$queries, length)
    gse.pathway.combined.tally$n <- as.numeric(gse.pathway.combined.tally$n)
    gse.pathway.combined.tally$set <- lapply(gse.pathway.combined.tally$queries, paste,collapse = ", ")
    gse.pathway.combined.tally <- gse.pathway.combined.tally %>%
      dplyr::select(-c("queries")) %>%
      dplyr::arrange(n)

  } else {
    gse.pathway.combined.tally <- NULL
  }

# 
}, silent = T)

```

```{r cormat heatmap, warning = FALSE}

message("Correlation heamap...")
if (exists("df.cor.list")) {
  
  df.cor.list.mat <- df.cor.list
  df.cor.list.mat <- df.cor.list.mat[!duplicated(df.cor.list.mat$genes), ]
  rownames(df.cor.list.mat) <- df.cor.list.mat$genes
  df.cor.list.mat <- dplyr::select(df.cor.list.mat, -c("genes"))
  cor.mat <- as.matrix(df.cor.list.mat)
  
  
  top.n.cor <- parameter.list$cor.top.n
  n.per.query <- ceiling(0.5*top.n.cor/ncol(cor.mat))
  
  filter.cor <- T
  if (filter.cor){
    
    cor.mat.df <- as.data.frame(cor.mat)
    top.cor <- unique(as.vector(unlist(apply(cor.mat.df, 2, function(x) {
      c(rownames(cor.mat)[order(-x)][1:n.per.query], rownames(cor.mat)[order(x)][1:n.per.query])
    }))))
    cor.mat.sub <- cor.mat[rownames(cor.mat) %in% top.cor, ]
    
    if (class(cor.mat.sub) == "numeric"){
      names(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor]
    } else {
      rownames(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor] 
    }
    
  } else {
    cor.mat.sub <- cor.mat
  }
}


```


```{r gene.expression tables, warning = FALSE}

message("Constructig expression tables...")
data.all <- as.data.frame(so.query@assays[[DefaultAssay(so.query)]]@data[rownames(so.query@assays[[DefaultAssay(so.query)]]@data) %in% available_markers, ])
data.rownames <- rownames(data.all)
match.ind <- data.rownames %in% available_markers
data.subset <- as.data.frame(t(data.all[match.ind, ]))

groups.of.interest <- list(cluster = "seurat_clusters",
                           batch = "batch",
                           barcode = "bc",
                           stratify.group = "stratify.group")

df.expression.list <- list()
for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    data.subset[ ,names(groups.of.interest)[i]] <- so.query@meta.data[[groups.of.interest[[i]]]]
  }
}

if ((grouping_var != "seurat_clusters") &  (grouping_var %in%  names(so.query@meta.data))){
  data.subset[ ,grouping_var] <- so.query@meta.data[[grouping_var]]
}
available_markers <-available_markers[available_markers %in% colnames(data.subset)]

data.subset.long <- gather(data.subset, gene, expression, available_markers)

for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    df.expression.list[[names(groups.of.interest)[i]]] <- data.subset.long %>%
      group_by(gene, get(names(groups.of.interest)[i])) %>%
      summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
                median.exp = signif(log(median(expm1(expression)+ 1)),3),
                sd.exp = signif(sd(((expression))),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    colnames( df.expression.list[[names(groups.of.interest)[i]]])[2] <- names(groups.of.interest)[i]
    
    if (parameter.list$general.print.inline) datatable(df.expression.list[[names(groups.of.interest)[i]]], filter = "top")
  }
}   

if (all(c("seurat_clusters", "batch") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x batch"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, batch) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif(sd(((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (parameter.list$general.print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (all(c("seurat_clusters", "stratify.group") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x stratify.group"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, stratify.group) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif(sd(((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (parameter.list$general.print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (all(c("seurat_clusters", "bc") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x Barcode"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, barcode) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif((sd((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (parameter.list$general.print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (grouping_var != "seurat_clusters"){
  
  if (all(grouping_var %in%  names(so.query@meta.data))){
    cur.entry <- grouping_var
    df.expression.list[[cur.entry]] <- data.subset.long %>%
      group_by(gene, get(cur.entry)) %>%
      summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
                median.exp = signif(log(median(expm1(expression)+ 1)),3),
                sd.exp = signif(sd(((expression)+ 1)),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    if (parameter.list$general.print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
  }
  
}


```

```{r cluster by barcode expression heatmaps, include = FALSE}

cb.hm.list <- list()


if ("cluster x Barcode"  %in% names(df.expression.list)){
  message("Constructing cluster x barcode expression heatmap(s)...")
  df.expression.cb <- df.expression.list[["cluster x Barcode"]]
  u.gene.cb <- unique(df.expression.cb$gene)
  
  for (i in 1:length(u.gene.cb)){
    gene.name <- u.gene.cb[i]
    df.ecb.cur <-   df.expression.cb %>%
      dplyr::filter(gene %in% gene.name) %>%
      dplyr::select(c("cluster", "barcode", "mean.exp")) %>%
      pivot_wider(names_from = "cluster", values_from ="mean.exp")
    df.ecb.cur <- as.data.frame(df.ecb.cur)
    rownames(df.ecb.cur) <- df.ecb.cur$barcode
    df.ecb.cur <- as.matrix(df.ecb.cur %>% dplyr::select(-c("gene", "barcode")))
    df.ecb.cur[is.na(df.ecb.cur)] <- 0
    colnames(df.ecb.cur) <- paste0("c", colnames(df.ecb.cur))
    
    is.success <- F
    if (nrow(df.ecb.cur) == 1){
      try({
        plt.hm.cb <- ggplotify::as.ggplot(pheatmap::pheatmap(t(df.ecb.cur), color = inferno(100), silent = T, cluster_cols = F)) +
          labs(title = "Expression", subtitle = "Cluster x Sample") + 
          theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))   
        is.success <- T
      }, silent = T)
    } else {
      try({
        plt.hm.cb <- ggplotify::as.ggplot(pheatmap::pheatmap(t(df.ecb.cur), color = inferno(100), silent = T)) +
          labs(title = "Expression", subtitle = "Cluster x Sample") + 
          theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))   
        is.success <- T
      }, silent = T)
    }
    
    if (!is.success)  plt.hm.cb <- NULL
    
    if (parameter.list$general.print.inline){
      print(plt.hm.cb)
    }
    
    cb.hm.list[[gene.name]] <- plt.hm.cb + theme_miko(legend = T)
    
  }
} else {
  cb.hm.list <- NULL
}


```


```{r create cor heatmap, include= F}

# fitered correlation matrix
  if ((class(cor.mat.sub) == "matrix") && (dim(cor.mat.sub)[2] > 0)) {
    
   cor.mat.sub <- cor.mat.sub[ ,!(is.na(apply(cor.mat.sub, 2, function(x) var(x, na.rm = T))))] 
    plt.heat <- ggplotify::as.ggplot(pheatmap::pheatmap(cor.mat.sub, 
                                                        main = "Query x Gene Correlations\nx=query, y=genes, z=correlation",
                                                         border_color = NA, silent = T))
    
    # plt.heat
                                    
  } else {
    plt.heat <- NULL
  }


```

```{r ranked correlations, fig.height=13, fig.width=10, include = FALSE}


# if (length(markers_of_interest) == 1){

  if (parameter.list$cor.method == "rho_p") {
    fill.label <- "Proportionality Metric"
  } else if (parameter.list$cor.method == "spearman") {
    fill.label <- "Spearman R"
  } else if (parameter.list$cor.method == "pearson") {
    fill.label <- "Pearson R"
  }

cor.list <- list()
for (i in 1:length(available_markers)){
  
  # all correlations
  df.cor.all <-  data.frame(genes = rownames(cor.mat), r = as.vector(cor.mat[ ,colnames(cor.mat) %in% available_markers[i]]))
  colnames(df.cor.all) <- c("genes", "r")
  df.cor.all <-  df.cor.all[df.cor.all$genes != available_markers[i], ]
  plt.heat
    plt.cor.dist <- df.cor.all %>%
    ggplot(aes(x = r)) +
    geom_density(fill = "grey") + 
    ylab("Density") + 
    xlab(fill.label) + 
    theme_classic() + 
      geom_vline(xintercept = 0, linetype = "dashed") + 
    labs(title = "Correlations", subtitle = available_markers[i]) + 
    theme(axis.text.y = element_blank()) + 
     theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))

    
    # get top genes to visualize
    gene.up <- (df2enrich %>% dplyr::arrange(get(available_markers[i])))[1:35,"genes"]
    gene.down <- (df2enrich %>% dplyr::arrange(-get(available_markers[i])))[1:35 ,"genes"]
    r.up <- (df2enrich %>% dplyr::arrange(get(available_markers[i])))[1:35,available_markers[i]]
    r.down <- (df2enrich %>% dplyr::arrange(-get(available_markers[i])))[1:35 ,available_markers[i]]
    df.cor.sub <- data.frame(genes = c(gene.up, gene.down), r = c(r.up, r.down))

  colnames(df.cor.sub) <- c("genes", "r")
  df.cor.sub <-  df.cor.sub[!(df.cor.sub$genes %in%  available_markers[i]), ]
  
  plt.ranked.cor.sub <- df.cor.sub %>%
    ggplot(aes(x = reorder(genes, r), y = r)) +
    geom_bar(stat = "identity") + 
    coord_flip() + 
    xlab("Genes") + 
    ylab(fill.label) + 
    theme_classic() + 
    labs( subtitle = "Top Correlations") 
  
  cor.list[[available_markers[i]]] <-  cowplot::plot_grid(plt.cor.dist, plt.ranked.cor.sub, ncol = 1, rel_heights = c(1,4.5), align = "hv")
  
  if (parameter.list$general.print.inline){
    print( cor.list[[available_markers[i]]])
  }
  # }
}

```


```{r combine expression plots, fig.height=12, fig.width=30, include = FALSE}

dash.list <- list()
message("Consolidating results into summary report...")

# helper to remove plot elements
rmv.plt.elements <- function(plt){
  plt <- plt + 
    theme(legend.position = "none",
          panel.grid = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.background = element_blank()) 
  return(plt)
}

# printProgress <- function(
#   
# )

for (i in 1:length(available_markers)){
  
  if (((100*(signif(i/length(available_markers)))) %% 5) == 0){
    message(paste0("Consolidation progress: ", 100*(signif(i/length(available_markers))), "%")) 
  }
  
  check.1 <- available_markers[i] %in% names(plt.umap.1)
  check.2 <- available_markers[i] %in% names(plt.umap.2)
  check.3 <- available_markers[i] %in% names(plt.sgExp.all)
  check.4 <- available_markers[i] %in% names(cor.list)
  
  # get component plots
  if (!(check.1 & check.2 & check.3 & check.4)) next
  
  # specify function for combining plots
  # combo.function <- cowplot::plot_grid()
  combo.function <- gridExtra::grid.arrange
  # combo.function <- ggpubr::ggarrange
  
  p1 <- plt.umap.1[[available_markers[i]]] + 
    theme_miko(legend = F) + labs(title = "UMAP", subtitle = "Clusters")
  p2 <- plt.umap.2[[available_markers[i]]]+ 
    theme_miko(legend = F) + labs(title = "", subtitle = paste0(available_markers[i], " Expression"))
  p3 <- plt.vd.list[[available_markers[i]]] 
  top.lq <- combo.function(grobs = list(p1, p2, p3),
                           ncol = 3, nrow = 1, widths =  c(2,2, 1.5)#, "C" , 0.5 , labels = c("A", "B", "C")
  )
  
  low.lq <- plt.sgExp.all[[available_markers[i]]]
  lq <- combo.function( top.lq, low.lq, ncol = 1,  heights = c(2,2)) #, labels = c("", "D") # , rel_heights = c(2,2), labels = c("", "D")
  plt.gsea <-  plt.top.gsea[[available_markers[i]]] + theme_miko(legend = F)
  
  cb.hm.list[[available_markers[i]]] <-  rmv.plt.elements(cb.hm.list[[available_markers[i]]]) +  
    theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))
  mc <- combo.function(cb.hm.list[[available_markers[i]]], cor.list[[available_markers[i]]], plt.gsea, ncol = 3, widths = c(1,1,1)
                      ) # labels = c("E", "F", "G")
  
  mq <- combo.function(lq, mc,  widths = c( 3,3),
                       ncol = 2)   
  
  # store final plot
  dash.list[[available_markers[i]]] <- mq
  
}


# plt.vd.list
# plot(dash.list)
# plot(mq)
```

```{r cluster-wise expression data}
# stop("stop here")
# get expression data
cluster.membership <- so.query@meta.data[[grouping_var]]
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]

# aggregate expression matrix
exp.mat.scale <- exp.mat
gene.scale.name <- rownames(exp.mat.scale)
cell.scale.name <- colnames(exp.mat.scale)

# percetnage expressed (observed)
per.dot.score <- DotPlot(so.query, features = available_markers, group.by = grouping_var)[["data"]]
per.dot.score$genes <- per.dot.score$features.plot
per.dot.score$id <- as.numeric(as.character( per.dot.score$id))
per.dot.score.sub <- per.dot.score[ ,c("id", "avg.exp.scaled", "genes")]
colnames(per.dot.score.sub) <- c("cluster", "expression", "genes")
per.dot.score.wide <- pivot_wider(per.dot.score.sub, names_from = "cluster", values_from = "expression")
gene.names.row <- per.dot.score.wide$genes
per.dot.score.wide <- dplyr::select(per.dot.score.wide, -c("genes"))
per.dot.score.wide <- per.dot.score.wide[ ,as.character(u.clusters)]
rownames(per.dot.score.wide) <- gene.names.row

# cast expression data as matrix
exp.mat.scale.processed <- as.matrix(per.dot.score.wide)
exp.mat.av <- exp.mat.scale.processed[rownames(exp.mat.scale.processed) %in% available_markers, ]

if (!is.null(dim(exp.mat.av))) exp.mat.av <- exp.mat.av[complete.cases(exp.mat.av), ]

```


```{r create exp heatmap object , include= F}

clust.success <- F
if (class(exp.mat.av) == "matrix") {
  try({
    heat.object.expression.cluster <- getHeat(exp.mat.av)
    mat.reconstruct.av <- exp.mat.av[heat.object.expression.cluster[["rowInd"]], heat.object.expression.cluster[["colInd"]]]
    gene.order.av <- rownames(mat.reconstruct.av)
    cluster.order.av <- colnames(mat.reconstruct.av)
    plt.heat.availableGenes <- ggplotify::as.ggplot(pheatmap::pheatmap(exp.mat.av))
    plt.heat.availableGenes <- ggplotify::as.ggplot(pheatmap::pheatmap(exp.mat.av,
                                                                       color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdYlGn")))(100)))
    clust.success <- T
  }, silent = T)
  
} else {
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  plt.heat.availableGenes <- NULL
}

if (!clust.success){
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  if (!exists("plt.heat.availableGenes")) plt.heat.availableGenes <- NULL  
}

```


```{r get dot size helper function}

get.dot.size <- function(gene.list){
  n.genes <- length(gene.list)
  if (n.genes < 11) xlab.size <- 15
  if (n.genes > 10) xlab.size <- 12
  if (n.genes > 40) xlab.size <- 10
  if (n.genes > 50) xlab.size <- 9
  return(xlab.size)
}

```



```{r create dot plots, fig.width = 8, fig.height = 10}

# dot plot

# order clusters according to hierarchial clustering
if (exists("cluster.order.av")){
  so.query@meta.data[[grouping_var]] <- factor(so.query@meta.data[[grouping_var]], 
                                               levels=cluster.order.av)
}

plt.dot.list <- list()

  if (!(exists("gene.order.av"))) gene.order.av <- available_markers
  
  # scale label sizes accordingly
  xlab.size <- get.dot.size(gene.order.av)
  
  # create dotplo
  plt.dot.list[["Dot.All"]] <-  DotPlot(so.query, features = factor(gene.order.av, levels = gene.order.av), 
                                        group.by = grouping_var, 
                                        dot.scale = 8,
                                        cols="RdBu" ) + 
    RotatedAxis() + ylab(group_name) +
    theme(axis.text.x=element_text(size=xlab.size, angle = 75)) + ggtitle("All Query Genes")
  if (parameter.list$general.print.inline) print( plt.dot.list[["Dot.All"]])

```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M09", input.data = input.file, input.subset = NA, pdf.flag = parameter.list$general.save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M09_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (parameter.list$general.save.pdf) dir.create(paste0(output.path, "PDF/"))

```


1) UMAP
===================================== 

Uniform manifold projection and approximation (UMAP) used to dimensionally reduce and visualize data while maintaining global transcriptomic structure. Clusters were determined using unsupervised Louvain community detection. 

Row {.tabset}
-------------------------------------

### Clusters

```{r plt.umap_by_c}
print(plt.umap_by_cluster) 
savePDF(file.name = paste0(output.path, "PDF/", "M09_umap_cluster.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = parameter.list$general.save.pdf)
```

### Barcodes

```{r plt.umap_by_b}
print(plt.umap_by_barcode) 
savePDF(file.name = paste0(output.path, "PDF/", "M09_umap_barcode.pdf"), plot.handle = plt.umap_by_barcode, 
        fig.width = 7, fig.height = 5, save.flag = parameter.list$general.save.pdf)
```


2) Expression
===================================== 

Expression plots of queried gene(sets). Dot.All shows all queries, whereas Dot.DEG shows only those that are differentially expressed (p<0.05) across clusters. Expression heatmap shows scaled expression values. All plots have been hierarchially-clustered. 

Row {.tabset}
-------------------------------------

```{r dot plot}

out1.1 <-NULL

try({
    out1.1 <- lapply(seq_along(plt.dot.list), function(i) {
      
      s1 <- paste("plt.dot.list[[", i, "]]", sep = "")
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.dot.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,  fig.width = 20, fig.height = 20}", paste(i, "plotly.dot.plt"))) 
      a3 <- knitr::knit_expand(text = sprintf("\n %s", s1))
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })
    
}, silent = T)

```
`r paste(knitr::knit(text = paste(out1.1, collapse = '\n')))`

```{r pdf dotplots,include = FALSE}

for (i in 1:length(plt.dot.list)){
  plot.name <- paste0("M09_expression_dotplot_", names(plt.dot.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.dot.list[[i]], 
          fig.width = 20, fig.height = 20, save.flag = parameter.list$general.save.pdf)
}

```

### Expression Heatmap

```{r,  fig.width = 20, fig.height = 20}

if (!is.null(plt.heat.availableGenes)) {
  
  print(plt.heat.availableGenes)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_heatmap.pdf"), plot.handle = plt.heat.availableGenes, 
          fig.width = 20, fig.height = 20, save.flag = parameter.list$general.save.pdf)
  
}



```

```{r scExpression plot v1, fig.width=10, fig.height=4}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 2){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
      savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 10, fig.height = 4, save.flag = parameter.list$general.save.pdf)
  }
}

```

```{r scExpression plot v2}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 1){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
          savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 5, fig.height =5, save.flag = parameter.list$general.save.pdf)
  }
}

```

3) Results
===================================== 

Query gene(set) summary report. A,B) Cluster memberships (A) and expression (B) projected onto UMAP. C) Variance decomposition analysis. D) Cluster- and barcode-level violin plots. Groups were hierarchially-clustered using normalized expression, expressing fraction and expression variance. E) Heatmap visualizing expression stratified by barcode and cluster. F, G) Query gene(set) correlations (F) were computed and correlation-based ranks were used as input into gene set enrichment analysis (GSEA; G) to identify query-associated enrichments. 

Row {.tabset}
-------------------------------------


```{r dash, fig.width=30, fig.height=12}

try({

    out <- lapply(seq_along(dash.list), function(i) {
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(dash.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=30, fig.height=12}", 
                                              paste(i, "dash")))  #, fig.width=50, fig.height=30
      a3 <- knitr::knit_expand(text = sprintf("\nplot(dash.list[[%d]])", i))
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })

}, silent = T)


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`



```{r pdf dash,include = FALSE}

for (i in 1:length(dash.list)){
  plot.name <- paste0("M09_summary_", names(dash.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  (dash.list[[i]]),
          fig.width = 30, fig.height = 12, save.flag = parameter.list$general.save.pdf)
}

```


4) Correlations
===================================== 

Gene(set) query correlation table and heatmap. Only top correlations are shown. 

Row {.tabset}
-------------------------------------



### Correlation Table (top)

```{r correlation table - top}


  if (class(cor.mat.sub) == "matrix"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% rownames(cor.mat.sub), ]
  } else if  (class(cor.mat.sub) == "numeric"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% names(cor.mat.sub), ]
  }

write.csv(cor.mat, file = paste0(output.path, "Tables/", "correlations.csv"), 
          row.names = T) 
  
  flex.asDT(df.cor.list.sub)

```


### Query Correlations (top)

```{r query correlation heatmap - top, fig.width=10, fig.height=13}

try({
  if (length(markers_of_interest) == 1){
    
    plt.dis.rank.cor <- cowplot::plot_grid(cowplot::plot_grid(plt.cor.dist, NULL, rel_heights = c(1,2), ncol = 1), plt.ranked.cor.sub, ncol = 2)
    
    savePDF(file.name = paste0(output.path, "PDF/", "M09_ranked_correlations.pdf"), 
            plot.handle = plt.dis.rank.cor, 
            fig.width = 10, fig.height =13, save.flag = parameter.list$general.save.pdf)
    
    print(plt.dis.rank.cor)
  } else {
        savePDF(file.name = paste0(output.path, "PDF/", "M09_correlation_heatmap.pdf"), 
            plot.handle = plt.heat, 
            fig.width = 10, fig.height =13, save.flag = parameter.list$general.save.pdf)
    
    plt.heat
  }
}, silent = T)

```

5) GSEA 
===================================== 

GSEA enrichment results for genes ranked by query correlations.  

Row {.tabset}
-------------------------------------

### Common Enrichments

```{r common enrich table }

if (exists("gse.pathway.combined.tally")){
  if (!is.null(gse.pathway.combined.tally)){
    gse.pathway.tally.output <- as.data.frame(gse.pathway.combined.tally)
    
    gse.pathway.tally.output$set <- vapply(gse.pathway.tally.output$set, paste, collapse = ", ", character(1L))
    write.csv(gse.pathway.tally.output, file = paste0(output.path, "Tables/", "gsea_pathway_tally.csv"), 
          row.names = F) 
    
    flex.asDT(gse.pathway.combined.tally)
  }
}

```


```{r gsea cor mat,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# create enrihcment list
if (exists("gse.pathway.list")){
  out_enrich_table <- flex.multiTabTables(gse.pathway.list, "gse.pathway.list")
} else {
  out_enrich_table <- NULL
}

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`


```{r save gsea statistics csv}

for (i in 1:length(gse.pathway.list)){
  table.name <- paste0(output.path, "Tables/", "gsea_statistics_", names(gse.pathway.list)[i] , ".csv")
  current.output <- gse.pathway.list[[i]]
  current.output$set <- vapply(current.output$set, paste, collapse = ", ", character(1L))
      write.csv(current.output, file = table.name, 
          row.names = F) 
}
```


6) Expression Table(s)
===================================== 

Gene(set) expression tables, stratified by clusters and sample barcodes. 

Row {.tabset}
-------------------------------------

```{r res4, echo = FALSE, eval = TRUE, message=TRUE, warning=FALSE}
out <- flex.multiTabTables(df.expression.list, "df.expression.list")
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save expression csv}

for (i in 1:length(df.expression.list)){
  table.name <- paste0(output.path, "Tables/", "expression_", names(df.expression.list)[i] , ".csv")
      write.csv(df.expression.list[[i]], file = table.name, row.names = F) 
}
```





```{r DEG query }

# 7) DEG
# ===================================== 
# Differential expression statistics for gene(set) queries. 
### DEG Query Genes
# write.csv(all.markers, file = paste0(output.path, "Tables/", "differential_expression_analysis.csv"), row.names = F) 
# flex.asDT(all.markers)
```

7) Variance Decomposition
===================================== 

Variance decomposition analysis. Proprtion of variance explained by each covariate is summarized in tables. 

### Variance Decomposition

```{r}


vd.df2 <- as.data.frame(t(apply(vd.df, 1, function(x) signif(x, 3))))

write.csv(vd.df2, file = paste0(output.path, "Tables/", "variance_decomposition.csv"), row.names = F) 
flex.asDT(vd.df2)
```

8) Genes
===================================== 

Gene(set) tables used in analysis. 

### Marker List

```{r}

write.csv(moi.df, file = paste0(output.path, "Tables/", "query_list.csv"), row.names = F) 
flex.asDT(moi.df)
```

```{r save results}

# Update analysis log
n.cells.analyzed <- ncol(so.query)
df.log <- addLogEntry("N Cells", n.cells.analyzed, df.log, "n.cells.analyzed")
df.log <- addLogEntry("Correlation Metric", parameter.list$cor.method, df.log, "cor.method")
df.log <- addLogEntry("Query Markers", markers_of_interest, df.log, "markers_of_interest")
df.log <- addLogEntry("Seurat Assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")
if (exists("exp.mat")) df.log <- addLogEntry("N genes for correlation", nrow(cor.mat), df.log, "nrow(cor.mat)")
if (exists("genes.not.found")) df.log <- addLogEntry("Genes not found", genes.not.found, df.log, "genes.not.found")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_9 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}
out1 <- flex.multiTabLogs(module.logs)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 9)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_9)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_9, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
# if (parameter.list$general.save.pdf){
#   try({
#     pdf.list <- list.files (path = paste0(output.path, "PDF/") )
#     pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
#     
#     pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
#   }, silent = T)
# }


```
