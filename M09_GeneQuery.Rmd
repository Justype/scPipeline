---
title: "Gene Query Analysis"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", "gridExtra",
                   "DT", "flexdashboard", "ggpmisc", "ggExtra", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db", "schex", "RColorBrewer")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```


```{r parameter specification}



# specify gene query
which.input <- list(
  
  # gene list input format options:
  #   0: Manual input; vector of genes (e.g., which.gene.set = c("cd70", "cd34"))
  #   1: M09_type1_queries.csv; gene.sets.type1 
  #   2: M09_type2_queries.csv; gene.sets.type2; .csv file
  #   3: cluster DEG
  #   4: top N cluster markers
  #   5: M09_type3_queries.csv; GO/Reactome genesets
  #   6: scMiko internal geneset
  query_input_format = 0,
  do.module = NA, #options: T, F, NA; if NA, takes default, otherwise overides. 
  
  # specify gene set (only if query_input_format == 1 | 2 | 5 | 6)
  which.gene.set = c("CD68", "GPNMB") # character
)


#############################

# specify which results to show
which.results <- data.frame(
  umap.top.n =10,       # plot top n markers (by DEG analysis). NA if all. 
  cor.top.n = 70,
  gsea.top.n = 20,
  gsea.threshold = 2 ,     # 1: padj < 0.1; 2: p<0.01 & |NES| > 1; 3: top 3 pathways (sorted by NES)
  annotation.db = "Bader",    # Reactome, GO, Bader
  ontology = c("BP"),         # "BP", "MF", "CC"
  do.hex = F               # specify whether to generate hex UMAPs (schex package)
)

cluster.resolution <- 0.45

# specify subgroup provided in M00_subgroups.csv; subgroup <- "no.subgroup" to include all data
subgroup <- "no.subset"

default.species <- "Mm" # if multple species are detected in input, only then default is used. 

dir.preprocessed <- "Preprocessed_Datasets/"
# query.file <- "M01_NM2_R1_test_300720.Rdata"
query.file <- "Module2_integrated_p4789_allGBM_210720.Rdata"
#query.file <- "Module1_M16_M27_UHN_240620.Rdata"

# print figures inline
print.inline <- F

# n workers
n.workers <- list(
  gsea = 5
)


# save PDF
save.pdf <- T

# downsample factor
subsample_factor <- 0.5


```

```{r import appropriate csv files}

if (which.input$query_input_format==1){
  gene.sets.type1 <- read.csv("M09_type1_queries.csv", header = TRUE)
  colnames(gene.sets.type1) <- rmvCSVprefix(colnames(gene.sets.type1))
} else if (which.input$query_input_format==2){
  gene.sets.type2.df <- read.csv("M09_type2_queries.csv", header = TRUE)
  colnames(gene.sets.type2.df) <- rmvCSVprefix(colnames(gene.sets.type2.df))
  gene.sets.type2 <- list()
  for (i in 1:nrow(gene.sets.type2.df)){
    gene.sets.type2[[gene.sets.type2.df$name[i]]] <- list(file = gene.sets.type2.df$file[i],
                                           directory = gene.sets.type2.df$directory[i],
                                           # prefix.label = gene.sets.type2.df$prefix.label[i],
                                           module = gene.sets.type2.df$module[i])
  }
} else if (which.input$query_input_format==5){
  gene.sets.type5 <- read.csv("M09_type5_queries.csv", header = TRUE)
  colnames(gene.sets.type5) <- rmvCSVprefix(colnames(gene.sets.type5))
}

if (!exists("subgroup")) subgroup <- "no.subset"
subset.input <- read.csv("M00_subgroups.csv", header = TRUE)
colnames(subset.input) <- rmvCSVprefix(colnames(subset.input))

subset.list <- list()
for (i in 1:nrow(subset.input)){
  subset.list[[subset.input$subset[i]]] <- data.frame(
    field = subset.input$field[i],
    subgroups =  stringr::str_trim(unlist(strsplit(as.character(subset.input$subgroups[i]), ","))) 
  )
  if (!is.na(subset.input$field[i]) && subset.input$field[i] == "seurat_clusters"){
    subset.list[[subset.input$subset[i]]]$subgroups <- as.numeric(subset.list[[subset.input$subset[i]]]$subgroups)
  }
}

subset.df <- subset.list[["no.subset"]] # NA specified as "no.subset"
```

```{r}
meta.module.helper <- function(do.module, default.set){
  
  if (is.na(do.module)){
    return(default.set)
  } else if (do.module == TRUE) {
    return(T)
  } else if (do.module == FALSE) {
    return(F)
  }
  
}
```


```{r input subtype data specification}

which.gene.set <- as.character(which.input$which.gene.set)

if (which.input$query_input_format==0){
  
  markers_of_interest <- which.gene.set
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
  # prefix.label = ""
} else if (which.input$query_input_format==1){
  stopifnot(which.gene.set %in% names(gene.sets.type1))
  markers_of_interest <- gene.sets.type1[[which.gene.set]] # REQUIRED if query_input_format == 1
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
  # prefix.label <- ""
} else if(which.input$query_input_format==2){
  stopifnot(which.gene.set %in% names(gene.sets.type2))
  input_spreadsheet <- gene.sets.type2[[which.gene.set]][["file"]]
  dir.geneset <- gene.sets.type2[[which.gene.set]][["directory"]]
  meta.module.flag <- meta.module.helper( which.input$do.module,gene.sets.type2[[which.gene.set]][["module"]])
  prefix.label <- gene.sets.type2[[which.gene.set]][["prefix.label"]]
} else if ((which.input$query_input_format==3) | (which.input$query_input_format==4)) {
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
  # prefix.label <- ""
} else if (which.input$query_input_format==5){
  stopifnot(which.gene.set %in% names(gene.sets.type5))
  markers_of_interest <- id2geneset(gene.sets.type5[[which.gene.set]], my.species = default.species) # REQUIRED if query_input_format == 1
  meta.module.flag <- meta.module.helper( which.input$do.module,F)
  # prefix.label <- ""
} else if (which.input$query_input_format==6){
  scMiko.geneSets <- scMiko::geneSets
  stopifnot(which.gene.set %in% names(scMiko.geneSets))
  markers_of_interest <- as.data.frame(scMiko.geneSets[[which.gene.set]])
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
  # prefix.label <- ""
}


if (exists("markers_of_interest") && "data.frame" %in% class(markers_of_interest)){
  markers_of_interest <- janitor::clean_names(markers_of_interest, "screaming_snake")
}

# annotation specifications
which.annotation.db <- which.results$annotation.db
which.ontology <- which.results$ontology


```




```{r import seurat object}

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

if (!exists("query.file")) stop("query.file not specified.")

# import and preprocess data
warning("Importing data...")
if (!grepl(".Rdata|.RData", query.file)) query.file <- paste0(query.file, ".Rdata")
load(getLoadPath(query.file, paste0(data.path, dir.preprocessed)))
so.query <- prepSeurat(so)
rm(so)

```

```{r get clusters and assay, warning = FALSE}

# get current assay
current.assay <- DefaultAssay(so.query)

# cluster data
so.query <- setResolution(so.query, cluster.resolution)

# subsample 
stopifnot(exists("subsample_factor"))
if (subsample_factor < 1){
  so.query <- downsampleSeurat(so.query, subsample.factor = subsample_factor)
}

# subset seurat object
so.query <- subsetSeurat(so.query, subset.df)

```



```{r prepare query gene list (input type 1 or 2), message=FALSE, warning=FALSE}

# IF multiple species available, set to specified default
which.species <- unique(so.query@meta.data[["Organism"]])
stopifnot(which.species == default.species)
if (length(which.species) > 1) which.species <- default.species

# import marker sets
if (which.input$query_input_format == 1){
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      markers.of.interest = markers_of_interest,
                                      which.species = which.species)
} else if (which.input$query_input_format == 2){
  
  if (meta.module.flag){
    which.col <- "all"
  } else {
    which.col <- "first"
  }
  
  input_file <- paste(data.path,dir.geneset, input_spreadsheet, sep = "")
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      input.file = input_file, 
                                      which.col = which.col,
                                      which.species = which.species)
} else if (which.input$query_input_format == 5){
  output.markers  <- m9.importMarkers(query.format = 1, 
                                      markers.of.interest = markers_of_interest,
                                      which.species = which.species)
} else if (which.input$query_input_format == 0){
  
  if (which.species == "Hs") {
    markers_of_interest <- toupper(markers_of_interest)
  } else if (which.species == "Mm") {
    markers_of_interest <- firstup(markers_of_interest)
  }
}

if (exists("output.markers")) markers_of_interest <- output.markers[[1]]


```


```{r prior log history, warning = FALSE}
# get prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r prep seurat  gene list, warning = FALSE}

try({so.query <- UpdateSeuratObject(so.query)}, silent = T)
gNames.list <- tryCatch({gNames.list <- prepGeneList( so.query, objects())},
                        error = function(e){
                          return(gNames.list)
                        })
```

```{r define grouping var, warning = FALSE}

# group by options:
#   1: clusters ID (seurat_clusters)
#   2: barcodes (Barcode)
#   3: Groups (in vivo)
group.by <- 1

# specift grouping variable
if (group.by == 1){
  grouping_var <- "seurat_clusters"
  group_name <- "Clusters"
} else if (group.by == 2){
  grouping_var <- "Barcode"
  group_name <- "Barcodes"
} else if (group.by == 3){
  grouping_var <- "Group"
  group_name <- "Group"
}

# determine unique groups
u_groups <- as.vector(unique(so.query@meta.data[[grouping_var]]))

# determine number of unique groups
n_group_members <- length(u_groups)
```



```{r analysis log, warning = FALSE}

df.log <- initiateLog("9, Query Marker Exploration")

df.log <- addLogEntry("Query File", query.file, df.log, "query.file")
df.log <- addLogEntry("Gene Set Name", which.gene.set, df.log, "which.gene.set")
df.log <- addLogEntry("Compute geneset module score", meta.module.flag, df.log, "meta.module.flag")
df.log <- addLogEntry("Default Species", default.species, df.log, "default.species")
df.log <- addLogEntry("Which Subset Field", subset.df$field, df.log, "field")
df.log <- addLogEntry("Which Subset Groups", subset.df$subgroups, df.log, "subgroups")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Grouping Variable", group_name, df.log, "group_name")
df.log <- addLogEntry("N Groups", n_group_members, df.log, "n_group_members")
df.log <- addLogEntry("Top N UMAPs", which.results$umap.top.n, df.log, "umap.top.n")
df.log <- addLogEntry("Top N GSEA", which.results$gsea.top.n, df.log, "gsea.top.n")
df.log <- addLogEntry("Top N correlations", which.results$corr.top.n, df.log, "corr.top.n")
df.log <- addLogEntry("Annotation DB", which.results$annotation.db, df.log, "annotation.db")
df.log <- addLogEntry("subsample_factor", subsample_factor, df.log, "subsample_factor")
if (which.results$annotation.db == "GO"){
  df.log <- addLogEntry("GO ontology", which.results$ontology, df.log, "ontology")
}
df.log <- addLogEntry("schex used for UMAPs", which.results$do.hex, df.log, "do.hex")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")
if (which.results$gsea.threshold == 1){
  df.log <- addLogEntry("GSEA threshold", "padj<0.1" , df.log, "gsea.threshold")
} else if (which.results$gsea.threshold == 2) {
  df.log <- addLogEntry("GSEA threshold", "p<0.05 & |NES| > 1" , df.log, "gsea.threshold")
} else if (which.results$gsea.threshold == 3) {
  df.log <- addLogEntry("GSEA threshold", "top 3 (sorted by NES)" , df.log, "gsea.threshold")
}


```


```{r convert to symbol, warning = FALSE}

# convert ENSEBLE to GENE names in Seurat object
gene.rep <-  checkGeneRep (gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))

if (gene.rep == "ensembl"){
  so.query <- ens2sym.so(so = so.query, gNames.list = gNames.list)
  gene.rep <-  checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
}


```

```{r get clusters and set assay, warning = FALSE}

if (DefaultAssay(so.query) == "integrated"){
  DefaultAssay(so.query) <- "RNA"
  so.query <-NormalizeData(so.query, verbose = FALSE)
  so.query <- ScaleData(so.query, verbose = FALSE)
  so.query <- FindVariableFeatures(so.query, selection.method = "vst", nfeatures = 3000)
  
  so.query@assays[["SCT"]] <- NULL
  so.query@assays[["integrated"]] <- NULL
  invisible(gc())
} 

current.assay =  DefaultAssay(so.query)

```

```{r keep available markers, warning = FALSE}

if (exists("markers_of_interest")){
  if (is.character(markers_of_interest)){
    which.available <- unlist(lapply(markers_of_interest, function(x) isGeneAvailable(so.query,x,gNames.list)))
    genes.not.found <- markers_of_interest[!which.available]
    markers_of_interest <- unique(markers_of_interest[which.available])
    markers_of_interest <- rmvCSVprefix(markers_of_interest)
    if (length(markers_of_interest) == 0) stop("None of queried genes found in seurat object. M09 run terminated.")
  } else if (is.data.frame(markers_of_interest)){
    colnames(markers_of_interest) <- rmvCSVprefix(colnames(markers_of_interest))
  }
}


```



```{r TYPE3 - prepare query gene list, warning = FALSE}

if (which.input$query_input_format == 3){
  
  orig.ident <-  Idents(so.query) 
  Idents(so.query) <- grouping_var
  deg.gene <- FindAllMarkers(so.query, 
                             assay = DefaultAssay(so.query),
                             slot = "data",
                             only.pos = F, 
                             min.pct = 0,
                             test.use = "MAST",
                             logfc.threshold = 0.15, 
                             max.cells.per.ident = 200,
                             return.thresh = 1, #1 ensures all genes are returned
                             verbose = F)
  Idents(so.query) <- orig.ident
} 

```


```{r TYPE3 - reformat DEG, warning = FALSE}

if (which.input$query_input_format == 3){
  
  p.threshold <- 0.05
  lfc.threshold <- 0.25
  pct.threshold <- 0.25
  
  # filter by threshold
  deg.gene.sig <- deg.gene[ (deg.gene$p_val_adj<p.threshold) & 
                              (abs(deg.gene$avg_logFC)>lfc.threshold) & 
                              (deg.gene$pct.1 > pct.threshold) & 
                              (deg.gene$pct.2 > pct.threshold), ]
  
  # subset and label (up vs down), merge after
  deg.gene.sig.up <- deg.gene.sig[deg.gene.sig$avg_logFC>0, ]
  deg.gene.sig.up$cluster <- as.character(paste("c", deg.gene.sig.up$cluster, ".up", sep = ""))
  deg.gene.sig.down <- deg.gene.sig[deg.gene.sig$avg_logFC<0, ]
  deg.gene.sig.down$cluster <- as.character(paste("c", deg.gene.sig.down$cluster, ".down", sep = ""))
  deg.gene.sig.all <- bind_rows(deg.gene.sig.up, deg.gene.sig.down)
  
  # pivot to wide (accomodate uneven col numbers)
  deg.gene.sig.all.subset <- unique(data.frame(cluster = deg.gene.sig.all$cluster, gene = deg.gene.sig.all$gene))
  deg.gene.sig.all.subset$cluster <- as.character(deg.gene.sig.all.subset$cluster)
  deg.all.wide <- deg.gene.sig.all.subset %>%
    group_by(cluster) %>%
    mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = cluster, values_from = gene) %>%
    select(-row)
  
  markers_of_interest <- as.data.frame(deg.all.wide)
  
  
} else if (which.input$query_input_format == 4){
  top.n.genes <- 50
  
  gene.scale.name <- unique(rownames(as.matrix(so.query@assays[[DefaultAssay(so.query)]]@scale.data)))
  df.avg.exp <- DotPlot(so.query, assay = DefaultAssay(so.query), features = gene.scale.name, group.by = "seurat_clusters")[["data"]]
  df.avg.exp.sub <- df.avg.exp[ , c("features.plot", "avg.exp", "id")]
  colnames(df.avg.exp.sub) <- c("genes", "exp", "cluster")
  df.avg.exp.sub$cluster <- paste("c", df.avg.exp.sub$cluster, sep = "")
  
  
  df.exp.all.top.wide <- df.avg.exp.sub %>%
    dplyr::group_by(cluster) %>%
    dplyr::top_n(n = top.n.genes, wt = exp) %>%
    dplyr::select(c("genes", "cluster")) %>%
    group_by(cluster) %>%
    mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = cluster, values_from = genes) %>%
    select(-row)
  
  markers_of_interest <- as.data.frame(df.exp.all.top.wide)
}

```



```{r umap by cluster, warning = FALSE}

# get GGplot handle for cluster umap
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = "seurat_clusters", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Clusters") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

if (print.inline) plt.umap_by_cluster

```

```{r meta module , warning = FALSE}

# pool genesets if modular activity is query of interest ##########################

if(!exists("moi.df")) moi.df <- (markers_of_interest)
if (meta.module.flag == T){
  
  gNames <- gNames.list
  plt.clustermarkers_by_umap <- list()
  available_markers <- c()
  
  markers_of_interest <- names(moi.df)
  
  exp.mat.new <- NULL
  
  all.list <- list()
  for (i in 1:length(markers_of_interest)){
    
    # get meta module name
    cur.marker <- markers_of_interest[i]
    
    # clean dataset and include only those available in seurat object
    cur.features <- as.character(moi.df[,i][moi.df[,i] != ""])
    cur.features <- cleanFilterGenes(cur.features, so.query, which.species)
    
    if (length(cur.features) == 0) next
    
    # append module prefix and get module scores
    # if (prefix.label != ""){
    #   module.name <- paste(prefix.label, "-",cur.marker, sep = "")
    # } else {
      module.name <- cur.marker
    # }
    
    so.query.try = NA
    so.query.try <-  try(AddModuleScore(so.query,  
                                        features = list(cur.features),
                                        ctrl = 50,
                                        name = "new.module",
                                        nbin = 5), silent = T)
    
    if (is.na(so.query.try)) next
    
    
    # assign name to modlue score
    names(so.query.try@meta.data)[names(so.query.try@meta.data) %in% paste("new.module", 1, sep = "")] <- module.name
    so.query@meta.data[[module.name]] <- so.query.try@meta.data[[module.name]]
    
    # concat scores to dataframe
    cur.module.df <- as.data.frame(so.query@meta.data[[module.name]])
    colnames(cur.module.df) <- module.name
    exp.mat.new <- bind_cols(exp.mat.new, cur.module.df)
    
    available_markers[i] <- module.name
    all.list[[module.name]] <- cur.features
    
  }
  
  # get all scores and cast as matrix
  exp.mat.new.mat.t <- t(as.matrix(exp.mat.new))
  
  # concat scores to seurat objects
  exp.mat.1 <-so.query@assays[[DefaultAssay(so.query)]]@data
  colnames(exp.mat.new.mat.t) <- colnames(exp.mat.1)
  exp.mat.1 <- rbind(exp.mat.1, exp.mat.new.mat.t)
  so.query@assays[[DefaultAssay(so.query)]]@data <- exp.mat.1
  
  exp.mat.2 <-so.query@assays[[DefaultAssay(so.query)]]@scale.data
  colnames(exp.mat.new.mat.t) <- colnames(exp.mat.2)
  exp.mat.2 <- rbind(exp.mat.2, exp.mat.new.mat.t)
  so.query@assays[[DefaultAssay(so.query)]]@scale.data <- exp.mat.2
  markers_of_interest <- available_markers[!is.na(available_markers)]
  
}

if (exists("so.query.try")) rm("so.query.try")
```



```{r bin cells, warning = FALSE}

if (which.results$do.hex){
  
  n.cells <- ncol(so.query)
  cells.per.bin <- 30
  
  if (round(n.cells/cells.per.bin) > 100){
    nhexbins <- 100
  } else {
    round(n.cells/cells.per.bin)
  }
  so.query <- schex::make_hexbin(so.query, nbins = round(n.cells/cells.per.bin), 
                                 dimension_reduction = "UMAP")
}

```


```{r umap expression plots, message=FALSE, warning=FALSE}

# initialize variables
# plt.clustermarkers_by_umap <- list()
plt.umap.1 <- list()
plt.umap.2 <- list()
gNames <- gNames.list
available_markers <- c()

if (class(markers_of_interest) == "data.frame"){
  markers_of_interest <- as.vector(markers_of_interest[,1])
}


if (group.by == 1){
  u_groups <- as.character(as.numeric(u_groups)[order(as.numeric(u_groups))])
}
query_genes_by_group <- data.frame(u_groups)
input.marker.list <- markers_of_interest

# sort genes by group
for (i in 1:length(markers_of_interest)){
  query_genes_by_group[ ,ncol(query_genes_by_group)+1] <- rep(markers_of_interest[i], nrow(query_genes_by_group))
}

# plot top differentially expressed genes per cluster and compare to cluster membership
for (i in c(1:(length(markers_of_interest)))) {
  
  # empty list where plts will be stored
  all_plts <- list()
  
  # highlight cluster plot
  all_plts[[1]]  <- DimPlot(so.query, reduction = "umap", group.by = grouping_var, label = TRUE, repel = TRUE)  + 
    ggtitle(label = "UMAP") + xlab("UMAP 1") +  ylab("UMAP 2")
  
  # marker plot (try mouse and human formats)
  
  if (meta.module.flag){
    cur.marker <- markers_of_interest[i]
  } else {
    cur.marker <-  speciesConvert(markers_of_interest[i], rownames(so.query@assays[[DefaultAssay(so.query)]]@data), which.species)
  }
  
  markers_of_interest[i] <- cur.marker
  
  if (!is.na(cur.marker)){
    
    if ((which.results$do.hex)){
      all_plts[[length(all_plts)+1]] <- schex::plot_hexbin_feature(so.query, feature=cur.marker, 
                                                                   action="mean", xlab="UMAP1", ylab="UMAP2", 
                                                                   title=cur.marker,
                                                                   mod = DefaultAssay(so.query),
                                                                   type = "data")
    } else {
      all_plts[[length(all_plts)+1]] <- scExpression.UMAP(so.query, cur.marker)
    }
    
  }
  
  if (length(all_plts) == 2){
    
    current.ind <- length(plt.umap.1)+1
    plt.umap.1[[current.ind]] <- all_plts[[1]]
    plt.umap.2[[current.ind]] <- all_plts[[2]]
    available_markers[length(available_markers)+1] <- markers_of_interest[i]
    
    if (print.inline) print((CombinePlots(all_plts, ncol = length(all_plts), legend = 'none')))
  }
}

# remove NA entries
available_markers <- available_markers[!is.na(available_markers)]

# assign names marker names to each plot
names(plt.umap.1) <- names(plt.umap.2) <- available_markers


```


```{r DEG query genes, warning = FALSE}

# run DEG analysis
orig.ident <-  Idents(so.query) 
Idents(so.query) <- grouping_var
all.markers <- FindAllMarkers(object = so.query,  features = available_markers, 
                              logfc.threshold = 0, min.pct = 0, return.thresh = 1)
Idents(so.query) <- orig.ident

if (nrow(all.markers) > 0){
  all.markers[, c("p_val", "avg_logFC", "p_val_adj")] <- signif(all.markers[, c("p_val", "avg_logFC", "p_val_adj")], 3)
  
  # get top DEGS
  if (!is.na(which.results$umap.top.n)){
    all.markers.sig <- all.markers %>% dplyr::top_n(which.results$umap.top.n, -log1p(p_val))
  } else {
    all.markers.sig <- all.markers
  }
  
  u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)
  if (length(u.clust) == 2){
    all.markers.sig <- all.markers.sig[!duplicated(all.markers.sig$gene), ]
    all.markers <- all.markers[!duplicated(all.markers$gene), ]
  }
  
  if (print.inline) all.markers.sig
} else {
  all.markers.sig <- NULL
}


```

```{r UMAP deg genes, warning = FALSE}

if (!is.na(which.results$umap.top.n)){
  top.markers <- all.markers %>% top_n(which.results$umap.top.n, -log10(p_val))
  which.match <- available_markers %in% top.markers$gene
  plt.umap.1 <- plt.umap.1[which.match]
  plt.umap.2 <- plt.umap.2[which.match]
} 

```


```{r, warning = FALSE}

expression.Plot.dev <- function(so, which.gene, e.mat = NULL, f.mat = NULL, which.group = "seurat_clusters", which.data = "data"){
  
  # get expression data
  if (is.null(e.mat)){
    em <- getExpressionMatrix(
      so,
      only.variable = F,
      which.assay = NULL,
      which.data = which.data,
      use.additional.genes = NA
    )
  } else {
    em <- e.mat
  }
  
  # get fraction of expressing cells
  if (is.null(f.mat)){
    em.frac <- avgGroupExpression(
      so,
      which.data = "data",
      which.center = "fraction",
      which.group = which.group
    )
  } else {
    em.frac <- f.mat
  }
  
  # get meta data
  so.meta <- so@meta.data
  
  # ensure grouping variable exists
  if (!(which.group) %in% colnames(so.meta)) stop("Grouping variable does not exist.")
  
  # merge datasets
  if (sum(rownames(em) %in% (which.gene)) != 1) stop("More than one gene matched query. Cannot continue.")
  df.meta <- data.frame(id = rownames(so.meta), group = so.meta[,which.group])
  em.mark <- as.data.frame(em[(rownames(em)) %in% (which.gene), ])
  em.df <- data.frame(id = rownames(em.mark), query = em.mark[,1])
  em.merge <- merge(em.df, df.meta, by = "id")
  
  # get summary statistics (for clustering)
  em.sum <- em.merge %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(x.mean = mean(query, na.rm = T),
                     x.sd = sd(query, na.rm = T))
  em.frac.mark <- as.data.frame(em.frac[(rownames(em.frac)) %in% (which.gene), ])
  colnames(em.frac.mark) <- which.gene
  # em.frac.mark <- t(em.frac.mark %>% select(-c("genes")))
  em.frac.mark.df <- data.frame(group = rownames(em.frac.mark), frac = em.frac.mark[,1])
  
  if (which.group == "seurat_clusters") em.frac.mark.df$group <- gsub("c", "", em.frac.mark.df$group)
  em.sum <- merge(em.sum, em.frac.mark.df, by = "group")
  
  # hierarchial clustering
  row.names.df <- em.sum$group
  em.sum <- em.sum %>% dplyr::select(-c("group"))
  clust.var <- as.matrix(em.sum)
  rownames(clust.var) <- row.names.df
  d <- dist(as.matrix(clust.var))   # find distance matrix
  
  clust.success <- F
  try({
    hc <- hclust(d)                # apply hirarchical clustering
    clust.success <- T
  }, silent = T)
  
  if (clust.success){
    # helper function for creating dendograms
    ggdend.v2 <- function(df) {
      ggplot() +
        geom_segment(data = df, aes(x=x, y=y, xend=xend, yend=yend)) +
        ggdendro::theme_dendro()
    }
    
    # get dendromgram data from heat object
    d.query.clust <- ggdendro::dendro_data(hc)
    
    # ggplot dendograms
    p.query.clust <- ggdend.v2(d.query.clust$segments) +
      ggtitle(paste0(which.gene, " Expression")) +
      theme(axis.title.x=element_blank(),
            axis.text=element_blank(),
            axis.line=element_blank(),
            axis.ticks=element_blank(),
            legend.position = "none")
    
    # reorder data according to clusters
    em.merge$group <- factor(as.character(em.merge$group), levels = (d.query.clust[["labels"]][["label"]]))
    
    # violin plots
    plt.em <- em.merge %>%
      group_by(group) %>%
      ggplot(aes(x = group, y = query, fill = group)) +
      geom_violin() + theme_bw() +
      ylab("Expression") +
      xlab(which.group)  +
      theme(plot.margin = unit(c(0, 1, 0, 1), "cm"),
            legend.position = "none")
    
    # combine plots
    plt.sgExp <-  cowplot::plot_grid(p.query.clust, plt.em, ncol = 1, align = "v", rel_heights = c(1,2))
    
  } else {
    plt.sgExp <- em.merge %>%
      group_by(group) %>%
      ggplot(aes(x = group, y = query, fill = group)) +
      geom_violin() + theme_bw() +
      ylab("Expression") +
      xlab(which.group)  +
      theme(plot.margin = unit(c(0, 1, 0, 1), "cm"),
            legend.position = "none")
  }
  
  return(plt.sgExp)
  
}

```

```{r single cell expression, fig.width=10, fig.height=4, include = FALSE, warning = FALSE}


# clean up
try({ rm(exp.mat); rm(exp.mat.2); rm(exp.mat.complete) }, silent = T)

e.mat <- getExpressionMatrix(
  so.query,
  only.variable = F,
  which.data = "data",
  use.additional.genes = NA)

f.mat <- getExpressionMatrix(
  so.query,
  only.variable = F,
  which.data = "data",
  use.additional.genes = NA)

# plot clustered violin plot
plt.sgExp.all <- list()
for (i in 1:length(available_markers)){
  
  plt.sgExp.clust <- expression.Plot.dev(so = so.query, e.mat = e.mat, f.mat = f.mat, 
                                         which.gene = available_markers[i], which.group = "seurat_clusters", which.data = "data") + ylab(paste0(available_markers[i], " Expression")) + xlab("Cluster ID") + labs(title = "Violin Plots", subtitle = "Clusters")
  
  is.success <- F
  try({
    plt.sgExp.barcode <- expression.Plot.dev(so = so.query, e.mat = e.mat, f.mat = f.mat, 
                                             which.gene = available_markers[i], which.group = "Barcode", which.data = "data") +  ylab(paste0(available_markers[i], " Expression"))  + xlab("Sample ID") + labs(title = "", subtitle = "Samples")
    is.success <- T
  })
  
  if (is.success){
    plt.sgExp <- grid.arrange(grobs = list(plt.sgExp.clust, plt.sgExp.barcode), ncol = 2)
  } else {
    plt.sgExp <-plt.sgExp.clust
  }
  
  plt.sgExp.all[[available_markers[i]]] <- plt.sgExp
  
  if (print.inline){
    print(plt.sgExp.all[[available_markers[i]]])
  }
}
```




```{r symbol2entrez, warning = FALSE}

# get symbol to entrez mapping
my.symbol <- as.vector(rownames(so.query@assays[[current.assay]]@scale.data))
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

```



```{r get correlations, message=FALSE, warning=FALSE}

which.data <- "data"

# entire matrix
exp.mat.complete <- getExpressionMatrix(so.query, which.data = which.data)

# variable gene only matrix
use.var <- T

n.var <- 3000 # specify number of variable genes
if (use.var){
  # scale down number of variable features
        df.meta <- so.query@assays[[current.assay]]@meta.features
  df.meta$genes <- rownames(df.meta)
  
  if (current.assay == "SCT"){
    df.meta <- df.meta[order(-df.meta$sct.residual_variance), ]
    top.var <- df.meta$genes[1:n.var]
    so.query@assays[[current.assay]]@var.features <- top.var
  } else if (current.assay == "RNA"){
    df.meta <- df.meta[order(-df.meta$vst.variance.standardized), ]
    top.var <- df.meta$genes[1:n.var]
    so.query@assays[[current.assay]]@var.features <- top.var
  }

  exp.mat <- getExpressionMatrix(so.query, only.variable = use.var, which.data = which.data)
} else {
  exp.mat <- exp.mat.complete
}

# ensure no negative values (necessary condition for proportionality association metrics)
if (min(exp.mat.complete) < 0) {
  exp.mat <- exp.mat + abs(min(exp.mat.complete))
  exp.mat.complete <- exp.mat.complete + abs(min(exp.mat.complete))
}

df.cor.list <- NULL

query.cor.list <- list()

  if (use.var){
    which.missing <- available_markers[!(available_markers %in% rownames(exp.mat) )]
    for (i in 1:length(which.missing)){
      exp.missing <- exp.mat.complete[rownames(exp.mat.complete) %in% which.missing[i], ]
      exp.mat <- rbind(exp.mat, exp.missing)
      rownames(exp.mat)[rownames(exp.mat) %in% "exp.missing"] <- which.missing[i]
    }
  }
  
  cor.method <- "rho_p" # rho_p, spearman, pearson
  t.exp.mat <- t(exp.mat)
  if (cor.method == "rho_p"){
    query.cor.object <-  propr::perb(t.exp.mat, select = colnames(t.exp.mat))
    query.cor.mat <- query.cor.object@matrix
  } else {
    query.cor.mat <-  dismay::dismay(t.exp.mat, metric = cor.method)
  }
  
  query.cor.mat.all <- query.cor.mat[!(rownames(query.cor.mat) %in% available_markers),colnames(query.cor.mat) %in% available_markers]
  
  # assign results
  df.cor.list <- as.data.frame(query.cor.mat.all)
  if (ncol(df.cor.list) == 1) {
    
    df.cor.list$genes<-  rownames(query.cor.mat)[!(rownames(query.cor.mat) %in% available_markers)]
    colnames(df.cor.list)[1] <- available_markers[1]
  } else {
    df.cor.list$genes <- rownames(df.cor.list)
  }
  
  df.cor.list <- df.cor.list[ ,c("genes", available_markers)]
  


```

```{r prep ranking lists, warning = FALSE}

# Rank by LFC if DEG
if (which.input$query_input_format == 3){
  deg.gene.enrich <- deg.gene[ ,c("cluster", "avg_logFC", "gene")]
  colnames(deg.gene.enrich) <- c("cluster", "avg_logFC", "genes")
  deg.gene.enrich$cluster <- paste("c", deg.gene.enrich$cluster , sep = "")
  deg.gene.enrich.wide <- pivot_wider(deg.gene.enrich, names_from = cluster, values_from = avg_logFC)
  
  df2enrich <- as.data.frame(deg.gene.enrich.wide)
  
  # Rank by Correlations if query genes
} else if (which.input$query_input_format == 4){
  
  exp.gene.enrich.wide <- pivot_wider(df.avg.exp.sub, names_from = cluster, values_from = exp)
  df2enrich <- as.data.frame(exp.gene.enrich.wide)
  
} else if (!is.null(df.cor.list)) {
  
  # query has r = 1 with itself; set to next top cor value (+1e-3) to ensure query does not dominate rankings
  df.cor.list.genes <- df.cor.list$genes
  df.cor.list.cor <- df.cor.list %>% dplyr::select(-c("genes"))
  mat.cor.list.cor <- as.matrix(df.cor.list.cor)
  filter.cor <- 0.9999999999
  for (i in 1:ncol(mat.cor.list.cor)){
    mat.cor.list.cor[mat.cor.list.cor[,i] > filter.cor, i] <- max(mat.cor.list.cor[mat.cor.list.cor[,i] < filter.cor, i], na.rm = T) + 1e-3
  }
  
  mat.cor.list.cor <- signif(mat.cor.list.cor, 4)
  df.cor.list <- bind_cols(data.frame(genes = df.cor.list.genes), as.data.frame(mat.cor.list.cor))
  
  df2enrich <- as.data.frame(df.cor.list)
} else {
  df2enrich <- NULL
}

# ensure no duplicate exist
if (!is.null(df2enrich)){
  df2enrich <- df2enrich[!duplicated(df2enrich$genes), ]
  enrich.groups <- colnames(df2enrich)
  enrich.groups <- enrich.groups[enrich.groups != "genes"]
  }

```

```{r get pathays, warning = FALSE}

# all.genes <-df2enrich$genes
all.genes <- rownames(so.query)

match.ind <- match(all.genes, my.entrez$SYMBOL)
all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind]) 

pathways.subset <- getAnnotationPathways(all.genes.entrez, db = which.annotation.db, ontology = "BP", species = default.species)

```


```{r gsea enrichment, warning = FALSE}

# get pathways relevant to current gene set
gse.pathway.combined <- NULL
gse.pathway.list <- list()

single.path.of.interest <- NULL

plt.enrichment <- list()

# specify analysis parameters
if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

# start cluster
if (n.workers$gsea > length(enrich.groups)) n.workers$gsea <- length(enrich.groups)
cl <- parallel::makeCluster(n.workers$gsea)
doParallel::registerDoParallel(cl)

score.results <- foreach(i = 1:length(enrich.groups), .packages = c("fgsea", "plyr"))  %dopar% {
  
  # for (i in 1:length(enrich.groups)){
  
  gene.list <- (df2enrich[, enrich.groups[i]])
  names(gene.list) <- df2enrich$genes
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  
  suppressMessages({gse.pathway <- fgsea(pathways.subset, gene.list.clean, nperm=1000, maxSize=500) })
  
  if (nrow(gse.pathway) == 0) {
    return(list(out1 = NULL,
                out2 = NULL))
  } else {
    
    gse.pathway$query <- enrich.groups[i]
    # gse.pathway.combined <- bind_rows(gse.pathway.combined, gse.pathway)
    
    if(which.results$gsea.threshold == 1){
      gse.pathway.filtered <- gse.pathway[gse.pathway$padj < 0.1, ]
    } else if (which.results$gsea.threshold == 2){
      gse.pathway.filtered <- gse.pathway[((gse.pathway$pval < 0.01) & (abs(gse.pathway$NES) > 1)), ]
    } else if (which.results$gsea.threshold == 3){
      gse.pathway.filtered <- gse.pathway %>% top_n(3, NES)
    }
    
    # if (nrow(gse.pathway.filtered) == 0) next
    
    # make human readable (map entrez to symbol)
    gse.pathway.filtered.orig <- gse.pathway.filtered
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$leadingEdge, 
                                       mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$set, paste,collapse = ", ")
    gse.pathway.filtered$query <- enrich.groups[i]
    
    
    # sig figs for numerics
    gse.pathway.filtered$ES <- signif(gse.pathway.filtered$ES, 3)
    gse.pathway.filtered$NES <- signif(gse.pathway.filtered$NES, 3)
    gse.pathway.filtered$pval <- signif(gse.pathway.filtered$pval, 3)
    gse.pathway.filtered$padj <- signif(gse.pathway.filtered$padj, 3)
    
    # filter and rearrange columns
    gse.pathway.cur <- gse.pathway.filtered[ ,c("query", "pathway", "size", "ES", "NES", "pval", "padj", "set")]
    
    # store results
    # gse.pathway.list[[enrich.groups[i]]] <- gse.pathway.all
    
    return(list(out1 = gse.pathway.cur,
                out2 = gse.pathway))
  }
  
} 

# stop workers
parallel::stopCluster(cl)

stopifnot(length(enrich.groups) == length(score.results))

for (i in 1:length(enrich.groups)){
  gse.pathway.list[[enrich.groups[i]]] <- score.results[[i]]$out1
  gse.pathway.combined <- bind_rows(gse.pathway.combined, score.results[[i]]$out2)
}

  # gse.pathway.combined <- bind_rows(gse.pathway.combined, gse.pathway)
  
```

```{r gsea barplot, warning = FALSE}


plt.top.gsea <- list()
for (i in 1:length(available_markers)){
  
 current.paths <- gse.pathway.list[[available_markers[i]]]
 current.paths <- bind_rows(current.paths %>% dplyr::top_n(which.results$gsea.top.n , NES) %>% dplyr::arrange(-NES), 
                            current.paths %>% dplyr::top_n(which.results$gsea.top.n , -NES) %>% dplyr::arrange(NES))
 
 plt.top.gsea[[available_markers[i]]] <- current.paths %>%
   ggplot(aes(x = reorder(pathway, NES), y = NES, size = -log10(pval), fill = -log10(pval))) + 
   geom_point(pch = 21) + 
   coord_flip() + 
   xlab("Pathways") + ylab("NES") + 
   labs(title = "GSEA", subtitle = paste0(available_markers[i], " corr. ranking")) + 
   geom_hline(yintercept = 0, linetype = "dashed") + 
   viridis::scale_fill_viridis(option = "B")
 
 if (print.inline){
   plt.top.gsea[[available_markers[i]]]
 }
}

```


```{r common enrichments, warning = FALSE}

# summarize enrichments
  gse.pathway.combined.label <- gse.pathway.combined
  
  if (!is.null(gse.pathway.combined.label)){
    
    which.enrich <- gse.pathway.combined.label$NES > 0
    which.enrich[is.na(which.enrich)] <- FALSE
    which.deplete <- gse.pathway.combined.label$NES < 0
    which.deplete[is.na(which.deplete)] <- FALSE
    gse.pathway.combined.label$pathway[which.enrich] <- paste("Enriched-", gse.pathway.combined.label$pathway[which.enrich], sep = "")
    gse.pathway.combined.label$pathway[which.deplete] <- paste("Depleted-", gse.pathway.combined.label$pathway[which.deplete], sep = "")
    
    gse.pathway.combined.tally <- gse.pathway.combined.label %>%
      dplyr::filter(pval < 0.01, abs(NES) > 1) %>%
      dplyr::group_by(pathway) %>%
      summarise(queries = list(query))
    
    gse.pathway.combined.tally$n <- lapply(gse.pathway.combined.tally$queries, length)
    gse.pathway.combined.tally$n <- as.numeric(gse.pathway.combined.tally$n)
    gse.pathway.combined.tally$set <- lapply(gse.pathway.combined.tally$queries, paste,collapse = ", ")
    gse.pathway.combined.tally <- gse.pathway.combined.tally %>%
      dplyr::select(-c("queries")) %>%
      dplyr::arrange(n)
    
  } else {
    gse.pathway.combined.tally <- NULL
  }


```

```{r cormat heatmap, warning = FALSE}


if (exists("df.cor.list")) {
  
  df.cor.list.mat <- df.cor.list
  df.cor.list.mat <- df.cor.list.mat[!duplicated(df.cor.list.mat$genes), ]
  rownames(df.cor.list.mat) <- df.cor.list.mat$genes
  df.cor.list.mat <- dplyr::select(df.cor.list.mat, -c("genes"))
  cor.mat <- as.matrix(df.cor.list.mat)
  
  
  top.n.cor <- which.results$cor.top.n
  n.per.query <- ceiling(0.5*top.n.cor/ncol(cor.mat))
  
  filter.cor <- T
  if (filter.cor){
    
    cor.mat.df <- as.data.frame(cor.mat)
    top.cor <- unique(as.vector(unlist(apply(cor.mat.df, 2, function(x) {
      c(rownames(cor.mat)[order(-x)][1:n.per.query], rownames(cor.mat)[order(x)][1:n.per.query])
    }))))
    cor.mat.sub <- cor.mat[rownames(cor.mat) %in% top.cor, ]
    
    if (class(cor.mat.sub) == "numeric"){
      names(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor]
    } else {
      rownames(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor] 
    }
    
  } else {
    cor.mat.sub <- cor.mat
  }
}


```


```{r gene.expression tables, warning = FALSE}

data.all <- as.data.frame(so.query@assays[[DefaultAssay(so.query)]]@data)
data.rownames <- rownames(data.all)
match.ind <- data.rownames %in% available_markers
data.subset <- as.data.frame(t(data.all[match.ind, ]))

groups.of.interest <- list(cluster = "seurat_clusters",
                           batch = "batch",
                           barcode = "Barcode",
                           stratify.group = "stratify.group")

df.expression.list <- list()
for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    data.subset[ ,names(groups.of.interest)[i]] <- so.query@meta.data[[groups.of.interest[[i]]]]
  }
}

if ((grouping_var != "seurat_clusters") &  (grouping_var %in%  names(so.query@meta.data))){
  data.subset[ ,grouping_var] <- so.query@meta.data[[grouping_var]]
}
available_markers <-available_markers[available_markers %in% colnames(data.subset)]

data.subset.long <- gather(data.subset, gene, expression, available_markers)

for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    df.expression.list[[names(groups.of.interest)[i]]] <- data.subset.long %>%
      group_by(gene, get(names(groups.of.interest)[i])) %>%
      summarize(mean.exp = signif(mean(expression),3), 
                median.exp = signif(median(expression),3),
                sd.exp = signif(sd(expression),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    colnames( df.expression.list[[names(groups.of.interest)[i]]])[2] <- names(groups.of.interest)[i]
    
    if (print.inline) datatable(df.expression.list[[names(groups.of.interest)[i]]], filter = "top")
  }
}   

if (all(c("seurat_clusters", "batch") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x batch"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, batch) %>%
    summarize(mean.exp = signif(mean(expression),3), 
              median.exp = signif(median(expression),3),
              sd.exp = signif(sd(expression),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (all(c("seurat_clusters", "stratify.group") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x stratify.group"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, stratify.group) %>%
    summarize(mean.exp = signif(mean(expression),3), 
              median.exp = signif(median(expression),3),
              sd.exp = signif(sd(expression),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (grouping_var != "seurat_clusters"){
  
  if (all(grouping_var %in%  names(so.query@meta.data))){
    cur.entry <- grouping_var
    df.expression.list[[cur.entry]] <- data.subset.long %>%
      group_by(gene, get(cur.entry)) %>%
      summarize(mean.exp = signif(mean(expression),3), 
                median.exp = signif(median(expression),3),
                sd.exp = signif(sd(expression),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
  }
  
}


```


```{r create cor heatmap, include= F}

# fitered correlation matrix
  if (class(cor.mat.sub) == "matrix") {
    plt.heat <- ggplotify::as.ggplot(pheatmap::pheatmap(cor.mat.sub, 
                                                        main = "Query x Gene Correlations\nx=query, y=genes, z=correlation"))
  } else {
    plt.heat <- NULL
  }
  
```

```{r ranked correlations, fig.height=13, fig.width=10, include = FALSE}


# if (length(markers_of_interest) == 1){

  if (cor.method == "rho_p") {
    fill.label <- "Proportionality Metric"
  } else if (cor.method == "spearman") {
    fill.label <- "Spearman R"
  } else if (cor.method == "pearson") {
    fill.label <- "Pearson R"
  }

cor.list <- list()
for (i in 1:length(available_markers)){
  
  # all correlations
  df.cor.all <-  data.frame(genes = rownames(cor.mat), r = as.vector(cor.mat[ ,colnames(cor.mat) %in% available_markers[i]]))
  colnames(df.cor.all) <- c("genes", "r")
  df.cor.all <-  df.cor.all[df.cor.all$genes != available_markers[i], ]
  
    plt.cor.dist <- df.cor.all %>%
    ggplot(aes(x = r)) +
    geom_density(fill = "grey") + 
    ylab("Density") + 
    xlab(fill.label) + 
    theme_classic() + 
      geom_vline(xintercept = 0, linetype = "dashed") + 
    labs(title = paste0(available_markers[i], " Correlations"), subtitle = "all variable genes") + 
    theme(axis.text.y = element_blank())
  
  # top corr
    if (class(cor.mat.sub) == "numeric"){
  df.cor.sub <-  data.frame(genes = names(cor.mat.sub), 
                            r = cor.mat.sub)
    } else {
  df.cor.sub <-  data.frame(genes = names((cor.mat.sub[ ,colnames(cor.mat.sub) %in% available_markers[i]])), 
                            r = (cor.mat.sub[ ,colnames(cor.mat.sub) %in% available_markers[i]]))      
    }

  colnames(df.cor.sub) <- c("genes", "r")
  df.cor.sub <-  df.cor.sub[!(df.cor.sub$genes %in%  available_markers[i]), ]
  
  plt.ranked.cor.sub <- df.cor.sub %>%
    ggplot(aes(x = reorder(genes, r), y = r)) +
    geom_bar(stat = "identity") + 
    coord_flip() + 
    xlab("Genes") + 
    ylab(fill.label) + 
    theme_classic() + 
    labs( subtitle = "Top Correlations") 
  
  cor.list[[available_markers[i]]] <-  cowplot::plot_grid(plt.cor.dist, plt.ranked.cor.sub, ncol = 1, rel_heights = c(1,2.5), align = "hv")
  
  if (print.inline){
    print( cor.list[[available_markers[i]]])
  }
  # }
}

```


```{r combine expression plots, fig.height=12, fig.width=20, include = FALSE}

dash.list <- list()


for (i in 1:length(available_markers)){
  
  check.1 <- available_markers[i] %in% names(plt.umap.1)
  check.2 <- available_markers[i] %in% names(plt.umap.2)
  check.3 <- available_markers[i] %in% names(plt.sgExp.all)
  check.4 <- available_markers[i] %in% all.markers$gene
  check.5 <- available_markers[i] %in% names(cor.list)
  
  if (!(check.1 & check.2 & check.3 & check.4 & check.5)) next
  top.lq <- cowplot::plot_grid(
    plt.umap.1[[available_markers[i]]] + theme_miko(legend = F) + labs(title = "UMAP", subtitle = "Clusters"), 
    plt.umap.2[[available_markers[i]]]+ theme_miko(legend = F) + labs(title = "", subtitle = paste0(available_markers[i], " Expression")),
    ncol = 2
    )
  
  low.lq <- plt.sgExp.all[[i]]
  
  deg.current <- all.markers[all.markers$gene %in% available_markers[i], ] %>% top_n(5, p_val) %>% arrange(p_val)
  rownames(deg.current) <- NULL
  tab1 <-  gridExtra::tableGrob(deg.current)
  
  exp.current <- df.expression.list[["cluster"]][df.expression.list[["cluster"]]$gene %in% available_markers[i], ] %>% top_n(5, pct.exp) %>% arrange(-pct.exp)
  df.expression.list[["cluster"]]
  rownames(exp.current) <- NULL
  tab2 <- gridExtra::tableGrob(exp.current) 

  lq <- grid.arrange(grobs = list(top.lq, low.lq, tab2, tab1), ncol = 1, heights = c(2,1.5,1.25, 1.25))
  mq <- grid.arrange(grobs = list(lq,  
                                  cor.list[[available_markers[i]]], 
                                  plt.top.gsea[[available_markers[i]]] + 
                                    scale_x_discrete(label = function(x) stringr::str_trunc(x, 40)) + theme_miko(legend = T)), 
                     ncol = 3, widths = c(3,2, 3))

  dash.list[[available_markers[i]]] <- mq
  

}




```

```{r cluster-wise expression data}

# get expression data
cluster.membership <- so.query@meta.data[[grouping_var]]
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]

# aggregate expression matrix
exp.mat.scale <- exp.mat
gene.scale.name <- rownames(exp.mat.scale)
cell.scale.name <- colnames(exp.mat.scale)

# percetnage expressed (observed)
per.dot.score <- DotPlot(so.query, features = available_markers, group.by = grouping_var)[["data"]]
per.dot.score$genes <- per.dot.score$features.plot
per.dot.score$id <- as.numeric(as.character( per.dot.score$id))
per.dot.score.sub <- per.dot.score[ ,c("id", "avg.exp.scaled", "genes")]
colnames(per.dot.score.sub) <- c("cluster", "expression", "genes")
per.dot.score.wide <- pivot_wider(per.dot.score.sub, names_from = "cluster", values_from = "expression")
gene.names.row <- per.dot.score.wide$genes
per.dot.score.wide <- dplyr::select(per.dot.score.wide, -c("genes"))
per.dot.score.wide <- per.dot.score.wide[ ,as.character(u.clusters)]
rownames(per.dot.score.wide) <- gene.names.row

# cast expression data as matrix
exp.mat.scale.processed <- as.matrix(per.dot.score.wide)
exp.mat.av <- exp.mat.scale.processed[rownames(exp.mat.scale.processed) %in% available_markers, ]

if (!is.null(dim(exp.mat.av))) exp.mat.av <- exp.mat.av[complete.cases(exp.mat.av), ]

```


```{r create exp heatmap object , include= F}

clust.success <- F
if (class(exp.mat.av) == "matrix") {
  try({
    heat.object.expression.cluster <- getHeat(exp.mat.av)
    mat.reconstruct.av <- exp.mat.av[heat.object.expression.cluster[["rowInd"]], heat.object.expression.cluster[["colInd"]]]
    gene.order.av <- rownames(mat.reconstruct.av)
    cluster.order.av <- colnames(mat.reconstruct.av)
    plt.heat.availableGenes <- ggplotify::as.ggplot(pheatmap::pheatmap(exp.mat.av))
    clust.success <- T
  }, silent = T)
  
} else {
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  plt.heat.availableGenes <- NULL
}

if (!clust.success){
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  if (!exists("plt.heat.availableGenes")) plt.heat.availableGenes <- NULL  
}

```


```{r get dot size helper function}

get.dot.size <- function(gene.list){
  n.genes <- length(gene.list)
  if (n.genes < 11) xlab.size <- 15
  if (n.genes > 10) xlab.size <- 12
  if (n.genes > 40) xlab.size <- 10
  if (n.genes > 50) xlab.size <- 9
  return(xlab.size)
}

```



```{r create dot plots, fig.width = 8, fig.height = 10}

# dot plot

# order clusters according to hierarchial clustering
if (exists("cluster.order.av")){
  so.query@meta.data[[grouping_var]] <- factor(so.query@meta.data[[grouping_var]], 
                                               levels=cluster.order.av)
}

plt.dot.list <- list()

  if (!(exists("gene.order.av"))) gene.order.av <- available_markers
  
  # scale label sizes accordingly
  xlab.size <- get.dot.size(gene.order.av)
  
  # create dotplo
  plt.dot.list[["Dot.All"]] <-  DotPlot(so.query, features = factor(gene.order.av, levels = gene.order.av), 
                                        group.by = grouping_var, 
                                        dot.scale = 8,
                                        cols="RdBu" ) + 
    RotatedAxis() + ylab(group_name) +
    theme(axis.text.x=element_text(size=xlab.size, angle = 75)) + ggtitle("All Query Genes")
  if (print.inline) print( plt.dot.list[["Dot.All"]])
  
  
  # create dotplot
  try({
    
    
    if (!is.null(all.markers.sig)){
      
      gene.order.av.deg <- unique(gene.order.av[gene.order.av %in% all.markers.sig$gene])
      
      if (length(gene.order.av.deg) > 0){
        
        # if (length(gene.order.av.deg) == 1) gene.order.av.deg <- c(gene.order.av.deg, gene.order.av.deg)
        xlab.size <- get.dot.size(gene.order.av.deg)
        plt.dot.list[["Dot.DEG"]] <-  DotPlot(so.query, features = factor(gene.order.av.deg, levels = gene.order.av.deg), 
                                              group.by = grouping_var, 
                                              dot.scale = 8,
                                              cols="RdBu" ) + 
          RotatedAxis() + ylab(group_name) +
          theme(axis.text.x=element_text(size=xlab.size, angle = 75)) + ggtitle("Top Genes")
        if (print.inline) print( plt.dot.list[["Dot.DEG"]])
      }
    }
  }, silent = T)
  

```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M09", input.data = query.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M09_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


1) cluster UMAP
===================================== 

```{r plt.umap_by_c}
print(plt.umap_by_cluster) 
savePDF(file.name = paste0(output.path, "PDF/", "M09_umap_cluster.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```

2) Expression
===================================== 

Row {.tabset}
-------------------------------------

```{r dot plot}

out1.1 <-NULL

try({
    out1.1 <- lapply(seq_along(plt.dot.list), function(i) {
      
      s1 <- paste("plt.dot.list[[", i, "]]", sep = "")
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.dot.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,  fig.width = 10, fig.height = 10}", paste(i, "plotly.dot.plt"))) 
      a3 <- knitr::knit_expand(text = sprintf("\n %s", s1))
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })
    
}, silent = T)

```
`r paste(knitr::knit(text = paste(out1.1, collapse = '\n')))`

```{r pdf dotplots,include = FALSE}

for (i in 1:length(plt.dot.list)){
  plot.name <- paste0("M09_expression_dotplot_", names(plt.dot.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.dot.list[[i]], 
          fig.width = 10, fig.height = 10, save.flag = save.pdf)
}

```

### Expression Heatmap

```{r}

if (!is.null(plt.heat.availableGenes)) {
  
  print(plt.heat.availableGenes)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_heatmap.pdf"), plot.handle = plt.heat.availableGenes, 
          fig.width = 5, fig.height = 5, save.flag = save.pdf)
  
}



```

```{r scExpression plot v1, fig.width=10, fig.height=4}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 2){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
      savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 10, fig.height = 4, save.flag = save.pdf)
  }
}

```

```{r scExpression plot v2}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 1){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
          savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 5, fig.height =5, save.flag = save.pdf)
  }
}

```

3) Results
===================================== 

Row {.tabset}
-------------------------------------

```{r dash}


try({

    out <- lapply(seq_along(dash.list), function(i) {
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(dash.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=20, fig.height=12}", paste(i, "dash"))) # start r chunk
      a3 <- knitr::knit_expand(text = sprintf("\nplot(dash.list[[%d]])", i)) 
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })

}, silent = T)


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pdf dash,include = FALSE}

for (i in 1:length(dash.list)){
  plot.name <- paste0("M09_summary_", names(dash.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plot(dash.list[[i]]), 
          fig.width = 20, fig.height = 12, save.flag = save.pdf)
}

```



4) Correlations
===================================== 

Row {.tabset}
-------------------------------------



### Correlation Table (top)

```{r correlation table - top}


  if (class(cor.mat.sub) == "matrix"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% rownames(cor.mat.sub), ]
  } else if  (class(cor.mat.sub) == "numeric"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% names(cor.mat.sub), ]
  }

write.csv(cor.mat, file = paste0(output.path, "Tables/", "correlations.csv"), 
          row.names = T) 
  
  flex.asDT(df.cor.list.sub)




```


### Query Correlations (top)

```{r query correlation heatmap - top, fig.width=10, fig.height=13}

try({
  if (length(markers_of_interest) == 1){
    
    plt.dis.rank.cor <- cowplot::plot_grid(cowplot::plot_grid(plt.cor.dist, NULL, rel_heights = c(1,2), ncol = 1), plt.ranked.cor.sub, ncol = 2)
    
    savePDF(file.name = paste0(output.path, "PDF/", "M09_ranked_correlations.pdf"), 
            plot.handle = plt.dis.rank.cor, 
            fig.width = 10, fig.height =13, save.flag = save.pdf)
    
    print(plt.dis.rank.cor)
  } else {
        savePDF(file.name = paste0(output.path, "PDF/", "M09_correlation_heatmap.pdf"), 
            plot.handle = plt.heat, 
            fig.width = 10, fig.height =13, save.flag = save.pdf)
    
    plt.heat
  }
}, silent = T)

```

5) GSEA 
===================================== 

Row {.tabset}
-------------------------------------

### Common Enrichments

```{r common enrich table }

if (exists("gse.pathway.combined.tally")){
  if (!is.null(gse.pathway.combined.tally)){
    gse.pathway.tally.output <- as.data.frame(gse.pathway.combined.tally)
    
    gse.pathway.tally.output$set <- vapply(gse.pathway.tally.output$set, paste, collapse = ", ", character(1L))
    write.csv(gse.pathway.tally.output, file = paste0(output.path, "Tables/", "gsea_pathway_tally.csv"), 
          row.names = F) 
    
    flex.asDT(gse.pathway.combined.tally)
  }
}

```


```{r gsea cor mat,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# create enrihcment list
if (exists("gse.pathway.list")){
  out_enrich_table <- flex.multiTabTables(gse.pathway.list, "gse.pathway.list")
} else {
  out_enrich_table <- NULL
}

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`


```{r save gsea statistics csv}

for (i in 1:length(gse.pathway.list)){
  table.name <- paste0(output.path, "Tables/", "gsea_statistics_", names(gse.pathway.list)[i] , ".csv")
  current.output <- gse.pathway.list[[i]]
  current.output$set <- vapply(current.output$set, paste, collapse = ", ", character(1L))
      write.csv(current.output, file = table.name, 
          row.names = F) 
}
```


6) Expression Table(s)
===================================== 

Row {.tabset}
-------------------------------------

```{r res4, echo = FALSE, eval = TRUE, message=TRUE, warning=FALSE}
out <- flex.multiTabTables(df.expression.list, "df.expression.list")
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save expression csv}

for (i in 1:length(df.expression.list)){
  table.name <- paste0(output.path, "Tables/", "expression_", names(df.expression.list)[i] , ".csv")
      write.csv(df.expression.list[[i]], file = table.name, row.names = F) 
}
```

7) DEG
===================================== 

### DEG Query Genes

```{r DEG query }
write.csv(all.markers, file = paste0(output.path, "Tables/", "differential_expression_analysis.csv"), row.names = F) 
flex.asDT(all.markers)
```

8) Marker List
===================================== 

### Marker List

```{r}

write.csv(moi.df, file = paste0(output.path, "Tables/", "query_list.csv"), row.names = F) 
flex.asDT(moi.df)
```

```{r save results}

# Update analysis log
df.log <- addLogEntry("Correlation Metric", cor.method, df.log, "cor.method")
df.log <- addLogEntry("Query Markers", markers_of_interest, df.log, "markers_of_interest")
df.log <- addLogEntry("Seurat Assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")
if (exists("exp.mat")) df.log <- addLogEntry("N genes for correlation", nrow(cor.mat), df.log, "nrow(cor.mat)")
if (exists("genes.not.found")) df.log <- addLogEntry("Genes not found", genes.not.found, df.log, "genes.not.found")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_9 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}
out1 <- flex.multiTabLogs(module.logs)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 9)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_9)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_9, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}


```
