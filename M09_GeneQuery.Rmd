---
title: "Gene Query Analysis"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---

```{r Module Description}

################################################################################
# Given a gene or gene panel query, M09 will evaluate the pattern of expression, and determine whether it is deferentially-expressed between clusters. Moreover, query correlations are computed and genes subsequently ranked by correlation prior to running GSEA to generate
# 1) Expression
# 2) Differential expression
# 3) Correlations
# 4) Associated pathways (via GSEA)
################################################################################

```


```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", 
                   "DT", "flexdashboard", "ggpmisc", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db",
                   "schex", "RColorBrewer", "cowplot", "viridis", "viridisLite")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```


```{r parameter specification}



# QUERY SPECIFICATION
which.input <- list(
  
  # gene list input format options:
  #   0: Manual input; vector of genes (e.g., which.gene.set = c("cd70", "cd34"))
  #   1: M09_type1_queries.csv; gene.sets.type1 
  #   2: M09_type2_queries.csv; gene.sets.type2; .csv file
  #   3: cluster DEG
  #   4: top N cluster markers
  #   5: M09_type5_queries.csv; GO/Reactome genesets
  #   6: scMiko internal geneset
  query_input_format = 1,
  do.module = NA, #options: T, F, NA; if NA, takes default, otherwise overides. 
  
  # specify gene set (only if query_input_format == 1 | 2 | 5 | 6)
  which.gene.set =c('GBM_HH_261120') # character (e.g., sex.specific)
)

# GBM.invitro.fig1
# neftel.modules
# coreCTL.grouped

# CT2A.invitro.fig1	GL261.invitro.fig1
# GBM.invitro.fig1
#############################

# ANALYSIS SPECIFICATION
which.results <- data.frame(
  umap.top.n = NA,       # plot top n markers (by DEG analysis). NA if all. 
  cor.top.n = 70,
  gsea.top.n = 20,
  gsea.threshold = 2 ,     # 1: padj < 0.1; 2: p<0.01 & |NES| > 1; 3: top 3 pathways (sorted by NES)
  annotation.db = "Bader",    # Reactome, GO, Bader
  ontology = c("BP"),         # "BP", "MF", "CC"
  do.hex = F               # specify whether to generate hex UMAPs (schex package)
)

############################

# CORRELATION SETTINGS
  cor.method <- "spearman" # rho_p, spearman, pearson
correlation.settings <- list(
  which.data = "data",                     # ONLY USE 'DATA'. which data used as input for correlations; options: 'data' or 'scale'
  check.existing = T,                        # check if correlation matrix was precomputed (M27)
  recompute.existing.if.query.missing = T   # if pre-computed corr matrix exists, but query is missing, recompute?
)

############################
# Miscillaneus settings

# cluster resolution
cluster.resolution <- 1

# specify subgroup provided in M00_subgroups.csv; subgroup <- "no.subgroup" to include all data
subset.df <- "no.subset"
# subset.df <- data.frame(field = "Barcode", subgroups = "C68")

which.species <- "Hs" # Option: Mm or Hs

# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "R111_M27_NM2_M02_p467891011_tumorImmune_tier1_150920.Rdata"
# input.file <- "Module1_p9_GBM_PR_noFilter_270620.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "R111_M27_NM2_M02_p467891011_tumorImmune_tier1_150920.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "R4_M02_BC2_M02_p467891011_Mm_allGBM_010920.Rdata"
# input.file <- "Module1_p7_mesoderm_110620.Rdata"
# input.file <- "Module1_m27_p7_mesoderm_070420.Rdata"
# input.file <- "Module1_p7_mesoderm_update_170620.Rdata"
# input.file <- "R4_M02_BC2_M02_p467891011_Mm_allGBM_010920.Rdata"
# input.file <- "R6_M02_BC2_allGBM_271020.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file <- "R291_M01_NM2_Rambow_Melanoma_221120.Rdata"
# input.file <- "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata"
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
input.file <- "Module1_p9_GBM_PR_noFilter_270620.Rdata"

# print figures inline
print.inline <- F

# n workers
n.workers <- list(
  gsea = 12
)


clean.clusters <- F
# save PDF
save.pdf <- T

# downsample factor
subsample_factor <- 1


```

```{r import appropriate csv files}

if (which.input$query_input_format==1){
  gene.sets.type1 <- read.csv("M09_type1_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type1) <- rmvCSVprefix(colnames(gene.sets.type1))
} else if (which.input$query_input_format==2){
  gene.sets.type2.df <- read.csv("M09_type2_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type2.df) <- rmvCSVprefix(colnames(gene.sets.type2.df))
  gene.sets.type2 <- list()
  for (i in 1:nrow(gene.sets.type2.df)){
    gene.sets.type2[[gene.sets.type2.df$name[i]]] <- list(file = gene.sets.type2.df$file[i],
                                           directory = gene.sets.type2.df$directory[i],
                                           # prefix.label = gene.sets.type2.df$prefix.label[i],
                                           module = gene.sets.type2.df$module[i])
  }
} else if (which.input$query_input_format==5){
  gene.sets.type5 <- read.csv("M09_type5_queries.csv", header = TRUE, stringsAsFactors = F)
  colnames(gene.sets.type5) <- rmvCSVprefix(colnames(gene.sets.type5))
}

```

```{r}
meta.module.helper <- function(do.module, default.set){
  
  if (is.na(do.module)){
    return(default.set)
  } else if (do.module == TRUE) {
    return(T)
  } else if (do.module == FALSE) {
    return(F)
  }
  
}
```


```{r input subtype data specification}

which.gene.set <- as.character(which.input$which.gene.set)

if (which.input$query_input_format==0){
  
  markers_of_interest <- which.gene.set
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
} else if (which.input$query_input_format==1){
  stopifnot(which.gene.set %in% names(gene.sets.type1))
  markers_of_interest <- gene.sets.type1[[which.gene.set]] # REQUIRED if query_input_format == 1
  meta.module.flag <- meta.module.helper( which.input$do.module,FALSE)
} else if(which.input$query_input_format==2){
  stopifnot(which.gene.set %in% names(gene.sets.type2))
  input_spreadsheet <- gene.sets.type2[[which.gene.set]][["file"]]
  dir.geneset <- gene.sets.type2[[which.gene.set]][["directory"]]
  meta.module.flag <- meta.module.helper( which.input$do.module,gene.sets.type2[[which.gene.set]][["module"]])
  prefix.label <- gene.sets.type2[[which.gene.set]][["prefix.label"]]
} else if ((which.input$query_input_format==3) | (which.input$query_input_format==4)) {
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
} else if (which.input$query_input_format==5){
  stopifnot(which.gene.set %in% gene.sets.type5$term)
  markers_of_interest <- id2geneset(gene.sets.type5$id[gene.sets.type5$term %in% which.gene.set ], 
                                    my.species = which.species) # REQUIRED if query_input_format == 1
   markers_of_interest <- as.data.frame(unique(markers_of_interest))
   colnames(markers_of_interest) <- which.gene.set
   
  meta.module.flag <- meta.module.helper( which.input$do.module,F)
} else if (which.input$query_input_format==6){
  scMiko.geneSets <- scMiko::geneSets
  stopifnot(which.gene.set %in% names(scMiko.geneSets))
  markers_of_interest <- as.data.frame(scMiko.geneSets[[which.gene.set]])
  meta.module.flag <- meta.module.helper( which.input$do.module,T)
}


if (exists("markers_of_interest") && "data.frame" %in% class(markers_of_interest)){
  markers_of_interest <- janitor::clean_names(markers_of_interest, "screaming_snake")
}

# annotation specifications
which.annotation.db <- which.results$annotation.db
which.ontology <- which.results$ontology


```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

if (!(exists("subset.df"))) subset.df <- "no.subset"

# prep seurat object
# prep.list <- prepSeurat2(so, e2s = gNames.list, 
#                              species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
#                              subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
#                              terms2drop = c("ica", "tsne", "nmf", "gsva", "deg"), rmv.pattern = "so", 
#                          scale.reprocessed = T, neighbors.reprocessed = F, keep.default.assay.only = T)


t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
                         subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = T)


# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

# clean clusters
if (clean.clusters) so.query <- cleanCluster(so.query, return.plots = F)

```



```{r prepare query gene list (input type 1 or 2), message=FALSE, warning=FALSE}


# import marker sets
if (which.input$query_input_format == 1){
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      markers.of.interest = markers_of_interest,
                                      which.species = which.species)
} else if (which.input$query_input_format == 2){
  
  if (meta.module.flag){
    which.col <- "all"
  } else {
    which.col <- "first"
  }
  
  input_file <- paste(data.path,dir.geneset, input_spreadsheet, sep = "")
  output.markers  <- m9.importMarkers(query.format = which.input$query_input_format, 
                                      input.file = input_file, 
                                      which.col = which.col,
                                      which.species = which.species)
} else if (which.input$query_input_format == 0){
  
  if (which.species == "Hs") {
    markers_of_interest <- toupper(markers_of_interest)
  } else if (which.species == "Mm") {
    markers_of_interest <- firstup(markers_of_interest)
  }
}

if (exists("output.markers")) markers_of_interest <- output.markers[[1]]


```


```{r prior log history, warning = FALSE}
# get prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r define grouping var, warning = FALSE}

# group by options:
#   1: clusters ID (seurat_clusters)
#   2: barcodes (Barcode)
#   3: Groups (in vivo)
group.by <- 1

# specift grouping variable
if (group.by == 1){
  grouping_var <- "seurat_clusters"
  group_name <- "Clusters"
} else if (group.by == 2){
  grouping_var <- "Barcode"
  group_name <- "Barcodes"
} else if (group.by == 3){
  grouping_var <- "Group"
  group_name <- "Group"
}

# determine unique groups
u_groups <- as.vector(unique(so.query@meta.data[[grouping_var]]))

# determine number of unique groups
n_group_members <- length(u_groups)
```



```{r analysis log, warning = FALSE}

df.log <- initiateLog("9, Query Marker Exploration")

df.log <- addLogEntry("Query File", input.file, df.log, "input.file")
df.log <- addLogEntry("Gene Set Name", which.gene.set, df.log, "which.gene.set")
df.log <- addLogEntry("Compute geneset module score", meta.module.flag, df.log, "meta.module.flag")
df.log <- addLogEntry("Species", which.species, df.log, "which.species")

if (exists("subset.df")){
  if ("data.frame" %in% class(subset.df)){
    df.log <- addLogEntry("Which Subset Field", subset.df$field, df.log, "field")
    df.log <- addLogEntry("Which Subset Groups", subset.df$subgroups, df.log, "subgroups")    
  } else if ("character" %in% class(subset.df)){
    df.log <- addLogEntry("Which Subset Groups", subset.df, df.log, "subset.df")    
  }
}
df.log <- addLogEntry("Clusters cleaned", clean.clusters, df.log, "clean.clusters")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Grouping Variable", group_name, df.log, "group_name")
df.log <- addLogEntry("N Groups", n_group_members, df.log, "n_group_members")
df.log <- addLogEntry("Top N UMAPs", which.results$umap.top.n, df.log, "umap.top.n")
df.log <- addLogEntry("Top N GSEA", which.results$gsea.top.n, df.log, "gsea.top.n")
df.log <- addLogEntry("Top N correlations", which.results$corr.top.n, df.log, "corr.top.n")
df.log <- addLogEntry("Annotation DB", which.results$annotation.db, df.log, "annotation.db")
df.log <- addLogEntry("subsample_factor", subsample_factor, df.log, "subsample_factor")
if (which.results$annotation.db == "GO"){
  df.log <- addLogEntry("GO ontology", which.results$ontology, df.log, "ontology")
}
df.log <- addLogEntry("schex used for UMAPs", which.results$do.hex, df.log, "do.hex")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")
if (which.results$gsea.threshold == 1){
  df.log <- addLogEntry("GSEA threshold", "padj<0.1" , df.log, "gsea.threshold")
} else if (which.results$gsea.threshold == 2) {
  df.log <- addLogEntry("GSEA threshold", "p<0.05 & |NES| > 1" , df.log, "gsea.threshold")
} else if (which.results$gsea.threshold == 3) {
  df.log <- addLogEntry("GSEA threshold", "top 3 (sorted by NES)" , df.log, "gsea.threshold")
}

df.log <- addLogEntry("correlation data", correlation.settings$which.data , df.log, "which.data")
df.log <- addLogEntry("Check for precomputed corr mat", correlation.settings$check.existing , df.log, "check.existing")
df.log <- addLogEntry("corr mat recomputed if query missing", correlation.settings$recompute.existing.if.query.missing , df.log, "recompute.existing.if.query.missing")


```


```{r keep available markers, warning = FALSE}

if (exists("markers_of_interest")){
  if (is.character(markers_of_interest)){
    which.available <- unlist(lapply(markers_of_interest, function(x) isGeneAvailable(so.query,x,gNames.list)))
    genes.not.found <- markers_of_interest[!which.available]
    try({genes.not.found <- genes.not.found[genes.not.found != ""]}, silent = T)
    markers_of_interest <- unique(markers_of_interest[which.available])
    markers_of_interest <- rmvCSVprefix(markers_of_interest)
    if (length(markers_of_interest) == 0) stop("None of queried genes found in seurat object. M09 run terminated.")
  } else if (is.data.frame(markers_of_interest)){
    colnames(markers_of_interest) <- rmvCSVprefix(colnames(markers_of_interest))
  }
}


```



```{r TYPE3 - prepare query gene list, warning = FALSE}

if (which.input$query_input_format == 3){
  
  orig.ident <-  Idents(so.query) 
  Idents(so.query) <- grouping_var
  deg.gene <- FindAllMarkers(so.query, 
                             assay = DefaultAssay(so.query),
                             slot = "data",
                             only.pos = F, 
                             min.pct = 0,
                             test.use = "MAST",
                             logfc.threshold = 0.15, 
                             max.cells.per.ident = 200,
                             return.thresh = 1, #1 ensures all genes are returned
                             verbose = F)
  Idents(so.query) <- orig.ident
} 

```


```{r TYPE3 - reformat DEG, warning = FALSE}

if (which.input$query_input_format == 3){
  
  p.threshold <- 0.05
  lfc.threshold <- 0.25
  pct.threshold <- 0.25
  
  # filter by threshold
  deg.gene.sig <- deg.gene[ (deg.gene$p_val_adj<p.threshold) & 
                              (abs(deg.gene$avg_log2FC)>lfc.threshold) & 
                              (deg.gene$pct.1 > pct.threshold) & 
                              (deg.gene$pct.2 > pct.threshold), ]
  
  # subset and label (up vs down), merge after
  deg.gene.sig.up <- deg.gene.sig[deg.gene.sig$avg_log2FC>0, ]
  deg.gene.sig.up$cluster <- as.character(paste("c", deg.gene.sig.up$cluster, ".up", sep = ""))
  deg.gene.sig.down <- deg.gene.sig[deg.gene.sig$avg_log2FC<0, ]
  deg.gene.sig.down$cluster <- as.character(paste("c", deg.gene.sig.down$cluster, ".down", sep = ""))
  deg.gene.sig.all <- bind_rows(deg.gene.sig.up, deg.gene.sig.down)
  
  # pivot to wide (accomodate uneven col numbers)
  deg.gene.sig.all.subset <- unique(data.frame(cluster = deg.gene.sig.all$cluster, gene = deg.gene.sig.all$gene))
  deg.gene.sig.all.subset$cluster <- as.character(deg.gene.sig.all.subset$cluster)
  deg.all.wide <- deg.gene.sig.all.subset %>%
    group_by(cluster) %>%
    mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = cluster, values_from = gene) %>%
    dplyr::select(-row)
  
  markers_of_interest <- as.data.frame(deg.all.wide)
  
  
} else if (which.input$query_input_format == 4){
  top.n.genes <- 50
  
  gene.scale.name <- unique(rownames(so.query))
  df.avg.exp <- DotPlot(so.query, assay = DefaultAssay(so.query), features = gene.scale.name, group.by = "seurat_clusters")[["data"]]
  df.avg.exp.sub <- df.avg.exp[ , c("features.plot", "avg.exp", "id")]
  colnames(df.avg.exp.sub) <- c("genes", "exp", "cluster")
  df.avg.exp.sub$cluster <- paste("c", df.avg.exp.sub$cluster, sep = "")
  
  
  df.exp.all.top.wide <- df.avg.exp.sub %>%
    dplyr::group_by(cluster) %>%
    dplyr::top_n(n = top.n.genes, wt = exp) %>%
    dplyr::select(c("genes", "cluster")) %>%
    group_by(cluster) %>%
    mutate(row = row_number()) %>%
    tidyr::pivot_wider(names_from = cluster, values_from = genes) %>%
    dplyr::select(-row)
  
  markers_of_interest <- as.data.frame(df.exp.all.top.wide)
}

```



```{r umap by cluster, warning = FALSE}

# get GGplot handle for cluster umap
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = "seurat_clusters", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Clusters") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = "Barcode", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Barcodes") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

if (print.inline) plt.umap_by_cluster

```

```{r meta module , warning = FALSE}

# pool genesets if modular activity is query of interest ##########################

if(!exists("moi.df")) moi.df <- (markers_of_interest)
if (meta.module.flag == T){
  
  gNames <- gNames.list
  plt.clustermarkers_by_umap <- list()
  available_markers <- c()
  
  markers_of_interest <- names(moi.df)
  
  exp.mat.new <- NULL
  
  all.list <- list()
  for (i in 1:length(markers_of_interest)){
    
    # get meta module name
    cur.marker <- markers_of_interest[i]
    
    # clean dataset and include only those available in seurat object
    cur.features <- as.character(moi.df[,i][moi.df[,i] != ""])
    cur.features <- cleanFilterGenes(cur.features, so.query, which.species)
    
    if (length(cur.features) == 0) next
    
      module.name <- cur.marker

    so.query.try = NA
    so.query.try <-  try(AddModuleScore(so.query,  
                                        features = list(cur.features),
                                        ctrl = 50,
                                        name = "new.module",
                                        nbin = 5), silent = T)
    
    if (is.na(so.query.try)) next
    
    
    # assign name to modlue score
    names(so.query.try@meta.data)[names(so.query.try@meta.data) %in% paste("new.module", 1, sep = "")] <- module.name
    so.query@meta.data[[module.name]] <- so.query.try@meta.data[[module.name]]
    
    # concat scores to dataframe
    cur.module.df <- as.data.frame(so.query@meta.data[[module.name]])
    colnames(cur.module.df) <- module.name
    exp.mat.new <- bind_cols(exp.mat.new, cur.module.df)
    
    available_markers[i] <- module.name
    all.list[[module.name]] <- cur.features
    
  }
  
  # get all scores and cast as matrix
  exp.mat.new.mat.t <- t(as.matrix(exp.mat.new))
  
  # concat scores to seurat objects
  exp.mat.1 <-so.query@assays[[DefaultAssay(so.query)]]@data
  colnames(exp.mat.new.mat.t) <- colnames(exp.mat.1)
  exp.mat.1 <- rbind(exp.mat.1, exp.mat.new.mat.t)
  so.query@assays[[DefaultAssay(so.query)]]@data <- exp.mat.1
  
  # exp.mat.2 <-so.query@assays[[DefaultAssay(so.query)]]@scale.data
  # colnames(exp.mat.new.mat.t) <- colnames(exp.mat.2)
  # exp.mat.2 <- rbind(exp.mat.2, exp.mat.new.mat.t)
  # so.query@assays[[DefaultAssay(so.query)]]@scale.data <- exp.mat.2
  markers_of_interest <- available_markers[!is.na(available_markers)]
  
}

if (exists("so.query.try")) rm("so.query.try")
```



```{r bin cells, warning = FALSE}

if (which.results$do.hex){
  
  n.cells <- ncol(so.query)
  cells.per.bin <- 30
  
  if (round(n.cells/cells.per.bin) > 100){
    nhexbins <- 100
  } else {
    round(n.cells/cells.per.bin)
  }
  so.query <- schex::make_hexbin(so.query, nbins = round(n.cells/cells.per.bin), 
                                 dimension_reduction = "UMAP")
}

```


```{r umap expression plots, message=FALSE, warning=FALSE, include = FALSE}

# initialize variables
# plt.clustermarkers_by_umap <- list()
plt.umap.1 <- list()
plt.umap.2 <- list()
gNames <- gNames.list
available_markers <- c()

# check if point size adjustment is necessary
if (ncol(so.query)> 35000) {
  aps <- F
  pt.size <- autoPointSize(ncol(so.query))
} else {
  aps <- T
  pt.size <- 1
}

if (class(markers_of_interest) == "data.frame") markers_of_interest <- as.vector(markers_of_interest[,1])
if (group.by == 1)u_groups <- as.character(as.numeric(u_groups)[order(as.numeric(u_groups))])

query_genes_by_group <- data.frame(u_groups)
input.marker.list <- markers_of_interest

# sort genes by group
for (i in 1:length(markers_of_interest)){
  query_genes_by_group[ ,ncol(query_genes_by_group)+1] <- rep(markers_of_interest[i], nrow(query_genes_by_group))
}

# plot top differentially expressed genes per cluster and compare to cluster membership
for (i in c(1:(length(markers_of_interest)))) {
  
  # empty list where plts will be stored
  all_plts <- list()
  
  # highlight cluster plot
  all_plts[[1]]  <- DimPlot(so.query, reduction = "umap", pt.size = aps, group.by = grouping_var, 
                            label = TRUE, repel = TRUE)  + 
    ggtitle(label = "UMAP") + xlab("UMAP 1") +  ylab("UMAP 2")
  
  # marker plot (try mouse and human formats)
  
  if (meta.module.flag){
    cur.marker <- markers_of_interest[i]
  } else {
    cur.marker <-  speciesConvert(markers_of_interest[i], 
                                  rownames(so.query@assays[[DefaultAssay(so.query)]]@data), 
                                  which.species)
  }
  
  markers_of_interest[i] <- cur.marker
  
  if (!is.na(cur.marker)){
    
    if ((which.results$do.hex)){
      all_plts[[length(all_plts)+1]] <- schex::plot_hexbin_feature(so.query, feature=cur.marker, 
                                                                   action="mean", xlab="UMAP1", ylab="UMAP2", 
                                                                   title=cur.marker,
                                                                   mod = DefaultAssay(so.query),
                                                                   type = "data")
    } else {

      # only use nebulosa for single gene expression profiles.
      if (meta.module.flag){
        all_plts[[length(all_plts)+1]] <- scExpression.UMAP(
          so.query,
          cur.marker,
          x.label = "UMAP 1",
          y.label = "",
          plot.name = NULL,
          adjust.pt.size = aps) +
          theme_miko(legend = T) +
          viridis::scale_color_viridis(option = "A") +
          labs(title = "", subtitle =cur.marker)
      } else {
        
        is.success.plot <- F
        try({
          all_plts[[length(all_plts)+1]] <- Nebulosa::plot_density(
            object = so.query,
            features = cur.marker,
            slot = "data",
            joint = FALSE,
            reduction = "umap",
            dims = c(1, 2),
            method = c("ks", "wkde"),
            adjust = 1,
            size = pt.size,
            shape = 16,
            combine = TRUE,
            pal = "inferno"
          )  +
            theme_miko(legend = T) +
            viridis::scale_color_viridis(option = "A") +
            labs(title = "", subtitle =cur.marker)  
          
          is.success.plot <- T
        }, silent = T)
        
        
        if (!is.success.plot){
          all_plts[[length(all_plts)+1]] <- scExpression.UMAP(
            so.query,
            cur.marker,
            x.label = "UMAP 1",
            y.label = "",
            plot.name = NULL,
            adjust.pt.size = aps) +
            theme_miko(legend = T) +
            viridis::scale_color_viridis(option = "A") +
            labs(title = "", subtitle =cur.marker)
        }
        
      }
    }
    
  }
  
  if (length(all_plts) == 2){
    
    current.ind <- length(plt.umap.1)+1
    plt.umap.1[[current.ind]] <- all_plts[[1]]
    plt.umap.2[[current.ind]] <- all_plts[[2]]
    available_markers[length(available_markers)+1] <- markers_of_interest[i]
    
    if (print.inline) print((CombinePlots(all_plts, ncol = length(all_plts), legend = 'none')))
  }
}

# remove NA entries
available_markers <- available_markers[!is.na(available_markers)]

# assign names marker names to each plot
names(plt.umap.1) <- names(plt.umap.2) <- available_markers

```



```{r UMAP deg genes, warning = FALSE}

if (!is.na(which.results$umap.top.n)){
  top.markers <- all.markers %>% top_n(which.results$umap.top.n, -log10(p_val))
  which.match <- available_markers %in% top.markers$gene
  plt.umap.1 <- plt.umap.1[which.match]
  plt.umap.2 <- plt.umap.2[which.match]
} 

```




```{r}

expression.Plot.dev <- function(so, which.gene, e.mat = NULL, f.mat = NULL,
                            which.group = "seurat_clusters", which.data = "data", which.assay = DefaultAssay(so),
                            x.label = NULL, x.label.angle = NULL){

  # get expression data
  if (is.null(e.mat)){
    em <- getExpressionMatrix(
      so,
      only.variable = F,
      which.assay = which.assay,
      which.data = which.data,
      use.additional.genes = NA
    )
  } else {
    em <- e.mat
  }

  # get fraction of expressing cells
  if (is.null(f.mat)){
    em.frac <- avgGroupExpression(
      so,
      which.data = "data",
      which.center = "fraction",
      which.group = which.group
    )
  } else {
    em.frac <- f.mat
  }

  if ("genes" %in% colnames(em)){
    rownames(em) <- em$genes
    em <- em %>% dplyr::select(-c("genes"))
  }
  if ("genes" %in% colnames(em.frac)){
    rownames(em.frac) <- em.frac$genes
    em.frac <- em.frac %>% dplyr::select(-c("genes"))
  }

  # get meta data
  so.meta <- so@meta.data

  # ensure grouping variable exists
  if (!(which.group) %in% colnames(so.meta)) stop("Grouping variable does not exist.")

  # merge datasets
  if (sum(rownames(em) %in% (which.gene)) != 1) stop("More than one gene matched query. Cannot continue.")
  df.meta <- data.frame(id = rownames(so.meta), group = so.meta[,which.group])
  em.mark <- as.data.frame(em[(rownames(em)) %in% (which.gene), ])
  em.df <- data.frame(id = rownames(em.mark), query = em.mark[,1])
  em.merge <- merge(em.df, df.meta, by = "id")

  # get summary statistics (for clustering)
  suppressMessages({em.sum <- em.merge %>%
    dplyr::group_by(group) %>%
    dplyr::summarise(x.mean = (mean((query), na.rm = T)),
                     x.sd = sd(query, na.rm = T))})
  em.frac.mark <- as.data.frame(em.frac[(rownames(em.frac)) %in% (which.gene), ])
  if (rownames(em.frac.mark) %in% which.gene) em.frac.mark <-as.data.frame(t(em.frac.mark))
  colnames(em.frac.mark) <- which.gene
  em.frac.mark.df <- data.frame(group = rownames(em.frac.mark), frac = em.frac.mark[,1])

  if (which.group == "seurat_clusters") em.frac.mark.df$group <- gsub("c", "", em.frac.mark.df$group)
  em.sum <- merge(em.sum, em.frac.mark.df, by = "group")

  # hierarchial clustering
  row.names.df <- em.sum$group
  em.sum <- em.sum %>% dplyr::select(-c("group"))
  clust.var <- as.matrix(em.sum)
  rownames(clust.var) <- row.names.df
  d <- dist(as.matrix(clust.var))   # find distance matrix

  clust.success <- F
  try({
    hc <- hclust(d)                # apply hirarchical clustering
    clust.success <- T
  }, silent = T)


  if (is.null(x.label)) x.label <- which.group

  if (clust.success){
    # helper function for creating dendograms
    ggdend.v2 <- function(df) {
      ggplot() +
        geom_segment(data = df, aes(x=x, y=y, xend=xend, yend=yend)) +
        ggdendro::theme_dendro()
    }

    # get dendromgram data from heat object
    d.query.clust <- ggdendro::dendro_data(hc)

    # ggplot dendograms
    p.query.clust <- ggdend.v2(d.query.clust$segments) +
      ggtitle(paste0(which.gene, " Expression")) +
      theme(axis.title.x=element_blank(),
            axis.text=element_blank(),
            axis.line=element_blank(),
            axis.ticks=element_blank(),
            legend.position = "none")

    # reorder data according to clusters
    em.merge$group <- factor(as.character(em.merge$group), levels = (d.query.clust[["labels"]][["label"]]))

    max.query <- max(em.merge$query, na.rm = T)
    em.merge$query.norm <- rescaleValues(values = em.merge$query, new.min = 0, new.max = 1)

    suppressMessages({em.merge.sum <- em.merge %>%
      dplyr::group_by(group) %>%
      dplyr::summarize(ef = mean(query > 0),
                ev = mean(query.norm, na.rm = T))})


    plt.em <- ggplot() +
      geom_bar(data = em.merge.sum, aes(x = group, y = ef, fill = group), stat = "identity", alpha = 0.5) +
      coord_cartesian(ylim = c(0, 1)) +
      geom_violin(data = em.merge, aes(x = group, y = query.norm, fill = group)) +
      geom_point(data = em.merge.sum, aes(x = group, y = (ev), fill = group)) +
      theme_miko() +
      xlab(x.label)  +
      scale_y_continuous(sec.axis = sec_axis(~., name = "Normalized Expression (violin)"), name = "Expressing Fraction (bar)") +
      theme(plot.margin = unit(c(0, 1, 0, 1), "cm"),
            legend.position = "none")

    if (!is.null(x.label.angle) && is.numeric(x.label.angle)){
      plt.em <- plt.em + theme(axis.text.x = element_text(angle = x.label.angle, hjust = 1))
    }

    # combine plots
    plt.sgExp <-  cowplot::plot_grid(p.query.clust, plt.em, ncol = 1, align = "v", rel_heights = c(1,3))

  } else {

    max.query <- max(em.merge$query, na.rm = T)
    em.merge.sum <- em.merge %>%
      group_by(group) %>%
      summarize(ef = mean(query > 0),
                ev = mean(query, na.rm = T))
    plt.sgExp <- ggplot() +
      geom_bar(data = em.merge.sum, aes(x = group, y = ef, fill = group), stat = "identity", alpha = 0.5) +
      coord_cartesian(ylim = c(0, 1)) +
      geom_violin(data = em.merge, aes(x = group, y = query/max.query, fill = group)) +
      geom_point(data = em.merge.sum, aes(x = group, y = (ev)/max.query, fill = group)) +
      theme_miko() +
      xlab(x.label)  +
      scale_y_continuous(sec.axis = sec_axis(~., name = "Expression (violin)"), name = "Expressing Fraction (bar)") +
      theme(plot.margin = unit(c(0, 1, 0, 1), "cm"),
            legend.position = "none")

    if (!is.null(x.label.angle) && is.numeric(x.label.angle)){
      plt.em <- plt.em + theme(axis.text.x = element_text(angle = x.label.angle, hjust = 1))
    }
  }

  return(plt.sgExp)

}


```


```{r single cell expression, fig.width=10, fig.height=4, include = FALSE, warning = FALSE}


# clean up
try({ rm(exp.mat); rm(exp.mat.2); rm(exp.mat.complete) }, silent = T)

e.mat <- exp.mat.complete <- so.query@assays[[DefaultAssay(so.query)]]@data
e.mat.log <- log1p(e.mat)

f.mat.clust <- avgGroupExpression(
  so.query,
  which.data = "data",
  which.center = "fraction",
  which.group = "seurat_clusters"
)
try({rownames(f.mat.clust) <- rownames(e.mat.log)}, silent = T)

f.mat.bc <- avgGroupExpression(
  so.query,
  which.data = "data",
  which.center = "fraction",
  which.group = "Barcode"
)
try({rownames(f.mat.bc) <- rownames(e.mat.log)}, silent = T)

# plot clustered violin plot
plt.sgExp.all <- list()
for (i in 1:length(available_markers)){
  
  plt.sgExp.clust <- expression.Plot(so = so.query, e.mat = e.mat.log, f.mat = f.mat.clust, 
                                         which.gene = available_markers[i], which.group = "seurat_clusters", 
                                         which.data = "data", x.label = "Cluster") + 
    labs(title = "Violin Plots", subtitle = "Clusters", caption = "violin = normalized expression\ndot = expression mean\nbar = expressin fraction")  
  
  is.success <- F
  try({
    plt.sgExp.barcode <- expression.Plot(so = so.query, e.mat = e.mat.log, f.mat = f.mat.bc, 
                                             which.gene = available_markers[i], which.group = "Barcode", which.data = "data",
                                              x.label = "Sample", x.label.angle = 25) +  
      labs(title = "", subtitle = "Samples", caption = "violin = normalized expression\ndot = expression mean\nbar = expressin fraction")  
      
    is.success <- T
  })
  
  if (is.success){
    plt.sgExp <- cowplot::plot_grid(plotlist = list(plt.sgExp.clust, plt.sgExp.barcode), ncol = 2)
  } else {
    plt.sgExp <-plt.sgExp.clust
  }
  
  plt.sgExp.all[[available_markers[i]]] <- plt.sgExp
  
  if (print.inline){
    print(plt.sgExp.all[[available_markers[i]]])
  }
}


# plt.sgExp.all
```


```{r symbol2entrez, warning = FALSE, message = FALSE}

# get symbol to entrez mapping
my.symbol <- as.vector(rownames(so.query))
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

```

```{r get correlations, message=FALSE, warning=FALSE}

which.data <- correlation.settings$which.data
stopifnot(which.data %in% c("data", "scale"))

if (which.data == "data"){
  query.cor <- "similarity.data"
} else if (which.data == "scale"){
  query.cor <- "similarity.scale"
}

# check for pre-computed matrix
if (!meta.module.flag && correlation.settings$check.existing && (query.cor %in% names(so.query@misc))){
  # get existing cor mat
  query.cor.mat <- so.query@misc[[query.cor]][["similarity.matrix"]]
  cor.method <- so.query@misc[[query.cor]][["metric"]]
  
  # check if pre-computed cor mat includes query genes
  n.query <- length(available_markers)
  n.included <- sum(rownames(query.cor.mat) %in% available_markers)
  if (n.query != n.included) {
    if (n.included == 0){
      warning("None of queried features are avaialble in precomputed corr matrix")
    } else {
      warning("Only subset of queried features are avaialble in precomputed corr matrix")
    }
    
    if (correlation.settings$recompute.existing.if.query.missing){
      compute.cor <- T
      query.cor.mat <- NULL
    } else {
      compute.cor <- F
    }
  } else {
    compute.cor <- F
  }
} else {
  compute.cor <- T
} 

# compute correlation matrix
if (compute.cor) {
  
  # entire matrix
  exp.mat.complete <- getExpressionMatrix(so.query, which.data = which.data)
  
  # variable gene only matrix
  use.var <- T
  
  n.var <- 3000 # specify number of variable genes
  if (use.var){

    
    is.exp <- exp.mat.complete > 0
    p.exp <- rowMeans(is.exp)
    # p.exp <- apply(exp.mat.complete, 1, function(x) mean(x > 0))
    which.keep <- rownames(exp.mat.complete)[which(p.exp > 0.1)]
    which.keep2 <-  rownames(exp.mat.complete)[rownames(exp.mat.complete) %in% available_markers]
    exp.mat <- exp.mat.complete[rownames(exp.mat.complete) %in% unique(c(which.keep, which.keep2)), ]
  } else {
    exp.mat <- exp.mat.complete
  }
  
  # ensure no negative values (necessary condition for proportionality association metrics)
  if ((min(exp.mat.complete) < 0) & (cor.method == "rho_p")) {
    exp.mat <- exp.mat + abs(min(exp.mat.complete))
    exp.mat.complete <- exp.mat.complete + abs(min(exp.mat.complete))
  }
  
  df.cor.list <- NULL
  
  query.cor.list <- list()

    which.missing <- c()
  
  if (which.data == "data"){
    t.exp.mat <- scMiko::sparse2dense(exp.mat, block.size = 10000, transpose = T)    
  } else {
    t.exp.mat <- t(exp.mat)
  }
  
  if (cor.method == "rho_p"){
    query.cor.object <-  propr::perb(t.exp.mat, select = colnames(t.exp.mat))
    query.cor.mat <- query.cor.object@matrix
  } else if (cor.method == "spearman"){
    
    exp.map.av <- t.exp.mat[ , toupper(colnames(t.exp.mat)) %in% toupper(available_markers)]
    query.cor.mat <-  cor(t.exp.mat, exp.map.av, method = "spearman")
    # query.cor.mat <-  dismay::dismay(t.exp.mat, metric = cor.method)
  } else if (cor.method == "pearson"){
    exp.map.av <- t.exp.mat[ , colnames(t.exp.mat) %in% available_markers]
    query.cor.mat <-  cor(t.exp.mat, exp.map.av)    
  }
}

query.cor.mat.all <- query.cor.mat[!(rownames(query.cor.mat) %in% available_markers),colnames(query.cor.mat) %in% available_markers]

if (!is.null(dim(query.cor.mat.all)) && ncol(query.cor.mat.all) == 0) stop("Correlation matrix is missing query features. If precomputed cor mat (M27) was used, try recomputing in current module (M09)")

# assign results
df.cor.list <- as.data.frame(query.cor.mat.all)
if (ncol(df.cor.list) == 1) {
  
  df.cor.list$genes<-  rownames(query.cor.mat)[!(rownames(query.cor.mat) %in% available_markers)]
  colnames(df.cor.list)[1] <- available_markers[1]
} else {
  df.cor.list$genes <- rownames(df.cor.list)
}

if (!("genes" %in% colnames(df.cor.list)))  df.cor.list$genes <- rownames(df.cor.list)
which.available.markers <- available_markers[available_markers %in% colnames(df.cor.list)]
df.cor.list <- df.cor.list[ ,c("genes", which.available.markers)]



```



```{r prep ranking lists, warning = FALSE}

# Rank by LFC if DEG
if (which.input$query_input_format == 3){
  deg.gene.enrich <- deg.gene[ ,c("cluster", "avg_log2FC", "gene")]
  colnames(deg.gene.enrich) <- c("cluster", "avg_log2FC", "genes")
  deg.gene.enrich$cluster <- paste("c", deg.gene.enrich$cluster , sep = "")
  deg.gene.enrich.wide <- pivot_wider(deg.gene.enrich, names_from = cluster, values_from = avg_log2FC)
  
  df2enrich <- as.data.frame(deg.gene.enrich.wide)
  
  # Rank by Correlations if query genes
} else if (which.input$query_input_format == 4){
  
  exp.gene.enrich.wide <- pivot_wider(df.avg.exp.sub, names_from = cluster, values_from = exp)
  df2enrich <- as.data.frame(exp.gene.enrich.wide)
  
} else if (!is.null(df.cor.list)) {
  
  # query has r = 1 with itself; set to next top cor value (+1e-3) to ensure query does not dominate rankings
  df.cor.list.genes <- df.cor.list$genes
  df.cor.list.cor <- df.cor.list %>% dplyr::select(-c("genes"))
  mat.cor.list.cor <- as.matrix(df.cor.list.cor)
  filter.cor <- 0.9999999999
  for (i in 1:ncol(mat.cor.list.cor)){
    mat.cor.list.cor[mat.cor.list.cor[,i] > filter.cor, i] <- max(mat.cor.list.cor[mat.cor.list.cor[,i] < filter.cor, i], na.rm = T) + 1e-3
  }
  
  mat.cor.list.cor <- signif(mat.cor.list.cor, 4)
  df.cor.list <- bind_cols(data.frame(genes = df.cor.list.genes), as.data.frame(mat.cor.list.cor))
  
  df2enrich <- as.data.frame(df.cor.list)
} else {
  df2enrich <- NULL
}

# ensure no duplicate exist
if (!is.null(df2enrich)){
  df2enrich <- df2enrich[!duplicated(df2enrich$genes), ]
  enrich.groups <- colnames(df2enrich)
  enrich.groups <- enrich.groups[enrich.groups != "genes"]
  }

```

```{r get pathways, warning = FALSE}

# all.genes <-df2enrich$genes
all.genes <- rownames(so.query)

match.ind <- match(all.genes, my.entrez$SYMBOL)
all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind]) 

pathways.subset <- getAnnotationPathways(all.genes.entrez, db = which.annotation.db, ontology = "BP", species = which.species)

```


```{r gsea enrichment, warning = FALSE}

# get pathways relevant to current gene set
gse.pathway.combined <- NULL
gse.pathway.list <- list()

single.path.of.interest <- NULL

plt.enrichment <- list()

# specify analysis parameters
if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

# start cluster
if (n.workers$gsea > length(enrich.groups)) n.workers$gsea <- length(enrich.groups)
cl <- parallel::makeCluster(n.workers$gsea)
doParallel::registerDoParallel(cl)

score.results <- foreach(i = 1:length(enrich.groups), .packages = c("fgsea", "plyr"))  %dopar% {

  gene.list <- (df2enrich[, enrich.groups[i]])
  names(gene.list) <- df2enrich$genes
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  
  suppressMessages({gse.pathway <- fgsea(pathways.subset, gene.list.clean, nperm=1000, maxSize=500) })
  
  if (nrow(gse.pathway) == 0) {
    return(list(out1 = NULL,
                out2 = NULL))
  } else {
    
    gse.pathway$query <- enrich.groups[i]

    if(which.results$gsea.threshold == 1){
      gse.pathway.filtered <- gse.pathway[gse.pathway$padj < 0.1, ]
    } else if (which.results$gsea.threshold == 2){
      gse.pathway.filtered <- gse.pathway[((gse.pathway$pval < 0.05) & (abs(gse.pathway$NES) > 0.8)), ]
    } else if (which.results$gsea.threshold == 3){
      gse.pathway.filtered <- gse.pathway %>% top_n(3, NES)
    }

    # make human readable (map entrez to symbol)
    gse.pathway.filtered.orig <- gse.pathway.filtered
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$leadingEdge, 
                                       mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$set, paste,collapse = ", ")
    gse.pathway.filtered$query <- enrich.groups[i]
    
    
    # sig figs for numerics
    gse.pathway.filtered$ES <- signif(gse.pathway.filtered$ES, 3)
    gse.pathway.filtered$NES <- signif(gse.pathway.filtered$NES, 3)
    gse.pathway.filtered$pval <- gse.pathway.filtered$pval
    gse.pathway.filtered$padj <- signif(gse.pathway.filtered$padj, 3)
    
    # filter and rearrange columns
    gse.pathway.cur <- gse.pathway.filtered[ ,c("query", "pathway", "size", "ES", "NES", "pval", "padj", "set")]
    
    return(list(out1 = gse.pathway.cur,
                out2 = gse.pathway))
  }
  
} 

# stop workers
parallel::stopCluster(cl)

stopifnot(length(enrich.groups) == length(score.results))

for (i in 1:length(enrich.groups)){
  gse.pathway.list[[enrich.groups[i]]] <- score.results[[i]]$out1
  gse.pathway.combined <- bind_rows(gse.pathway.combined, score.results[[i]]$out2)
}

```

```{r gsea barplot, warning = FALSE}


plt.top.gsea <- list()
for (i in 1:length(available_markers)){
  
  current.paths <- gse.pathway.list[[available_markers[i]]]
  
  if (is.null(current.paths)) {
    plt.top.gsea[[available_markers[i]]] <- NULL
    next
  }
  
  current.paths <- current.paths %>% dplyr::arrange(-abs(NES))
  current.paths <- current.paths[!duplicated(current.paths$set), ]
  
  if (is.null(current.paths)) {
    plt.top.gsea[[available_markers[i]]] <- NULL
    next
  }
 
 df.set1 <- current.paths %>% dplyr::filter(NES > 0) %>% dplyr::arrange(log10(pval))
  df.set2 <- current.paths %>% dplyr::filter(NES < 0) %>% dplyr::arrange(log10(pval))
 current.paths <- bind_rows(df.set1[1:which.results$gsea.top.n, ] %>% dplyr::arrange(-NES),
                            df.set2[1:which.results$gsea.top.n, ] %>% dplyr::arrange(NES))
 
 
 # current.paths <- bind_rows(current.paths %>% dplyr::top_n(which.results$gsea.top.n , NES) %>% dplyr::arrange(-NES), 
                            # current.paths %>% dplyr::top_n(which.results$gsea.top.n , -NES) %>% dplyr::arrange(NES))

 current.paths$pathway <- stringr::str_trunc(current.paths$pathway, 40)
 
 plt.top.gsea[[available_markers[i]]] <- current.paths %>%
   ggplot(aes(x = reorder(pathway, -log10(pval) * sign(NES)), y = -log10(pval) * sign(NES), size = abs(NES), fill = abs(NES))) + 
   geom_point(pch = 21) + 
   coord_flip() + 
   xlab("Pathways") + ylab("-log(p)") + 
   labs(title = "GSEA", subtitle = paste0(available_markers[i], " corr. ranking"), caption = "x-axis = -log(p), color = |NEs|, size = |NEs|") + 
   geom_hline(yintercept = 0, linetype = "dashed") + 
   viridis::scale_fill_viridis(option = "B", limits = c(min(abs(current.paths$NES)),max(abs(current.paths$NES))))
 
 
 if (print.inline){
   plt.top.gsea[[available_markers[i]]]
 }
}


```


```{r common enrichments, warning = FALSE, include = FALSE}

gse.pathway.combined.tally <- NULL
try({
  

# summarize enrichments
  gse.pathway.combined.label <- gse.pathway.combined

  if (!is.null(gse.pathway.combined.label)){

    which.enrich <- gse.pathway.combined.label$NES > 0
    which.enrich[is.na(which.enrich)] <- FALSE
    which.deplete <- gse.pathway.combined.label$NES < 0
    which.deplete[is.na(which.deplete)] <- FALSE
    gse.pathway.combined.label$pathway[which.enrich] <- paste("Enriched-", gse.pathway.combined.label$pathway[which.enrich], sep = "")
    gse.pathway.combined.label$pathway[which.deplete] <- paste("Depleted-", gse.pathway.combined.label$pathway[which.deplete], sep = "")

    gse.pathway.combined.tally <- gse.pathway.combined.label %>%
      dplyr::filter(pval < 0.01, abs(NES) > 1) %>%
      dplyr::group_by(pathway) %>%
      summarise(queries = list(query))

    gse.pathway.combined.tally$n <- lapply(gse.pathway.combined.tally$queries, length)
    gse.pathway.combined.tally$n <- as.numeric(gse.pathway.combined.tally$n)
    gse.pathway.combined.tally$set <- lapply(gse.pathway.combined.tally$queries, paste,collapse = ", ")
    gse.pathway.combined.tally <- gse.pathway.combined.tally %>%
      dplyr::select(-c("queries")) %>%
      dplyr::arrange(n)

  } else {
    gse.pathway.combined.tally <- NULL
  }

# 
}, silent = T)

```

```{r cormat heatmap, warning = FALSE}


if (exists("df.cor.list")) {
  
  df.cor.list.mat <- df.cor.list
  df.cor.list.mat <- df.cor.list.mat[!duplicated(df.cor.list.mat$genes), ]
  rownames(df.cor.list.mat) <- df.cor.list.mat$genes
  df.cor.list.mat <- dplyr::select(df.cor.list.mat, -c("genes"))
  cor.mat <- as.matrix(df.cor.list.mat)
  
  
  top.n.cor <- which.results$cor.top.n
  n.per.query <- ceiling(0.5*top.n.cor/ncol(cor.mat))
  
  filter.cor <- T
  if (filter.cor){
    
    cor.mat.df <- as.data.frame(cor.mat)
    top.cor <- unique(as.vector(unlist(apply(cor.mat.df, 2, function(x) {
      c(rownames(cor.mat)[order(-x)][1:n.per.query], rownames(cor.mat)[order(x)][1:n.per.query])
    }))))
    cor.mat.sub <- cor.mat[rownames(cor.mat) %in% top.cor, ]
    
    if (class(cor.mat.sub) == "numeric"){
      names(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor]
    } else {
      rownames(cor.mat.sub) <- rownames(cor.mat)[rownames(cor.mat) %in% top.cor] 
    }
    
  } else {
    cor.mat.sub <- cor.mat
  }
}


```


```{r gene.expression tables, warning = FALSE}

data.all <- as.data.frame(so.query@assays[[DefaultAssay(so.query)]]@data[rownames(so.query@assays[[DefaultAssay(so.query)]]@data) %in% available_markers, ])
data.rownames <- rownames(data.all)
match.ind <- data.rownames %in% available_markers
data.subset <- as.data.frame(t(data.all[match.ind, ]))

groups.of.interest <- list(cluster = "seurat_clusters",
                           batch = "batch",
                           barcode = "Barcode",
                           stratify.group = "stratify.group")

df.expression.list <- list()
for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    data.subset[ ,names(groups.of.interest)[i]] <- so.query@meta.data[[groups.of.interest[[i]]]]
  }
}

if ((grouping_var != "seurat_clusters") &  (grouping_var %in%  names(so.query@meta.data))){
  data.subset[ ,grouping_var] <- so.query@meta.data[[grouping_var]]
}
available_markers <-available_markers[available_markers %in% colnames(data.subset)]

data.subset.long <- gather(data.subset, gene, expression, available_markers)

for (i in 1:length(groups.of.interest)){
  if (groups.of.interest[[i]] %in%  names(so.query@meta.data)){
    df.expression.list[[names(groups.of.interest)[i]]] <- data.subset.long %>%
      group_by(gene, get(names(groups.of.interest)[i])) %>%
      summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
                median.exp = signif(log(median(expm1(expression)+ 1)),3),
                sd.exp = signif(sd(((expression))),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    colnames( df.expression.list[[names(groups.of.interest)[i]]])[2] <- names(groups.of.interest)[i]
    
    if (print.inline) datatable(df.expression.list[[names(groups.of.interest)[i]]], filter = "top")
  }
}   

if (all(c("seurat_clusters", "batch") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x batch"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, batch) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif(sd(((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (all(c("seurat_clusters", "stratify.group") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x stratify.group"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, stratify.group) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif(sd(((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (all(c("seurat_clusters", "Barcode") %in%  names(so.query@meta.data))){
  cur.entry <- "cluster x Barcode"
  df.expression.list[[cur.entry]] <- data.subset.long %>%
    group_by(gene, cluster, barcode) %>%
    summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
              median.exp = signif(log(median(expm1(expression)+ 1)),3),
              sd.exp = signif((sd((expression))),3),
              pct.exp = signif(mean(expression > 0),3),
              n.cells = length(expression))
  
  if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
}

if (grouping_var != "seurat_clusters"){
  
  if (all(grouping_var %in%  names(so.query@meta.data))){
    cur.entry <- grouping_var
    df.expression.list[[cur.entry]] <- data.subset.long %>%
      group_by(gene, get(cur.entry)) %>%
      summarize(mean.exp = signif(log(mean(expm1(expression)+ 1)),3), 
                median.exp = signif(log(median(expm1(expression)+ 1)),3),
                sd.exp = signif(sd(((expression)+ 1)),3),
                pct.exp = signif(mean(expression > 0),3),
                n.cells = length(expression))
    
    if (print.inline) datatable(df.expression.list[[cur.entry]], filter = "top")
  }
  
}


```

```{r cluster by barcode expression heatmaps, include = FALSE}

cb.hm.list <- list()

if ("cluster x Barcode"  %in% names(df.expression.list)){
  
  df.expression.cb <- df.expression.list[["cluster x Barcode"]]
  u.gene.cb <- unique(df.expression.cb$gene)
  
  for (i in 1:length(u.gene.cb)){
    gene.name <- u.gene.cb[i]
    df.ecb.cur <-   df.expression.cb %>%
      dplyr::filter(gene %in% gene.name) %>%
      dplyr::select(c("cluster", "barcode", "mean.exp")) %>%
      pivot_wider(names_from = "cluster", values_from ="mean.exp")
    df.ecb.cur <- as.data.frame(df.ecb.cur)
    rownames(df.ecb.cur) <- df.ecb.cur$barcode
    df.ecb.cur <- as.matrix(df.ecb.cur %>% dplyr::select(-c("gene", "barcode")))
    df.ecb.cur[is.na(df.ecb.cur)] <- 0
    colnames(df.ecb.cur) <- paste0("c", colnames(df.ecb.cur))
    
    is.success <- F
    if (nrow(df.ecb.cur) == 1){
      try({
        plt.hm.cb <- ggplotify::as.ggplot(pheatmap::pheatmap(t(df.ecb.cur), color = inferno(100), silent = T, cluster_cols = F)) +
          labs(title = "Expression", subtitle = "Cluster x Sample") + 
          theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))   
        is.success <- T
      }, silent = T)
    } else {
      try({
        plt.hm.cb <- ggplotify::as.ggplot(pheatmap::pheatmap(t(df.ecb.cur), color = inferno(100), silent = T)) +
          labs(title = "Expression", subtitle = "Cluster x Sample") + 
          theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))   
        is.success <- T
      }, silent = T)
    }
    
    if (!is.success)  plt.hm.cb <- NULL
    
    if (print.inline){
      print(plt.hm.cb)
    }
    
    cb.hm.list[[gene.name]] <- plt.hm.cb
    
  }
} else {
  cb.hm.list <- NULL
}

```


```{r create cor heatmap, include= F}

# fitered correlation matrix
  if (class(cor.mat.sub) == "matrix") {
    
   cor.mat.sub <- cor.mat.sub[ ,!(is.na(apply(cor.mat.sub, 2, function(x) var(x))))] 
    plt.heat <- ggplotify::as.ggplot(pheatmap::pheatmap(cor.mat.sub, 
                                                        main = "Query x Gene Correlations\nx=query, y=genes, z=correlation",
                                                         border_color = NA, silent = T))
    
    # plt.heat
                                    
  } else {
    plt.heat <- NULL
  }

```

```{r ranked correlations, fig.height=13, fig.width=10, include = FALSE}


# if (length(markers_of_interest) == 1){

  if (cor.method == "rho_p") {
    fill.label <- "Proportionality Metric"
  } else if (cor.method == "spearman") {
    fill.label <- "Spearman R"
  } else if (cor.method == "pearson") {
    fill.label <- "Pearson R"
  }

cor.list <- list()
for (i in 1:length(available_markers)){
  
  # all correlations
  df.cor.all <-  data.frame(genes = rownames(cor.mat), r = as.vector(cor.mat[ ,colnames(cor.mat) %in% available_markers[i]]))
  colnames(df.cor.all) <- c("genes", "r")
  df.cor.all <-  df.cor.all[df.cor.all$genes != available_markers[i], ]
  plt.heat
    plt.cor.dist <- df.cor.all %>%
    ggplot(aes(x = r)) +
    geom_density(fill = "grey") + 
    ylab("Density") + 
    xlab(fill.label) + 
    theme_classic() + 
      geom_vline(xintercept = 0, linetype = "dashed") + 
    labs(title = "Correlations", subtitle = available_markers[i]) + 
    theme(axis.text.y = element_blank()) + 
     theme(plot.title = element_text(hjust = 0.5), plot.subtitle = element_text(hjust = 0.5))

    
    # get top genes to visualize
    gene.up <- (df2enrich %>% dplyr::arrange(get(available_markers[i])))[1:35,"genes"]
    gene.down <- (df2enrich %>% dplyr::arrange(-get(available_markers[i])))[1:35 ,"genes"]
    r.up <- (df2enrich %>% dplyr::arrange(get(available_markers[i])))[1:35,available_markers[i]]
    r.down <- (df2enrich %>% dplyr::arrange(-get(available_markers[i])))[1:35 ,available_markers[i]]
    df.cor.sub <- data.frame(genes = c(gene.up, gene.down), r = c(r.up, r.down))

  colnames(df.cor.sub) <- c("genes", "r")
  df.cor.sub <-  df.cor.sub[!(df.cor.sub$genes %in%  available_markers[i]), ]
  
  plt.ranked.cor.sub <- df.cor.sub %>%
    ggplot(aes(x = reorder(genes, r), y = r)) +
    geom_bar(stat = "identity") + 
    coord_flip() + 
    xlab("Genes") + 
    ylab(fill.label) + 
    theme_classic() + 
    labs( subtitle = "Top Correlations") 
  
  cor.list[[available_markers[i]]] <-  cowplot::plot_grid(plt.cor.dist, plt.ranked.cor.sub, ncol = 1, rel_heights = c(1,4.5), align = "hv")
  
  if (print.inline){
    print( cor.list[[available_markers[i]]])
  }
  # }
}

```


```{r combine expression plots, fig.height=12, fig.width=25, include = FALSE}

dash.list <- list()

# helper to remove plot elements
rmv.plt.elements <- function(plt){
  plt <- plt + 
    theme(legend.position = "none",
          panel.grid = element_blank(),
          axis.title = element_blank(),
          axis.text = element_blank(),
          axis.ticks = element_blank(),
          panel.background = element_blank()) 
  return(plt)
}

for (i in 1:length(available_markers)){
  
  check.1 <- available_markers[i] %in% names(plt.umap.1)
  check.2 <- available_markers[i] %in% names(plt.umap.2)
  check.3 <- available_markers[i] %in% names(plt.sgExp.all)
  check.4 <- available_markers[i] %in% names(cor.list)
  
  # get component plots
  if (!(check.1 & check.2 & check.3 & check.4)) next
  top.lq <- cowplot::plot_grid(
    plt.umap.1[[available_markers[i]]] + 
      theme_miko(legend = F) + labs(title = "UMAP", subtitle = "Clusters"), 
    plt.umap.2[[available_markers[i]]]+ theme_miko(legend = F) + 
      labs(title = "", subtitle = paste0(available_markers[i], " Expression")),
    ncol = 2, labels = c("A", "B")
  )
  
  low.lq <- plt.sgExp.all[[available_markers[i]]]
  lq <- cowplot::plot_grid(plotlist = list(top.lq, low.lq), ncol = 1, rel_heights = c(2,2), labels = c("", "C"))
  plt.gsea <-  plt.top.gsea[[available_markers[i]]] + theme_miko(legend = F) 
  
  
  if (!is.null(cb.hm.list)){
  mq <- cowplot::plot_grid(plotlist = list(lq,
                                           cb.hm.list[[available_markers[i]]],
                                           cor.list[[available_markers[i]]],
                                           plt.gsea),
                           ncol = 4, rel_widths = c( 5,2,1, 2), labels = c("", "D", "E", "F"))    
  } else {
  mq <- cowplot::plot_grid(plotlist = list(lq,
                                           cor.list[[available_markers[i]]],
                                           plt.gsea),
                           ncol = 3, rel_widths = c( 5,2, 3), labels = c("", "D", "E"))       
  }

  
  # store final plot
  dash.list[[available_markers[i]]] <- mq
  
}

# mq
```

```{r cluster-wise expression data}
# stop("stop here")
# get expression data
cluster.membership <- so.query@meta.data[[grouping_var]]
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]

# aggregate expression matrix
exp.mat.scale <- exp.mat
gene.scale.name <- rownames(exp.mat.scale)
cell.scale.name <- colnames(exp.mat.scale)

# percetnage expressed (observed)
per.dot.score <- DotPlot(so.query, features = available_markers, group.by = grouping_var)[["data"]]
per.dot.score$genes <- per.dot.score$features.plot
per.dot.score$id <- as.numeric(as.character( per.dot.score$id))
per.dot.score.sub <- per.dot.score[ ,c("id", "avg.exp.scaled", "genes")]
colnames(per.dot.score.sub) <- c("cluster", "expression", "genes")
per.dot.score.wide <- pivot_wider(per.dot.score.sub, names_from = "cluster", values_from = "expression")
gene.names.row <- per.dot.score.wide$genes
per.dot.score.wide <- dplyr::select(per.dot.score.wide, -c("genes"))
per.dot.score.wide <- per.dot.score.wide[ ,as.character(u.clusters)]
rownames(per.dot.score.wide) <- gene.names.row

# cast expression data as matrix
exp.mat.scale.processed <- as.matrix(per.dot.score.wide)
exp.mat.av <- exp.mat.scale.processed[rownames(exp.mat.scale.processed) %in% available_markers, ]

if (!is.null(dim(exp.mat.av))) exp.mat.av <- exp.mat.av[complete.cases(exp.mat.av), ]

```


```{r create exp heatmap object , include= F}

clust.success <- F
if (class(exp.mat.av) == "matrix") {
  try({
    heat.object.expression.cluster <- getHeat(exp.mat.av)
    mat.reconstruct.av <- exp.mat.av[heat.object.expression.cluster[["rowInd"]], heat.object.expression.cluster[["colInd"]]]
    gene.order.av <- rownames(mat.reconstruct.av)
    cluster.order.av <- colnames(mat.reconstruct.av)
    plt.heat.availableGenes <- ggplotify::as.ggplot(pheatmap::pheatmap(exp.mat.av))
    clust.success <- T
  }, silent = T)
  
} else {
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  plt.heat.availableGenes <- NULL
}

if (!clust.success){
  gene.order.av <- rownames(exp.mat.scale.processed)[rownames(exp.mat.scale.processed) %in% available_markers]
  cluster.order.av <- colnames(exp.mat.scale.processed)
  if (!exists("plt.heat.availableGenes")) plt.heat.availableGenes <- NULL  
}

```


```{r get dot size helper function}

get.dot.size <- function(gene.list){
  n.genes <- length(gene.list)
  if (n.genes < 11) xlab.size <- 15
  if (n.genes > 10) xlab.size <- 12
  if (n.genes > 40) xlab.size <- 10
  if (n.genes > 50) xlab.size <- 9
  return(xlab.size)
}

```



```{r create dot plots, fig.width = 8, fig.height = 10}

# dot plot

# order clusters according to hierarchial clustering
if (exists("cluster.order.av")){
  so.query@meta.data[[grouping_var]] <- factor(so.query@meta.data[[grouping_var]], 
                                               levels=cluster.order.av)
}

plt.dot.list <- list()

  if (!(exists("gene.order.av"))) gene.order.av <- available_markers
  
  # scale label sizes accordingly
  xlab.size <- get.dot.size(gene.order.av)
  
  # create dotplo
  plt.dot.list[["Dot.All"]] <-  DotPlot(so.query, features = factor(gene.order.av, levels = gene.order.av), 
                                        group.by = grouping_var, 
                                        dot.scale = 8,
                                        cols="RdBu" ) + 
    RotatedAxis() + ylab(group_name) +
    theme(axis.text.x=element_text(size=xlab.size, angle = 75)) + ggtitle("All Query Genes")
  if (print.inline) print( plt.dot.list[["Dot.All"]])

```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M09", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M09_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


1) cluster UMAP
===================================== 

Uniform manifold projection and approximation (UMAP) used to dimensionally reduce and visualize data while maintaining global transcriptomic structure. Clusters were determined using unsupervised Louvain community detection. 

Row {.tabset}
-------------------------------------

### Clusters

```{r plt.umap_by_c}
print(plt.umap_by_cluster) 
savePDF(file.name = paste0(output.path, "PDF/", "M09_umap_cluster.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```

### Barcodes

```{r plt.umap_by_b}
print(plt.umap_by_barcode) 
savePDF(file.name = paste0(output.path, "PDF/", "M09_umap_barcode.pdf"), plot.handle = plt.umap_by_barcode, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```


2) Expression
===================================== 

Expression plots of queried gene(sets). Dot.All shows all queries, whereas Dot.DEG shows only those that are differentially expressed (p<0.05) across clusters. Expression heatmap shows scaled expression values. All plots have been hierarchially-clustered. 

Row {.tabset}
-------------------------------------

```{r dot plot}

out1.1 <-NULL

try({
    out1.1 <- lapply(seq_along(plt.dot.list), function(i) {
      
      s1 <- paste("plt.dot.list[[", i, "]]", sep = "")
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.dot.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,  fig.width = 20, fig.height = 20}", paste(i, "plotly.dot.plt"))) 
      a3 <- knitr::knit_expand(text = sprintf("\n %s", s1))
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })
    
}, silent = T)

```
`r paste(knitr::knit(text = paste(out1.1, collapse = '\n')))`

```{r pdf dotplots,include = FALSE}

for (i in 1:length(plt.dot.list)){
  plot.name <- paste0("M09_expression_dotplot_", names(plt.dot.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.dot.list[[i]], 
          fig.width = 20, fig.height = 20, save.flag = save.pdf)
}

```

### Expression Heatmap

```{r,  fig.width = 20, fig.height = 20}

if (!is.null(plt.heat.availableGenes)) {
  
  print(plt.heat.availableGenes)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_heatmap.pdf"), plot.handle = plt.heat.availableGenes, 
          fig.width = 20, fig.height = 20, save.flag = save.pdf)
  
}



```

```{r scExpression plot v1, fig.width=10, fig.height=4}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 2){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
      savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 10, fig.height = 4, save.flag = save.pdf)
  }
}

```

```{r scExpression plot v2}

if (exists("plt.sgExp.list")){
  if (length(plt.sgExp.list) == 1){
    print(cowplot::plot_grid(plotlist = plt.sgExp.list))
          savePDF(file.name = paste0(output.path, "PDF/", "M09_expression_violin.pdf"), 
              plot.handle = cowplot::plot_grid(plotlist = plt.sgExp.list), 
          fig.width = 5, fig.height =5, save.flag = save.pdf)
  }
}

```

3) Results
===================================== 

Summary report for each query gene(set). Top left: Expression values projected onto UMAP and corresponding cluster memberships. Bottom left: Normalized expression strafied by clusters or sample barcodes. Groups were hierarchially-clustered using normalized expression, expressing fraction and expression variance. Right: Query gene(set) correlations were computed and correlation-based ranks were used as input into gene set enrichment analysis (GSEA) to identify query-associated enrichments. 

Row {.tabset}
-------------------------------------


```{r dash}

try({

    out <- lapply(seq_along(dash.list), function(i) {
      
      a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(dash.list)[i])) # tab header
      a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=25, fig.height=12}", paste(i, "dash"))) 
      a3 <- knitr::knit_expand(text = sprintf("\nprint(dash.list[[%d]])", i)) 
      a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
      
      paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
      
    })

}, silent = T)


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`



```{r pdf dash,include = FALSE}

for (i in 1:length(dash.list)){
  plot.name <- paste0("M09_summary_", names(dash.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  (dash.list[[i]]), 
          fig.width = 25, fig.height = 12, save.flag = save.pdf)
}

```


4) Correlations
===================================== 

Gene(set) query correlation table and heatmap. Only top correlations are shown. 

Row {.tabset}
-------------------------------------



### Correlation Table (top)

```{r correlation table - top}


  if (class(cor.mat.sub) == "matrix"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% rownames(cor.mat.sub), ]
  } else if  (class(cor.mat.sub) == "numeric"){
    df.cor.list.sub <- df.cor.list[df.cor.list$genes %in% names(cor.mat.sub), ]
  }

write.csv(cor.mat, file = paste0(output.path, "Tables/", "correlations.csv"), 
          row.names = T) 
  
  flex.asDT(df.cor.list.sub)

```


### Query Correlations (top)

```{r query correlation heatmap - top, fig.width=10, fig.height=13}

try({
  if (length(markers_of_interest) == 1){
    
    plt.dis.rank.cor <- cowplot::plot_grid(cowplot::plot_grid(plt.cor.dist, NULL, rel_heights = c(1,2), ncol = 1), plt.ranked.cor.sub, ncol = 2)
    
    savePDF(file.name = paste0(output.path, "PDF/", "M09_ranked_correlations.pdf"), 
            plot.handle = plt.dis.rank.cor, 
            fig.width = 10, fig.height =13, save.flag = save.pdf)
    
    print(plt.dis.rank.cor)
  } else {
        savePDF(file.name = paste0(output.path, "PDF/", "M09_correlation_heatmap.pdf"), 
            plot.handle = plt.heat, 
            fig.width = 10, fig.height =13, save.flag = save.pdf)
    
    plt.heat
  }
}, silent = T)

```

5) GSEA 
===================================== 

GSEA enrichment results for genes ranked by query correlations.  

Row {.tabset}
-------------------------------------

### Common Enrichments

```{r common enrich table }

if (exists("gse.pathway.combined.tally")){
  if (!is.null(gse.pathway.combined.tally)){
    gse.pathway.tally.output <- as.data.frame(gse.pathway.combined.tally)
    
    gse.pathway.tally.output$set <- vapply(gse.pathway.tally.output$set, paste, collapse = ", ", character(1L))
    write.csv(gse.pathway.tally.output, file = paste0(output.path, "Tables/", "gsea_pathway_tally.csv"), 
          row.names = F) 
    
    flex.asDT(gse.pathway.combined.tally)
  }
}

```


```{r gsea cor mat,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# create enrihcment list
if (exists("gse.pathway.list")){
  out_enrich_table <- flex.multiTabTables(gse.pathway.list, "gse.pathway.list")
} else {
  out_enrich_table <- NULL
}

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`


```{r save gsea statistics csv}

for (i in 1:length(gse.pathway.list)){
  table.name <- paste0(output.path, "Tables/", "gsea_statistics_", names(gse.pathway.list)[i] , ".csv")
  current.output <- gse.pathway.list[[i]]
  current.output$set <- vapply(current.output$set, paste, collapse = ", ", character(1L))
      write.csv(current.output, file = table.name, 
          row.names = F) 
}
```


6) Expression Table(s)
===================================== 

Gene(set) expression tables, stratified by clusters and sample barcodes. 

Row {.tabset}
-------------------------------------

```{r res4, echo = FALSE, eval = TRUE, message=TRUE, warning=FALSE}
out <- flex.multiTabTables(df.expression.list, "df.expression.list")
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save expression csv}

for (i in 1:length(df.expression.list)){
  table.name <- paste0(output.path, "Tables/", "expression_", names(df.expression.list)[i] , ".csv")
      write.csv(df.expression.list[[i]], file = table.name, row.names = F) 
}
```





```{r DEG query }

# 7) DEG
# ===================================== 
# Differential expression statistics for gene(set) queries. 
### DEG Query Genes
# write.csv(all.markers, file = paste0(output.path, "Tables/", "differential_expression_analysis.csv"), row.names = F) 
# flex.asDT(all.markers)
```

7) Marker List
===================================== 

Gene(set) tables used in analysis. 

### Marker List

```{r}

write.csv(moi.df, file = paste0(output.path, "Tables/", "query_list.csv"), row.names = F) 
flex.asDT(moi.df)
```

```{r save results}

# Update analysis log
n.cells.analyzed <- ncol(so.query)
df.log <- addLogEntry("N Cells", n.cells.analyzed, df.log, "n.cells.analyzed")
df.log <- addLogEntry("Correlation Metric", cor.method, df.log, "cor.method")
df.log <- addLogEntry("Query Markers", markers_of_interest, df.log, "markers_of_interest")
df.log <- addLogEntry("Seurat Assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")
if (exists("exp.mat")) df.log <- addLogEntry("N genes for correlation", nrow(cor.mat), df.log, "nrow(cor.mat)")
if (exists("genes.not.found")) df.log <- addLogEntry("Genes not found", genes.not.found, df.log, "genes.not.found")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_9 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}
out1 <- flex.multiTabLogs(module.logs)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 9)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_9)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_9, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
# if (save.pdf){
#   try({
#     pdf.list <- list.files (path = paste0(output.path, "PDF/") )
#     pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
#     
#     pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
#   }, silent = T)
# }


```
