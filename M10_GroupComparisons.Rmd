---
title: "Group Comparison"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", 
                   "DT", "flexdashboard", "ggpmisc", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db",
                   "RColorBrewer", "cowplot", "WGCNA", "viridis")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```


```{r parameter specification}


# query input
# input.file <- "Module1_invivo_EMT6_screen_metaDAta_270320.Rdata"
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "Module1_pilot6_invitroGBM_updatedBarcodes_290220.Rdata"
# input.file <- "Module2_Renca_cell_nuc_sci_T12_4000ds_Celsius_integrated_240220.Rdata"


cluster.resolution <- c(0.5)

# subsample factor (for downsampling)
subsample_factor <- 1

which.species <- "Mm"

# grouping (list specifying group compositions); supports indirect matching 
# group.field <- "batch" # batch used when using intergration dataset
group.field <- "Barcode"

# group.list <- list(GL261 = "GL261",
#                    CT2A = "CT2A")

group.list <- list(WT = "WT",
                   C68 = "C68")


# specify which group is reference/control group (NA if unspecified)
# which.reference <- NA 
# which.reference <- "ctrl.0238"
 # which.reference <- "GL261"
which.reference <- "WT" # specify whcih group to use as reference (e.g., DEG compared to what?)

# compare groups flag
# if F, direct comparison of groups. If T, pairwise comparison of groups within clusters. 
# note that if F, cluster resolution is ignored and forced to 0
compare.within.clusters.flag <- T

# DEG thresholds
lfc.threshold <- 0.25
p.threshold <- 0.05
 deg.min.pct <- 0.1
only.pos <- F # 

# print inline flag
print.inline <- F

```





```{r analysis log}

species <- which.species
if (!exists("which.reference")) which.reference <- NA
if (compare.within.clusters.flag == F) cluster.resolution <- 0

df.log <- initiateLog("10, Group Comparison")
df.log <- addLogEntry("Input File", input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsampling factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Grouping Field", group.field, df.log, "group.field")
df.log <- addLogEntry("new field names", names(group.list), df.log, "names(group.list)")
df.log <- addLogEntry("old field names", unlist(group.list), df.log, "unlist(group.list)")
df.log <- addLogEntry("LFC threshold", lfc.threshold, df.log, "lfc.threshold")
df.log <- addLogEntry("p-value threshold", p.threshold, df.log, "p.threshold")
df.log <- addLogEntry("Positive marker flag", only.pos, df.log, "only.pos")
df.log <- addLogEntry("Compare groups within clusters", compare.within.clusters.flag, df.log, "compare.within.clusters.flag")
df.log <- addLogEntry("Reference group", which.reference, df.log, "which.reference")
df.log <- addLogEntry("Print flag", print.inline, df.log, "print.inline")

```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

if (!(exists("subset.df"))) subset.df <- "no.subset"

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "gsva", "deg"), rmv.pattern = "so", 
                         scale.reprocessed = T, neighbors.reprocessed = F, keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```




```{r get prior log history}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r group membership}
# group membership

library(viridis)

membership.n <- c()
membership.list <- list()

keep.this <- NULL
for (i in 1:length(group.list)){
  
  cur.group <- names(group.list)[order(names(group.list))][i]
  cur.pattern <- (group.list)[order(names(group.list))][[i]]
  
  u.members <- as.vector(unique(so.query@meta.data[[group.field]][grepl(cur.pattern, so.query@meta.data[[group.field]])]))
  membership.list[[cur.group]] <- u.members
  membership.n[i] <- length(u.members)
  
  if (is.null(keep.this)){
    keep.this <- grepl(cur.pattern, so.query@meta.data[[group.field]])
  } else {
    keep.this <- (keep.this | grepl(cur.pattern, so.query@meta.data[[group.field]]))
  }
  
  so.query@meta.data[["group.query"]][grepl(cur.pattern, so.query@meta.data[[group.field]])] <- cur.group
  
  
}

# ensure groups are ordered and that order is maintained throughout analysis. 
u.groups <- as.character(unique(so.query@meta.data[["group.query"]]))
u.groups <- u.groups[order(u.groups)]
so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = u.groups)
so.query <-so.query[, keep.this]


names(membership.n) <-  names(group.list)[order(names(group.list))]

if (length(group.list) == 2){
  col.end <- 0.6
} else {
  col.end <- 1
}

group.cols <- scales::viridis_pal(option = "D", end = col.end)(length(group.list))
names(group.cols) <- names(group.list)[order(names(group.list))]

membership.cols <- viridis_pal(option = "D", end = col.end)(length(as.vector(unlist(membership.list))))
names(membership.cols) <- as.vector(unlist(membership.list))

plt.umap_group <- cluster.UMAP(so.query, group.by = "group.query", cols = group.cols)
plt.umap_membership <- cluster.UMAP(so.query, group.by = group.field, cols = membership.cols,  split.by = "group.query")

if (print.inline){
  print(plt.umap_group) 
  print(plt.umap_membership)
}



```

```{r ensure reference group is correctly specified}

# ensure groups are ordered correctly
if (is.na(which.reference)){
  
  available.levels <- levels(so.query@meta.data[["group.query"]])
  so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = available.levels[available.levels %in% unique(so.query@meta.data[["group.query"]])])
  
  which.reference <- levels(so.query@meta.data[["group.query"]])[1]
}

stopifnot(length(levels(so.query@meta.data[["group.query"]])) == 2)
grp.levels <- levels(so.query@meta.data[["group.query"]])
group.order <- which.reference
group.order <- c(group.order, grp.levels[grp.levels != which.reference])

so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = group.order)

# specify reference and comparison groups
reference.group <- group.order[1]
comparison.group <- group.order[2]

```

```{r, warning = FALSE, message = FALSE}

so.query.2 <- so.query

# Visualization
p1.dim <- DimPlot(so.query.2, reduction = "umap", group.by = "group.query") + xlab("UMAP 1") + ylab("UMAP 2")
p2.dim <- DimPlot(so.query.2, reduction = "umap", label = TRUE) + xlab("UMAP 1") + ylab("UMAP 2")

if (print.inline){
  cowplot::plot_grid(p1.dim, p2.dim)
}

```



```{r get conserved markers}

# get unique clusters
u.clusters <- as.numeric(as.character(unique((so.query.2@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]

# initiate results list
conserved.markers.list <- list()

which.assay.cons <- "RNA"
if (!(which.assay.cons %in% names(so.query.2@assays))) which.assay.cons <- DefaultAssay(so.query.2)

# oncly get conserved markers if multiple clusters available
if (length(u.clusters) > 1){

  # iterate through each cluster
  for (i in 1:length(u.clusters)){
    
    # check if any subgroups have fewer than 3 cells - if yes, skip to next cluster
    n.cell.cur <-  as.vector(table(so.query.2@meta.data[["group.query"]][so.query.2@meta.data[["seurat_clusters"]] %in% u.clusters[i]])) 
    if (any(n.cell.cur < 3)) next
    
    # find DEG that are conserved across groups
    conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- FindConservedMarkers(so.query.2, 
                                                                                                        ident.1 = u.clusters[i], 
                                                                                                        grouping.var = "group.query", 
                                                                                                        verbose = FALSE,
                                                                                                        min.pct = deg.min.pct,
                                                                                                        assay = which.assay.cons, 
                                                                                                        logfc.threshold = lfc.threshold,
                                                                                                        max.cells.per.ident = 200,
                                                                                                        return.thresh = p.threshold)
    
    
    
    # store results
    conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- as.data.frame(apply(conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]], 2, signif, 3) )
    
  }
  
}

```



```{r plot conserved, fig.height=6, fig.width=10}

plt.cg.umap <- list()
plt.cg.vln <- list()

for (i in 1:length(u.clusters)){
  
  df.cons <-  conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  df.cons$genes <- rownames(df.cons)
  
  df.cons.adj <- df.cons[df.cons$minimump_p_val<0.05, ]
  
  if (!is.null(df.cons.adj)){
    df.cons.filtered <- df.cons.adj %>% 
      dplyr::arrange(desc(minimump_p_val)) %>%
      dplyr::top_n(n = 6, wt = -minimump_p_val) %>%
      dplyr::arrange((minimump_p_val))
    
    # get feature plot
    plt.cg <- FeaturePlot(so.query.2, features = df.cons.filtered$genes, 
                          split.by = "group.query", cols = c("grey", "red"), order = T, combine = F) 
    
    # clear axes
    plt.cg <- lapply(plt.cg, function(x){x + NoLegend() +  NoAxes() + theme(axis.title.y = element_text(angle = 90))})  
    
    # get group names (ordered)
    split.names <- names(group.list)[order(names(group.list))]
    
    plots <- plt.cg
    nsplits <- 2
    features <-  df.cons.filtered$genes
    
    # assign labels
    idx <- 1
    for (j in which(x = 1:length(x = plots)%%length(x = features) ==   1)) {
      plots[[j]] <- plots[[j]] + ylab(split.names[idx])
      idx <- idx + 1
    }
    
    # combine and store sorted plots
    plt.cg.umap[[paste("c", as.character(u.clusters[i]), sep = "")]]  <- CombinePlots(plots, nrow = length(group.list)) 

    
    plt.cg.vln[[paste("c", as.character(u.clusters[i]), sep = "")]] <- VlnPlot(so.query.2, features = df.cons.filtered$genes, split.by = "group.query", group.by = "seurat_clusters", pt.size = 0, combine = FALSE)
    
    if (nrow(df.cons.filtered) > 0){
      if (print.inline){
        
        print( plt.cg.umap[[paste("c", as.character(u.clusters[i]), sep = "")]])
        
        print(CombinePlots(plots =   plt.cg.vln[[paste("c", as.character(u.clusters[i]), sep = "")]] , nrow = 2))
      }
      
    }
  }
  
}

# plt.cg.vln
```



```{r plot conserved markers}

plt.cmarkers.scatter <- list()

if (length(conserved.markers.list)>0){
  
  for (i in 1:length(conserved.markers.list)){
    
    which.cluster <- names(conserved.markers.list)[i]
    cur.cons.markers <- conserved.markers.list[[which.cluster]]
    cur.cons.markers$gene <- rownames(cur.cons.markers)
    
    x.var.name <- paste(names(group.list)[order(names(group.list))][1], "_avg_logFC", sep = "")
    y.var.name <- paste(names(group.list)[order(names(group.list))][2], "_avg_logFC", sep = "")
    plt.cmarkers.scatter[[which.cluster]] <- cur.cons.markers %>%
      dplyr::arrange(-minimump_p_val) %>%
      ggplot(aes(x = get(x.var.name), y = get(y.var.name), size = -log10( minimump_p_val),  color = -log10( minimump_p_val))) + 
      geom_abline(slope = 1, intercept = 0, linetype = "dashed", alpha = 0.5) + 
      geom_hline(yintercept = 0) + 
      geom_vline(xintercept = 0) + 
      xlab(names(group.list)[order(names(group.list))][1]) + 
      ylab(names(group.list)[order(names(group.list))][2])+ 
      geom_text(aes(label = gene)) + 
      ggtitle(paste("Conserved Markers: ", which.cluster, sep = "")) + 
      theme_miko(legend = T) + 
      labs(color = "-log(p)", size = "-log(p)", caption = "Differential-genes that are conserved across queried conditions; p<0.05")
    
    if (print.inline) print(plt.cmarkers.scatter[[which.cluster]] ) 
    
  }
}

```



```{r differential expression (between clusters), fig.height=8, fig.width=10, warning = FALSE, message = FALSE}

# create seurat copy - label identities
so.query.3 <- so.query.2
so.query.3$cluster.group <- paste(Idents(so.query.3), so.query.3@meta.data[["group.query"]], sep = "_")
so.query.3$cluster.orig <- Idents(so.query.3)
Idents(so.query.3) <- "cluster.group"

# get cluster group averages
e.mat <- getExpressionMatrix(so = so.query.3, which.data = "data")
u.cg <- as.character(unique(Idents(so.query.3)))

cg.mat <- matrix(nrow = nrow(e.mat), ncol = length(u.cg))
for (i in 1:length(u.cg)){
  which.match <- Idents(so.query.3) %in% u.cg[i]
  if (sum(which.match) < 3) next
   cg.mat[ ,i] <- log(rowMeans(expm1(x = e.mat[, which.match])) + 1)
}
colnames(cg.mat) <- u.cg
rownames(cg.mat) <- rownames(e.mat)
rm(e.mat); invisible({gc()})

# get unique clusters
u.clusters <- as.numeric(as.character(unique((so.query.3@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]

# get unique groups
levels.groups <- as.character(levels(so.query.3@meta.data[["group.query"]]))
u.groups <- unique(so.query.3@meta.data[["group.query"]])
u.groups <- levels.groups[levels.groups %in% u.groups]
so.query.3@meta.data[["group.query"]] <- factor(so.query.3@meta.data[["group.query"]], levels = u.groups)
stopifnot(length(u.groups) == 2)


which.assay.deg <- "SCT"
if (!(which.assay.deg %in% names(so.query.3@assays))) which.assay.deg <- DefaultAssay(so.query.3)

df.deg.list <- list()
df.deg.mat <- matrix(nrow = nrow(cg.mat), ncol = length(u.clusters)) 
df.deg.master <- NULL
for (i in 1:length(u.clusters)){
  
  # check if any subgroups have fewer than 3 cells - if yes, skip to next cluster
  n.cell.cur <-  as.vector(table(so.query.3@meta.data[["group.query"]][so.query.3@meta.data[["seurat_clusters"]] %in% u.clusters[i]])) 
  if (any(n.cell.cur < 3)) next
  
  # specify group names
  which.cluster <- u.clusters[i]
  group1 <- paste(which.cluster, "_", u.groups[2], sep = "")
  group2 <- paste(which.cluster, "_", u.groups[1], sep = "")
  
  # find group-wise differences (stratified by cluster)
  # Note logFC = Group 1 - Group 2
  df.deg <- FindMarkers(so.query.3,
                        assay = which.assay.deg,
                        ident.1 = group1,
                        ident.2 = group2,
                        only.pos = only.pos,
                        min.pct = deg.min.pct,
                        logfc.threshold = lfc.threshold,
                        verbose = F)
  
 
  
  df.deg[ ,c("p_val","avg_logFC","pct.1", "pct.2","p_val_adj")] <- signif(df.deg[ ,c("p_val","avg_logFC","pct.1", "pct.2","p_val_adj")], 3)
  
  df.deg$group.1 <- group1
  df.deg$group.2 <- group2
  
  # store results
  df.deg.mat[ ,i] <- cg.mat[ ,group1] - cg.mat[ ,group2]
  df.deg$genes <- rownames(df.deg)
  df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- df.deg
  df.deg.master <- bind_rows(df.deg.master, df.deg)
  
}

# label matrix
rownames(df.deg.mat) <- rownames(cg.mat)
colnames(df.deg.mat) <- as.character(u.clusters)


```


```{r plot top DEG (between conditions), fig.height=6, fig.width=13}

plt.deg.umap <- list()
plt.deg.vln <- list()
for (i in 1:length(u.clusters)){
  
  
  # store results
  df.deg <- df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  
  # get top differentially expressed genes
  df.deg.adj <- df.deg[df.deg$p_val_adj<0.05, ]
  df.deg.adj <- df.deg.adj[df.deg.adj$avg_logFC>0, ]
   if (is.null(df.deg.adj)) next
  df.deg.adj <- df.deg.adj[complete.cases(df.deg.adj),]
  df.deg.adj$logp <- -log10(df.deg.adj$p_val_adj)
  

    
    df.deg.filtered <- df.deg.adj %>% 
      dplyr::arrange(logp) %>%
      dplyr::top_n(n = 6, wt = logp) %>%
      dplyr::arrange(desc(logp))
    
    # if data remains after filetering, plot results
    if (nrow(df.deg.filtered) > 0){
      
      # get feature plot
      plt.deg <-  FeaturePlot(so.query.3, features = df.deg.filtered$genes, 
                              split.by = "group.query", cols = c("grey", "red"), order = T, combine = F)
      
      # clear axes
      plt.deg <- lapply(plt.deg, function(x){x + NoLegend() +  NoAxes() + theme(axis.title.y = element_text(angle = 90))})  
      
      # get group names (ordered)
      # split.names <- names(group.list)[order(names(group.list))]
      split.names <- names(group.list)
      
      plots <- plt.deg
      nsplits <- 2
      features <- df.deg.filtered$genes
      
      # assign labels
      idx <- 1
      for (j in which(x = 1:length(x = plots)%%length(x = features) ==   1)) {
        plots[[j]] <- plots[[j]] + ylab(split.names[idx])
        idx <- idx + 1
      }
    
          # combine and store sorted plots
    plt.deg.umap[[paste("c", as.character(u.clusters[i]), "-top", sep = "")]]  <- CombinePlots(plots, nrow = length(group.list)) 
      
      # plt.deg.umap[[paste("c", as.character(u.clusters[i]), sep = "")]] <- FeaturePlot(so.query.3, features = df.deg.filtered$genes, split.by = "group.query", cols = c("grey", "red"), order = T)
      
      plt.deg.vln[[paste("c", as.character(u.clusters[i]), "-top", sep = "")]] <- VlnPlot(so.query.3, features = df.deg.filtered$genes, split.by = "group.query", group.by = "cluster.orig", 
                         pt.size = 0, combine = FALSE)
      
      if (print.inline){
        print( plt.deg.umap[[paste("c", as.character(u.clusters[i]), "-top", sep = "")]] )
        print(CombinePlots(plots =  plt.deg.vln[[paste("c", as.character(u.clusters[i]), "-top", sep = "")]] , nrow = 2))
      }
      
    }
}


# plt.deg.umap

```



```{r plot bottom DEG (between conditions), fig.height=6, fig.width=13}

for (i in 1:length(u.clusters)){
  
  # store results
  df.deg <- df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  
    # get bottom differentially expressed genes
  df.deg.adj <- df.deg[df.deg$p_val_adj<0.05, ]
  df.deg.adj <- df.deg.adj[df.deg.adj$avg_logFC<0, ]
   if (is.null(df.deg.adj)) next
  df.deg.adj <- df.deg.adj[complete.cases(df.deg.adj),]
  df.deg.adj$logp <- -log10(df.deg.adj$p_val_adj)
  
    
    
    df.deg.filtered <- df.deg.adj %>% 
      dplyr::arrange(logp) %>%
      dplyr::top_n(n = 6, wt = logp) %>%
      dplyr::arrange(desc(logp))
    
    
    # if data remains after filetering, plot results
    if (nrow(df.deg.filtered) > 0){
      
      
      # get feature plot
      plt.deg <-  FeaturePlot(so.query.3, features = df.deg.filtered$genes, 
                              split.by = "group.query", cols = c("grey", "blue"), order = T, combine = F)
      
      # clear axes
      plt.deg <- lapply(plt.deg, function(x){x + NoLegend() +  NoAxes() + theme(axis.title.y = element_text(angle = 90))})  
      
      # get group names (ordered)
      # split.names <- names(group.list)[order(names(group.list))]
      split.names <- names(group.list)
      
      plots <- plt.deg
      nsplits <- 2
      features <- df.deg.filtered$genes
      
      # assign labels
      idx <- 1
      for (j in which(x = 1:length(x = plots)%%length(x = features) ==   1)) {
        plots[[j]] <- plots[[j]] + ylab(split.names[idx])
        idx <- idx + 1
      }
    
          # combine and store sorted plots
    plt.deg.umap[[paste("c", as.character(u.clusters[i]), "-bottom", sep = "")]]  <- CombinePlots(plots, nrow = length(group.list)) 
      plt.deg.vln[[paste("c", as.character(u.clusters[i]), "-bottom", sep = "")]] <- VlnPlot(so.query.3, features = df.deg.filtered$genes, split.by = "group.query", group.by = "cluster.orig", 
                         pt.size = 0, combine = FALSE)
    
      
      if (print.inline){
        print(plt.deg.umap[[paste("c", as.character(u.clusters[i]), "-bottom", sep = "")]])
        print(CombinePlots(plots =   plt.deg.vln[[paste("c", as.character(u.clusters[i]), "-bottom", sep = "")]] , nrow = 2))
      }
      
    }
  
  
}


# plt.deg.umap

```



```{r pairwise expression plot, warning=FALSE, message=FALSE}

  which.x <- names(group.list)[order(names(group.list))][1]
which.y <- names(group.list)[order(names(group.list))][2]
u.clusters <- as.numeric(as.character(unique((so.query.2@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]
plt.pairwise.list <- list()

for (i in 1:length(u.clusters)){
  
  # get current cluster
  which.cluster <- u.clusters[i]
  
  # get DEGs
  df.deg <- df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  
  # get top differentially expressed genes
  df.deg.adj <- df.deg[df.deg$p_val_adj<0.1, ]
  
  try({if (is.null(df.deg.adj)){next} }, silent = T)
  try({if (nrow(df.deg.adj) == 0){next} }, silent = T)
  
  # ranked by signed lop p 
  df.deg.adj <- df.deg.adj[complete.cases(df.deg.adj),]
  df.deg.adj$logp <- -log10(df.deg.adj$p_val_adj)
  df.deg.adj$logp <- df.deg.adj$logp * sign(df.deg.adj$avg_logFC)
  
  # get top genes
  df.deg.filtered.top <- df.deg.adj %>% 
    dplyr::arrange(logp) %>%
    dplyr::top_n(n = 40, wt = logp) %>%
    dplyr::arrange(desc(logp))
  df.deg.filtered.top <- df.deg.filtered.top[df.deg.filtered.top$logp > 0, ]
  
  # get bottom genes
  df.deg.filtered.bottom <- df.deg.adj %>% 
    dplyr::arrange(desc(logp)) %>%
    dplyr::top_n(n = 40, wt = -logp) %>%
    dplyr::arrange(((logp)))
  df.deg.filtered.bottom <- df.deg.filtered.bottom[df.deg.filtered.bottom$logp < 0, ]
  
  # combine top and bottom genes
  genes.to.label <- c(df.deg.filtered.top$genes, df.deg.filtered.bottom$genes)
  colors.to.label <- c(rep("tomato", nrow(df.deg.filtered.top)), rep("skyblue", nrow(df.deg.filtered.bottom)))
  
  # get average expression profile
  sub.pop <- subset(so.query.2, idents = which.cluster)
  Idents(sub.pop) <- "group.query"
  sub.pop <- rmDuplicateGenes(sub.pop)
  avg.sub.pop <- log1p(AverageExpression(sub.pop, verbose = FALSE)[[1]])
  avg.sub.pop$gene <- rownames(avg.sub.pop)
  
  # specify gene coloring
  avg.sub.pop$color <- "grey90"
  avg.sub.pop$color[avg.sub.pop$gene %in% df.deg.adj$gene[df.deg.adj$avg_logFC > 0]] <- "tomato"
  avg.sub.pop$color[avg.sub.pop$gene %in% df.deg.adj$gene[df.deg.adj$avg_logFC < 0]] <- "skyblue"
  
  avg.sub.pop$dif <- abs(avg.sub.pop[ ,which.y] - avg.sub.pop[ ,which.x])
  avg.sub.pop <- avg.sub.pop[complete.cases(avg.sub.pop$dif) , ]
  avg.sub.pop <- avg.sub.pop %>% dplyr::arrange(dif)
  # generate plot
  p1 <- avg.sub.pop %>%
    ggplot(aes(get(which.x), get(which.y))) + 
    # geom_text(aes(label = gene, size = dif), alpha = 0.25, color = avg.sub.pop$color) +
    geom_point(aes(size = dif), alpha = 0.25, color = avg.sub.pop$color) +
    ggtitle(paste("Cluster ", which.cluster, sep = "")) + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") + 
    scale_x_continuous(trans='log10') +
    scale_y_continuous(trans='log10') + 
    xlab(paste0(which.x, " Expression")) + 
    ylab(paste0(which.y, " Expression")) + 
    labs(size = "|Dif|", caption = "Highlighted p adjusted < 0.1") + 
    theme_miko(legend = T)
  
  # add labels to plot
  p1 <- LabelPoints(p1, points = genes.to.label, repel = T, color = colors.to.label)
  
  plt.pairwise.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- p1
  
  if (print.inline){
    print(p1)
  }
  
}
# plt.pairwise.list
# plt.pairwise.list
```


```{r symbol2entrez}

my.symbol <- rownames(so.query.3)
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

```




```{r get annotation pathways}

# # get gene lists for pathway annotation
species <- which.species
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = "BP", species = which.species)
pathways <- pathways.go

```


```{r GO enrich DEG, warning = FALSE}

# enrich DEGs (differential)
gse.pathway.list <- list()
gse.pathway.deg <- NULL

for (i in 1:length(u.clusters)){
  
  which.cluster <- u.clusters[i]
  
  # get DEGs
  # df.deg <- df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]]
  df.deg <- data.frame(df.deg.mat[ ,as.character(which.cluster)])
  colnames(df.deg) <- "logFC"
  
  # ranked by signed lop p 
   if (is.null(df.deg)) next
  gene.list <- df.deg$logFC
  names(gene.list) <- rownames(df.deg)
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  # pathway gsea enrichment
  
# fgseaMultilevel {fgsea}
  gse.pathway <- fgsea::fgsea(pathways, gene.list.clean, nperm=1000, maxSize=500)
  # gse.pathway <- fgsea::fgseaMultilevel (pathways, gene.list.clean, maxSize=500)

  if (nrow(gse.pathway) == 0) next
  
  gse.pathway$cluster <- paste("c", as.character(u.clusters[i]), sep = "")
  gse.pathway.deg <- bind_rows(gse.pathway.deg, gse.pathway)
  
}

# data wrangle
gse.pathway.deg[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.deg[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.deg.all <- gse.pathway.deg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
gse.pathway.deg.sig <- gse.pathway.deg.all[(gse.pathway.deg.all$pval < 0.05) & (abs(gse.pathway.deg.all$NES) >= 0.7), ]
gse.pathway.deg.sub <- gse.pathway.deg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]

# print data table
if (print.inline){
  datatable(gse.pathway.deg.sig, 
            filter = 'top',
            extensions = 'Buttons',
            options = list(pageLength = 50,
                           dom = 'Bfrtip', 
                           buttons = c('copy', 'csv', 'pdf')))
}

```





```{r enrich CG}

# get current cluster
gse.pathway.cg.list <- list()

gse.pathway.cg <- NULL

for (i in 1:length(u.clusters)){
  
  which.cluster <- u.clusters[i]
  
  # get DEGs
  df.cons <- conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  
  # prep gene list (match to EntrezID, sort)
  if (is.null(df.cons)) next
  
  # specify group names
  group1 <- paste(u.groups[1], "_avg_logFC", sep = "")
  group2 <- paste(u.groups[2], "_avg_logFC", sep = "")
  df.cons$avg_logFC <- ((df.cons[, group1]) + (df.cons[, group2]))/2
  
  df.cons$genes <- rownames(df.cons)
  
  # only keep genes which have consistent sign of logFC
  df.cons <- df.cons[ sign(df.cons[, group1]) ==  sign(df.cons[, group2]), ]
  
  gene.list.cg <- df.cons$avg_logFC
  names(gene.list.cg) <- df.cons$genes
  match.ind <- match(names(gene.list.cg), my.entrez$SYMBOL)
  names(gene.list.cg) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list.cg = sort(gene.list.cg, decreasing = TRUE)
  
  # clean list
  df.ent.cg <- data.frame(names = names(gene.list.cg), values = as.vector(gene.list.cg))
  df.ent.cg <- df.ent.cg[complete.cases(df.ent.cg), ]
  df.ent.cg <- df.ent.cg[!is.infinite(df.ent.cg$values), ]
  gene.list.cg.clean <- df.ent.cg$values
  names(gene.list.cg.clean) <- df.ent.cg$names

    # pathway gsea enrichment
  gse.pathway <- fgsea::fgsea(pathways, gene.list.cg.clean, nperm=1000, maxSize=500)
  
  if (nrow(gse.pathway) == 0) next
  
  gse.pathway$cluster <- paste("c", as.character(u.clusters[i]), sep = "")
  gse.pathway.cg <- bind_rows(gse.pathway.cg, gse.pathway)

}

if (is.null(gse.pathway.cg)){
  
  gse.pathway.cg <- NULL
  gse.pathway.cg.all <- NULL
  gse.pathway.cg.sub <- NULL
} else {
  
  
  gse.pathway.cg[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.cg[ ,c("ES","NES", "pval", "padj")], 3)
  
  gse.pathway.cg.all <- gse.pathway.cg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
  
  gse.pathway.cg.sub <- gse.pathway.cg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
  
  
  # print data table
  if (print.inline){
    datatable(gse.pathway.cg.all, 
              filter = 'top',
              extensions = 'Buttons',
              options = list(pageLength = 50,
                             dom = 'Bfrtip', 
                             buttons = c('copy', 'csv', 'pdf')))
  }
  
}

```

```{r pooled group DEG}

# set correct ID
cur.id <- Idents(so.query.3)
Idents(so.query.3) <- so.query.3@meta.data[["group.query"]]



# get cluster group averages
e.mat <- getExpressionMatrix(so = so.query.3, which.data = "data")
u.cg <- as.character(unique(Idents(so.query.3)))

dif.mat <- matrix(nrow = nrow(e.mat), ncol = length(u.cg))
for (i in 1:length(u.cg)){
  which.match <- Idents(so.query.3) %in% u.cg[i]
  if (sum(which.match) < 3) next
   dif.mat[ ,i] <- log(rowMeans(expm1(x = e.mat[, which.match])) + 1)
}
colnames(dif.mat) <- u.cg
rownames(dif.mat) <- rownames(e.mat)
rm(e.mat); invisible({gc()})
dif.mat <- data.frame(dif.mat)
dif.mat$gene <- rownames(dif.mat) 
dif.mat$logfc <- dif.mat[ , comparison.group] -  dif.mat[ , reference.group]

# deg master for group comparison

  df.deg.pool <- FindMarkers(so.query.3,
                        assay = which.assay.deg,
                        ident.1 = comparison.group,
                        ident.2 = reference.group,
                        only.pos = F,
                        min.pct = 0.01,
                        logfc.threshold = 0.1,
                        verbose = F)
  
  df.deg.pool[ ,c("p_val","avg_logFC","pct.1", "pct.2","p_val_adj")] <- signif(df.deg.pool[ ,c("p_val","avg_logFC","pct.1", "pct.2","p_val_adj")], 3)
  
  df.deg.pool$group.1 <- comparison.group
  df.deg.pool$group.2 <- reference.group
  
```

```{r}
# 
#   # # compute group-wise averages ################################################
#   # 
#   # mat.rz <- mat.r <- matrix(nrow = length(gene.names), ncol = length(gene.names))
#   # for (i in 1:length(gene.names)){
#   #  # for (i in 1){
#   #   gene.i <- gene.names[i]
#   #   
#   #   group.i <-  gene.group.bin[[gene.i]]
#   #   for (j in 1:length(gene.names)){
#   #     gene.j <- gene.names[j]
#   #      group.j <-  gene.group.bin[[gene.j]]
#   #     # query.features <- c(gene.i, gene.j)
#   #     
#   #     if (gene.i == gene.j){
#   #       r <- 1
#   #       rz <- Inf
#   #     } else {
#   # 
#   #       h.int <- unlist(lapply(seq_len(length(group.i)), function(x) {
#   #         cor(group.i[[x]], group.j[[x]], method = "spearman")
#   #       }))
#   #       
#   #       # lapply(group.i)
#   #       
#   #       h.int[is.na(h.int)] <- 0
#   #       
#   #       r <- mean(h.int, na.rm = T)
#   #       r.s <- sd(h.int, na.rm = T)
#   #       
#   #       if (r == 0 & r.s == 0){
#   #         rz <- 0
#   #       } else {
#   #         rz <- r/sd(h.int, na.rm = T)
#   #       }
#   #       
#   #     }
#   #     
#   #     mat.rz[i,j] <- rz
#   #     mat.r[i,j] <- r
#   #   
#   #   }
#   # }
#   # 
#   # rownames(mat.rz) <- rownames(mat.r) <- gene.names
#   # colnames(mat.rz) <- colnames(mat.r) <- gene.names
#   # 
# 
# 
# # plot_hexbin_feature(
# #   so.query.4,
# #   mod = "SCT",
# #   type = "data",
# #   feature=c("Meg3", "Rian"),
# #   action = "mean",
# #   title = NULL,
# #   xlab = NULL,
# #   ylab = NULL,
# #   lower_cutoff = 0,
# #   upper_cutoff = 1
# # )
# # 
# # plot_hexbin_interact (
# #   so.query.4,
# #   mod = c("SCT", "SCT"),
# #   type = c("data", "data"),
# #   feature=c("Lif", "Meg3"),
# #   interact = "corr_spearman"
# # )
# 
#   # out <- .extract_hexbin(so.query.4)
#   # cID <- .extract_cID(sce)
#   
# prepDataFun <- function (sce, mod="RNA", type, feature) {
#     if(mod=="RNA"){
#         x <- GetAssayData(sce, type)    
#         ind <- match(feature, rownames(x))
#         if (is.na(ind)) {
#             stop("Gene cannot be found.")
#         }
#         x <- as.numeric(x[ind,])
#   } else{
#     if(!mod %in% names(sce)){
#         stop("Specify a valid modularity.")
#     }
#     if(!type %in% slotNames(GetAssay(sce, mod))){
#         stop("Specify a valid assay type.")
#     }
#     x <- GetAssayData(sce, assay=mod, type)
#     ind <- match(feature, rownames(x))
#     if (is.na(ind)) {
#         stop("Feature cannot be found.")
#     }
#     x <- as.numeric(x[ind,])
#   }
#   return(x)
# } 
# 
# # hexInteractHelper <- function(first_x, second_x,  out, cID, interact,
# #     feature, title, xlab, ylab) {
# #   
# #     hh <- .interact_hexbin_function(first_x, second_x, interact, cID)
# #     out <- as_tibble(out)
# #     
# #     if(is.null(title)){
# #       title <- paste0(interact, "_", feature[1], "_", feature[2])
# #     }
# #     
# #     out$interact <- hh
# #   
# #     .plot_hexbin(out, colour_by="interact", action="interact",
# #         title=title, xlab=xlab, ylab=ylab)
# # }
# # 
# 
# inheractHex <- function(first_x, second_x, interact, cID) {
#   if (interact == "corr_spearman") {
#     func_if <- !(is.numeric(first_x) | is.numeric(second_x))
# 
#     if (func_if) {
#       stop("Features need to be numeric.")
#     } else {
#       res_first <- tapply(first_x, cID, FUN = function(z) z)
#       res_second <- tapply(second_x, cID, FUN = function(z) z)
#       
#       
#       d <- data.frame(cID=cID,
#                first_x=first_x,
#                res_second)
#       ss <- split.data.frame(d,d$cID)
#       
#       
#       # which.omit.first <- unlist(lapply(res_first, function(x) (length(x) < 3) )) # | (sd(x, na.rm = T) == 0)
#       # which.omit.second <- unlist(lapply(res_second, function(x) (length(x) < 3) )) # | (sd(x, na.rm = T) == 0)
#       
#       # which.omit.all <- which.omit.first | which.omit.second
#       
#       # res_first <- res_first[!which.omit.all]
#       # res_second <- res_second[!which.omit.all]
# 
#       res <- unlist(lapply(seq_len(length(res_first)), function(x) {
#         cor(res_first[[x]], res_second[[x]], method = "spearman")
#       }))
#       
#       res[is.na(res)] <- 0
# 
#       return(res)
#     }
#   }
# }
# 
#   
# 
#   
#   
#   query.features <- c("Lif", "Meg3")
#   
#     first_x <- prepDataFun(so.query.4,DefaultAssay(so.query.4),"data", query.features[1])
#   second_x <- prepDataFun(so.query.4,DefaultAssay(so.query.4), "data", query.features[2])
#   
#   h.int <- inheractHex(first_x, second_x, interact = "corr_spearman", cID)
#   h.int <- h.int[!is.na(h.int)]
#   
#   hist(h.int)
#   
#   mean(h.int)
#   sd(h.int)
#   median(h.int)
#   
#   rz <- mean(h.int, na.rm = T)/sd(h.int, na.rm = T)
#   
#   
#   cID <- so.query.4@misc$hexbin[[1]]
#   out <- so.query.4@misc$hexbin[[2]]  
#   
#   # specify analysis 
#   
#   # cor type
#   cor.type <- "between" #options: 'within' -
#   
#   
#  within-cluster correlations; 'between' - between-cluster correlations
#   
```


```{r runGSEA helper function}

runGSEA <- function(gene, value, species, db = "GO", my.entrez = NULL, my.pathway = NULL, min.size = 3, 
                    max.size = 300, do.plot = T, plot.top.n = 10){
  
  if (is.null(my.entrez)){
    # get entrez to gene symbol mapping
    my.symbol <-gene
    my.entrez <- sym2entrez(my.symbol, my.species = species )
    my.entrez <- my.entrez[complete.cases(my.entrez), ]
  }
  
  if (is.null(my.pathway)){
    # get pathways
    my.pathway <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = db, ontology = "BP", species = species)    
  }
  
  # prep genelist
  gene.list <- value
  names(gene.list) <- gene
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  # pathway gsea enrichment
  
  # fgseaMultilevel {fgsea}
  gse.pathway <- fgsea::fgsea(my.pathway, gene.list.clean, nperm=1000, minSize = min.size, maxSize=max.size)
  
  # make human readable
  gse.pathway <- gse.pathway
  gse.pathway$set <- lapply(gse.pathway$leadingEdge, 
                            mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
  gse.pathway$set <- lapply(gse.pathway$set, paste,collapse = ", ")
  gse.pathway <- gse.pathway %>% dplyr::select(-c("leadingEdge"))
  
  if (do.plot){
    # get top GSEA
    gse.pathway.top <- bind_rows((gse.pathway %>% dplyr::filter(NES > 0) %>% dplyr::arrange(log1p(pval)))[1:plot.top.n], 
                                 (gse.pathway %>% dplyr::filter(NES < 0) %>% dplyr::arrange(log1p(pval)))[1:plot.top.n])
    
    # plot
    plt.gsea <- gse.pathway.top %>%
      ggplot(aes(x = NES, y = reorder(pathway, NES), fill = -log1p(pval), size = -log1p(pval))) + 
      geom_point(pch=21) + 
      theme_miko(legend = T) + 
      xlab("NES") + ylab("") +
      labs(title = "GSEA", fill = "-log(p)", size =  "-log(p)") + 
      geom_vline(xintercept = 0, linetype = "dashed") + 
      viridis::scale_fill_viridis(option ="B")    
    
    return(list(
      gse.pathway = gse.pathway,
      gse.pathway.top = gse.pathway.top,
      plt.gsea = plt.gsea
    ))
  } else {
    return(gse.pathway)
  }
  
}
```


```{r filter expression matrix and calculate similary matrix (for network analysis), warning = FALSE, message=FALSE}


sim.type <- "bin" #option: bin vs single

# min expression

# entire matrix
which.data <- "data"
exp.mat.complete <- getExpressionMatrix(so.query, which.data = which.data)


plt.grc <- geneRepCurve(so.query)

# variable gene only matrix
use.var <- F
if (use.var){
  exp.mat <- getExpressionMatrix(so.query, only.variable = use.var, which.data = which.data, use.additional.genes = NA)
} else {
  exp.mat <- exp.mat.complete
}

# max var n
if (DefaultAssay(so.query) == "SCT"){
  max.var.n <- 8000
  df.var <- so.query@assays[["SCT"]]@meta.features
  df.var$genes <- rownames(df.var)
  top.var.df <- df.var %>% top_n(max.var.n, (sct.residual_variance))
  top.var <- top.var.df$genes

    exp.mat <- exp.mat[rownames(exp.mat) %in% unique(top.var), ]

}


which.col <- colnames(so.query)
  which.row <- unique(rownames(exp.mat))

 exp.mat <- exp.mat.complete[rownames(exp.mat.complete) %in% which.row, colnames(exp.mat.complete) %in% which.col]
 exp.mat <- exp.mat[!duplicated(rownames(exp.mat)), ]
 

# transpose expressio matrix (genes are columns)
t.exp.mat <- t(exp.mat)
datExpr <- as.matrix(t.exp.mat)
SubGeneNames=colnames(datExpr)
  datExpr.orig.noz <- datExpr

# split into two groups
de.orig.1 <- datExpr.orig.noz[rownames(datExpr.orig.noz) %in% colnames(so.query.3)[grepl(reference.group, so.query.3@active.ident)], ]
de.orig.2 <- datExpr.orig.noz[rownames(datExpr.orig.noz) %in% colnames(so.query.3)[grepl(comparison.group, so.query.3@active.ident)], ]


# ensure sample sizes are balanced across groups
output.mat <- balanceMatrixSize(de.orig.1, de.orig.2, method = "match.max")
de.1 <- output.mat[["de.1"]]
de.2 <- output.mat[["de.2"]]
datExpr.noz <- output.mat[["de.all"]]

# assert unique names
rownames(de.1) <- make.names(rownames(de.1), unique = T)
rownames(de.2) <- make.names(rownames(de.2), unique = T)
rownames(datExpr.noz) <- make.names(rownames(datExpr.noz), unique = T)



```


```{r schex hex bins, warning = FALSE, message = FALSE, fig.width = 14, fig.height=5, include = FALSE}

library(schex)
so.query.4 <- make_hexbin(so.query.3, 20, dimension_reduction = "UMAP")
  cID <- so.query.4@misc$hexbin[[1]]
  out <- so.query.4@misc$hexbin[[2]]

  # specfiy genesets ###########################################################
# exp.mat <- getExpressionMatrix(so.query, only.variable = T, which.data = "scale", use.additional.genes = NA)
  gene.names <- rownames(exp.mat)
  # gene.names <- c("Meg3", "Rian", "Mirg", gene.names)
  
  
  
  # get data partitions ########################################################
  u.bin <- unique(cID)
  be.mat <- matrix(nrow = length(gene.names), ncol = length(u.bin))
  be.mat.ref <- matrix(nrow = length(gene.names), ncol = length(u.bin))
  be.mat.comp <- matrix(nrow = length(gene.names), ncol = length(u.bin))
  
  gene.group.bin <- list()
  
  which.ref <- so.query.4@meta.data[["group.query"]] %in% reference.group
  which.comp <- so.query.4@meta.data[["group.query"]] %in% comparison.group
  
  df.group.gene.comp <- NULL
  # for (i in 1:length(gene.names)){
    
n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)


  # single.exp <- prepDataFun(so.query.4,DefaultAssay(so.query.4),"data", gene.names[i])
# e.mat <- getExpressionMatrix(so.query.4, which.data = which.data)
# e.mat.sub <- e.mat[rownames(e.mat)  %in% gene.names, ]
e.mat.sub <- exp.mat
e.mat.sub <- e.mat.sub[!duplicated(rownames(e.mat.sub)), ]

bin.e.list <- list()
bin.e.list <- foreach(i = 1:length(gene.names), .packages = c("dplyr", "Seurat"))  %dopar% {
# for (i in 1:length(gene.names)){
  
  single.exp <- as.vector(e.mat.sub[ rownames(e.mat.sub) %in% gene.names[i], ])
    group.exp <- tapply(single.exp, cID, FUN = function(z) z)
    
    single.exp.ref <- single.exp; single.exp.ref[which.comp] <- NA
    single.exp.comp <- single.exp; single.exp.comp[which.ref] <- NA
    
    group.exp.ref <- tapply(single.exp.ref, cID, FUN = function(z) z)
    group.exp.comp <- tapply(single.exp.comp, cID, FUN = function(z) z)
    
    gene.avg.ref <- (unlist(lapply(group.exp.ref, function(x) log(mean(expm1(x)+1, na.rm = T)))))
    gene.avg.comp <- (unlist(lapply(group.exp.comp, function(x) log(mean(expm1(x)+1, na.rm = T)))))
    
    df.rc <- data.frame(x = gene.avg.ref, y = gene.avg.comp)
    df.rc <- df.rc[complete.cases(df.rc), ]

    df.cor.current =  data.frame(gene =  gene.names[i], r =  cor(df.rc$x, df.rc$y, method = "spearman"), 
                                           x = mean(df.rc$x, na.rm = T), sx = sd(df.rc$x, na.rm = T), 
                                 y =  mean(df.rc$y, na.rm = T), sy = sd(df.rc$y, na.rm = T), n = nrow(df.rc))
    
    df.cor.current$dif <- df.cor.current$y - df.cor.current$x
     df.cor.current$sp <- sqrt((df.cor.current$sx^2) + (df.cor.current$sy^2))
 df.cor.current$z <- df.cor.current$dif/df.cor.current$sp
 df.cor.current$sig.dig <- df.cor.current$z > 1.96
    
    gene.avg <- (unlist(lapply(group.exp, function(x) log(mean(expm1(x)+1)))))
 
    
    list(
      group.exp = group.exp,
      gene.avg.ref = gene.avg.ref,
      gene.avg.comp = gene.avg.comp,
      gene.avg = gene.avg,
      df.cor.current = df.cor.current,
      gn =  gene.names[i]
    )
}

stopCluster(cl)

for (i in 1:length(bin.e.list)){
  gene.name <- bin.e.list[[i]]$gn
  be.mat[i ,] <- bin.e.list[[i]]$gene.avg
  be.mat.ref[i ,] <- bin.e.list[[i]]$gene.avg.ref
  be.mat.comp[i ,] <- bin.e.list[[i]]$gene.avg.comp
  df.group.gene.comp <- bind_rows(df.group.gene.comp,  bin.e.list[[i]]$df.cor.current)
  gene.group.bin[[gene.name]] <- bin.e.list[[i]]$group.exp
}
rownames(be.mat) <- rownames(be.mat.ref) <- rownames(be.mat.comp) <- gene.names

plt.bd.genes <- df.group.gene.comp %>%
  ggplot(aes(dif, abs(z), color = (x+y))) + 
  geom_text(aes(label = gene, size = abs(z))) + 
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")") ) + 
  # geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") +
  ylab("|z|") + 
  theme_miko(legend = T) + 
  labs(title = "Group-wise Differential Expression", subtitle = paste0(length(u.bin), " bins"),
       color = "Avg.Exp.", size = "logFC")


bd.enrich.list <- runGSEA(gene = df.group.gene.comp$gene, 
                          value = df.group.gene.comp$z,  species = which.species, 
                          db = "GO", min.size = 5, max.size = 300)

plt.bd.paths <- bd.enrich.list$plt.gsea + (xlab(paste0("NES (", comparison.group, "-", reference.group, ")")))

plt.bin.deg.ann <- cowplot::plot_grid(plt.bd.genes, plt.bd.paths, rel_widths = c(1,1.5))

if (print.inline){
  # fig.width = 14, fig.height=5
  print(plt.bin.deg.ann)
}

```



```{r compute correlations, include = FALSE}

# specify network parameters
TOM.type <- "signed"
which.network <- "signed" # 'signed', 'unsighed', or 'signed hybrid'
which.cor <- "spearman"


if (sim.type == "single"){
  # get similarity matrices ######################################################
n.workers <- list(cor = 10)


s.mat <- parCor(mat = datExpr.noz, method = which.cor, do.par = T, n.workers = n.workers$cor)
a.mat <-  sim2adj(s.mat, soft.power = 2, network.type = which.network)
s.1 <- parCor(mat = de.1, method = which.cor, do.par = T, n.workers = n.workers$cor)
s.2 <- parCor(mat = de.2, method = which.cor, do.par = T, n.workers = n.workers$cor)

# clear NAs
s.mat[is.na(s.mat)] <- 0
s.1[is.na(s.1)] <- 0
s.2[is.na(s.2)] <- 0
} else if (sim.type == "bin"){
  
  datExpr.noz.bin <- t(be.mat); rownames(datExpr.noz.bin) <- paste0("v", seq(1,nrow(datExpr.noz.bin)))
de.1.bin <-  t(be.mat.ref); rownames(de.1.bin) <- paste0("v", seq(1,nrow(de.1.bin)))
de.2.bin <-  t(be.mat.comp); rownames(de.2.bin) <- paste0("v", seq(1,nrow(de.2.bin)))

s.mat <- parCor(mat = datExpr.noz.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)
a.mat <-  sim2adj(s.mat, soft.power = 2, network.type = which.network)
s.1 <- parCor(mat = de.1.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)
s.2 <- parCor(mat = de.2.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)

# clear NAs
s.mat[is.na(s.mat)] <- 0
s.1[is.na(s.1)] <- 0
s.2[is.na(s.2)] <- 0
}


```


```{r}

# e.g., softPower=12, type='signed',
# MEDissThres=0.7
# using step-by-step network construction and module detection
# strategies

```


```{r get soft power, fig.width=10, fig.height=7}

sft <- getSoftThreshold2(s.mat, power =c(seq(1,20, by = 1)), 
                           network.type = which.network, rescale.adjacency = F, n.cores = 8, nBreaks = 16)

if (print.inline){
cowplot::plot_grid(plotlist = sft$distribution.plot, ncol = 5)
}

```

```{r optimal soft power plot}

if (print.inline){
print(sft$optimization.plot)
}

```

```{r calculate network connectivity, include = FALSE}

# get soft power
best.power <- sft[["powerEstimate"]]
if (is.na(best.power)) best.power <- 1

# TOMsimilarityFromExpr()

TOM.type = "signed"

# run WCGNA ####################################################################
output.all <- runWGCNA(e.mat = datExpr.noz, s.mat = s.mat, cor.metric = which.cor, 
                       soft.power = best.power, use.TOM = T, 
                       network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)

output.1 <- NULL
  output.1 <- runWGCNA(e.mat = de.1, s.mat = s.1, cor.metric = which.cor, 
                       soft.power = best.power, use.TOM = T, 
                       network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)  

output.2 <- NULL
  output.2 <- runWGCNA(e.mat = de.2, s.mat = s.2, cor.metric = which.cor, 
                       soft.power = best.power, use.TOM = T, 
                       network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)  

# unpack output ################################################################
s.mat <- output.all[["s.mat"]] # similar matrix
a.mat <- output.all[["a.mat"]] # adjacency matrix
w.mat <- output.all[["w.mat"]] # topological overlap matix
d.mat <- output.all[["d.mat"]] # disimilarity matix

s.1 <- output.1[["s.mat"]]
a.1 <- output.1[["a.mat"]]
w.1 <- output.1[["w.mat"]]
d.1 <- output.1[["d.mat"]] 

s.2 <- output.2[["s.mat"]]
a.2 <- output.2[["a.mat"]]
w.2 <- output.2[["w.mat"]]
d.2 <- output.2[["d.mat"]] 



w.mat <- a.mat
d.mat <- 1-w.mat

w.1 <- a.1
d.1 <- 1-w.1

w.2 <- a.2
d.2 <- 1-w.2

```




```{r TOM scaling}

# TOM matrices of different datasets may have different statistical properties. Since consensus is defined as teh component-wise minimum of two-TOMs, a bias may results. Simple scaling can mitigate the effects of different statistical properties to some degree. TOM are scales such that 95th percentile equals the 95th percentile of the female TOM. 

# scale TOM matrices
# w.1 <- tryCatch({
  # w.1 <- scaleTOM(query.TOM = w.1, reference.TOM = w.2, reference.percentile = 0.95)
# }, error = function(e){
#   return(w.1)
# }
# )


# recompute the distance matrix
d.mat <- 1-w.mat
d.1 <- 1-w.1
d.2 <- 1-w.2

# compute consensus topological overlap
w.co <- pmin(w.1, w.2) # component-wise parallel minimum of TOMs
w.dis <- pmax(w.1, w.2)
d.co <- 1-w.co
d.dis <- 1-w.dis

```


```{r connectivity comparison, fig.height = 4, fig.width=14}

# quantile normalization of 2 vectors (Hicks 2014)

# quantile normalization
x.s1 <- getConnectivity(s.1, gene.names = colnames(a.1))$wi
y.s2 <- getConnectivity(s.2, gene.names = colnames(a.2))$wi
df.xy.s <- qNorm(x.s1, y.s2, genes = colnames(a.1))

x.a1 <- getConnectivity(a.1, gene.names = colnames(a.1))$wi
y.a2 <- getConnectivity(a.2, gene.names = colnames(a.2))$wi
df.xy.a <- qNorm(x.a1, y.a2, genes = colnames(a.1))

x.w1 <- getConnectivity(w.1, gene.names = colnames(a.1))$wi
y.w2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.xy.w <- qNorm(x.w1, y.w2, genes = colnames(a.1))

# generate plots

# similarity-based connectivity plots
plt.input.xy.s <- df.xy.s %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("Original Similarity (", reference.group , ")")) + ylab(paste0("Original Similarity (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("Original Similarity") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 

# plt.output.xy.s <- df.xy.s %>%
#   ggplot(aes(x.new, y.new)) + geom_point() +  geom_smooth(color = "tomato") + geom_abline(slope = 1) +
#   xlab(paste0("Normalized Similarity (", reference.group , ")")) + ylab(paste0("Normalized Similarity (", comparison.group , ")")) +
#   theme_classic() +   ggtitle("Normalized Similarity") +
#   ggrepel::geom_text_repel(aes(x.new, y.new, label =ifelse(top.new ,as.character(genes),'')), size = 2.5, color = "black")

# adjacency-based connectivity plots
plt.input.xy.a <- df.xy.a %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("Original Adjacency (", reference.group , ")")) + ylab(paste0("Original Adjacency (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("Original Adjacency") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 

# plt.output.xy.a <- df.xy.a %>%
#   ggplot(aes(x.new, y.new)) + geom_point() +  geom_smooth(color = "tomato") + geom_abline(slope = 1) + 
#   xlab(paste0("Normalized Adjacency (", reference.group , ")")) + ylab(paste0("Normalized Adjacency (", comparison.group , ")")) + 
#   theme_classic() +   ggtitle("Normalized Adjacency") + 
#   ggrepel::geom_text_repel(aes(x.new, y.new, label =ifelse(top.new ,as.character(genes),'')), size = 2.5, color = "black") 

# TOM-based connectivity plots
plt.input.xy.w <- df.xy.w %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("Original TOM (", reference.group , ")")) + ylab(paste0("Original TOM (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("Original TOM") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 

# plt.output.xy.w <- df.xy.w %>%
#   ggplot(aes(x.new, y.new)) + geom_point() +  geom_smooth(color = "tomato") + geom_abline(slope = 1) + 
#   xlab(paste0("Normalized TOM (", reference.group , ")")) + ylab(paste0("Normalized TOM (", comparison.group , ")")) + 
#   theme_classic() +   ggtitle("Normalized TOM") + 
#   ggrepel::geom_text_repel(aes(x.new, y.new, label =ifelse(top.new ,as.character(genes),'')), size = 2.5, color = "black") 

# cowplot::plot_grid(plt.input.xy.w, plt.output.xy.w)


if (print.inline){
  # fig.height = 10, fig.width=10
 cowplot::plot_grid(plt.input.xy.s, 
                   plt.input.xy.a, 
                   plt.input.xy.w, 
                   ncol = 3)
}

```



```{r subnetwork (optional)}
# do.subnetwork <- F
# 
# if (do.subnetwork){
# 
# 
# w.co.1 <- NULL
# w.co.2 <- NULL
# 
# subnetwork.size <- 100
# n.cells <- nrow(datExpr.noz)
# n.subnetworks <- round(n.cells / subnetwork.size)
# for (i in 1:n.subnetworks){
#   
#   svMisc::progress(i, n.subnetworks)
#   
#   sample.id.1 <- sample(seq(1,nrow(de.1)), subnetwork.size)
#   sample.id.2 <- sample(seq(1,nrow(de.2)), subnetwork.size)
#   
#   mat.sub.1 <- de.1[ sample.id.1, ]
#   mat.sub.2 <- de.2[ sample.id.2, ]
#   
#   output.sub.1 <- runWGCNA(e.mat = mat.sub.1,  cor.metric = which.cor, soft.power = best.power, use.TOM = T, 
#                                network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, 
#                                rescale.adjacency = F)
#   
#   output.sub.2 <- runWGCNA(e.mat = mat.sub.2,  cor.metric = which.cor, soft.power = best.power, use.TOM = T, 
#                                network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, 
#                                rescale.adjacency = F)
#   
#   if (is.null(w.co.1)){
#     w.co.1 <- output.sub.1$w.mat
#   } else {
#     w.co.1 <- pmin(w.co.1, output.sub.1$w.mat)
#   }
#   
#     if (is.null(w.co.2)){
#     w.co.2 <- output.sub.2$w.mat
#   } else {
#     w.co.2 <- pmin(w.co.2, output.sub.2$w.mat)
#   }
#   
#   if (i == n.subnetworks) cat("Done!\n")
#   
# }
# 
# 
# 
# d.co.1 <- 1-w.co.1
# d.co.2 <- 1-w.co.2
# geneTree.all <- dist2hclust(d.mat)
# geneTree.co.1 <- dist2hclust(d.co.1)
# geneTree.co.2 <- dist2hclust(d.co.2)
# 
# w.co.all <- pmax(w.co.1, w.co.2)
# d.co.all <- 1 - w.co.all
# geneTree.co.all <- dist2hclust(d.co.all)
# 
# par(mfrow = c(1,4))
# plot(geneTree.all, xlab = "", sub = "", main = "All", labels = F, hang = 0.04)
# plot(geneTree.co.1, xlab = "", sub = "", main = "1", labels = F, hang = 0.04)
# plot(geneTree.co.2, xlab = "", sub = "", main = "2", labels = F, hang = 0.04)
# plot(geneTree.co.all, xlab = "", sub = "", main = "Consensus", labels = F, hang = 0.04)
# 
# 
# d.1 <- d.co.1
# d.2 <- d.co.2
# d.co <- d.co.all
# 
# geneTree.all <- geneTree.all
# geneTree.co <- geneTree.co.all
# geneTree.1 <- geneTree.co.1
# geneTree.2 <- geneTree.co.2
# 
#   
# }
```




```{r, fig.width=10, fig.height=3}

library(flashClust)
# get dendrograms
geneTree.all <- dist2hclust(d.mat)
geneTree.co <- dist2hclust(d.co)
geneTree.1 <- dist2hclust(d.1)
geneTree.2 <- dist2hclust(d.2)
geneTree.dif <- dist2hclust(d.dis)

if (print.inline){
par(mfrow = c(1,5))
plot(geneTree.all, xlab = "", sub = "", main = "All", labels = F, hang = 0.04)
plot(geneTree.co, xlab = "", sub = "", main = "Consensus", labels = F, hang = 0.04)
plot(geneTree.1, xlab = "", sub = "", main = paste0("Group 1: ", reference.group), labels = F, hang = 0.04)
plot(geneTree.2, xlab = "", sub = "", main = paste0("Group 2: ", comparison.group), labels = F, hang = 0.04)
plot(geneTree.dif, xlab = "", sub = "", main = paste0("Differential"), labels = F, hang = 0.04)
}
```

```{r specfiy which meta network to evaluate}

which.metanet <- "differential" # "consensus" or "differential"

if (which.metanet == "consensus"){
  w.co <- w.co
  d.co <- d.co
  geneTree.co <- geneTree.co
} else if (which.metanet== "differential"){
  w.co <- w.dis
  d.co <- d.dis  
  geneTree.co <- geneTree.dif
}
```



```{r dendro cuts, message=FALSE, warning=FALSE}

# mColorh.1 <- optimalDS(tree = geneTree.1, d.mat = d.1, genes  = rownames(a.1),pamStage = F)

# print2hide <- capture.output(mColorh <- optimalDS(tree = geneTree.wgcna, d.mat = d.mat, 
                                                  # genes  = rownames(a.mat), minClusterSize  = 5, method = "hybrid", cut.height = NULL))

# determine number of modules based on refrence dataset
p2h <- capture.output(mColorh.1 <- optimalDS(tree = geneTree.1, d.mat = d.1, genes  = rownames(a.1), minClusterSize  = 5, method = "hybrid", cut.height = NULL))
p2h <- capture.output(mColorh.2 <- optimalDS(tree = geneTree.2, d.mat = d.2, genes  = rownames(a.2), minClusterSize  = 5, method = "hybrid", cut.height = NULL))
p2h <- capture.output(mColorh.all <- optimalDS(tree = geneTree.all, d.mat= d.mat, genes  = rownames(a.mat), minClusterSize  = 5, method = "hybrid", cut.height = NULL))
p2h <- capture.output(mColorh.co <- optimalDS(tree = geneTree.co, d.mat= d.co, genes  = rownames(a.mat), minClusterSize  = 5, method = "hybrid", cut.height = NULL))

# select modules based off best clustering above
which.deepcut <- "ds.1"
modules.1a = mColorh.1[ ,which.deepcut]
modules.2a = mColorh.2[ ,which.deepcut]
modules.all <- mColorh.all[ ,which.deepcut]
modules.coa <- mColorh.co[ ,which.deepcut]

if (print.inline){
# plot dendrograms (with module labels)
plotDendroAndColors(geneTree.all, mColorh.all[,1:5], paste("dpSplt =", 0:4), main = "All", dendroLabels = F)
  plotDendroAndColors(geneTree.co, mColorh.co[,1:5], paste("dpSplt =", 0:4), main = "Consensus", dendroLabels = F)
plotDendroAndColors(geneTree.1, mColorh.1[,1:5], paste("dpSplt =", 0:4), 
                    main = paste0("Group 1: ", reference.group), dendroLabels = F)
plotDendroAndColors(geneTree.2, mColorh.2[,1:5], paste("dpSplt =", 0:4), 
                    main = paste0("Group 2: ", comparison.group), dendroLabels = F)
}

```




```{r merge redundant modules}

# do.redundant.merge <- F
# 
# if (do.redundant.merge){
#   
# 
# # Calculate module eigengenes
# multiExpr <- list(A1=list(data=de.1),A2=list(data=de.2))
# 
# print2hide <- capture.output(unmergedMEs.co <- multiSetMEs(multiExpr, colors = NULL, universalColors = modules.coa))
# print2hide <- capture.output(unmergedMEs.all <- multiSetMEs(multiExpr, colors = NULL, universalColors = modules.all))
# 
# # Calculate consensus dissimilarity of consensus module eigengenes
# consMEDiss.co <- consensusMEDissimilarity(unmergedMEs.co);
# consMEDiss.all <- consensusMEDissimilarity(unmergedMEs.all);
# 
# # Cluster consensus modules
# consMETree.co <- hclust(as.dist(consMEDiss.co), method = "average");
# consMETree.all <- hclust(as.dist(consMEDiss.all), method = "average");
# 
# # Plot the result
# if (print.inline){
#   sizeGrWindow(7,6)
#   par(mfrow = c(1,1))
#   plot(consMETree.co, main = "Consensus clustering of consensus module eigengenes",
#        xlab = "", sub = "")
#   abline(h=0.25, col = "red")  
# }
# 
# print2hide <- capture.output(module.merge.co <- mergeCloseModules(multiExpr, modules.coa, cutHeight = 0.25, verbose = 3))
# moduleLabels <- module.merge.co$colors;
# modules.COA <- labels2colors(moduleLabels)
# 
# print2hide <- capture.output(module.merge.all <- mergeCloseModules(multiExpr, modules.all, cutHeight = 0.25, verbose = 3))
# moduleLabels <- module.merge.all$colors;
# modules.ALL <- labels2colors(moduleLabels)
# 
# } else {
  modules.COA <- modules.coa
  modules.ALL <- modules.all
# }

```



```{r Comparing networks with different module definitions}

# harmonize module labels across datasets
# modules.all <- modules.ALL
modules.coa <- modules.COA
modules.1b = as.vector(matchLabels(modules.1a,  modules.coa))
modules.2b = as.vector(matchLabels(modules.2a,  modules.coa))
modules.cob = as.vector(matchLabels(modules.coa,  modules.coa))
modules.all = as.vector(matchLabels(modules.ALL,  modules.coa))

if (print.inline){
plotDendroAndColors(geneTree.all, modules.all, "All", dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main="All dendrogram")
  plotDendroAndColors(geneTree.co, modules.cob, paste0("Consensus\n", reference.group, "+", comparison.group), dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main="Consensus dendrogram")
plotDendroAndColors(geneTree.1, modules.1b, paste0("Group 1: ", reference.group), dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main=paste0("Group 1: ", reference.group))
plotDendroAndColors(geneTree.2, modules.2b, paste0("Group 2: ", comparison.group), dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main=paste0("Group 2: ", comparison.group))
}

common.modules <- intersect(modules.1b, modules.2b)
m1.u <- unique(modules.1b)
m2.u <- unique(modules.2b)
g1.specific.modules <- m1.u[!(m1.u %in% common.modules)]
g2.specific.modules <- m2.u[!(m2.u %in% common.modules)]

module.sets <- list(all = unique(modules.all),
                    group.1 = unique(modules.1b), 
                    group.2 = unique(modules.2b),
                    consensus = unique(modules.cob))

module.sets.v2 <- list(all = unique(modules.all),
                    consensus = unique(modules.cob))



if (print.inline){
  # fig.width=15, fig.height=4
ggVennDiagram::ggVennDiagram(module.sets) + ggtitle("Network Preservations")
  # ggVennDiagram::ggVennDiagram(module.sets.v2) + ggtitle("Network Preservations")
}

# get robust consensus modules (all else set to grey)
# consensus.modules <-intersect(modules.all, intersect(modules.cob, intersect(modules.1b, modules.2b)))
modules.consensus <- modules.cob
consensus.modules <-modules.consensus

# modules.consensus[!(modules.consensus %in% consensus.modules)] <- "grey"
modules.1b[!(modules.1b %in% modules.consensus)] <- "grey"
modules.2b[!(modules.2b %in% modules.consensus)] <- "grey"
modules.all[!(modules.all %in% modules.consensus)] <- "grey"

# get mapping df for late
df.map.all <- data.frame(module = modules.consensus, genes = mColorh.all[ ,"genes"])

```




```{r matrix distributions, fig.width=15, fig.height=4}


if (print.inline){
  # fig.width=15, fig.height=4
  par(mfrow = c(1,4))
hist(datExpr.noz, main = "Expression", xlab = "Expression")
hist(s.mat[s.mat != 1], main = "Similarity (correlation)", xlab = "Similarity")
hist(a.mat[a.mat != 1], main = "Adjacency", xlab = "Adjacency")
hist(w.mat[w.mat != 1], main = "TOM", xlab = "TOM")
}

```


```{r preservation of group1 network in group2}


if (print.inline){
plotDendroAndColors(geneTree.1, modules.1b, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
guideHang=0.05, main="Gene dendrogram and module colors (Group 1 -> Group 1)")
plotDendroAndColors(geneTree.1, modules.cob, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
guideHang=0.05, main="Gene dendrogram and module colors (Group 1 -> consensus)")

plotDendroAndColors(geneTree.2, modules.2b, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
guideHang=0.05, main="Gene dendrogram and module colors (Group 2 -> Group 2)")
plotDendroAndColors(geneTree.2, modules.cob, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
guideHang=0.05, main="Gene dendrogram and module colors (Group 2 -> consensus)")



}


```



```{r module preservation}

# modulePreservation function in WGCNA library assesses how well a module in one study is preserved in another 
# study using a number of stratgies and outputs a single Z-score summary. 

# In general, the higher the value of "Zsummary.pres" the more preserved the module is between data sets:
# 5<Z<10 indicates moderate preservation, while Z>10 indicates high preservation. (See the WGCNA website
# for a more complete tutorial on this function.) The "grey" module contains uncharacterized gene while the gold
# module contains random genes. In general, these modules should have lower Z-scores than most of the other
# modules. In this case, we find that all modules are very well preserved.

# 
# do.preservation <- F
# 
# if (do.preservation){
# 
# modules.rand.match.all <-  as.vector(matchLabels(modules.rand,  modules.all))
# 
# 
# n.perm <- 3 # default: 30
# stats <- getModulePreservation(ref.mat = datExpr.noz, 
#                                    query.mat = de.rand, 
#                                    ref.module = modules.all, 
#                                    query.modules = modules.rand.match.all,
#                                    networkType=which.network,
#                                    nPermutations=n.perm,
#                                    maxGoldModuleSize=100,
#                                    maxModuleSize=400, 
#                                    verbose=3,
#                                    savePermutedStatistics = F)
# 
# 
# df.mod.pres <-  stats[order(-stats[,2]),c(1:2)]
# df.mod.pres$module <- rownames(df.mod.pres)
# df.mod.pres$dataset <- "Modules"
# df.mod.pres$dataset[df.mod.pres$module %in% c("grey", "gold")] <- "Controls"
# 
# df.mod.pres %>%
#   ggplot(aes(x = reorder(module, Zsummary.pres), y = Zsummary.pres, fill = dataset)) + 
#   geom_bar(stat = "identity") + 
#   geom_hline(yintercept = 5, linetype = "dashed")+ 
#   geom_hline(yintercept = 10, linetype = "dashed")+ 
#   coord_flip() + 
#   theme_classic() + 
#   ggtitle("Module Preservation\nvs. Randomized Dataset") + 
#   ylab("Z score, preservation \n(5-10: moderate preservation; >10 high preservation)") + 
#   xlab("Modules") + scale_fill_manual(values=c("tomato", "grey"))
#   
# }


```

```{r eigenGenes}

library(irlba)

modules.union <- c()
for (i in 1:length(modules.1b)){
  if(modules.1b[i] == modules.2b[i]){
    modules.union[i] <- modules.1b[i] 
  } else {
    modules.union[i] <- "grey"
  }
}

# ME activity of group 1
which.module.membership <- modules.consensus


getME <- function(mat, module.membership, scale.ME = F){
 
  ME <- matrix(nrow = nrow(mat), ncol = length(unique(module.membership)))
for (i in 1:length(unique(module.membership))){
  current.mod <- unique(module.membership)[i]
  mat.sub <- mat[ ,colnames(mat) %in% colnames(mat)[module.membership %in% current.mod]]
  
    svd.out <- irlba(mat.sub, nv = 1)
    PrinComps <- svd.out[["u"]][ ,1]
    
            scaledExpr = scale((mat.sub))
        averExpr = rowMeans(scaledExpr, na.rm = TRUE)
          corAve = cor(averExpr,PrinComps, 
            use = "p")
          if (!is.finite(corAve)) corAve = 0
          if (corAve < 0) PrinComps = -PrinComps
        
        # center and scale
          if (scale.ME){
            PrinComps <- scale(PrinComps)
          }
          
  ME[ ,i] <- PrinComps
}
colnames(ME) <- paste0("ME", unique(module.membership))
ME <- as.data.frame(ME)
rownames(ME) <- rownames(mat)

  return(list(
    ME = ME,
    colors = names(table(module.membership))
  ))
}

de.1[is.na(de.1)] <- 0
ME_1.list <- getME(de.1, which.module.membership)
ME_1A <- ME_1.list$ME
colorsA1 <-  ME_1.list$colors

de.2[is.na(de.2)] <- 0
ME_2.list <- getME(de.2, which.module.membership)
ME_2A <- ME_2.list$ME
colorsA2 <-  ME_2.list$colors

datExpr.noz[is.na(datExpr.noz)] <- 0
ME.all.list <- getME(datExpr.noz, which.module.membership)
ME.all <- ME.all.list$ME
colors.all <-  ME.all.list$colors



```

```{r ME activity analysis, fig.width= 8, fig.height=4}

# prep ME activity data
df.ME.all <- ME.all
ME.names <-  colnames(ME.all)
df.ME.all$id <- rownames(df.ME.all)
df.ME.all.long <-pivot_longer(df.ME.all, ME.names)
df.ME.all.long <- df.ME.all.long %>%  filter(!(name %in% "MEgrey")) 

df.meta <- so.query.3@meta.data
df.meta$id <- rownames(df.meta)
df.meta.sub <- df.meta[ ,c("cluster.group", "id", "cluster.orig")]
df.meta.sub$cluster.group <- gsub("[0-9]*_", "", df.meta.sub$cluster.group ) # introduced here
so.query.3@meta.data$cg <- df.meta.sub$cluster.group

# merge ME activity and module identities
df.ME.all.long.merge <- merge(df.ME.all.long, df.meta.sub, by = "id")

# monitor this segment...may need to be revisited. 
if (nrow(df.ME.all.long.merge) == 0){
  df.ME.all.long$id <- gsub("[.].", "", df.ME.all.long$id)
  df.meta.sub$id <- gsub("-.", "", df.meta.sub$id)
  df.ME.all.long.merge <- merge(df.ME.all.long, df.meta.sub, by = "id")
  stopifnot((nrow(df.ME.all.long.merge) > 0))
}



# enforce reference/comparison order
u.groups <- unique(df.ME.all.long.merge$cluster.group)
if (length(u.groups) == 2){
  u.groups.ordered <-c(u.groups[grepl(reference.group, u.groups)], u.groups[grepl(comparison.group, u.groups)])
} else {
  warning("More than 2 unique groups detected. Network analysis is void.")
}

df.ME.all.long.merge$cluster.group <- factor(df.ME.all.long.merge$cluster.group, u.groups.ordered)

# get summary
df.ME.sum <- df.ME.all.long.merge %>%
  group_by(name, cluster.group) %>%
  summarize(mean.ME = mean(value),
            median.ME = median(value),
            sd.ME = sd(value),
            n.ME = length(value),
            raw.values = list(value))

# consolidated view
plt.dif.box <- df.ME.all.long.merge %>%
  ggplot(aes(x = name, y = value, fill = cluster.group)) +
  geom_boxplot() + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  # geom_hline(yintercept = 0, linetype = "dashed") + 
  scale_fill_manual(values=c("skyblue", "tomato")) + 
  theme_bw() + xlab("groups") + ylab("Module Activity (Eigenvalue)") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle("Module Activity")

# stratified view
plt.dif.box.1 <- df.ME.all.long.merge %>%
  ggplot(aes(x = cluster.group, y = value, fill = cluster.group)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free_y") + 
  scale_fill_manual(values=c("skyblue", "tomato")) + 
  theme_bw() + xlab("groups") + ylab("Module Activity (Eigenvalue)")

if (print.inline){
  # print(plt.dif.box.1)
  
   # fig.width= 8, fig.height=4
print(plt.dif.box.1)
}

```

```{r ME differential expression, fig.height = 4, fig.width=12}

# get unique groups
u.groups <- unique(as.character(levels((so.query.3@meta.data[["group.query"]]))))

# get ME activity for each group and merge
df.ME.sum.1 <- df.ME.sum[  grepl(reference.group, df.ME.sum$cluster.group), ]
df.ME.sum.2 <- df.ME.sum[  grepl(comparison.group, df.ME.sum$cluster.group), ]
df.ME.sum.merge <- merge(df.ME.sum.1, df.ME.sum.2, by = c( "name"))

# get ME connectivity for each group and merge
which.mat <- "w" # s: s.mat, a: a.mat, w: w.mat

if (which.mat == "w"){
  mat.1 <- w.1
  mat.2 <- w.2
} else if (which.mat == "a") {
  mat.1 <- a.1
  mat.2 <- a.2  
} else if (which.mat == "s") {
  mat.1 <- s.1
  mat.2 <- s.2  
}

# get connectivity scores
df.ME.k.1 <- getConnectivity(mat.1, rownames(a.1))
df.ME.k.2 <- getConnectivity(mat.2, rownames(a.2))

# quantile normalization of connectivity
# df.ME.qNorm <- qNorm(df.ME.k.1$wi, df.ME.k.2$wi, df.ME.k.2$genes)
# df.ME.k.1$wi <- df.ME.qNorm$x.new
# df.ME.k.2$wi <- df.ME.qNorm$y.new

# merge connecitivty
df.ME.k.merge <- merge(df.ME.k.1, df.ME.k.2, by = "genes")

# get gene and modules
df.gene2module <-  namedList2longDF(getModuleGenes(modules.cob, SubGeneNames, add.prefix = F),
                                    name.header = "module", value.header = "genes")
df.ME.k.merge <- merge(df.ME.k.merge, df.gene2module, by = "genes")

# summary statistics for ME activity
df.ME.sum.merge <- df.ME.sum.merge %>%
  group_by(name) %>%
  mutate(ME.dif.mean = mean.ME.y - mean.ME.x,
         ME.dif.median = median.ME.y - median.ME.x,
         pVal = wilcox.test(unlist(raw.values.x), unlist(raw.values.y))[["p.value"]]) 


which.connect <- "r" # r: ranks, w: wi

if (which.connect == "r"){
df.ME.k.sum.merge <- df.ME.k.merge %>%
  group_by(module) %>%
  summarize(ME.dif.mean = mean(rank.y) - mean(rank.x),
         ME.dif.median = median(rank.y) - median(rank.x),
         pVal = wilcox.test(rank.y, rank.x)[["p.value"]])  
} else if (which.connect == "w"){
df.ME.k.sum.merge <- df.ME.k.merge %>%
  group_by(module) %>%
  summarize(ME.dif.mean = mean(wi.y) - mean(wi.x),
         ME.dif.median = median(wi.y) - median(wi.x),
         pVal = wilcox.test(wi.y, wi.x)[["p.value"]])    
}

# FDR correction
df.ME.sum.merge$pAdj <- p.adjust(df.ME.sum.merge$pVal, method = "BH", n = length(df.ME.sum.merge$pVal))
df.ME.k.sum.merge$pAdj <- p.adjust(df.ME.k.sum.merge$pVal, method = "BH", n = length(df.ME.k.sum.merge$pVal))

# node volcano plot
sig.exp <-df.ME.sum.merge$name[ df.ME.sum.merge$pVal < 0.05] 
sig.exp <- unique(gsub("ME", "", sig.exp))
plt.dif.volc <- df.ME.sum.merge %>%
  ggplot(aes(x = ME.dif.median, y = -log10(pAdj), size = -log10(pAdj), color = ME.dif.median)) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Differential ME Activity (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(pAdj)") + 
  geom_hline(yintercept = -log10(0.05), linetype = "dashed")  +
  geom_vline(xintercept = 0, linetype = "dashed")  +
  # ggrepel::geom_text_repel(aes(ME.dif.median,  -log10(pAdj), label =name), size = 3, color = "black") +
  ggtitle("Differential ME Activity") + 
  scale_colour_gradientn("Difference", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                           values=c(rescaleValues(c(min(df.ME.sum.merge$ME.dif.median), 0, max(df.ME.sum.merge$ME.dif.median))))) + theme(legend.position="bottom") + guides(size=guide_legend("-log10(pAdj)"), color = FALSE)

# rank volcano plot
sig.con <- unique(df.ME.k.sum.merge$module[ df.ME.k.sum.merge$pVal < 0.05]) 
plt.rank.volc <- df.ME.k.sum.merge %>%
  ggplot(aes(x = ME.dif.median, y = -log10(pAdj), size = -log10(pAdj), color = ME.dif.median)) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Differential ME Connectivity (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(pAdj)") + 
  geom_vline(xintercept = 0, linetype = "dashed")  +
  # ggrepel::geom_text_repel(aes(ME.dif.median,  -log10(pAdj), label =module), size = 3, color = "black") + 
  ggtitle("Differential ME Connectivity") + 
  scale_colour_gradientn("Difference", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                           values=c(rescaleValues(c(min(df.ME.k.sum.merge$ME.dif.median), 0, max(df.ME.k.sum.merge$ME.dif.median))))) + theme(legend.position="bottom") + guides(size=guide_legend("-log10(pAdj)"), color = FALSE)

if (min(df.ME.k.sum.merge$pAdj) < 0.05) plt.rank.volc <- plt.rank.volc +  geom_hline(yintercept = -log10(0.05), linetype = "dashed")


# pairwise comparison
df.me.activity <- df.ME.sum.merge[ ,c("name", "ME.dif.median")]
colnames(df.me.activity) <- c("module", "x")
df.me.activity$module <- gsub("ME", "", df.me.activity$module)
df.me.connect <- df.ME.k.sum.merge[ ,c("module", "ME.dif.median")]
colnames(df.me.connect) <- c("module", "y")
df.me.merge <- merge(df.me.activity, df.me.connect, by = "module") 

# euclidean distance from origin
df.me.merge$x.s <- (df.me.merge$x - mean(df.me.merge$x))/sd(df.me.merge$x)
df.me.merge$y.s <- (df.me.merge$y - mean(df.me.merge$y))/sd(df.me.merge$y)
df.me.merge$z.s <- sqrt(((df.me.merge$x.s)^2) + ((df.me.merge$y.s)^2))

df.me.merge$label <- ""
df.me.merge$label[df.me.merge$module %in% unique(c(sig.con, sig.exp))] <- df.me.merge$module[df.me.merge$module %in% unique(c(sig.con, sig.exp))]
plt.dif.rank.comp <- df.me.merge %>%
  ggplot(aes(x,y, size = z.s)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  theme_classic() + 
  ggrepel::geom_text_repel(aes(x,y, label =label), size = 3, color = "black") +
  xlab(paste0("Differential Activity\n", comparison.group, "-", reference.group)) + 
  ylab(paste0("Differential Connectivity\n", comparison.group, "-", reference.group)) +
  labs(title = paste0("Modular Sector Plot"), subtitle = paste0(comparison.group, "-", reference.group),
       caption = "Labeled nodes: p<0.05")  + 
  theme(legend.position = "none")

if (print.inline){
  cowplot::plot_grid(plt.dif.volc, plt.rank.volc,plt.dif.rank.comp,  ncol = 3)
}

```




```{r sector plot}


# get differential expression
df.avg <- avgGroupExpression(so = so.query.3, which.data = "scale", which.center= "mean", which.group = "cg")
df.sd <- avgGroupExpression(so = so.query.3, which.data = "scale", which.center = "sd", which.group = "cg")

df.avg$dif <- df.avg[ , comparison.group] - df.avg[ , reference.group]
df.sd$sp <- sqrt((df.sd[ , comparison.group]^2) + (df.sd[ , reference.group]^2))
df.deg.all <- data.frame(genes = df.avg$genes, dif =  df.avg$dif, sp = df.sd$sp )
df.deg.all$z <- df.deg.all$dif / df.deg.all$sp

# get differential connectivity
# get connectivity scores
df.con.1 <- getConnectivity(w.1, rownames(a.1))
df.con.2 <- getConnectivity(w.2, rownames(a.2))

# quantile normalization of connectivity
# df.con.qNorm <- qNorm(df.con.1$wi, df.con.2$wi, df.con.2$genes)
# df.con.1$wi <- df.con.qNorm$x.new
# df.con.2$wi <- df.con.qNorm$y.new

# merge scores
df.con.merge <- merge(df.con.1, df.con.2, by = "genes")
df.con.merge <- merge(df.con.merge, df.map.all, by = "genes")
df.con.merge$w.x.norm <- df.con.merge$wi.x
df.con.merge$w.y.norm <- df.con.merge$wi.y

# get ranked connectivity
# df.con.merge$w.x.rank <- rank(df.con.merge$wi.x)
# df.con.merge$w.y.rank <- rank(df.con.merge$wi.y)

# compute w.delta
  df.con.merge$w.delta <- df.con.merge$w.y.norm - df.con.merge$w.x.norm
  # df.con.merge$r.delta <- df.con.merge$w.y.rank - df.con.merge$w.x.rank

# merge results
df.con.deg.merge <- merge(df.con.merge, df.deg.all, by = "genes")
df.con.deg.merge <- unique(df.con.deg.merge)


df.con.deg.merge.noMod <- df.con.deg.merge %>% dplyr::select(-c("module"))

# data driven threshold
connectivity.threshold <- 1.96*sd(df.con.deg.merge$w.delta)
expression.threshold <-  1.96*sd(df.con.deg.merge$z)

# Z score threhsolds
# connectivity.threshold <- 1.96
# expression.threshold <-  1.96

plt.sector <- df.con.deg.merge %>%
  ggplot(aes(w.delta, z, text = genes)) + 
   geom_point(data = df.con.deg.merge.noMod, aes(x = w.delta, y =  z), color = "grey", alpha = 0.4) + 
  geom_point(color = "tomato", alpha = 1) + 
  geom_hline(yintercept = 0, color = "black") + 
  geom_vline(xintercept = 0, color = "black") + 
  geom_hline(yintercept = -expression.threshold, color = "black", linetype = "dashed") + 
  geom_hline(yintercept = expression.threshold, color = "black", linetype = "dashed") + 
  geom_vline(xintercept = -connectivity.threshold, color = "black", linetype = "dashed") + 
  geom_vline(xintercept = connectivity.threshold, color = "black", linetype = "dashed") + 
  theme_classic() + 
  facet_wrap(~module) + 
  xlab(paste0("Delta Connectivity (", comparison.group, " - ", reference.group, ")")) + 
  ylab(paste0("Delta Expression (", comparison.group, " - ", reference.group, ")")) + 
  labs(title = "Network Sector Plot", subtitle = "Differential expression vs. differential connectivity")



if (print.inline){
  # fig.width = 10, fig.height=10
print(plt.sector)
}


# plt.delta.comp <- df.con.merge %>%
#   ggplot(aes(x = w.delta, y = r.delta)) + geom_point()
# 
# plt.norm <- df.con.merge %>%
#   ggplot() +
#   geom_density(aes(x = w.x.norm, fill = "ref"), alpha = 0.5) +
#   geom_density(aes(x = w.y.norm, fill = "comp"), alpha = 0.5)
# 
# plt.wi <- df.con.merge %>%
#   ggplot() +
#   geom_density(aes(x = wi.x, fill = "ref"), alpha = 0.5) +
#   geom_density(aes(x = wi.y, fill = "comp"), alpha = 0.5)
# 
# plt.log <- df.con.merge %>%
#   ggplot() +
#   geom_density(aes(x = wi.x.log, fill = "ref"), alpha = 0.5) +
#   geom_density(aes(x = wi.y.log, fill = "comp"), alpha = 0.5)
# 
# 
# cowplot::plot_grid(plt.delta.comp, plt.norm, plt.wi, plt.log, ncol = 2)

```


```{r ME activity heatmap}

me.exp.mat <- (datExpr.noz)
me.exp.mat <- me.exp.mat[ ,!(modules.cob %in% "grey")]
modules.all.sub <- modules.cob[!(modules.cob %in% "grey")]
membership.all.sub <- rep(NA, nrow(ME.all))
ME.all.rownames <- rownames(ME.all)
membership.all.sub[ME.all.rownames %in% df.meta$id[df.meta$group.query %in% reference.group] ] <- reference.group
membership.all.sub[ME.all.rownames %in% df.meta$id[df.meta$group.query %in% comparison.group] ] <- comparison.group

# monitor this segment...may need to be revisited. 
if (sum(is.na(membership.all.sub)) == length(membership.all.sub)){
  ME.all.rownames <- gsub("[.].", "",rownames(ME.all))
  df.meta$id.v2 <- gsub("-.", "",df.meta$id)
  
  membership.all.sub[ME.all.rownames %in% df.meta$id.v2[df.meta$group.query %in% reference.group] ] <- reference.group
membership.all.sub[ME.all.rownames %in% df.meta$id.v2[df.meta$group.query %in% comparison.group] ] <- comparison.group

stopifnot( (sum(is.na(membership.all.sub)) < length(membership.all.sub)))
}

grouping.mem <- as.data.frame(membership.all.sub)
names(grouping.mem) <- "Group"

ME.all.sub <- ME.all

windsorize.thres <- 0.15
ME.all.sub[ME.all.sub > windsorize.thres] <- windsorize.thres
ME.all.sub[ME.all.sub < -windsorize.thres] <- -windsorize.thres

min.me <- min(ME.all.sub)
max.me <- max(ME.all.sub)
scale.limit <- max(c(abs(min.me), abs(max.me)))


if (print.inline){
  
  min.me <- min(ME.all.sub)
max.me <- max(ME.all.sub)
scale.limit <- max(c(abs(min.me), abs(max.me)))
heatmaply::heatmaply(
  (ME.all.sub),
  plot_method = c("plotly"),
  row_side_colors = grouping.mem,
  limits = c(-scale.limit, scale.limit),
   colors = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdBu"))(100)) , 
  xlab("Modules"), key.title="ME Activity", hide_colorbar=F, labRow = rep("", nrow(ME.all.sub))
)
  
}


```


```{r group prediction, fig.width= 12, fig.height=4, warning = FALSE, message = FALSE}

# some machine learning...
library(caret) 
library(ROCR) 
library(Metrics)

# omit grey module
# ME.all.sub <- ME.all[ ,!grepl("grey", colnames(ME.all))]
ME.all.sub <- ME.all[ ,!(colnames(ME.all) %in% "MEgrey")]

# prep data for model fitting
all.data <- as.data.frame(ME.all.sub)
all.data$group <- (membership.all.sub)
all.data$group[all.data$group == reference.group] <- 0
all.data$group[all.data$group == comparison.group] <- 1
all.data$group <- as.factor(all.data$group)

# partition data into test and training sets
split <- createDataPartition(y = all.data$group,p = 0.8,list = FALSE)
train <- all.data[split, ]
test <- all.data[-split, ]

# fit logistic regressio model
model <- glm(group ~ ., family = binomial(link = 'logit'), data = train)

# get model stats
model.coef <- summary(model)
model.anova <- anova(model, test = 'Chisq')
model.anova[ , "Pr(>Chi)"] <- model.anova[ , "Pr(>Chi)"]  + 1e-20

# model stat wrangling
df.model.1 <- as.data.frame(model.coef[["coefficients"]])
df.model.1$terms <- rownames(df.model.1)
colnames(df.model.1) <- c("Estimate", "SE", "z.model", "p.model", "terms")
df.model.2 <- model.anova
df.model.2$terms <- rownames(df.model.2)
colnames(df.model.2) <- c("df", "Deviance", "resid.df", "resid.dev", "p.anova", "terms")
df.model.merge <- merge(df.model.1, df.model.2, by = "terms")
df.model.merge$varExplained <- df.model.merge$Deviance / sum(df.model.merge$Deviance)

# compute model perormance using test set
log_predict <- predict(model,newdata = test,type = "response")
log_predict <- ifelse(log_predict > 0.5,1,0)
df.prediction <- as.data.frame(table(test$group,log_predict))

# plot confusion matrix
a1 <- as.numeric(as.character(test$group))
a2 <- as.numeric(as.character(log_predict))
df.a12 <- data.frame(x = a1, y = a2)
df.a12 <- df.a12[complete.cases(df.a12), ]

plt.confusion <- ggplot(data =  df.prediction, mapping = aes(x = Var1, y = log_predict)) +
  geom_tile(aes(fill = Freq), colour = "white") +
  geom_text(aes(label = sprintf("%1.0f",Freq)), vjust = 1) +
  scale_fill_gradient(low = "white", high = "steelblue") + 
  xlab("True Label") + ylab("Predicted Label") + 
  labs(title = ("Confusion Matrix"), subtitle = paste0("AUC=", signif(Metrics::auc(df.a12$x,df.a12$y), 2)," (20% validation set)")) + 
  theme(legend.position = "none")

# plot model volcano plot
plt.logitModel <- df.model.merge %>%
  ggplot(aes(x = Estimate, y = -log10(p.model), size = varExplained, color = -log10(p.anova))) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Logit Model Coefficient (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(p.model), Model Coefficient") + 
  geom_vline(xintercept = 0, linetype = "dashed")  +
  ggrepel::geom_text_repel(aes(Estimate,  -log10(p.model), label =terms), size = 3, color = "black") + 
  labs(title = "Logistic Regression", subtitle = "80% training set") + theme(legend.position="bottom")

if (min(df.model.merge$p.model) < 0.05) plt.logitModel <- plt.logitModel + geom_hline(yintercept = -log10(0.05), linetype = "dashed")

# min(df.model.merge$p.model)
# merge plots

model.anova$var.exp <- model.anova$Deviance / sum(model.anova$Deviance, na.rm = T)
model.anova$terms <- rownames(model.anova)
model.anova <- model.anova[!(model.anova$terms %in% "NULL"), ]
model.anova$terms <- gsub("ME", "", model.anova$terms)

colnames(model.anova)[colnames(model.anova) %in% "Pr(>Chi)"] <- "pVal"
# model.anova$pVal <- model.anova$pVal + 1e-20
model.anova$pVal.log <- -log10(model.anova$pVal)



plt.var.exp <- model.anova %>%
  ggplot(aes(reorder(terms, var.exp), var.exp, fill = pVal.log)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + 
  theme_classic() + 
  xlab("Module") + 
  ylab(paste0("Variance Explained\n", reference.group, " vs. ", comparison.group)) + labs(fill = "-log10(p)") + 
  ggtitle("Variance Explained")


if (print.inline){
  # fig.width= 12, fig.height=4
  cowplot::plot_grid(plt.logitModel, plt.confusion, plt.var.exp, ncol = 3)
}

```




```{r module membership (kME), warning = FALSE, message = FALSE}

# The first thing we can do is plot the kME values of each gene in A1 against the corresponding kME values of
# each gene in A2. Modules with points showing a high correlation are highly preserved.

# kME can be used to measure correlations between each gene and each ME, and thus even genes which were not initially assigned to a module can be included in between-network comparisons

# module.membership <- modules.union
# module.membership <- modules.all
module.membership <- modules.consensus
# module.membership <- modules.union

# geneModuleMembership.alt <- signedKME(de.1, ME_1A)
geneModuleMembership1 <- signedKME(de.1, ME_1A)
colnames(geneModuleMembership1) <- paste("PC",colorsA1,".cor",sep="");
MMPvalue1 <- corPvalueStudent(as.matrix(geneModuleMembership1),dim(de.1)[[1]]);
colnames(MMPvalue1) <- paste("PC",colorsA1,".pval",sep="");
Gene  <-  colnames(de.1)
kMEtable1 <-  cbind(Gene,Gene,module.membership)
for (i in 1:length(colorsA1)){
  kMEtable1 <- cbind(kMEtable1, geneModuleMembership1[,i], MMPvalue1[,i])
}

colnames(kMEtable1) <- c("PSID","Gene","Module",sort(c(colnames(geneModuleMembership1), colnames(MMPvalue1))))


# First calculate MEs for A2, since we haven't done that yet
geneModuleMembership2 <- signedKME(de.2, ME_2A)
# geneModuleMembership2 <- signedKME(de.2, ME_2A, corOptions = "use = 'p', method = 'spearman'")
colnames(geneModuleMembership2) <- paste("PC",colorsA2,".cor",sep="");
MMPvalue2 <- corPvalueStudent(as.matrix(geneModuleMembership2),dim(de.2)[[1]]);
colnames(MMPvalue2) <- paste("PC",colorsA2,".pval",sep="");
kMEtable2  <-  cbind(Gene,Gene,module.membership)
for (i in 1:length(colorsA1)){
  kMEtable2 <- cbind(kMEtable2, geneModuleMembership2[,i], MMPvalue2[,i])
}

colnames(kMEtable2) <- colnames(kMEtable2)

# SET 2
df.kME.sub <- NULL
df.kME.all <- NULL
for (c in 1:length(colorsA1)){
inMod = which.module.membership == colorsA1[c]

df.kME.sub <- bind_rows(df.kME.sub, data.frame(kME.x = geneModuleMembership1[inMod,c], kME.y = geneModuleMembership2[inMod,c], module = colorsA1[c], genes = rownames(geneModuleMembership1)[inMod]))

df.cur <- data.frame(kME.x = geneModuleMembership1[,c], kME.y = geneModuleMembership2[,c], module = colorsA1[c], genes = rownames(geneModuleMembership1))
df.cur$inMod <- "out"
df.cur$inMod[df.cur$genes %in% rownames(geneModuleMembership1)[inMod]] <-  "in"
df.kME.all <- bind_rows(df.kME.all, df.cur)
};

  # dplyr::filter(! module %in% "grey") %>%
plt.kME <- df.kME.all %>%
    ggplot(aes(x = kME.x, y = kME.y, text = genes, color = inMod)) + 
    geom_point(alpha = 0.4) + 
    theme_classic() + 
    geom_hline(yintercept = 0, linetype = "dashed") + 
    geom_vline(xintercept = 0, linetype = "dashed") + 
    geom_abline(slope = 1, color = "red",  linetype = "dashed") + 
    labs(title = "kME Plot", subtitle = "Fuzzy membership") + scale_color_manual(breaks = c("in", "out"), values=c( "tomato", "grey")) + 
  xlab(paste0("kME (", reference.group ,")")) + ylab(paste0("kME (", comparison.group ,")")) + 
facet_wrap(~module)

# plotly::ggplotly(plt.kME)

if (print.inline){
  print(plt.kME)
}



# These two types of plots convey similar, but not identical, information. Using all genes (SET 1) allows one to
# include all positively and negatively correlated genes, but often also includes a lot of noise (although not in this
# case). Using only in-module genes (SET 2) is a visual way of assessing hub gene conservation: if these genes
# show between-set correlation, then the genes in the upper right of the plot are likely to be common hub genes
# between data sets. (Hub genes are genes that show significant correlation with MEs and high within-module
# connectivity.)
# inMod
```

```{r kme based module annotation}

u.modules <- unique(df.kME.all$module)

df.kme.model <- NULL
for (i in 1:length(u.modules)){
  cur.module <- u.modules[i]
  df.in.cur <- df.kME.all[(df.kME.all$module %in% cur.module) & df.kME.all$inMod == "in", ]
  df.out.cur <- df.kME.all[(df.kME.all$module %in% cur.module) & df.kME.all$inMod == "out", ]
  
  
  
  fit.in <- lm(kME.y ~ kME.x, df.in.cur)
  fit.out <- lm(kME.y ~ kME.x, df.out.cur)
  
  in.sum <- summary(fit.in)
  out.sum <- summary(fit.out)
  
      f.stat <- in.sum$fstatistic
    # p <- pf(f[1],f[2],f[3],lower.tail=F)
  
  df.mod.res.cur <- data.frame(
    module = cur.module,
    r2.in = in.sum[["r.squared"]],
    p.in = pf(f.stat[1],f.stat[2],f.stat[3],lower.tail=F),
    r2.out = out.sum[["r.squared"]]
  )
  
  df.kme.model <- bind_rows(df.kme.model, df.mod.res.cur)
  
}


plt.kme.comp <- df.kme.model %>%
  ggplot(aes(x = r2.in, y = r2.out, size = r2.in)) + 
  geom_point(alpha = 0.5) + 
  theme_classic() + 
  labs(title = ("Intra vs. Intermodular kME Scores"), subtitle = paste0("R2: ", reference.group, " vs ", comparison.group, " kME scores\nHigh R2 suggests preserved network connectivity")) +
  ggrepel::geom_text_repel(aes(r2.in, r2.out, label =module), size = 3, color = "black") + 
  geom_abline(slope = 1, linetype = "dashed") + 
  xlab(paste0("Intramodular R2 (", reference.group, " vs ", comparison.group, " in-kME)")) + 
  ylab(paste0("Intermodular R2 (", reference.group, " vs ", comparison.group, " out-kME)")) 


plt.mod.pres <- df.kme.model %>%
  ggplot(aes(x = reorder(module, r2.in), y = r2.in, fill = -log10(p.in))) + 
  geom_bar(stat = "identity") + 
  theme_classic() + 
  labs(title = ("Module Preservation"), subtitle = paste0(reference.group , " vs. ", comparison.group)) +
  xlab("Module") + ylab("kME R2") + 
  coord_flip() + 
  labs(fill = "-log10(p)")
  

if (print.inline){
  print(plt.kme.comp)
  print(plt.mod.pres)
}
  

df.kME.all$delta.kme <- df.kME.all$kME.y - df.kME.all$kME.x
df.kME.all$mean.kme <- (df.kME.all$kME.y + df.kME.all$kME.x)/2
df.kME.all$abs.max.kme <-  pmax(abs(df.kME.all$kME.y), abs(df.kME.all$kME.x))
df.kME.all$max.kme <-  pmax((df.kME.all$kME.y), (df.kME.all$kME.x))
df.kME.all$min.kme <-  pmin((df.kME.all$kME.y), (df.kME.all$kME.x))


df.kME.all$signl <- T
df.kME.all$signl[abs(df.kME.all$max.kme) < abs(df.kME.all$min.kme)] <- F
  df.kME.all$abs.max.kme[df.kME.all$signl] <- df.kME.all$abs.max.kme[df.kME.all$signl]*-1
  
  df.kME.all <- df.kME.all[complete.cases(df.kME.all), ]

  # filter(inMod == "in") %>%
plt.kme.dif <- df.kME.all %>%
  ggplot(aes(x = delta.kme, y = max.kme, color = delta.kme, text = genes)) + 
  geom_point() +
  facet_wrap(~module) + 
  ylab("Max kME") + 
  xlab(paste0("Delta kME (", comparison.group, "-", reference.group, ")")) +
  theme_bw() + 
  labs(title = "Differential kME") + 
  geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + 
  scale_colour_gradientn("delta", colours=c("skyblue", "grey90","grey90", "seagreen", "grey90","grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.kME.all$delta.kme), 
                                                  min(df.kME.all$delta.kme)/2,
                                                  min(df.kME.all$delta.kme)/4, 
                                                  0, 
                                                  max(df.kME.all$delta.kme)/4,
                                                  max(df.kME.all$delta.kme)/2, 
                                                  max(df.kME.all$delta.kme))))) 

if (print.inline){
   print(plt.kme.dif)
}
 

# "skyblue", "grey90", "tomato"
```

```{r gsea enrichment of kme conserved}


u.modules <- as.character(unique(df.kME.all$module))
gsea.pathway.kme.all.consensus <- NULL
gsea.pathway.kme.all.differential <- NULL


delta.kme.threshold <- 0.1
for (i in 1:length(u.modules)){
  
  which.module <- u.modules[i]
  
  # get DEGs
  df.kme.cur <- df.kME.all[df.kME.all$module %in% which.module, ]
  df.kme <- df.kme.cur[abs(df.kme.cur$delta.kme) < delta.kme.threshold, ]
  
  # ranked by signed lop p 
  if (is.null(df.kme)) next
  
  # prep gene list for consensus enrichment (match to EntrezID, sort)
  gene.list.v1 <- df.kme$max.kme
  names(gene.list.v1) <- df.kme$genes
  match.ind <- match(names(gene.list.v1), my.entrez$SYMBOL)
  names(gene.list.v1) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list.v1 = sort(gene.list.v1, decreasing = TRUE)
  
    # clean list
  df.ent.v1 <- data.frame(names = names(gene.list.v1), values = as.vector(gene.list.v1))
  df.ent.v1 <- df.ent.v1[complete.cases(df.ent.v1), ]
  df.ent.v1 <- df.ent.v1[!is.infinite(df.ent.v1$values), ]
  gene.list.clean.v1 <- df.ent.v1$values
  names(gene.list.clean.v1) <- df.ent.v1$names
  
    # prep gene list for differential enrichment (match to EntrezID, sort)
  gene.list.v2 <- df.kme.cur$delta.kme
  names(gene.list.v2) <- df.kme.cur$genes
  match.ind <- match(names(gene.list.v2), my.entrez$SYMBOL)
  names(gene.list.v2) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list.v2 = sort(gene.list.v2, decreasing = TRUE)
  
      # clean list
  df.ent.v2 <- data.frame(names = names(gene.list.v2), values = as.vector(gene.list.v2))
  df.ent.v2 <- df.ent.v2[complete.cases(df.ent.v2), ]
  df.ent.v2 <- df.ent.v2[!is.infinite(df.ent.v2$values), ]
  gene.list.clean.v2 <- df.ent.v2$values
  names(gene.list.clean.v2) <- df.ent.v2$names
  

  
  # pathway gsea enrichment
  gsea.pathway.kme.v1 <- fgsea::fgsea(pathways.go, gene.list.clean.v1, nperm=1000, maxSize=500)
  gsea.pathway.kme.v2 <- fgsea::fgsea(pathways.go, gene.list.clean.v2, nperm=1000, maxSize=500)
  
  if (nrow(gsea.pathway.kme.v1) > 0){
  gsea.pathway.kme.v1$module <- which.module
  gsea.pathway.kme.all.consensus <- bind_rows(gsea.pathway.kme.all.consensus, gsea.pathway.kme.v1)    
  } 
  
    if (nrow(gsea.pathway.kme.v2) > 0){
  gsea.pathway.kme.v2$module <- which.module
  gsea.pathway.kme.all.differential <- bind_rows(gsea.pathway.kme.all.differential, gsea.pathway.kme.v2)    
  } 

  
}


```



```{r converserved vs. differential hubs}

# The second thing we can do is determine which genes are hubs in both networks by determine which genes
# have extremely high kME values in both networks.

top.n.hub <- 20

topGenesKME = NULL
for (c in 1:length(colorsA1)){
  kMErank1 = rank(-geneModuleMembership1[,c])
  kMErank2 = rank(-geneModuleMembership2[,c])
  maxKMErank = rank(apply(cbind(kMErank1,kMErank2+.00001),1,max))
  topGenesKME = cbind(topGenesKME,Gene[maxKMErank<=top.n.hub])
}; colnames(topGenesKME) = colorsA1


df.topGenesKME <- as.data.frame(topGenesKME)

if (print.inline){
  topGenesKME
}

# ENRICH TUB
my.symbol <- rownames(a.mat)
my.entrez <- sym2entrez(my.symbol, my.species =which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = "BP", species =  which.species)

g2e.list <- my.entrez$ENTREZID
names(g2e.list) <- my.entrez$SYMBOL

gene.universe <- unique(rownames(so.query))
gene.universe <- unique(g2e.list[gene.universe])

# res.h.list <- list()

# hub.genes <- 
n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)

res.hub.list <- list()
res.hub.list <- foreach(i = 1:ncol(topGenesKME), .packages = c("dplyr", "fgsea"))  %dopar% {

  # warning(paste0("progress: ", round(100*i/length(module.list.co)), "%\n"))
  current.genes <- unique(topGenesKME[ ,i])
  current.genes <- unique(g2e.list[current.genes])
  
  res.hyper <-  fora(pathways = pathways.go, genes = current.genes, universe = gene.universe, minSize = 2, maxSize = 200)
  res.hyper$f.query.ann <- res.hyper$overlap / res.hyper$size
  res.hyper$f.query.all <- res.hyper$overlap / length(current.genes)
  res.hyper$n.query.all <-length(current.genes)
  # res.hyper <- res.hyper[res.hyper$pval < 0.05, ]
  
  return(res.hyper)
  
}

names(res.hub.list) <- colnames(topGenesKME)

stopCluster(cl)

results.co.hub.p <- results.co.hub.bh <- NULL
for (i in 1:length(res.hub.list)){
  
  df.enrich.cur <- res.hub.list[[i]]
  df.enrich.cur$module <- names(res.hub.list)[i]
  results.co.hub.p <- bind_rows(results.co.hub.p,
                            (df.enrich.cur[df.enrich.cur$pval< 0.05]))
  results.co.hub.bh <- bind_rows(results.co.hub.bh,
                            (df.enrich.cur[df.enrich.cur$padj< 0.1]))
  
}
# rm(res.hub.list)

# flex.asDT(results.co.hub.bh)
```


```{r}

plt.tom <- F

if (print.inline & plt.tom) TOMplot(dissim = d.co, dendro = geneTree.co)

```

```{r go enrich, warning=FALSE, message=FALSE}

# run go enrichment
all.genes <- colnames(de.1)
library(topGO)

module.list.all <- getModuleGenes(modules.all, SubGeneNames, add.prefix = F)
module.list.co <- getModuleGenes(modules.cob, SubGeneNames, add.prefix = F)

# all genes
# enrichment.list.co <- runEnrichment(module.list.co, gene.universe = all.genes, species = species, p.threshold = 0.05, p.adj.threshold = 0.1)
# results.co.p <- enrichment.list.co$results.table.p
# results.co.bh <- enrichment.list.co$results.table.bh



my.symbol <- rownames(a.mat)
my.entrez <- sym2entrez(my.symbol, my.species =which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = "BP", species =  which.species)

g2e.list <- my.entrez$ENTREZID
names(g2e.list) <- my.entrez$SYMBOL

gene.universe <- unique(rownames(so.query))
gene.universe <- unique(g2e.list[gene.universe])

# res.h.list <- list()

n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)

res.h.list <- list()
res.h.list <- foreach(i = 1:length(module.list.co), .packages = c("dplyr", "fgsea"))  %dopar% {

  warning(paste0("progress: ", round(100*i/length(module.list.co)), "%\n"))
  current.genes <- unique(g2e.list[module.list.co[[i]]])
  
  res.hyper <-  fora(pathways = pathways.go, genes = current.genes, universe = gene.universe, minSize = 2, maxSize = Inf)
  res.hyper$f.query.ann <- res.hyper$overlap / res.hyper$size
  res.hyper$f.query.all <- res.hyper$overlap / length(current.genes)
  res.hyper$n.query.all <-length(current.genes)
  # res.hyper <- res.hyper[res.hyper$pval < 0.05, ]
  
  return(res.hyper)
  
}

names(res.h.list) <- names(module.list.co)

stopCluster(cl)

results.co.p <- results.co.bh <- NULL
for (i in 1:length(res.h.list)){
  
  df.enrich.cur <- res.h.list[[i]]
  df.enrich.cur$module <- names(res.h.list)[i]
  results.co.p <- bind_rows(results.co.p,
                            (df.enrich.cur[df.enrich.cur$pval< 0.05]))
  results.co.bh <- bind_rows(results.co.bh,
                            (df.enrich.cur[df.enrich.cur$padj< 0.1]))
  
}
rm(res.h.list)

```

```{r orthogonal enrichment of module annotations, fig.height = 10, fig.width = 10}


enrich.results <- results.co.p

# kme based enrichment (GSEA)
e.k <- gsea.pathway.kme.all.consensus[ ,c("pathway", "pval", "NES", "module", "padj")]
e.d <- gsea.pathway.kme.all.differential[ ,c("pathway", "pval", "NES", "module", "padj")]

# module overrepresentation based enrichment (topGO)
e.m <- enrich.results[ ,c("pathway", "module", "pval")]
colnames(e.m) <- c("pathway", "module", "pval")

# merge annotations and get significant
e.merge <- merge(e.m, e.k, by = c("pathway", "module"))
e.merge$p.max <- pmax(e.merge$pval.x, e.merge$pval.y)
e.merge$p.adj <- p.adjust(e.merge$p.max, method = "BH", length(e.merge$p.max))
e.merge.sub <- e.merge[(e.merge$p.max < 0.1) & (abs(e.merge$NES) > 0.7), ]



top.module.annotations.con <- e.merge.sub %>%
  group_by(module) %>%
  top_n(10,  -log10(as.numeric(p.adj))) %>%
    group_by(module) %>%
  top_n(5,  -log10(as.numeric(p.max))) 

top.module.annotations.dif <- e.d %>%
  group_by(module) %>%
  top_n(10,  -log10(as.numeric(padj))) %>%
    group_by(module) %>%
  top_n(5,  -log10(as.numeric(pval))) 

top.module.annotations.con.v2 <- e.k %>%
  group_by(module) %>%
  top_n(10,  -log10(as.numeric(padj))) %>%
    group_by(module) %>%
  top_n(5,  -log10(as.numeric(pval))) 



plt.enrich.all <- list()
u.modules <- as.character(unique(top.module.annotations.con$module))
for (i in 1:length(u.modules)){
   col.pal <- top.module.annotations.con$module[top.module.annotations.con$module == u.modules[i]]
names(col.pal)  <- top.module.annotations.con$module[top.module.annotations.con$module == u.modules[i]]
  plt.enrich.all[[u.modules[i]]] <- top.module.annotations.con %>%
  filter(module == u.modules[i]) %>%
  ggplot(aes(x = reorder(pathway, NES), y = NES, fill = module)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + scale_fill_manual(values = col.pal) + 
    geom_hline(yintercept = 0, linetype = "dashed") + 
  theme_classic() + 
   xlab("") + 
  ggtitle(u.modules[i]) + theme(legend.position = "none")
}
  
if (print.inline){
   cowplot::plot_grid(plotlist  = plt.enrich.all, ncol = 2, align = "hv")
}





```


```{r visualize top enrichments, fig.width=15, fig.height=10}

enrich.results <- results.co.p

enrich.results$prop <- enrich.results$Significant / enrich.results$Annotated
top.module.annotations <- enrich.results %>%
  group_by(module) %>%
  top_n(3,  -log10(as.numeric(pval))) 

top.module.annotations <- enrich.results %>%
  group_by(module) %>%
  top_n(2,  -log10(as.numeric(padj))) %>%
    group_by(module) %>%
  top_n(2,  -log10(as.numeric(pval))) 



col.pal <- top.module.annotations$module
names(col.pal)  <- top.module.annotations$module

plt.go.1 <- top.module.annotations %>%
  ggplot(aes(x = reorder(pathway, -log10(pval)), y = -log10(pval), fill = module)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + scale_fill_manual(values = col.pal) + 
  theme_classic() + 
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") + xlab("") + 
  labs(title = "GO Enrichment of Network Modules", subtitle = "p values")

plt.go.2 <- top.module.annotations %>%
  ggplot(aes(x = reorder(pathway, -log10(padj)), y = -log10(padj), fill = module)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + scale_fill_manual(values = col.pal) + 
  theme_classic() + 
  geom_hline(yintercept = -log10(0.05), linetype = "dashed") + xlab("") + 
  labs(title = "GO Enrichment of Network Modules", subtitle = "adjusted p values")

if (print.inline){
  # fig.width=15, fig.height=10
  cowplot::plot_grid(plt.go.1, plt.go.2, col = 2)
}


```


```{r module enrichment statistics, fig.width = 10, fig.height = 4}

# percentage of genes that contribute to enrichment

# df.gene2module <-  namedList2longDF(getModuleGenes(modules.cob, SubGeneNames, add.prefix = F),
#                                     name.header = "module", value.header = "genes")
# df.moduleSize <- data.frame(table(df.gene2module$module))
# colnames(df.moduleSize) <- c("module", "n")
# 
# results.all.stats <- results.co.p
# results.all.stats <- merge(results.all.stats, df.moduleSize, by = "module")
# results.all.stats$module.prop <- results.all.stats$Significant / results.all.stats$n

# results.bh.sum <- results.all.stats %>%
#   group_by(module) %>%
#   summarize(mean.prop = mean(module.prop), 
#             module.size = mean(n),
#             n.enrichments = length(n))

# plt.e.1 <- results.bh.sum %>%
#   ggplot(aes(x = reorder(module, n.enrichments), y = n.enrichments, fill = module.size)) + 
#   geom_bar(stat = "identity")+
#   theme_classic() + 
#   xlab("Module") + ylab("N Enrichments") + 
#   coord_flip() + 
#   labs(title = "Enrichments per Module", subtitle = "high blue ~ signal; low red ~ noise", fill = "Module Size") + 
#   scale_fill_gradient(low="blue", high="red")
# 
# 
# plt.e.2 <- results.all.stats %>%
#   ggplot(aes(x = reorder(module, -module.prop), y = module.prop, fill = n)) + 
#   geom_boxplot()+
#   theme_classic() + 
#   theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) + 
#   xlab("Module") + ylab("Proportion of Module Contributing to Enrichment") + 
#   labs(title = "Module Fraction per Enrichment", subtitle = "high red ~ signal; low blue ~ noise", fill = "Module Size") + 
#   scale_fill_gradient(low="blue", high="red")
# 
# 
# if (print.inline){
#   # fig.width = 10, fig.height = 4
#   cowplot::plot_grid(plt.e.1, plt.e.2)
# }

```



```{r generate network plots}

# df.visNet <- graph_from_data_frame(d, directed = TRUE, vertices = NULL)

library(visNetwork)

which.modules <- "all" # all or color for specific module
top.n.interactions <- 200

net.modules <- modules.consensus # modules.all
net.mat <- w.co # w.mat

module.list.all <- getModuleGenes(net.modules, SubGeneNames, add.prefix = F)
rownames(net.mat) <- rownames(a.mat) 
colnames(net.mat) <- colnames(a.mat)

# get network connectivity ===============================
if (which.modules %in% names(module.list.all)){
  module.name <- names(module.list.all)[names(module.list.all) %in% which.modules]
  module.gene.cur <- module.list.all[[module.name]]
  w.cur <- net.mat[rownames(net.mat) %in% module.gene.cur, colnames(net.mat) %in% module.gene.cur]
  w.df.top <- wgcna2graphDF(w.cur, top.n = top.n.interactions)
  w.df.top$module.membership <- module.name
  
} else if (which.modules == "all"){
  w.df.top <- NULL
  for (i in 1:length(names(module.list.all))){
    module.name <- names(module.list.all)[names(module.list.all) %in% names(module.list.all)[i]]
    if (module.name == "grey") next
    module.gene.cur <- module.list.all[[module.name]]
    w.cur <- net.mat[rownames(net.mat) %in% module.gene.cur, colnames(net.mat) %in% module.gene.cur]
    w.df.top.cur <- wgcna2graphDF(w.cur, top.n = top.n.interactions)
    w.df.top.cur$module.membership <- module.name
    w.df.top <- bind_rows(w.df.top.cur, w.df.top)
  }
}

# get nodes and edges ===============================

node.edge.output <- getNodesEdges(w.df.top)
vis.nodes <- node.edge.output$nodes
vis.links <- node.edge.output$edges

# node attributes ===============================

# assign module membership to nodes
df.map.network <- df.map.all
colnames(df.map.network) <- c("module", "id")
u.modules <- as.character(unique(df.map.network$module))
vis.nodes$module <- "grey"
for (i in 1:length(u.modules)){
  vis.nodes$module[vis.nodes$id %in% df.map.network$id[df.map.network$module %in% u.modules[i]]] <- u.modules[i]
}

# get differential expression
df.deg.network <- df.con.deg.merge.noMod[ ,c("genes", "dif", "w.delta")]
colnames(df.deg.network) <- c("id", "z", "w.delta")
df.deg.network <- df.deg.network[df.deg.network$id %in% vis.nodes$id, ]
vis.nodes <- merge(vis.nodes, df.deg.network)

# get connectivity
df.con <- getConnectivity(net.mat, gene.names = colnames(a.mat))[,c("genes", "wi")]
colnames(df.con) <- c("id", "wi")
df.con <- df.con[!(duplicated(df.con$id)), ]
df.con <- df.con[df.con$id %in% vis.nodes$id, ]
vis.nodes <- merge(vis.nodes, df.con)

# map deg to color gradient
# col.lim.z <- max(c(abs(min(vis.nodes$z)), abs(max(vis.nodes$z))))
col.lim.z <- 1
node.colors <- value2col(vis.nodes$z, limit = col.lim.z)
vis.nodes$deg <- "grey" # no effect
vis.nodes$deg[vis.nodes$id %in% df.deg$genes[df.deg$p_val_adj < 0.05]] <- "black"

if ("color" %in% colnames(vis.nodes)) vis.nodes <- vis.nodes %>% dplyr::select(-c("color"))
vis.nodes$color.border <-vis.nodes$deg 
vis.nodes$color.background <- node.colors
vis.nodes$size <- 10*(vis.nodes$wi - mean(vis.nodes$wi))/sd(vis.nodes$wi) + 25
vis.nodes$font.size <- 45

# edge attributes ===============================

# data preprocessing
w.delta.mat <- log(w.2/sum(w.2)) - log(w.1/sum(w.1))
# w.delta.mat <- a.2 - a.1
colnames(w.delta.mat) <- colnames(a.mat)
rownames(w.delta.mat) <- rownames(a.mat)
w.delta.mat <- w.delta.mat[rownames(w.delta.mat) %in% vis.nodes$id, colnames(w.delta.mat) %in% vis.nodes$id]
w.delta.df <- as.data.frame(w.delta.mat)
w.detla.genenames <-  colnames(w.delta.df)
w.delta.df$genes <- rownames(w.delta.df)
w.delta.df <- w.delta.df[!(duplicated(w.delta.df$genes)), !(duplicated(colnames(w.delta.df)))]
w.delta.df.long <- unique(pivot_longer(w.delta.df, cols = w.detla.genenames))
colnames(w.delta.df.long) <- c("from", "to", "value")
vis.links <- merge(vis.links, w.delta.df.long, by = c("from", "to"))

# edge colors
col.lim <- max(c(abs(min(vis.links$value)), abs(max(vis.links$value))))
edge.colors <- value2col(vis.links$value, limit = col.lim)

vis.links$edge.color <-edge.colors
vis.links$color <-edge.colors
vis.links$smooth <- F
vis.links$width <- 1+vis.links$weight/20

# generate network plot

# layout_with_kk
# layout_with_fr

# enfore unique id
vis.nodes <- vis.nodes[!(duplicated(vis.nodes$id)), ]
which.unique <- unique(vis.nodes$id)
vis.links <- vis.links[vis.links$from %in% which.unique, ]
vis.links <- vis.links[vis.links$to %in% which.unique, ]

# ensure all cases are complete
vis.nodes <- vis.nodes[complete.cases(vis.nodes), ]
vis.links <- vis.links[complete.cases(vis.links), ]

# generate master network
master.nodes <- vis.nodes
master.links <- vis.links

master.nodes$color.background <- master.nodes$module
master.nodes$color.border <- "grey"
master.nodes$font.size <- 45

node.modules <- master.nodes[ ,c("id", "module")]
colnames(node.modules) <- c("from", "module")
master.links <- merge(master.links, node.modules, by = "from")
master.links$edge.color <- master.links$module
master.links$color <-master.links$module
master.links$width <- 0.02
master.links$weight <- 0.02

if (print.inline){
  visNetwork( master.nodes,master.links,  main = "Reference Network") %>%
    visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
    visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T), 
               nodesIdSelection = T, selectedBy = c("module")) %>%
    visInteraction(navigationButtons = TRUE,keyboard = TRUE) %>%
    visConfigure(enabled = TRUE)  
  
  # generate differential network
  visNetwork( vis.nodes,vis.links,  main = "Differential Network Analysis",
              submain = paste0(comparison.group, " (red) - ", reference.group, " (blue)")) %>%
    visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
    visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T), 
               nodesIdSelection = T, selectedBy = c("module")) %>%
    visInteraction(navigationButtons = TRUE,keyboard = TRUE) %>%
    visConfigure(enabled = TRUE)  
}


```



```{r top annotations projected onto network map}
# todo: include this part in earlier assignment to vis.nodes and vis.links (300420)


# get top pathways for each module
if (!is.null(results.co.bh)){
  

top.annotations <- results.co.bh %>%
  group_by(module) %>%
  top_n(3,  -log10(padj)) %>%
  group_by(module) %>%
  top_n(3,  -log10(as.numeric(pval))) 

# generate master network
path.nodes <- vis.nodes
path.links <- vis.links

annotation.features<- c()
for (i in 1:nrow(top.annotations)){
  
  try({
    
  top.annotations$genes[i] <- list(id2geneset(top.annotations$GO.ID[i], my.species = species))
  
  # annotation.features[i] <- paste0("M.", top.annotations$module[i])
  annotation.features[i] <- paste0(top.annotations$module[i],"_", top.annotations$Term[i], "_", top.annotations$GO.ID[i])
  path.nodes[ ,annotation.features[i]] <- ""
  path.nodes[path.nodes$id %in% unlist(top.annotations$genes[i]) ,annotation.features[i]] <- annotation.features[i]
  }, silent = T)
}

annotation.features <- annotation.features[annotation.features %in% colnames(path.nodes)]

for (i in 1:nrow(path.nodes)){
  cur.entries <-  c(as.character(path.nodes[ i,annotation.features]))
  cur.entries <- cur.entries[cur.entries != ""]
  path.nodes$group[i]  <- paste(cur.entries, collapse = ", ")
}


if (print.inline){
    visNetwork( path.nodes,path.links,  main = "Differential Network v2",
              submain = paste0(comparison.group, " (red) - ", reference.group, " (blue)")) %>%
    visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
    visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T), 
               nodesIdSelection = T, selectedBy = c("group")) %>%
    visInteraction(navigationButtons = TRUE,keyboard = TRUE) %>%
    visConfigure(enabled = TRUE) 
}

}


```






```{r get module genes}

module.list.1 <- getModuleGenes(modules.1b, SubGeneNames, add.prefix = F)
module.list.2 <- getModuleGenes(modules.2b, SubGeneNames, add.prefix = F)
module.list.co <- getModuleGenes(modules.cob, SubGeneNames, add.prefix = F)
module.list.all <- getModuleGenes(modules.all, SubGeneNames, add.prefix = F)

# get genes that are common to both network modules
module.union.list <- list()
common.modules <- intersect(modules.1b, modules.2b)
module.u1.list <- list()
module.u2.list <- list()
for (i in 1:length(common.modules)){
  common.genes <- intersect(module.list.1[[common.modules[i]]], module.list.2[[common.modules[i]]])
  set.1 <- setdiff(module.list.1[[common.modules[i]]], module.list.2[[common.modules[i]]])
  set.2 <- setdiff(module.list.2[[common.modules[i]]], module.list.1[[common.modules[i]]])
  module.union.list[[common.modules[i]]] <- common.genes
  module.u1.list[[common.modules[i]]] <- set.1
  module.u2.list[[common.modules[i]]] <- set.2
}



if (print.inline) {
  table(modules.1b)
  table(modules.2b)
}

# convert list to wide df (for export)
module.df.1 <- namedList2wideDF(module.list.1)
module.df.2 <- namedList2wideDF(module.list.2)
module.df.co <- namedList2wideDF(module.list.co)
module.df.all <- namedList2wideDF(module.list.all)

```


```{r connectivity, fig.width=10, fig.height=4}

# go.here

# get connectivity
df.con <- getConnectivity(w.co, gene.names = colnames(a.mat))

# get connectivity scores
df.con.1 <- getConnectivity(w.1, rownames(a.1))
df.con.2 <- getConnectivity(w.2, rownames(a.2))

# quantile normalization of connectivity
# df.con.qNorm <- qNorm(df.con.1$wi, df.con.2$wi, df.con.2$genes)
# df.con.1$wi <- df.con.qNorm$x.new
# df.con.2$wi <- df.con.qNorm$y.new


# w.1.scale <- scaleTOM(w.1, w.co)
# w.2.scale <- scaleTOM(w.2, w.co)
# 
# df.con.1 <- getConnectivity(w.1, gene.names = colnames(a.1))
# df.con.2 <- getConnectivity(w.2, gene.names = colnames(a.2))

df.deg.pool$genes <- rownames(df.deg.pool)
df.con.merge <- merge(df.con.1, df.con.2, by = "genes")
df.con.deg <- merge(df.deg.pool, df.con, by = "genes")
df.delta.con.deg <- merge(df.deg.pool, df.con.merge, by = "genes")

# df.delta.con.deg$wi.x.norm <- rank((df.delta.con.deg$wi.x)/sum((df.delta.con.deg$wi.x)))
# df.delta.con.deg$wi.y.norm <- rank((df.delta.con.deg$wi.y)/sum((df.delta.con.deg$wi.y)))
df.delta.con.deg$wi.x.norm <- df.delta.con.deg$wi.x
df.delta.con.deg$wi.y.norm <- df.delta.con.deg$wi.y
df.delta.con.deg$delta.rank <- df.delta.con.deg$wi.y.norm - df.delta.con.deg$wi.x.norm

df.delta.con.deg$composite.score <- (((df.delta.con.deg$avg_logFC - mean(df.delta.con.deg$avg_logFC)) / sd(df.delta.con.deg$avg_logFC))  + ((df.delta.con.deg$delta.rank - mean(df.delta.con.deg$delta.rank)) / sd(df.delta.con.deg$delta.rank))) / 2
rank.limit <- max(c(abs(min(df.delta.con.deg$composite.score)), abs(max(df.delta.con.deg$composite.score))))

label.top.n <-15
top.delta <- c(top_n(df.delta.con.deg, label.top.n, avg_logFC)$genes,
               top_n(df.delta.con.deg, label.top.n, -avg_logFC)$genes,
               top_n(df.delta.con.deg, label.top.n, delta.rank)$genes,
               top_n(df.delta.con.deg, label.top.n, -delta.rank)$genes,
               top_n(df.con.deg, label.top.n, wi)$genes)
top.delta <- unique(top.delta)

plt.2 <- df.delta.con.deg %>%
  ggplot(aes(x = avg_logFC, y = delta.rank,color = composite.score,  size = -log1p(p_val_adj) * 0.5, text = genes)) +
  geom_point(alpha = 0.5) +
  xlab("log FC") +
  ylab(paste0("Delta Rank Connectivity (", comparison.group, "-", reference.group, ")")) +
  geom_vline(xintercept = 0 , linetype = "dashed") +
  geom_hline(yintercept = 0 , linetype = "dashed") +
  labs(title = "DEG vs. Connectivity", subtitle = "CS = mean(standardized delta node & link)", size = "-log(p)") +
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")") ) +
  theme_classic() +
  scale_colour_gradientn("CS", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.delta.con.deg$composite.score), 0, max(df.delta.con.deg$composite.score))))) +
  ggrepel::geom_text_repel(aes(avg_logFC, delta.rank,
                               label =ifelse(genes %in% top.delta ,as.character(genes),'')), size = 2.5, color = "black") 


df.delta.con.deg$mean.rank <- (df.delta.con.deg$wi.x.norm + df.delta.con.deg$wi.y.norm)/2

# df.con.deg$logp <- 
plt.3 <- df.con.deg %>%
  ggplot(aes(x = avg_logFC, y = rank(wi) ,color =avg_logFC, size = -log1p(p_val_adj) * 0.5, text = genes)) +
  geom_point(alpha = 0.5) +
  ylab("Connectivity Rank") +
  theme_classic() +
  geom_vline(xintercept = 0 , linetype = "dashed") +
  labs(title = "DEG Rank Plot", subtitle = "Ranked by Network Connectivity", size = "-log(p)") + 
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")")) +
  ggrepel::geom_text_repel(aes(avg_logFC, rank(wi), label =ifelse(genes %in% top.delta ,as.character(genes),'')), size = 2.5, color = "black") +
  scale_colour_gradientn("logFC", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.con.deg$avg_logFC), 0, max(df.con.deg$avg_logFC)))))

df.delta.con.deg$top.connect <- F
df.delta.con.deg$top.connect[df.delta.con.deg$mean.rank >  nrow(df.delta.con.deg)-20] <- T
df.delta.con.deg$sig.flag <- F
df.delta.con.deg$sig.flag[df.delta.con.deg$delta.rank >  1.96*sd(df.delta.con.deg$delta.rank)] <- T
df.delta.con.deg$sig.flag[df.delta.con.deg$delta.rank < -1.96*sd(df.delta.con.deg$delta.rank)] <- T

if (print.inline){
  cowplot::plot_grid(plt.2, plt.3, ncol = 2)
}

```


```{r connectivity and expression overview, fig.width=10, fig.height=4}

# Distribution of connectivities
plt.overview.1 <- df.delta.con.deg %>%
  ggplot() + 
  geom_density(aes(wi.x), alpha = 0.5, fill = "skyblue") + 
  geom_density(aes(wi.y), alpha = 0.5, fill = "tomato") + 
  theme_classic() + 
  xlab("Quantile Normalized Connectivity, wi") + 
  labs(title = ("Network Connectivity Distribution"), subtitle = paste0(reference.group, " (blue) vs. ", comparison.group, " (red)\np=", signif(wilcox.test(df.delta.con.deg$wi.x, df.delta.con.deg$wi.y)[["p.value"]], 3)))



# Distribution of expression differences
plt.overview.2 <- df.delta.con.deg %>%
  ggplot() + 
  geom_density(aes(avg_logFC, fill = "logFC"), alpha = 0.5) + 
  geom_density(aes(pct.1 - pct.2, fill = "deltaFraction"), alpha = 0.5) + 
  theme_classic() + 
  xlab(paste0("logFC (", comparison.group , "-", reference.group , ")")) + 
  geom_vline(xintercept= 0, linetype = "dashed") +    
  scale_fill_manual("", 
                      breaks = c("logFC", "deltaFraction"),
                      values = c("logFC"="black", "deltaFraction"="grey")) + 
  labs(title = ("Expression Difference Distribution"), subtitle = paste0(comparison.group, "-", reference.group))

if (print.inline){
  cowplot::plot_grid(plt.overview.1, plt.overview.2, ncol = 2)
}
```

```{r delta node enrichment, fig.height = 8, fig.width=10}

# Connections DEG ##############################################################
x.w1 <- getConnectivity(w.1, gene.names = colnames(a.1))$wi
y.w2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.con.deg.cur <- data.frame(genes = colnames(a.1), w.ref = x.w1, w.comp  = y.w2, dif = y.w2-x.w1)
  if (is.null(df.con.deg.cur)) next
  df.con.deg.cur <- df.con.deg.cur[complete.cases(df.con.deg.cur),]
  
  # prep gene list (match to EntrezID, sort)
  gene.list <- df.con.deg.cur$dif
  names(gene.list) <- df.con.deg.cur$genes
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  # pathway gsea enrichment
  gse.deg.wiRank.pathway <- fgsea::fgsea(pathways.go, gene.list.clean, nperm=1000, maxSize=500)
  
  if (nrow(gse.deg.wiRank.pathway) == 0) next
  
  gse.deg.wiRank.pathway$cluster <- "all"
  
  gse.pathway.degWi <- gse.deg.wiRank.pathway
  gse.pathway.degWi[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.degWi[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.degWi.all <- gse.pathway.degWi[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
  
# Expression DEG ##############################################################
  
  x.e1 <- dif.mat[ ,reference.group]; y.e2 <- dif.mat[ ,comparison.group]
# y.e2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.exp.deg.cur <- data.frame(genes = dif.mat$gene, e.ref = x.e1, e.comp  = y.e2, dif = y.e2-x.e1)
  if (is.null(df.exp.deg.cur)) next
  df.exp.deg.cur <- df.exp.deg.cur[complete.cases(df.exp.deg.cur),]
  
  # prep gene list (match to EntrezID, sort)
  gene.list <- df.exp.deg.cur$dif
  names(gene.list) <- df.exp.deg.cur$genes
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  # pathway gsea enrichment
  gse.deg.expRank.pathway <- fgsea::fgsea(pathways.go, gene.list.clean, nperm=1000, maxSize=500)
  
  if (nrow(gse.deg.expRank.pathway) == 0) next
  
  gse.deg.expRank.pathway$cluster <- "all"
  
  gse.pathway.degExp <- gse.deg.expRank.pathway

  gse.pathway.degExp[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.degExp[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.degExp.all <- gse.pathway.degExp[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
  
# Merge and Plot ##############################################################

gsea.deg.merge <- merge(gse.pathway.degExp.all, gse.pathway.degWi.all, by = "pathway")
gsea.deg.merge$NES.mean <- (gsea.deg.merge$NES.x + gsea.deg.merge$NES.y)/2
gsea.deg.merge$NES.dif <- (gsea.deg.merge$NES.x - gsea.deg.merge$NES.y)
gsea.deg.merge$p.mean <- (gsea.deg.merge$pval.x + gsea.deg.merge$pval.y)/2

# plot top enrichments (bar plot)
top.n.enrich <- 10
gsea.degWi.sig.top <- bind_rows(top_n(gsea.deg.merge, top.n.enrich, NES.mean),
                                top_n(gsea.deg.merge, top.n.enrich, -NES.mean)) 


top.n.enrich.merge<- 5
gsea.deg.merge.topMean <- bind_rows(top_n(gsea.deg.merge, top.n.enrich.merge, NES.mean),
                                top_n(gsea.deg.merge, top.n.enrich.merge, -NES.mean)) 
gsea.deg.merge.topDif <- bind_rows(top_n(gsea.deg.merge, top.n.enrich.merge, NES.dif),
                                top_n(gsea.deg.merge, top.n.enrich.merge, -NES.dif)) 


# compare enrichment based on differen ranking schemes
gsea.deg.merge$label <- F
gsea.deg.merge$label[gsea.deg.merge$pathway %in% gsea.deg.merge.topMean$pathway] <- T
gsea.deg.merge$label[gsea.deg.merge$pathway %in% gsea.deg.merge.topDif$pathway] <- T

plt.gsea.comp <- gsea.deg.merge %>%
  ggplot(aes(x = NES.x, y = NES.y, color = (NES.mean), size = 1/abs(NES.dif), text = pathway)) + 
  geom_point() + 
  xlab(paste0("GSEA score (differential expression)\n", comparison.group, "-", reference.group)) + 
  ylab(paste0("GSEA score (differential connectivity)\n", comparison.group, "-", reference.group)) + 
  theme_classic() + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  ggrepel::geom_text_repel(aes(NES.x, NES.y, label =ifelse(label ,as.character(pathway),'')), size = 2.5, color = "black") +
  labs(title = "Delta Node Enrichment", subtitle = "DEG vs Connectivity-based Ranking") + 
    scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(gsea.deg.merge$NES.mean), 0, max(gsea.deg.merge$NES.mean))))) + 
  theme_miko(legend = T)

if (print.inline){
  print(plt.gsea.comp)
}



```

```{r plot differential gene expression and connectivity}

# df.con.deg.cur
# df.exp.deg.cur
df.ecd.merge <- merge(df.con.deg.cur, df.exp.deg.cur, by = "genes")
df.ecd.merge$avg.w <- (df.ecd.merge$w.ref + df.ecd.merge$w.comp)/2

df.ecd.merge$s.e <- scale( df.ecd.merge$dif.y, center = F, scale = T)
df.ecd.merge$s.w <- scale( df.ecd.merge$dif.x, center = F, scale = T)

df.ecd.merge$dif.xy <- sqrt(df.ecd.merge$s.w^2 + df.ecd.merge$s.e^2)


deg.genes <- df.deg.pool$genes

df.ecd.merge$is.sig <- F
df.ecd.merge$is.sig[df.ecd.merge$genes %in% deg.genes] <- T
df.ecd.merge$lab <- "lightgrey"
df.ecd.merge$lab[df.ecd.merge$is.sig] <- scales::muted("red")

plt.dif.exp.con <- df.ecd.merge %>%
  ggplot(aes(x = s.e, y = avg.w, label = genes, size =avg.w,  alpha =avg.w)) + 
  geom_text(color = df.ecd.merge$lab) + 
  theme_miko(legend = T) + 
  geom_vline(xintercept = 0, linetype = "dashed") +
  # geom_hline(yintercept = 0, linetype = "dashed") + 
  labs(color = "~ sig", size = "~ sig") + 
  ylab("Gene Connectivity") + 
  xlab("Delta Expression")

if (print.inline){
  print(plt.dif.exp.con)
}

```

```{r differential linkage analysis, message = FALSE, warning = FALSE}

# Differential linkage ############################################
# gene to module mapping
# df.gene2module <-  namedList2longDF(getModuleGenes(modules.cob, SubGeneNames, add.prefix = F),
#                                     name.header = "module", value.header = "genes")
# 
# # differential connectivity 
# df.dif.con.merge <- df.con.merge
# df.dif.con.merge <- merge(df.dif.con.merge, df.gene2module, by = "genes")
# df.dif.con.merge$wi.x.norm <- df.dif.con.merge$wi.x
# df.dif.con.merge$wi.y.norm <- df.dif.con.merge$wi.y
# df.dif.con.merge$delta.wi <- df.dif.con.merge$wi.y.norm - df.dif.con.merge$wi.x.norm
# 
# df.dif.wi.sum <- df.dif.con.merge %>%
#   group_by(module) %>%
#   summarize(mean.dif = mean(wi.y.norm - wi.x.norm),
#             median.dif = median(wi.y.norm - wi.x.norm),
#             sd.dif = sd(wi.y.norm - wi.x.norm),
#             n.dif = length(wi.y.norm - wi.x.norm),
#             val.x = list(wi.x.norm),
#             val.y = list(wi.y.norm),
#             pVal = wilcox.test(wi.x.norm, wi.y.norm)[["p.value"]])
# 
# # multiple comparison correction
# df.dif.wi.sum$pAdj <- p.adjust(df.dif.wi.sum$pVal, method = "BH", n = nrow(df.dif.wi.sum))
# # df.dif.rank.sum$pAdj <- p.adjust(df.dif.rank.sum$pVal, method = "BH", n = nrow(df.dif.rank.sum))
# 
# # differential connectivity volcano
# plt.dif.con <- df.dif.wi.sum %>%
#   ggplot(aes(x = median.dif, y = -log10(pVal), color = median.dif, size = -log10(pVal))) +
#   geom_point(stat = "identity") +
#   theme_classic() + 
#   xlab(paste0("Connectivity Difference (", comparison.group, " - ", reference.group, ")")) + 
#   ylab("-log10(p.Adj)") + 
#   geom_vline(xintercept = 0, linetype = "dashed")  +
#   ggrepel::geom_text_repel(aes(median.dif,  -log10(pVal), label =module), size = 3, color = "black") + 
#   ggtitle("Differential Connectivity") + 
#     scale_colour_gradientn("Difference", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
#                          values=c(rescaleValues(c(min(df.dif.wi.sum$median.dif), 0, max(df.dif.wi.sum$median.dif))))) 
# 
# 
# if (sum(df.dif.wi.sum$pAdj < 0.05) > 0) plt.dif.con <- plt.dif.con +  geom_hline(yintercept =-log10(0.05), linetype = "dashed") 
# 
# 
# if (print.inline){
#   print(plt.dif.con)
# }


```


```{r, fig.width=10, fig.height=10}

top.n.terms <- 5
df.top.link <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.x > 0) %>% dplyr::arrange(pval.x))[1:top.n.terms],
(gsea.deg.merge %>% dplyr::filter(NES.x < 0) %>% dplyr::arrange(pval.x))[1:top.n.terms])

df.top.node <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.y > 0) %>% dplyr::arrange(pval.y))[1:top.n.terms],
(gsea.deg.merge %>% dplyr::filter(NES.y < 0) %>% dplyr::arrange(pval.y))[1:top.n.terms])

df.top.net <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.mean > 0) %>% dplyr::arrange(p.mean))[1:top.n.terms],
(gsea.deg.merge %>% dplyr::filter(NES.mean < 0) %>% dplyr::arrange(p.mean))[1:top.n.terms])

df.top.all <- bind_rows(df.top.link, df.top.node, df.top.net)


plt.e.node.linkage <- df.top.net %>%
  ggplot(aes(x = reorder(pathway,NES.mean),  y = NES.mean, fill = -log10(p.mean))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment (Consensus)\nNode + Linkage Scores") + 
  xlab("") + 
  ylab(paste0("Consensus GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

plt.e.node <- df.top.node %>%
  ggplot(aes(x = reorder(pathway,NES.y),  y = NES.y, fill = -log10(pval.y))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment\nNode Scores") + 
  xlab("") + 
   ylab(paste0("Node GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

plt.e.linkage <- df.top.link %>%
  ggplot(aes(x = reorder(pathway,NES.x),  y = NES.x, fill = -log10(pval.x))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment\nLinkage Scores") + 
  xlab("") + 
   ylab(paste0("Linkage GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

if (print.inline){
   # fig.height=10, fig.width=10
  cowplot::plot_grid(plt.e.node.linkage, plt.e.node, plt.e.linkage, ncol = 1, align = "v")
}

```


```{r delta linkage enrichment}

# GSEA Delta linkage ############################################

# enrich based on delta connectivity
# gene.list.delta <- df.dif.con.merge$delta.wi
# names(gene.list.delta) <- (as.character(df.dif.con.merge$genes))
# match.ind <- match(names(gene.list.delta), my.entrez$SYMBOL)
# names(gene.list.delta) <- as.character(my.entrez$ENTREZID[match.ind])
# gene.list.delta = sort(gene.list.delta, decreasing = TRUE)
# 
# # clean list
# df.ent.delta <- data.frame(names = names(gene.list.delta), values = as.vector(gene.list.delta))
# df.ent.delta <- df.ent.delta[complete.cases(df.ent.delta), ]
# df.ent.delta <- df.ent.delta[!is.infinite(df.ent.delta$values), ]
# gene.list.delta.clean <- df.ent.delta$values
# names(gene.list.delta.clean) <- df.ent.delta$names
# 
# # pathway gsea enrichment
# gsea.pathway.wi <- fgsea::fgsea(pathways, gene.list.delta.clean, nperm=1000, maxSize=500)
# gsea.pathway.wi.sig <- gsea.pathway.wi[(gsea.pathway.wi$pval < 0.05) & (abs(gsea.pathway.wi$NES) >= 1), ]
# 
# gsea.pathway.merge <- merge(gsea.deg.merge, gsea.pathway.wi, by = "pathway")
# 
# gsea.pathway.merge$NES.mean.all <- (gsea.pathway.merge$NES.mean + gsea.pathway.merge$NES)/2
# gsea.pathway.merge$NES.dif.all <- (gsea.pathway.merge$NES.mean - gsea.pathway.merge$NES)
# # gsea.pathway.merge$p.pool <- 10^(mean(log10()))
# 
# # get geometric mean of pval
# gsea.pathway.merge <- gsea.pathway.merge %>%   mutate(p.pool =  10^((log10(pval.x) + log10(pval.y) + log10(pval))/3))
# 
# # flag top pathways
# top.n.enrich.merge <- 3
# gsea.wi.merge.topMean <- bind_rows(top_n(gsea.pathway.merge, top.n.enrich.merge, NES.mean.all),
#                                 top_n(gsea.pathway.merge, top.n.enrich.merge, -NES.mean.all)) 
# gsea.wi.merge.topDif <- bind_rows(top_n(gsea.pathway.merge, top.n.enrich.merge, NES.dif.all),
#                                 top_n(gsea.pathway.merge, top.n.enrich.merge, -NES.dif.all)) 
# 
# gsea.pathway.merge$label <- F
# gsea.pathway.merge$label[gsea.pathway.merge$pathway %in% gsea.wi.merge.topMean$pathway] <- T
# gsea.pathway.merge$label[gsea.pathway.merge$pathway %in% gsea.wi.merge.topDif$pathway] <- T
# 
# # generate plot
# plt.dif.net.enrich <- gsea.pathway.merge %>%
#   ggplot(aes(x = NES.mean,y = NES, color = (NES.mean.all), size = 1/abs(NES.dif.all))) + 
#   geom_point() + 
#   xlab("Delta Node Enrichment") + 
#   ylab("Delta Linkage Enrichment") + 
#   theme_classic() + 
#   geom_hline(yintercept = 0) + 
#   geom_vline(xintercept = 0) + 
#   ggrepel::geom_text_repel(aes(NES.mean, NES, label =ifelse(label ,as.character(pathway),'')), size = 2.5, color = "black") + 
#       scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
#                          values=c(rescaleValues(c(min(gsea.pathway.merge$NES.mean.all, na.rm = T), 0, max(gsea.pathway.merge$NES.mean.all, na.rm = T))))) + 
#  labs(title = paste0("Differential Network Enrichment (GSEA)"), subtitle = paste0(comparison.group, " (red) - ", reference.group, " (blue)"))

# if (print.inline){
#   print(plt.dif.net.enrich)
# }

```

```{r, fig.height=10, fig.width=10}

# 
# top.n.enrich <- 10
# gsea.node.linkage.enrich.top <- bind_rows(top_n(gsea.pathway.merge, top.n.enrich, NES.mean.all),
#                                   top_n(gsea.pathway.merge, top.n.enrich, -NES.mean.all)) 
# 
# gsea.node.enrich.top <- bind_rows(top_n(gsea.pathway.merge, top.n.enrich, NES.mean),
#                                   top_n(gsea.pathway.merge, top.n.enrich, -NES.mean)) 

# gsea.linkage.enrich.top <- bind_rows(top_n(gsea.pathway.merge, top.n.enrich, NES),
#                                   top_n(gsea.pathway.merge, top.n.enrich, -NES)) 
# 
# plt.e.node.linkage <- gsea.node.linkage.enrich.top %>%
#   ggplot(aes(x = reorder(pathway,NES.mean.all),  y = NES.mean.all, fill = -log10(p.pool))) + 
#   geom_bar(stat = "identity") + coord_flip() + 
#   ggtitle("GSEA Enrichment (Consensus)\nNode + Linkage Scores") + 
#   xlab("") + 
#   ylab(paste0("Consensus GSEA Score\n", comparison.group, "-", reference.group)) + 
#   theme_classic()
# 
# plt.e.node <- gsea.node.enrich.top %>%
#   ggplot(aes(x = reorder(pathway,NES.mean),  y = NES.mean, fill = -log10(pval.x))) + 
#   geom_bar(stat = "identity") + coord_flip() + 
#   ggtitle("GSEA Enrichment\nNode Scores") + 
#   xlab("") + 
#    ylab(paste0("Node GSEA Score\n", comparison.group, "-", reference.group)) + 
#   theme_classic()
# 
# plt.e.linkage <- gsea.linkage.enrich.top %>%
#   ggplot(aes(x = reorder(pathway,NES),  y = NES, fill = -log10(pval))) + 
#   geom_bar(stat = "identity") + coord_flip() + 
#   ggtitle("GSEA Enrichment\nLinkage Scores") + 
#   xlab("") + 
#    ylab(paste0("Linkage GSEA Score\n", comparison.group, "-", reference.group)) + 
#   theme_classic()
# 
# if (print.inline){
#    # fig.height=10, fig.width=10
#   cowplot::plot_grid(plt.e.node.linkage, plt.e.node, plt.e.linkage, ncol = 1, align = "v")
# }
# 


```

```{r network-level gsea, fig.width=8, fig.height=7}

# prep data for gsea dotplot
# gsea.pathway.dot <- gsea.pathway.merge[ ,c("pathway", "NES.mean", "pval.x", "NES", "pval", "NES.mean.all", "p.pool")]
# colnames(gsea.pathway.dot) <- c("pathway", "NES.node", "p.node", "NES.link", "p.link", "NES.pool", "p.pool")
# gsea.pathway.dot$NES.dif <- gsea.pathway.dot$NES.node - gsea.pathway.dot$NES.link
# gsea.pathway.dot$p.dif <- gsea.pathway.dot$p.pool
# gsea.pathway.dot.p <- gsea.pathway.dot[ ,c("pathway",  "p.node", "p.link", "p.pool", "p.dif")]
# gsea.pathway.dot.n <- gsea.pathway.dot[ ,c("pathway",  "NES.node", "NES.link", "NES.pool", "NES.dif")]

gsea.pathway.dot <- unique(df.top.all[ ,c("pathway", "NES.x", "NES.y", "NES.mean", "pval.x", "pval.y", "p.mean")])
gsea.pathway.dot <- gsea.pathway.dot %>% dplyr::arrange(NES.mean)
gsea.pathway.dot$rank.pool <- seq(1, nrow(gsea.pathway.dot))
ordered.path.names <- as.character(gsea.pathway.dot$pathway)

gpd.long.n <- pivot_longer(gsea.pathway.dot, cols = c("NES.x", "NES.y", "NES.mean"))
gpd.long.n$name[gpd.long.n$name %in% "NES.x"] <- "Link"
gpd.long.n$name[gpd.long.n$name %in% "NES.y"] <- "Node"
gpd.long.n$name[gpd.long.n$name %in% "NES.mean"] <- "Node+Link"
gpd.long.p <- pivot_longer(gsea.pathway.dot, cols = c("pval.x", "pval.y", "p.mean"))
gpd.long.p$name[gpd.long.p$name %in% "pval.x"] <- "Link"
gpd.long.p$name[gpd.long.p$name %in% "pval.y"] <- "Node"
gpd.long.p$name[gpd.long.p$name %in% "p.mean"] <- "Node+Link"

gpd.long.merge <- merge(gpd.long.n, gpd.long.p, by = c("pathway", "name"))

# gsea.pathway.dot.n$rank <- rank(gsea.pathway.dot.n$NES.pool, ties.method = "random")
# gsea.pathway.n.long <- pivot_longer(gsea.pathway.dot.n, cols = starts_with("NES."))
# gsea.pathway.p.long <- pivot_longer(gsea.pathway.dot.p, cols = starts_with("p."))

# gsea.pathway.n.long$type <- NA
# gsea.pathway.n.long$type[grepl("node", gsea.pathway.n.long$name)] <- "node"
# gsea.pathway.n.long$type[grepl("link", gsea.pathway.n.long$name)] <- "link"
# gsea.pathway.n.long$type[grepl("pool", gsea.pathway.n.long$name)] <- "pool"
# gsea.pathway.n.long$type[grepl("dif", gsea.pathway.n.long$name)] <- "dif"
# gsea.pathway.p.long$type <- NA
# gsea.pathway.p.long$type[grepl("node", gsea.pathway.p.long$name)] <- "node"
# gsea.pathway.p.long$type[grepl("link", gsea.pathway.p.long$name)] <- "link"
# gsea.pathway.p.long$type[grepl("pool", gsea.pathway.p.long$name)] <- "pool"
# gsea.pathway.p.long$type[grepl("dif", gsea.pathway.p.long$name)] <- "dif"

# merge nes and p values
# gsea.pathway.dot.long <- merge(gsea.pathway.n.long, gsea.pathway.p.long, by = c("pathway", "type"))
# gsea.pathway.dot.long <- gsea.pathway.dot.long[complete.cases(gsea.pathway.dot.long), ]

# flag top pathways
# p.threshold.n <- 15
# top.path <- c(top_n(gsea.pathway.dot, p.threshold.n, -NES.node)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.n, NES.node)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.n, -NES.link)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.n, NES.link)$pathway,
#     top_n(gsea.pathway.dot, p.threshold.n, -(NES.dif))$pathway,
#   top_n(gsea.pathway.dot, p.threshold.n, (NES.dif))$pathway)
# 
# 
# p.threshold.s <- 5
# top.path.s <- c(top_n(gsea.pathway.dot, p.threshold.s, -NES.node)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.s, NES.node)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.s, NES.pool)$pathway,
#   top_n(gsea.pathway.dot, p.threshold.s, NES.pool)$pathway)
# top.path.s <- unique(top.path.s)

# ensure no duplicates are present
# top.path <- unique(top.path)
  
# assertion
# df.assert <- as.data.frame(table(gsea.pathway.dot.long$pathway))

# GSEA dot plot
# plt.gsea.dot <- gsea.pathway.dot.long %>%
#   filter(pathway %in% top.path, type %in% c("node", "link", "pool")) %>%
#   ggplot(aes(x = type, y = reorder(pathway, value.x), color = value.x, size = -log10(value.y))) + 
#   geom_point() + 
#   scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
#                          values=c(rescaleValues(c(min(gsea.pathway.dot.long$value.x), 0, max(gsea.pathway.dot.long$value.x))))) + 
#   labs(title = ("Differential Network Enrichment (GSEA)"), subtitle = paste0(comparison.group, " (red) - ", reference.group, " (blue)")) + 
#   theme_classic() + 
#   ylab("") + 
#   xlab("Network Feature")


gpd.long.merge$name <- factor(gpd.long.merge$name, levels = c("Node", "Link", "Node+Link"))
gpd.long.merge$pathway <- factor(gpd.long.merge$pathway, levels =ordered.path.names)
plt.gsea.dot <- gpd.long.merge %>%
  # filter(pathway %in% top.path, type %in% c("node", "link", "pool")) %>%
  ggplot(aes(x = name, y =pathway, color = value.x, size = -log10(value.y))) + 
  geom_point()  + 
  scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(gpd.long.merge$value.x), 0, max(gpd.long.merge$value.x))))) +
  labs(title = ("Differential Network Enrichment (GSEA)"), subtitle = paste0(comparison.group, " (red) - ", reference.group, " (blue)"),
       size = "-log(p)") +
  theme_miko(legend = T) +
  ylab("") +  xlab("Network Feature") 


# print plot
if (print.inline){
  print(plt.gsea.dot)
}
```

```{r gene-level heatmaps}

# do.pathway.heat <- F
# 
# if (do.pathway.heat){
#   
# 
# # get expression matrix
# exp.mat.all <- getExpressionMatrix(so.query, which.data = which.data, only.variable = T)
# 
# # downsample expression matrix 
# max.cell.per.group <- 100
# sample.ind.1 <- sample(idMap.list[[reference.group]], max.cell.per.group, replace = F)
# sample.ind.2 <- sample(idMap.list[[comparison.group]], max.cell.per.group, replace = F)
# sample.ind <- c(sample.ind.1, sample.ind.2)
# exp.mat.sub <- exp.mat.all[ ,sample.ind]
# 
# 
# df.deg.top <- df.deg[abs(df.deg$avg_logFC) > 1, ]
# df.deg.bottom <- df.deg[abs(df.deg$avg_logFC) > 1, ]
# pathway.sym <- df.deg.top$genes
# 
# # get pathway genes
# 
# cur.pathway <- "antigen processing and presentation of exogenous peptide antigen via MHC class I, TAP-dependent"
# # cur.pathway <- "Notch signaling pathway"
# 
# for (i in 1:length(top.path.s)){
#   cur.pathway <- top.path.s[i]
# 
# pathway.entrez <- pathways[[cur.pathway]]
# pathway.sym <- entrez2sym(pathway.entrez, my.species = species)$SYMBOL
# exp.mat.cur <- exp.mat.sub[rownames(exp.mat.sub) %in% pathway.sym  , ]
# exp.df.cur <- as.data.frame(exp.mat.cur)
# 
# # map cell id to group
# df.id <- data.frame(cell.id = colnames(exp.df.cur))
# df.idMap <- data.frame(group = so.query.3@meta.data[["group.query"]], cell.id = colnames(so.query.3))
# u.group <- as.character(unique(df.idMap$group))
# idMap.list <- list()
# for (i in 1:length(u.group)) idMap.list[[u.group[i]]] <- as.character(df.idMap$cell.id[df.idMap$group == u.group[i]])
# 
# df.id$group <- NA
# df.id$group[df.id$cell.id %in% idMap.list[[reference.group]]] <- reference.group
# df.id$group[df.id$cell.id %in% idMap.list[[comparison.group]]] <- comparison.group
# grouping.df <- as.data.frame(df.id$group)
# 
# plt.this <- heatmaply::heatmaply(
#   exp.df.cur,
#   col_side_colors = grouping.df,
#   key.title="Expression",
#   labCol = rep("", ncol(exp.df.cur)),
#   main = paste0(cur.pathway)
# )
# 
# print(plt.this)
# 
# }
# 
# }


```


```{r heatmap top deg}

# get expression matrix
exp.mat.all <- getExpressionMatrix(so.query, which.data = which.data, only.variable = T)

# map cell id to group
df.idMap <- data.frame(group = so.query.3@meta.data[["group.query"]], cell.id = colnames(so.query.3))
u.group <- as.character(unique(df.idMap$group))
idMap.list <- list()
for (i in 1:length(u.group)) idMap.list[[u.group[i]]] <- as.character(df.idMap$cell.id[df.idMap$group == u.group[i]])

# downsample expression matrix 
max.cell.per.group <- 100
sample.ind.1 <- sample(idMap.list[[reference.group]], max.cell.per.group, replace = F)
sample.ind.2 <- sample(idMap.list[[comparison.group]], max.cell.per.group, replace = F)
sample.ind <- c(sample.ind.1, sample.ind.2)
exp.mat.sub <- exp.mat.all[ ,sample.ind]

# get DEG genes
top.n.deg <- 30
df.deg.enr <- df.deg.pool
df.deg.enr$genes <- rownames(df.deg.enr)
# df.deg.enr <- df.deg.pool[abs(df.deg.pool$avg_logFC) > 1, ]
deg.top <- top_n(df.deg.enr, top.n.deg, (avg_logFC))$genes
deg.bottom <- top_n(df.deg.enr, top.n.deg, -(avg_logFC))$genes
deg.genes <- c(deg.top, deg.bottom)

# get DCG genes
top.n.dcg <- 30
dcg.top <- as.character(top_n(df.con.deg.merge, top.n.deg, (w.delta))$genes)
dcg.bottom <- as.character(top_n(df.con.deg.merge, top.n.deg, -(w.delta))$genes)
dcg.genes <- c(dcg.top, dcg.bottom)

# get DCG genes
top.n.hub <- 60
hub.genes <- as.character(top_n(df.con.deg, top.n.hub, (wi))$genes)

# filter matrix
exp.mat.deg <- exp.mat.sub[rownames(exp.mat.sub) %in% deg.genes  , ]
exp.df.deg <- as.data.frame(exp.mat.deg)

exp.mat.dcg <- exp.mat.sub[rownames(exp.mat.sub) %in% dcg.genes  , ]
exp.df.dcg <- as.data.frame(exp.mat.dcg)

exp.mat.hub <- exp.mat.sub[rownames(exp.mat.sub) %in% hub.genes  , ]
exp.df.hub <- as.data.frame(exp.mat.hub)

# get group ids
df.id <- data.frame(cell.id = colnames(exp.df.deg))
df.id$group <- NA
df.id$group[df.id$cell.id %in% idMap.list[[reference.group]]] <- reference.group
df.id$group[df.id$cell.id %in% idMap.list[[comparison.group]]] <- comparison.group
grouping.df <- as.data.frame(df.id$group)


# if (print.inline){
#   plt.deg.genes <- heatmaply::heatmaply(
#     exp.df.deg,
#     col_side_colors = grouping.df,
#     key.title="Expression",
#     labCol = rep("", ncol(exp.df.deg)),
#     main = "DEG"
#   )
#   
#   plt.dcg.genes <- heatmaply::heatmaply(
#     exp.df.dcg,
#     col_side_colors = grouping.df,
#     key.title="Expression",
#     labCol = rep("", ncol(exp.df.dcg)),
#     main = "DCG"
#   )
#   
#   plt.hub.genes <- heatmaply::heatmaply(
#     exp.df.hub,
#     col_side_colors = grouping.df,
#     key.title="Expression",
#     labCol = rep("", ncol(exp.df.hub)),
#     main = "Hub"
#   )
#   
#   print(plt.deg.genes)
#   print(plt.dcg.genes)
#   print(plt.hub.genes)
# }
# 


```


UMAP
===================================== 

Row {.tabset}
-------------------------------------

### UMAP

```{r plt.umap_by_c1, fig.width=8, fig.height=6}
  plt.umap_group + theme_miko(legend = T)
```

### Reclustered

```{r plt.umap_by_c2, fig.width=15, fig.height=5}
    cowplot::plot_grid(p1.dim + ggtitle("Re-Clustered UMAP: Group Strata") + theme_miko(legend = T), 
                       p2.dim+ ggtitle("Re-Clustered UMAP: Cluster Strata") + theme_miko(legend = T))
```

Pairwise Comparison
===================================== 

Differentially-expressed genes between groups (within-clusters)

Row {.tabset}
-------------------------------------

```{r paired, warning = FALSE, message = FALSE}

paired_out <- NULL
paired_out <- lapply(seq_along(plt.pairwise.list), function(i) {
  
  try({
  s1 <- names(plt.pairwise.list)[i]
  
    s2 <- paste("plt.pairwise.list[[", i, "]]", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("paired_deg", i, sep = ""))) 
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  }, silent = T)
})
# plt.pairwise.list[[1]]

# paired_out
plt.pairwise.list
```

`r paste0(knitr::knit(text = paste(paired_out, collapse = '\n')))`


Enrichment | Within-Cluster (DEG)
===================================== 

Difference between two groups. Positive values indicate that the gene is more highly expressed in the first group (group1 of DEG)

Row {.tabset}
-------------------------------------

### Enrichment

```{r enrich wi cluster}


if (!is.null(gse.pathway.deg.all)){
  
  gse.pathway.deg.all.sig <- gse.pathway.deg.all[gse.pathway.deg.all$pval <= 0.05, ]
    datatable(gse.pathway.deg.all.sig, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}
```

```{r deg table all,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# Deg table

deg_table_out <- lapply(seq_along(df.deg.list), function(i) {
  
  s1 <- paste("df.deg.list[[", i, "]]", sep = "")
  
  table.name <- paste("DEG | ", names(df.deg.list)[i], sep = "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
      s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("deg table", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(deg_table_out, collapse = '\n')))`

DEG | UMAP
===================================== 

Row {.tabset}
-------------------------------------

```{r deg umap,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

deg_umap_out <- lapply(seq_along(plt.deg.umap), function(i) {
  
  s1 <- names(plt.deg.umap)[i]
  
    s2 <- paste("print(plt.deg.umap[[", i, "]])", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("deg_umap_out", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
# plt.deg.umap
```

`r paste(knitr::knit(text = paste(deg_umap_out, collapse = '\n')))`

DEG | Vln
===================================== 

Row {.tabset}
-------------------------------------

```{r deg vln,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

deg_vln_out <- lapply(seq_along(plt.deg.vln), function(i) {
  
  s1 <- names(plt.deg.vln)[i]
  
    # s2 <- paste("plt.deg.vln[[", i, "]]", sep = "")
    s2 <- paste("print(CombinePlots(plots =  plt.deg.vln[[", i, "]], nrow = 2))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("deg vln", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(deg_vln_out, collapse = '\n')))`


Enrichment | Between-Cluster (CG)
===================================== 

Row {.tabset}
-------------------------------------

### Enrichment

```{r enrich bw cluster}

if (!is.null(gse.pathway.cg.all)){
    datatable(gse.pathway.cg.all, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}

```


```{r cg table all,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# Deg table

cg_table_out <- lapply(seq_along(conserved.markers.list), function(i) {
  
  s1 <- paste("conserved.markers.list[[", i, "]]", sep = "")
  
  table.name <- paste("CG | ", names(conserved.markers.list)[i], sep = "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
      s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("cg table", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(cg_table_out, collapse = '\n')))`

CG | UMAP
===================================== 

Row {.tabset}
-------------------------------------

```{r cg umap,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

deg_umap_out <- lapply(seq_along(plt.cg.umap), function(i) {
  
  s1 <- names(plt.cg.umap)[i]
  
    s2 <- paste("print(plt.cg.umap[[", i, "]])", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("cg umap", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(deg_umap_out, collapse = '\n')))`

CG | Vln
===================================== 

Row {.tabset}
-------------------------------------

```{r cg vln,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

deg_vln_out <- lapply(seq_along(plt.cg.vln), function(i) {
  
  s1 <- names(plt.cg.vln)[i]
  
  # print(CombinePlots(plots =   plt.cg.vln[[paste("c", as.character(u.clusters[i]), sep = "")]] , nrow = 2))
    s2 <- paste("print(CombinePlots(plots =  plt.cg.vln[[", i, "]], nrow = 2))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("cg vln", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(deg_vln_out, collapse = '\n')))`



Network Construction
===================================== 

Row {.tabset}
-------------------------------------

### Power Optimization

```{r power opt}
try({
print(sft$optimization.plot)
}, silent = T)
```

### Node-Linkage Distributions

```{r node linkage,fig.width=16, fig.height=10}
try({
cowplot::plot_grid(plotlist = sft$distribution.plot, ncol = 5)
}, silent = T)
```


### Module Clusters

Clustered TOM matrix is hierarchially-clustered and adaptive pruning method is applied to identify gene modules. Consensus modules are determind by taking parallel-component max/min of two paired matrices. 

```{r module clusters 2}
try({
plotDendroAndColors(geneTree.all, modules.all, "All", dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main="All dendrogram")
  plotDendroAndColors(geneTree.co, modules.cob, "Consensus", dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main="Consensus dendrogram")
plotDendroAndColors(geneTree.1, modules.1b, "Group 1", dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main=paste0("Group 1: ", reference.group))
plotDendroAndColors(geneTree.2, modules.2b, "Group 2", dendroLabels=FALSE, hang=0.03,
                    addGuide=TRUE, guideHang=0.05, main=paste0("Group 2: ", comparison.group))
}, silent = T)

```

### Dendrograms

Hierarchially-clustered TOM matrices.

```{r, fig.width=15, fig.height=4}

par(mfrow = c(1,4))
plot(geneTree.all, xlab = "", sub = "", main = "All", labels = F, hang = 0.04)
plot(geneTree.co, xlab = "", sub = "", main = "Consensus", labels = F, hang = 0.04)
plot(geneTree.1, xlab = "", sub = "", main = paste0("Group 1: ", reference.group), labels = F, hang = 0.04)
plot(geneTree.2, xlab = "", sub = "", main = paste0("Group 2: ", comparison.group), labels = F, hang = 0.04)
```

### Module Preservation

Module gene set overlap between datasets. 

```{r mod preservations, fig.width=15, fig.height=4}
try({
ggVennDiagram::ggVennDiagram(module.sets) + ggtitle("Network Preservations")
}, silent = T)
```

### Matrix Distributions

Distributions of expression matrix, similarity matrix, adjacency matrix and TOM. 

```{r mat distributions, fig.width=15, fig.height=4}

  # fig.width=15, fig.height=4
try({
  par(mfrow = c(1,4))
hist(datExpr.noz, main = "Expression")
hist(s.mat, main = "Similarity (correlation)")
hist(a.mat, main = "Adjacency")
hist(w.mat, main = "TOM")
}, silent = T)
```

### Nodes and Links

Distribution of quantile-normalized connectivity and differential expression/fraction of genes. 

```{r net overview, fig.width=10, fig.height=4}

try({
  cowplot::plot_grid(plt.overview.1, plt.overview.2, ncol = 2, rel_widths = c(1,1.2))
}, silent = T)


```




Differential Network Analysis
===================================== 

Row {.tabset}
-------------------------------------

### DEG Volcano

Volcano plot illustrating differentially-expressed gene Modules. 

```{r deg volc, fig.width=14, fig.height=5}

try({
    cowplot::plot_grid(plt.dif.volc, plt.rank.volc,plt.dif.rank.comp,  ncol = 3)
}, silent = T)

```

### DEG Box

Box plots illustrate paired module activity levels. 

```{r deg box, fig.width=12, fig.height=8}

  # fig.width=15, fig.height=4
try({
print(plt.dif.box.1)
}, silent = T)
```


### DCG Scatter

Comparison of pre- and post- quantile normlized similarity, adjacency and TOM-based connectivities for each sample. 

```{r, fig.height = 4, fig.width=14}

 cowplot::plot_grid(plt.input.xy.s, 
                   plt.input.xy.a, 
                   plt.input.xy.w, 
                   ncol = 3)

```

### Logistic Classifier

Logistic regression-based classifier was trained (80% training set) and performance was evaluated on test set (20%). Variance explained by each classifier coeffcient (ie., module) is ranked. 
```{r logistic regression, fig.width=16, fig.height=6}

  cowplot::plot_grid(plt.logitModel, plt.confusion, plt.var.exp, ncol = 3)

```

### Sector Plots

Sector plots illustrate relationship between differential connectivity (x axis) and differential connectivity (y axis) 

```{r sector plots, fig.width = 10, fig.height=10}

  # fig.width=15, fig.height=4
try({
 print(plt.sector)
}, silent = T)

```

### kME Plots

Modular membership score for each sample compared using scatter plot. 

```{r kme plots, fig.width=12, fig.height=12}
  # fig.width=15, fig.height=4
try({
print(plt.kME + theme_miko(legend = T))
# print(plt.kME.sub)
}, silent = T)
```

### intra vs. intermodularity scores

```{r intra vs. intermodularity scores plt, fig.width=7, fig.height=6}

 print(plt.kme.comp + theme_miko(legend = T))
```

### Module Preservation (kME) v1

```{r model preserve, fig.width=8, fig.height=7}

  print(plt.mod.pres + theme_miko(legend = T))
```


### Module Preservation (kME) v2

```{r, fig.width=12, fig.height=12}

plt.kme.dif

```

Heatmaps
===================================== 

Row {.tabset}
-------------------------------------

### Eigenmodule Activity

Eigenmodule activity for each cell, hierarchially-clustered. Sample identity is shown and can be used to determine how well modules can discriminate sample identity. 

```{r eigenmodule heatmap}

try({

    
    gm.current <- grouping.mem
    rownames(gm.current) <- rownames(ME.all.sub)
    u.g <- unique(grouping.mem$group); u.g <- u.g[!is.na(u.g)]
    ann.list <- list(group = c(g1 = "grey", g2 = "black"))
    names(ann.list$group) <- u.g
    
    pheatmap::pheatmap(ME.all.sub, 
             color = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdBu"))(100)),
             scale = "row",
             show_rownames = F,
             annotation_row = gm.current,
             annotation_colors = ann.list,
             main = "Eigenmodule Activity (module x cell)")
    
}, silent = T)



```  

### DEG

Heatmap of top differentially-expressed genes. 

```{r deg heatmap, fig.height=12, fig.width=12}

try({

    gm.current <- grouping.df
    colnames(gm.current) <- "group"
    rownames(gm.current) <- colnames(exp.df.deg)
    u.g <- unique(gm.current$group); u.g <- u.g[!is.na(u.g)]
    ann.list <- list(group = c(g1 = "grey", g2 = "black"))
    names(ann.list$group) <- u.g
    
    pheatmap::pheatmap(exp.df.deg, 
             color = viridis(20),
             show_colnames = F,
             annotation_col = gm.current,
             annotation_colors = ann.list,
             main = "Differential Expression (cell x genes)")
}, silent = T)

```  

### DCG

Expression heatmap of top differentially-connected genes. 

```{r dcg heatmap, fig.height=12, fig.width=12}

try({
  

  
      gm.current <- grouping.df
    colnames(gm.current) <- "group"
    rownames(gm.current) <- colnames(exp.df.dcg)
    u.g <- unique(gm.current$group); u.g <- u.g[!is.na(u.g)]
    ann.list <- list(group = c(g1 = "grey", g2 = "black"))
    names(ann.list$group) <- u.g
    
    pheatmap::pheatmap(exp.df.dcg, 
             color = viridis(20),
             show_colnames = F,
             annotation_col = gm.current,
             annotation_colors = ann.list,
             main = "Differential Connectivity (cell x genes)")
}, silent = T)



```  

### Hub

Expression heatmap of top connected (hub) genes. 

```{r hub heatmap, fig.height=12, fig.width=12}

try({

        gm.current <- grouping.df
    colnames(gm.current) <- "group"
    rownames(gm.current) <- colnames(exp.df.dcg)
    u.g <- unique(gm.current$group); u.g <- u.g[!is.na(u.g)]
    ann.list <- list(group = c(g1 = "grey", g2 = "black"))
    names(ann.list$group) <- u.g
    
    pheatmap::pheatmap(exp.df.hub, 
             color = viridis(20),
             show_colnames = F,
             annotation_col = gm.current,
             annotation_colors = ann.list,
             main = "Hub Gene Expression (cell x genes)")
}, silent = T)



```  


Network Modules
===================================== 

Row {.tabset}
-------------------------------------

### Enriched Module Annotations

Union between GSEA- and over-representation-based enrichment was taken and top annotations are shown for each module. If a given module is missing, no consistent set of annotations were identified. 

```{r e mod ano small, fig.width = 8, fig.height = 10}


if (length(plt.enrich.all) < 5)  cowplot::plot_grid(plotlist  = plt.enrich.all, ncol = 2, align = "hv")

```

```{r e mod ano mid , fig.width = 8, fig.height = 15}


if (length(plt.enrich.all) < 10 & length(plt.enrich.all) >= 5)  cowplot::plot_grid(plotlist  = plt.enrich.all, ncol = 2, align = "hv")

```

```{r e mod ano large, fig.width = 14, fig.height = 20}


if (length(plt.enrich.all) >= 10)  cowplot::plot_grid(plotlist  = plt.enrich.all, ncol = 2, align = "hv")

```


### topGO Module Annotations

Over-representation-based enrichment of module gene sets. Top two annotations are shown for each module. 

```{r, fig.width = 25, fig.height = 14}

  cowplot::plot_grid(plt.go.1, plt.go.2, col = 2)

```


 

```{r, fig.width = 10, fig.height = 5}

### Enrichment Statistics
# 
# Summary of over-representation-based enrichment. Module size, number of annotations and proportion of gene set contributing to annotation are illustrated.  
# try({
#   cowplot::plot_grid(plt.e.1, plt.e.2)
# }, silent = T)
#   
```

### Module Enrichment (pAdj)

```{r module enrichment bh}

try({
  if (!is.null(results.co.bh)){
    datatable(results.co.bh, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}
}, silent = T)

```

### Module Enrichment (pVal)

```{r module enrichment pval}

try({
if (!is.null(results.co.p)){
    datatable(results.co.p, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}
}, silent = T)

```





```{r network plot 1}

# Network Plots
# ===================================== 

# Row {.tabset}
# -------------------------------------
### Master

# Summary network plot. Colors correspond to module id.  

# try({
#   visNetwork( master.nodes,master.links,  main = "Reference Network") %>%
#     visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
#     visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T), 
#                nodesIdSelection = T, selectedBy = c("module")) %>%
#     visInteraction(navigationButtons = TRUE,keyboard = TRUE) %>%
#     visConfigure(enabled = TRUE)  
# }, silent = T)

```



```{r network plot 2}

### Differential v1

# Differential network plot. Nodes represent differential expression and links represent differential connectivity. Nodes with black edges/outline represent genes that were differentially expressed (p<0.05).
# try({
#   visNetwork( vis.nodes,vis.links,  main = "Differential Network Analysis") %>%
#     visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
#     visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T), 
#                nodesIdSelection = T, selectedBy = c("module")) %>%
#     visInteraction(navigationButtons = TRUE,keyboard = TRUE) %>%
#     visConfigure(enabled = TRUE) 
# }, silent = T)
# 

```



```{r network plot 3}

# Differential v2
# try({
# if (!is.null(results.all.bh)){
#   visNetwork( path.nodes,path.links,  main = "Reference Network") %>%
#   visIgraphLayout(randomSeed = 123, layout = "layout_with_kk") %>%
#   visOptions(highlightNearest = list(enabled = F, degree = 1, hover = T),
#              nodesIdSelection = T, selectedBy =  list(variable = "group", multiple = TRUE))
# }
# 
# }, silent = T)

```

Network Enrichment
===================================== 

Row {.tabset}
-------------------------------------




### Differential Link/Node

Differential expression and connectivity illustrated. Top genes are labeled. 

```{r dif con deg,  fig.width=12, fig.height=6}

try({
  # cowplot::plot_grid(plt.2, plt.3, ncol = 2)
  plt.2 <- plt.2 + theme_miko()
  plt.3 <- plt.3 + theme_miko()
  cowplot::plot_grid(plt.2, plt.3, ncol = 2)
}, silent = T)

```


### Node Enrichment

Differentially-expressed genes were annotated by GSEA, with genes ranked by p value (x axis) or connectivity (y axis). Enrichments with inconsistent signs (i.e., upper left and lower right quadrants) were omitted from further consideration. Plot is interactive (scroll over points for gene info, click and draft to zoom in). 

```{r deg node, fig.width=10, fig.height=7}

try({
   # plotly::ggplotly(, tooltip="text")
  print(plt.gsea.comp + theme_miko(legend = T))
}, silent = T)

```




```{r plt.dif.net enrich 2, fig.width=10, fig.height=7}
### Differential Link/Node Enrichment

# Node-based annotations (i.e., based on differential expression) were further compared to link-based annotations, where GSEA was performed on genes ranked by differential connectivity. Blue/red spectrum represents average of normalized enrichment scores (NES) from differential node- and link-based GSEA. 
# try({
#      print(plt.dif.net.enrich+ theme_miko(legend = T))
# }, silent = T)
```

### Enrichment Dot

Dot plot of Node- and Link-based GSEA annotations. 

```{r plt.dif.net enrich, fig.width=8, fig.height=7}

try({
      print(plt.gsea.dot)
}, silent = T)
```


### Enrichment Bar

```{r, fig.height=14, fig.width=10}

  cowplot::plot_grid(plt.e.node.linkage, plt.e.node, plt.e.linkage, ncol = 1, align = "v")

```


### GSEA network

```{r}
try({
if (!is.null(gsea.pathway.dot)){
  
  gsea.pathway.dot.out <- gsea.pathway.dot
  gsea.pathway.dot.out[ ,c("NES.link", "p.link", "NES.pool", "p.pool", "NES.dif", "p.dif")] <- signif(gsea.pathway.dot.out[ ,c("NES.link", "p.link", "NES.pool", "p.pool", "NES.dif", "p.dif")], 3)
  
  gsea.pathway.dot.out <- gsea.pathway.dot.out[gsea.pathway.dot.out$p.pool <= 0.05, ]
    datatable(gsea.pathway.dot.out, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}
}, silent = T)

```

### GSEA consensus kME

```{r}

try({
 top.module.annotations.con.v2[ ,c("pval", "NES", "padj")] <- signif(top.module.annotations.con.v2[ ,c("pval", "NES", "padj")], 3)
    datatable(top.module.annotations.con.v2, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf'))) 
}, silent = T)


```

### GSEA differential kME

```{r}

try({
top.module.annotations.dif[ ,c("pval", "NES", "padj")] <- signif(top.module.annotations.dif[ ,c("pval", "NES", "padj")], 3)
    datatable(top.module.annotations.dif, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}, silent = T)

```


Gene Sets
===================================== 

Row {.tabset}
-------------------------------------

```{r}

df.module.list <- list(all = module.df.all,
                       consensus = module.df.co,
                       group.1 = module.df.1,
                       group.2 = module.df.2,
                       hub.genes = df.topGenesKME)

out <- flex.multiTabTables(df.module.list, "df.module.list")

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


```{r save analysis log and Rdata results}



# additional log entries
df.log <- addLogEntry("which data used", which.data, df.log, "which.data")

df.log <- addLogEntry("variable genes only?", use.var, df.log, "use.var")

df.log <- addLogEntry("N genes in network", length(SubGeneNames), df.log, "length(SubGeneNames)")

df.log <- addLogEntry("TOM Type", TOM.type, df.log, "TOM.type")

df.log <- addLogEntry("Network Type", which.network, df.log, "which.network")

df.log <- addLogEntry("Correlation Type", which.cor, df.log, "which.cor")

df.log <- addLogEntry("Optimal soft power (complete dataset)", best.power, df.log, "best.power")
# df.log <- addLogEntry("Optimal soft power (reference group)", best.power.1, df.log, "best.power.1")
# df.log <- addLogEntry("Optimal soft power (comparison group)", best.power.2, df.log, "best.power.2")

df.log <- addLogEntry("Deep cut (tree pruning)", which.deepcut, df.log, "which.deepcut")

df.log <- addLogEntry("Delta kME threshold", delta.kme.threshold, df.log, "delta.kme.threshold")

df.log <- addLogEntry("Edges/module shown in network plot", top.n.interactions, df.log, "top.n.interactions")
df.log <- addLogEntry("meta network method", which.metanet, df.log, "which.metanet")

df.log <- addLogEntry("Reference Group", reference.group, df.log, "reference.group")
df.log <- addLogEntry("Comparison Group", comparison.group, df.log, "comparison.group")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)


df.log_Module_10 <- df.log


```


```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 10)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_10)

```

