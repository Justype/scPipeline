---
title: "Group Comparison"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r load libraries, include=FALSE}

# clear global enviroment                          
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", 
                   "DT", "flexdashboard", "ggpmisc", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db",
                   "RColorBrewer", "cowplot", "WGCNA", "viridis", "ggnewscale", "igraph", "ggnetwork", "caret", "ROCR", "Metrics", "topGO",
                   "glmnet", "sjPlot")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```


```{r parameter specification}


# query input ##################################################################
# input.file <- "Module1_invivo_EMT6_screen_metaDAta_270320.Rdata"
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "R308_M27_NM2_M02_BC2_allGBM_immune_tier2_251120.Rdata"
input.file <- "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module1_pilot6_invitroGBM_updatedBarcodes_290220.Rdata"
# input.file <- "Module2_Renca_cell_nuc_sci_T12_4000ds_Celsius_integrated_240220.Rdata"

# general analysis parameters ##################################################
cluster.resolution <- c(1)
subsample_factor <- 1
which.species <- "Mm"

# grouping #####################################################################
# (list specifying group compositions); supports indirect matching 
# group.field <- "batch" # batch used when using intergration dataset
group.field <- "Barcode"

group.list <- list(GL261 = "GL261",
                   CT2A = "CT2A")


# group.list <- list(ctrl = "ctrl.0231",
#                    TR = "TR.0231")
# group.list <- list(C68 = "C68",
#                    C2 = "C2")

# specify which group is reference/control group (NA if unspecified)
# which.reference <- NA 
# which.reference <- "ctrl.0231"
which.reference <- "GL261"
# which.reference <- "WT" # specify whcih group to use as reference (e.g., DEG compared to what?)


# Network topology parameters ##################################################
sim.type <- "bin" #option: bin vs single - expression binned or not prior to taking correlations - binning recommeneded for large overlapping samples
TOM.type <- "signed"
which.network <- "signed"       # 'signed', 'unsigned', or 'signed hybrid'
which.cor <- "spearman"         # correlation method (Recommended: spearman)
min.cluster.size <- 3          # minimal number of genes per module
which.metanet <- "total"    # "consensus" or "differential" or "total" or "mean"
pct.threshold <- 0.1            # min expressing fraction threhsold


# DEG thresholds ###############################################################
lfc.threshold <- 0.25
p.threshold <- 0.05
deg.min.pct <- 0.1
only.pos <- F # 
  do.pca.correction <- F

  
# print inline flag
print.inline <- F
save.pdf <- T

```





```{r analysis log}

species <- which.species
if (!exists("which.reference")) which.reference <- NA
df.log <- initiateLog("10, Group Comparison")
df.log <- addLogEntry("Input File", input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsampling factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Grouping Field", group.field, df.log, "group.field")
df.log <- addLogEntry("new field names", names(group.list), df.log, "names(group.list)")
df.log <- addLogEntry("old field names", unlist(group.list), df.log, "unlist(group.list)")
df.log <- addLogEntry("LFC threshold", lfc.threshold, df.log, "lfc.threshold")
df.log <- addLogEntry("p-value threshold", p.threshold, df.log, "p.threshold")
df.log <- addLogEntry("Positive marker flag", only.pos, df.log, "only.pos")
df.log <- addLogEntry("PCA-based matrix correction", do.pca.correction, df.log, "do.pca.correction")
df.log <- addLogEntry("Min module size", min.cluster.size, df.log, "min.cluster.size")

df.log <- addLogEntry("Reference group", which.reference, df.log, "which.reference")
df.log <- addLogEntry("Print flag", print.inline, df.log, "print.inline")

```


```{r assertions}

stopifnot(which.reference %in% names(group.list))

```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

if (!(exists("subset.df"))) subset.df <- "no.subset"

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
                         subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = c("ica", "tsne", "nmf", "gsva", "deg"), rmv.pattern = "so", 
                         scale.reprocessed = T, neighbors.reprocessed = F, keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```




```{r get prior log history}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r group membership}
# group membership

library(viridis)

membership.n <- c()
membership.list <- list()

keep.this <- NULL
for (i in 1:length(group.list)){
  
  cur.group <- names(group.list)[order(names(group.list))][i]
  cur.pattern <- (group.list)[order(names(group.list))][[i]]
  
  u.members <- as.vector(unique(so.query@meta.data[[group.field]][grepl(cur.pattern, so.query@meta.data[[group.field]])]))
  membership.list[[cur.group]] <- u.members
  membership.n[i] <- length(u.members)
  
  if (is.null(keep.this)){
    keep.this <- grepl(cur.pattern, so.query@meta.data[[group.field]])
  } else {
    keep.this <- (keep.this | grepl(cur.pattern, so.query@meta.data[[group.field]]))
  }
  
  so.query@meta.data[["group.query"]][grepl(cur.pattern, so.query@meta.data[[group.field]])] <- cur.group
  
  
}

# ensure groups are ordered and that order is maintained throughout analysis. 
u.groups <- as.character(unique(so.query@meta.data[["group.query"]]))
u.groups <- u.groups[order(u.groups)]
so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = u.groups)
so.query <-so.query[, keep.this]


names(membership.n) <-  names(group.list)[order(names(group.list))]

if (length(group.list) == 2){
  col.end <- 0.6
} else {
  col.end <- 1
}

group.cols <- scales::viridis_pal(option = "D", end = col.end)(length(group.list))
names(group.cols) <- names(group.list)[order(names(group.list))]

membership.cols <- viridis_pal(option = "D", end = col.end)(length(as.vector(unlist(membership.list))))
names(membership.cols) <- as.vector(unlist(membership.list))

plt.umap_group <- cluster.UMAP(so.query, group.by = "group.query", cols = group.cols)
plt.umap_membership <- cluster.UMAP(so.query, group.by = group.field, cols = membership.cols,  split.by = "group.query")

if (print.inline){
  print(plt.umap_group) 
  print(plt.umap_membership)
}



```

```{r ensure reference group is correctly specified}

# ensure groups are ordered correctly
if (is.na(which.reference)){
  
  available.levels <- levels(so.query@meta.data[["group.query"]])
  so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = available.levels[available.levels %in% unique(so.query@meta.data[["group.query"]])])
  
  which.reference <- levels(so.query@meta.data[["group.query"]])[1]
}

stopifnot(length(levels(so.query@meta.data[["group.query"]])) == 2)
grp.levels <- levels(so.query@meta.data[["group.query"]])
group.order <- which.reference
group.order <- c(group.order, grp.levels[grp.levels != which.reference])

so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = group.order)

# specify reference and comparison groups
reference.group <- group.order[1]
comparison.group <- group.order[2]

```

```{r, warning = FALSE, message = FALSE}

so.query <- so.query

# Visualization
p1.dim <- DimPlot(so.query, reduction = "umap", group.by = "group.query") + xlab("UMAP 1") + ylab("UMAP 2")
p2.dim <- DimPlot(so.query, reduction = "umap", label = TRUE) + xlab("UMAP 1") + ylab("UMAP 2")

if (print.inline){
  cowplot::plot_grid(p1.dim, p2.dim)
}

```



```{r get conserved markers}

# get unique clusters
u.clusters <- as.numeric(as.character(unique((so.query@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]

# initiate results list
conserved.markers.list <- list()

which.assay.cons <- "RNA"
if (!(which.assay.cons %in% names(so.query@assays))) which.assay.cons <- DefaultAssay(so.query)

# oncly get conserved markers if multiple clusters available
if (length(u.clusters) > 1){
  
  # iterate through each cluster
  for (i in 1:length(u.clusters)){
    
    # check if any subgroups have fewer than 3 cells - if yes, skip to next cluster
    n.cell.cur <-  as.vector(table(so.query@meta.data[["group.query"]][so.query@meta.data[["seurat_clusters"]] %in% u.clusters[i]])) 
    if (any(n.cell.cur < 3)) next
    
    # find DEG that are conserved across groups
    conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- FindConservedMarkers(so.query, 
                                                                                                        ident.1 = u.clusters[i], 
                                                                                                        grouping.var = "group.query", 
                                                                                                        verbose = FALSE,
                                                                                                        min.pct = deg.min.pct,
                                                                                                        assay = which.assay.cons, 
                                                                                                        logfc.threshold = lfc.threshold,
                                                                                                        max.cells.per.ident = 200,
                                                                                                        return.thresh = p.threshold)
    
    
    
    # store results
    conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- as.data.frame(apply(conserved.markers.list[[paste("c", as.character(u.clusters[i]), sep = "")]], 2, signif, 3) )
    
  }
  
}

```


```{r plot conserved markers}

plt.cmarkers.scatter <- list()

if (length(conserved.markers.list)>0){
  
  nonconserved.genes <- list()
  conserved.genes <- list()
  for (i in 1:length(conserved.markers.list)){
    
    which.cluster <- names(conserved.markers.list)[i]
    cur.cons.markers <- conserved.markers.list[[which.cluster]]
    cur.cons.markers <- cur.cons.markers[cur.cons.markers$minimump_p_val < 0.05, ]
    cur.cons.markers$gene <- rownames(cur.cons.markers)
    
    x.var.name <- paste(reference.group, "_avg_log2FC", sep = "")
    y.var.name <- paste(comparison.group, "_avg_log2FC", sep = "")
    
    cur.genes <- cur.cons.markers
    cur.genes$gene.type <- sign(cur.genes[ , x.var.name] * cur.genes[ , y.var.name])
    nonconserved.genes[[which.cluster]] <- cur.genes$gene[cur.genes$gene.type == -1]
    conserved.genes[[which.cluster]] <- cur.genes$gene[(cur.genes$gene.type == 1) & (cur.genes[ ,x.var.name] > 0)]
    
    plt.cmarkers.scatter[[which.cluster]] <- cur.cons.markers %>%
      dplyr::arrange(-minimump_p_val) %>%
      ggplot(aes(x = get(x.var.name), y = get(y.var.name), size = -log10( minimump_p_val),  color = -log10( minimump_p_val))) + 
      geom_abline(slope = 1, intercept = 0, linetype = "dashed", alpha = 0.5) + 
      geom_hline(yintercept = 0) + 
      geom_vline(xintercept = 0) + 
      xlab(paste0(reference.group, " logFC")) + 
      ylab(paste0(comparison.group, " logFC"))+ 
      geom_text(aes(label = gene)) + 
      ggtitle(paste("Conserved Markers: ", which.cluster, sep = "")) + 
      theme_miko(legend = T) + 
      labs(color = "-log(p)", size = "-log(p)", caption = "same sign = conserved; different sign = non-conserved.\npadj<0.05")
    
    if (print.inline) print(plt.cmarkers.scatter[[which.cluster]] ) 
    
  }
}

```



```{r GO enrichment of conserved genes}

# ENRICH TUB
my.symbol <- rownames(so.query)
my.entrez <- sym2entrez(my.symbol, my.species =which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = "BP", species =  which.species)

g2e.list <- my.entrez$ENTREZID
names(g2e.list) <- my.entrez$SYMBOL

gene.universe <- unique(rownames(so.query))
gene.universe <- unique(g2e.list[gene.universe])

# clean fora output function
cleanForaOutput <- function(fora.output, my.entrez){
  suppressMessages({
    suppressWarnings({
      fora.output$set <- lapply(fora.output$overlapGenes, 
                                mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
      fora.output$set <- lapply(fora.output$set, paste,collapse = ", ")
      fora.output[ ,c("pval", "padj")] <- signif( fora.output[ ,c("pval", "padj")], 3)
      fora.output <- fora.output %>% dplyr::select(-c("overlapGenes"))
    })
  })
  return(fora.output)
}


cons.noncons <- list()
if (length(conserved.markers.list) > 0){
  

n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)


cons.noncons <- foreach(i = 1:length(conserved.markers.list), .packages = c("dplyr", "fgsea"))  %dopar% {
  
  cluster.name <- names(conserved.markers.list)[i]
  cgene <-  unique(conserved.genes[[cluster.name]])
  ngene <- unique(nonconserved.genes[[cluster.name]])
  
  # current.genes <- unique(topGenesKME[ ,i])
  cgene <- unique(g2e.list[cgene])
  ngene <- unique(g2e.list[ngene])
  c.res <-  fora(pathways = pathways.go, genes = cgene, universe = gene.universe, minSize = 2, maxSize = 200)
  n.res <-  fora(pathways = pathways.go, genes = ngene, universe = gene.universe, minSize = 2, maxSize = 200)
  
  return(list(
    cluster = cluster.name,
    c.res = c.res,
    n.res = n.res
  ))
  
}

names(cons.noncons) <- names(conserved.markers.list)

stopCluster(cl)



results.conserved <- results.nonconserved <- NULL
for (i in 1:length(cons.noncons)){
  
  cluster.name <- cons.noncons[[i]]$cluster
  c.res.df <- cons.noncons[[i]]$c.res
  n.res.df <- cons.noncons[[i]]$n.res
  c.res.df$cluster <- n.res.df$cluster <- cluster.name
  
  results.conserved <- bind_rows(results.conserved,
                                 (c.res.df[c.res.df$padj< 0.2]))
  results.nonconserved <- bind_rows(results.nonconserved,
                                    (n.res.df[n.res.df$padj< 0.2]))
}

results.nonconserved <- cleanForaOutput(results.nonconserved, my.entrez = my.entrez)
results.conserved <- cleanForaOutput(results.conserved, my.entrez = my.entrez)

} else {
  
  
  results.nonconserved <- NULL
results.conserved <- NULL
}





```


```{r conserved dash, fig.width= 14, fig.height=5}


df.umap <- data.frame(so.query@reductions[["umap"]]@cell.embeddings)
colnames(df.umap) <- c("x", "y")
df.umap$cluster <- so.query@meta.data[["seurat_clusters"]]
df.umap$group <- so.query@meta.data[["group.query"]]

cc.nc.list <- list()
for (i in 1:length(plt.cmarkers.scatter)){
  
  cluster.name <- names(plt.cmarkers.scatter)[i]
  if (is.null(cluster.name)) next
  cluster.id <- as.numeric(as.character(gsub("c", "", cluster.name)))
  
  # UMAP #######################################################################
  df.umap$flag <- "grey"
  df.umap$flag[(df.umap$cluster %in% cluster.id) & (df.umap$group %in% comparison.group)] <- "tomato"
  df.umap$flag[(df.umap$cluster %in% cluster.id) & (df.umap$group %in% reference.group)] <- scales::muted("blue")
  df.umap <- df.umap %>% dplyr::arrange(flag)
  
  df.umap.cluster <- df.umap[df.umap$flag != "grey", ]
  df.umap.cluster <- df.umap.cluster[sample(c(1:nrow(df.umap.cluster)), nrow(df.umap.cluster)), ]
  df.umap.noncluster <- df.umap[df.umap$flag == "grey", ]
  df.umap <- bind_rows(df.umap.noncluster, df.umap.cluster)
  
  plt.cur.cluster.umap <- df.umap %>%
    ggplot(aes(x, y)) + 
    geom_point(color = df.umap$flag, size = autoPointSize(nrow(df.umap))) + 
    theme_miko() + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = paste0("Cluster ", cluster.id), 
                                           caption = paste0("Cluster ", cluster.id, 
                                                            " highlighted in red (", 
                                                            comparison.group, ") and blue (", 
                                                            reference.group, ")"))
  
  
  rnc.cur <- results.nonconserved[results.nonconserved$cluster %in% cluster.name, ]
  if (!is.null(rnc.cur)){
  rnc.cur <- (rnc.cur %>% dplyr::arrange(pval))[1:10, ]
  rnc.cur$path.trun <- stringr::str_trunc(rnc.cur$pathway, 40)
  rnc.cur <- rnc.cur[!is.na(rnc.cur$pathway), ]    
  }

  
  rcc.cur <- results.conserved[results.conserved$cluster %in% cluster.name, ]
   if (!is.null(rnc.cur)){
  rcc.cur <- (rcc.cur %>% dplyr::arrange(pval))[1:10, ]
  rcc.cur$path.trun <- stringr::str_trunc(rcc.cur$pathway, 40)
  rcc.cur <- rcc.cur[!is.na(rcc.cur$pathway), ]
   }
  
  plt.conserved.go <- rcc.cur %>%
    ggplot(aes(x = -log10(pval), y = reorder(path.trun, -log1p(pval)), fill = -log1p(pval))) + 
    geom_bar(stat = "identity", color = "black") + 
    theme_miko(legend = T) + 
    viridis::scale_fill_viridis() + 
    geom_vline(xintercept = -log10(0.05), linetype = "dashed") + ylab("") + 
    xlab("-log(p)") + labs(title = "Conserved DEGs", subtitle = "GO Ontology", fill = "-log(p)")
  
  plt.nonconserved.go <- rnc.cur %>%
    ggplot(aes(x = -log10(pval), y = reorder(path.trun, -log1p(pval)), fill = -log1p(pval))) + 
    geom_bar(stat = "identity", color = "black") + 
    theme_miko(legend = T) + 
    viridis::scale_fill_viridis() + 
    geom_vline(xintercept = -log10(0.05), linetype = "dashed") + ylab("") + 
    xlab("-log(p)") + labs(title = "Non-conserved DEGs", subtitle = "GO Ontology", fill = "-log(p)")
  
  
  is.success <- F
  try({

  if ((nrow(rnc.cur) > 0) & (nrow(rcc.cur) > 0)){
    plt.right <- cowplot::plot_grid(plt.conserved.go, plt.nonconserved.go, ncol = 1)
  } else if ((nrow(rnc.cur) > 0) & (nrow(rcc.cur) == 0)) {
    plt.right <- plt.nonconserved.go
  } else if ((nrow(rnc.cur) == 0) & (nrow(rcc.cur) > 0)) {
    plt.right <- plt.conserved.go
  } else if ((nrow(rnc.cur) == 0) & (nrow(rcc.cur) == 0)) {
    plt.right <- NULL
  }
    
    is.success <- T    
  }, silent = T)
  
  if (!is.success) plt.right <- NULL
  
  if (length(plt.cmarkers.scatter) == 0){
    plt.cms <- NULL
  } else {
    plt.cms <- plt.cmarkers.scatter[[i]]
  }
  
  if (is.null(plt.right)){
    plt.cc.nc <- cowplot::plot_grid(plt.cur.cluster.umap, plt.cms, ncol = 2, align = "hv")
  } else {
    plt.cc.nc <- cowplot::plot_grid(plt.cur.cluster.umap, plt.cms, plt.right, ncol = 3, align = "hv")
  }
  
  cc.nc.list[[cluster.name]] <- plt.cc.nc
}

# cc.nc.list
# plt.cc.nc

```



```{r differential expression (between clusters), fig.height=8, fig.width=10, warning = FALSE, message = FALSE}

# create seurat copy - label identities
# so.query <- so.query
so.query$cluster.group <- paste(Idents(so.query), so.query@meta.data[["group.query"]], sep = "_")
so.query$cluster.orig <- Idents(so.query)
Idents(so.query) <- "cluster.group"

# get cluster group averages
e.mat <- getExpressionMatrix(so = so.query, which.data = "data")
u.cg <- as.character(unique(Idents(so.query)))

cg.mat <- matrix(nrow = nrow(e.mat), ncol = length(u.cg))
for (i in 1:length(u.cg)){
  which.match <- Idents(so.query) %in% u.cg[i]
  if (sum(which.match) < 3) next
  cg.mat[ ,i] <- log(rowMeans(expm1(x = e.mat[, which.match])) + 1)
}
colnames(cg.mat) <- u.cg
rownames(cg.mat) <- rownames(e.mat)
rm(e.mat); invisible({gc()})

# get unique clusters
u.clusters <- as.numeric(as.character(unique((so.query@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]

# get unique groups
levels.groups <- as.character(levels(so.query@meta.data[["group.query"]]))
u.groups <- unique(so.query@meta.data[["group.query"]])
u.groups <- levels.groups[levels.groups %in% u.groups]
so.query@meta.data[["group.query"]] <- factor(so.query@meta.data[["group.query"]], levels = u.groups)
stopifnot(length(u.groups) == 2)


which.assay.deg <- "SCT"
if (!(which.assay.deg %in% names(so.query@assays))) which.assay.deg <- DefaultAssay(so.query)

df.deg.list <- list()
df.deg.mat <- matrix(nrow = nrow(cg.mat), ncol = length(u.clusters)) 
df.deg.master <- NULL
for (i in 1:length(u.clusters)){
  
  # check if any subgroups have fewer than 3 cells - if yes, skip to next cluster
  n.cell.cur <-  as.vector(table(so.query@meta.data[["group.query"]][so.query@meta.data[["seurat_clusters"]] %in% u.clusters[i]])) 
  if (any(n.cell.cur < 3)) next
  
  # specify group names
  which.cluster <- u.clusters[i]
  group1 <- paste(which.cluster, "_", u.groups[2], sep = "")
  group2 <- paste(which.cluster, "_", u.groups[1], sep = "")
  
  # find group-wise differences (stratified by cluster)
  # Note logFC = Group 1 - Group 2
  df.deg <- FindMarkers(so.query,
                        assay = which.assay.deg,
                        ident.1 = group1,
                        ident.2 = group2,
                        only.pos = only.pos,
                        min.pct = deg.min.pct,
                        logfc.threshold = lfc.threshold,
                        verbose = F)
  
  
  
  df.deg[ ,c("p_val","avg_log2FC","pct.1", "pct.2","p_val_adj")] <- signif(df.deg[ ,c("p_val","avg_log2FC","pct.1", "pct.2","p_val_adj")], 3)
  
  df.deg$group.1 <- group1
  df.deg$group.2 <- group2
  
  # store results
  df.deg.mat[ ,i] <- cg.mat[ ,group1] - cg.mat[ ,group2]
  df.deg$genes <- rownames(df.deg)
  df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- df.deg
  df.deg.master <- bind_rows(df.deg.master, df.deg)
  
}

# label matrix
rownames(df.deg.mat) <- rownames(cg.mat)
colnames(df.deg.mat) <- as.character(u.clusters)


```


```{r pairwise expression plot, warning=FALSE, message=FALSE}

which.x <- reference.group
which.y <- comparison.group
u.clusters <- as.numeric(as.character(unique((so.query@meta.data[["seurat_clusters"]]))))
u.clusters <- u.clusters[order(u.clusters)]
plt.pairwise.list <- list()
Idents(so.query) <- "seurat_clusters"

for (i in 1:length(u.clusters)){
  
  # get current cluster
  which.cluster <- u.clusters[i]
  
  # get DEGs
  df.deg <- df.deg.list[[paste("c", as.character(u.clusters[i]), sep = "")]] 
  
  # get top differentially expressed genes
  df.deg.adj <- df.deg[df.deg$p_val_adj<0.2, ]
  
  try({if (is.null(df.deg.adj)){next} }, silent = T)
  try({if (nrow(df.deg.adj) == 0){next} }, silent = T)
  
  # ranked by signed lop p 
  df.deg.adj <- df.deg.adj[complete.cases(df.deg.adj),]
  df.deg.adj$logp <- -log10(df.deg.adj$p_val_adj)
  df.deg.adj$logp <- df.deg.adj$logp * sign(df.deg.adj$avg_log2FC)
  
  # get top genes
  df.deg.filtered.top <- df.deg.adj %>% 
    dplyr::arrange(logp) %>%
    dplyr::top_n(n = 40, wt = logp) %>%
    dplyr::arrange(desc(logp))
  df.deg.filtered.top <- df.deg.filtered.top[df.deg.filtered.top$logp > 0, ]
  
  # get bottom genes
  df.deg.filtered.bottom <- df.deg.adj %>% 
    dplyr::arrange(desc(logp)) %>%
    dplyr::top_n(n = 40, wt = -logp) %>%
    dplyr::arrange(((logp)))
  df.deg.filtered.bottom <- df.deg.filtered.bottom[df.deg.filtered.bottom$logp < 0, ]
  
  # combine top and bottom genes
  genes.to.label <- c(df.deg.filtered.top$genes, df.deg.filtered.bottom$genes)
  colors.to.label <- c(rep("tomato", nrow(df.deg.filtered.top)), rep("skyblue", nrow(df.deg.filtered.bottom)))
  
  # get average expression profile
  sub.pop <- subset(so.query, idents = which.cluster)
  Idents(sub.pop) <- "group.query"
  sub.pop <- rmDuplicateGenes(sub.pop)
  avg.sub.pop <- log1p(AverageExpression(sub.pop, verbose = FALSE)[[1]])
  colnames(avg.sub.pop) <- c("x", "y")
  avg.sub.pop$gene <- rownames(avg.sub.pop)
  
  # specify gene coloring
  avg.sub.pop$color <- "grey90"
  avg.sub.pop$color[avg.sub.pop$gene %in% df.deg.adj$gene[df.deg.adj$avg_log2FC > 0]] <- "tomato"
  avg.sub.pop$color[avg.sub.pop$gene %in% df.deg.adj$gene[df.deg.adj$avg_log2FC < 0]] <- "skyblue"
  
  avg.sub.pop$dif <- abs(avg.sub.pop$y - avg.sub.pop$x)
  avg.sub.pop <- avg.sub.pop[complete.cases(avg.sub.pop$dif) , ]
  avg.sub.pop <- avg.sub.pop %>% dplyr::arrange(dif)
  # generate plot
  p1 <- avg.sub.pop %>%
    ggplot(aes(x = x+1, y= y+1)) + 
    geom_point(aes(size = dif), alpha = 0.25, color = avg.sub.pop$color) +
    ggtitle(paste("Cluster ", which.cluster, sep = "")) + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") + 
    scale_x_continuous(trans='log10') +
    scale_y_continuous(trans='log10') + 
    xlab(paste0(which.x, " Expression, log(x+1)")) + 
    ylab(paste0(which.y, " Expression, log(y+1)")) + 
    labs(size = "|Dif|", caption = "Highlighted p adjusted < 0.2") + 
    theme_miko(legend = T)
  
  # add labels to plot
  p1 <- LabelPoints(p1, points = genes.to.label, repel = T, color = colors.to.label, ynudge = 0, xnudge = 0)
  
  plt.pairwise.list[[paste("c", as.character(u.clusters[i]), sep = "")]] <- p1
  
  if (print.inline){
    print(p1)
  }
  
}

# plt.pairwise.list

```


```{r symbol2entrez}

my.symbol <- rownames(so.query)
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

```

```{r GO enrich DEG, warning = FALSE}

# # get gene lists for pathway annotation
species <- which.species
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = "BP", species = which.species)
pathways <- pathways.go

# enrich DEGs (differential)
gse.pathway.list <- list()
gse.pathway.deg <- NULL

for (i in 1:length(u.clusters)){
  
  which.cluster <- u.clusters[i]
  
  # get DEGs
  df.deg <- data.frame(df.deg.mat[ ,as.character(which.cluster)])
  colnames(df.deg) <- "logFC"
  
  # ranked by signed lop p 
  if (is.null(df.deg)) next
  gene.list <- df.deg$logFC
  names(gene.list) <- rownames(df.deg)
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  # pathway gsea enrichment
  gse.pathway <- fgsea::fgsea(pathways, gene.list.clean, nperm=1000, maxSize=500)

  if (nrow(gse.pathway) == 0) next
  
  gse.pathway$cluster <- paste("c", as.character(u.clusters[i]), sep = "")
  gse.pathway.deg <- bind_rows(gse.pathway.deg, gse.pathway)
  
}

# data wrangle
gse.pathway.deg[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.deg[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.deg.all <- gse.pathway.deg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]
gse.pathway.deg.sig <- gse.pathway.deg.all[(gse.pathway.deg.all$pval < 0.05) & (abs(gse.pathway.deg.all$NES) >= 0.7), ]
gse.pathway.deg.sub <- gse.pathway.deg[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]

# print data table
if (print.inline){
  datatable(gse.pathway.deg.sig, 
            filter = 'top',
            extensions = 'Buttons',
            options = list(pageLength = 50,
                           dom = 'Bfrtip', 
                           buttons = c('copy', 'csv', 'pdf')))
}

```

```{r pooled group DEG}

# set correct ID
cur.id <- Idents(so.query)
Idents(so.query) <- so.query@meta.data[["group.query"]]

# get cluster group averages
e.mat <- getExpressionMatrix(so = so.query, which.data = "data")
u.cg <- as.character(unique(Idents(so.query)))

dif.mat <- matrix(nrow = nrow(e.mat), ncol = length(u.cg))
for (i in 1:length(u.cg)){
  which.match <- Idents(so.query) %in% u.cg[i]
  if (sum(which.match) < 3) next
  dif.mat[ ,i] <- log(rowMeans(expm1(x = e.mat[, which.match])) + 1)
}
colnames(dif.mat) <- u.cg
rownames(dif.mat) <- rownames(e.mat)
rm(e.mat); invisible({gc()})
dif.mat <- data.frame(dif.mat)
dif.mat$gene <- rownames(dif.mat) 
dif.mat$logfc <- dif.mat[ , comparison.group] -  dif.mat[ , reference.group]

# deg master for group comparison
df.deg.pool <- FindMarkers(so.query,
                           assay = which.assay.deg,
                           ident.1 = comparison.group,
                           ident.2 = reference.group,
                           only.pos = F,
                           min.pct = 0.01,
                           logfc.threshold = 0.1,
                           verbose = F)

df.deg.pool[ ,c("p_val","avg_log2FC","pct.1", "pct.2","p_val_adj")] <- signif(df.deg.pool[ ,c("p_val","avg_log2FC","pct.1", "pct.2","p_val_adj")], 3)

df.deg.pool$group.1 <- comparison.group
df.deg.pool$group.2 <- reference.group

```

```{r filter expression matrix and calculate similary matrix (for network analysis), warning = FALSE, message=FALSE}




# entire matrix
which.data <- "data"
exp.mat.complete <- getExpressionMatrix(so.query, which.data = which.data)

# pct expression exceeds threshold (in both datasets)
exp.mat.g1 <- exp.mat.complete[ ,so.query@meta.data[["group.query"]] %in% reference.group]
exp.mat.g2 <- exp.mat.complete[ ,so.query@meta.data[["group.query"]] %in% comparison.group]
pct.rep <- apply(exp.mat.complete, 1, function(x) mean(x>0))
pct.rep.g1 <- apply(exp.mat.g1, 1, function(x) mean(x>0))
pct.rep.g2 <- apply(exp.mat.g2, 1, function(x) mean(x>0))
df.pct.rep <- data.frame(pct.rep.g1, pct.rep.g2); colnames(df.pct.rep) <- c("x", "y")
# df.pct.rep$xy <- df.pct.rep$x * df.pct.rep$y
df.pct.rep$minxy <- pmin(df.pct.rep$x, df.pct.rep$y)
# which.rep <- rownames(df.pct.rep)[df.pct.rep$minxy > pct.threshold]
which.rep <- names(pct.rep)[pct.rep > pct.threshold]

# if (length(which.rep) < 1000) which.rep <- rownames((df.pct.rep %>% dplyr::top_n(1000, xy)))


# variable gene only matrix
use.var <- F
if (use.var){
  exp.mat <- getExpressionMatrix(so.query, only.variable = use.var, which.data = which.data, use.additional.genes = NA)
} else {
  exp.mat <- exp.mat.complete
}

# max var n
max.var.n <- 8000
if (DefaultAssay(so.query) == "SCT"){
  df.var <- so.query@assays[["SCT"]]@meta.features
  df.var$genes <- rownames(df.var)
  top.var.df <- df.var %>% top_n(max.var.n, (sct.residual_variance))
  top.var <- top.var.df$genes
  exp.mat <- exp.mat[rownames(exp.mat) %in% unique(top.var), ]
  exp.mat <- exp.mat[rownames(exp.mat) %in% unique(which.rep), ]
} else if (DefaultAssay(so.query) == "RNA"){
  df.var <- so.query@assays[["RNA"]]@meta.features
   top.var.df <- df.var %>% top_n(max.var.n, (vst.variance.standardized))
   top.var <- rownames(top.var.df)
   exp.mat <- exp.mat[rownames(exp.mat) %in% unique(which.rep), ]
}


which.col <- colnames(so.query)
which.row <- unique(rownames(exp.mat))

exp.mat <- exp.mat.complete[rownames(exp.mat.complete) %in% which.row, colnames(exp.mat.complete) %in% which.col]
exp.mat <- exp.mat[!duplicated(rownames(exp.mat)), ]


# transpose expressio matrix (genes are columns)
t.exp.mat <- t(exp.mat)
datExpr <- as.matrix(t.exp.mat)
SubGeneNames=colnames(datExpr)
datExpr.orig.noz <- datExpr

# split into two groups
de.orig.1 <- datExpr.orig.noz[rownames(datExpr.orig.noz) %in% colnames(so.query)[grepl(reference.group, so.query@active.ident)], ]
de.orig.2 <- datExpr.orig.noz[rownames(datExpr.orig.noz) %in% colnames(so.query)[grepl(comparison.group, so.query@active.ident)], ]


# ensure sample sizes are balanced across groups
output.mat <- balanceMatrixSize(de.orig.1, de.orig.2, method = "match.max")
de.1 <- output.mat[["de.1"]]
de.2 <- output.mat[["de.2"]]
datExpr.noz <- output.mat[["de.all"]]

# assert unique names
rownames(de.1) <- make.names(rownames(de.1), unique = T)
rownames(de.2) <- make.names(rownames(de.2), unique = T)
rownames(datExpr.noz) <- make.names(rownames(datExpr.noz), unique = T)



```


```{r}

runGSEA.dev <- function(gene, value, species, db = "GO", my.entrez = NULL, my.pathway = NULL, min.size = 3,
                        max.size = 300, do.plot = T, plot.top.n = 10){
  
  
  suppressMessages({
    suppressWarnings({
      
      
      if (is.null(my.entrez)){
        # get entrez to gene symbol mapping
        my.symbol <-gene
        my.entrez <- sym2entrez(my.symbol, my.species = species )
        my.entrez <- my.entrez[complete.cases(my.entrez), ]
      }
      
      if (is.null(my.pathway)){
        # get pathways
        my.pathway <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = db, ontology = "BP", species = species)
      }
      
      # prep genelist
      gene.list <- value
      names(gene.list) <- gene
      match.ind <- match(names(gene.list), my.entrez$SYMBOL)
      names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
      gene.list = sort(gene.list, decreasing = TRUE)
      
      # clean list
      df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
      df.ent <- df.ent[complete.cases(df.ent), ]
      df.ent <- df.ent[!is.infinite(df.ent$values), ]
      gene.list.clean <- df.ent$values
      names(gene.list.clean) <- df.ent$names
      
      # pathway gsea enrichment
      gse.pathway <- fgsea::fgsea(my.pathway, gene.list.clean, nperm=1000, minSize = min.size, maxSize=max.size)
      
      # make human readable
      gse.pathway <- gse.pathway
      gse.pathway$set <- lapply(gse.pathway$leadingEdge,
                                mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
      gse.pathway$set <- lapply(gse.pathway$set, paste,collapse = ", ")
      gse.pathway <- gse.pathway %>% dplyr::select(-c("leadingEdge"))
      
    })
  })
  
  if (do.plot){
    # get top GSEA
    gse.pathway.top <- bind_rows((gse.pathway %>% dplyr::filter(NES > 0) %>% dplyr::arrange(log1p(pval)))[1:plot.top.n],
                                 (gse.pathway %>% dplyr::filter(NES < 0) %>% dplyr::arrange(log1p(pval)))[1:plot.top.n])
    
    # plot
    gse.pathway.top$path.trun <- stringr::str_trunc(gse.pathway.top$pathway, 40)
    plt.gsea <- gse.pathway.top %>%
      ggplot(aes(x = NES, y = reorder(path.trun, NES), fill = -log1p(pval), size = -log1p(pval))) +
      geom_point(pch=21) +
      theme_miko(legend = T) +
      xlab("NES") + ylab("") +
      labs(title = "GSEA", fill = "-log(p)", size =  "-log(p)") +
      geom_vline(xintercept = 0, linetype = "dashed") +
      viridis::scale_fill_viridis(option ="B")
    
    return(list(
      gse.pathway = gse.pathway,
      gse.pathway.top = gse.pathway.top,
      plt.gsea = plt.gsea
    ))
  } else {
    return(gse.pathway)
  }
}

```

```{r schex hex bins, warning = FALSE, message = FALSE, fig.width = 14, fig.height=5, include = FALSE}

library(schex)
so.query <- make_hexbin(so.query, 20, dimension_reduction = "UMAP")
cID <- so.query@misc$hexbin[[1]]
out <- so.query@misc$hexbin[[2]]

# specfiy genesets ###########################################################
gene.names <- rownames(exp.mat)

# get data partitions ########################################################
u.bin <- unique(cID)
be.mat <- matrix(nrow = length(gene.names), ncol = length(u.bin))
be.mat.ref <- matrix(nrow = length(gene.names), ncol = length(u.bin))
be.mat.comp <- matrix(nrow = length(gene.names), ncol = length(u.bin))

gene.group.bin <- list()

which.ref <- so.query@meta.data[["group.query"]] %in% reference.group
which.comp <- so.query@meta.data[["group.query"]] %in% comparison.group

df.group.gene.comp <- NULL
# for (i in 1:length(gene.names)){

n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)


# single.exp <- prepDataFun(so.query,DefaultAssay(so.query),"data", gene.names[i])
e.mat.sub <- exp.mat
e.mat.sub <- e.mat.sub[!duplicated(rownames(e.mat.sub)), ]

bin.e.list <- list()
bin.e.list <- foreach(i = 1:length(gene.names), .packages = c("dplyr", "Seurat"))  %dopar% {
  # for (i in 1:length(gene.names)){
  
  single.exp <- as.vector(e.mat.sub[ rownames(e.mat.sub) %in% gene.names[i], ])
  group.exp <- tapply(single.exp, cID, FUN = function(z) z)
  
  single.exp.ref <- single.exp; single.exp.ref[which.comp] <- NA
  single.exp.comp <- single.exp; single.exp.comp[which.ref] <- NA
  
  group.exp.ref <- tapply(single.exp.ref, cID, FUN = function(z) z)
  group.exp.comp <- tapply(single.exp.comp, cID, FUN = function(z) z)
  
  gene.avg.ref <- (unlist(lapply(group.exp.ref, function(x) log(mean(expm1(x)+1, na.rm = T)))))
  gene.avg.comp <- (unlist(lapply(group.exp.comp, function(x) log(mean(expm1(x)+1, na.rm = T)))))
  
  df.rc <- data.frame(x = gene.avg.ref, y = gene.avg.comp)
  df.rc <- df.rc[complete.cases(df.rc), ]
  
  df.cor.current =  data.frame(gene =  gene.names[i], r =  cor(df.rc$x, df.rc$y, method = "spearman"), 
                               x = mean(df.rc$x, na.rm = T), sx = sd(df.rc$x, na.rm = T), 
                               y =  mean(df.rc$y, na.rm = T), sy = sd(df.rc$y, na.rm = T), n = nrow(df.rc))
  
  df.cor.current$dif <- df.cor.current$y - df.cor.current$x
  df.cor.current$sp <- sqrt((df.cor.current$sx^2) + (df.cor.current$sy^2))
  df.cor.current$z <- df.cor.current$dif/df.cor.current$sp
  df.cor.current$sig.dig <- df.cor.current$z > 1.96
  
  gene.avg <- (unlist(lapply(group.exp, function(x) log(mean(expm1(x)+1)))))
  
  
  list(
    group.exp = group.exp,
    gene.avg.ref = gene.avg.ref,
    gene.avg.comp = gene.avg.comp,
    gene.avg = gene.avg,
    df.cor.current = df.cor.current,
    gn =  gene.names[i]
  )
}

stopCluster(cl)

for (i in 1:length(bin.e.list)){
  gene.name <- bin.e.list[[i]]$gn
  be.mat[i ,] <- bin.e.list[[i]]$gene.avg
  be.mat.ref[i ,] <- bin.e.list[[i]]$gene.avg.ref
  be.mat.comp[i ,] <- bin.e.list[[i]]$gene.avg.comp
  df.group.gene.comp <- bind_rows(df.group.gene.comp,  bin.e.list[[i]]$df.cor.current)
  gene.group.bin[[gene.name]] <- bin.e.list[[i]]$group.exp
}
rownames(be.mat) <- rownames(be.mat.ref) <- rownames(be.mat.comp) <- gene.names

plt.bd.genes <- df.group.gene.comp %>%
  ggplot(aes(dif, abs(z), color = (x+y))) + 
  geom_text(aes(label = gene, size = abs(z))) + 
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")") ) + 
  # geom_hline(yintercept = 0, linetype = "dashed") + 
  geom_vline(xintercept = 0, linetype = "dashed") +
  ylab("|z|") + 
  theme_miko(legend = T) + 
  labs(title = "Group-wise Differential Expression", subtitle = paste0(length(u.bin), " bins"),
       color = "Avg.Exp.", size = "logFC")


bd.enrich.list <- runGSEA.dev(gene = df.group.gene.comp$gene, 
                              value = df.group.gene.comp$z,  species = which.species, 
                              db = "GO", min.size = 5, max.size = 300)

plt.bd.paths <- bd.enrich.list$plt.gsea + (xlab(paste0("NES (", comparison.group, "-", reference.group, ")")))

plt.bin.deg.ann <- cowplot::plot_grid(plt.bd.genes, plt.bd.paths, rel_widths = c(1,1.5))

if (print.inline){
  # fig.width = 14, fig.height=5
  print(plt.bin.deg.ann)
}

```



```{r compute correlations, include = FALSE}

# specify network parameters



  applyCorrection <- function(dat){
    require(sva)
    mod=matrix(1,nrow=dim(t(dat))[1],ncol=1)
    colnames(mod)="Intercept"
    nsv=num.sv(dat,mod = mod, method = "be")
    dat.correct = sva_network(dat, nsv)   
    
    list(
      dat.correct = dat.correct,
      nsv = nsv
    )
  }
  
  q_normalize <- function(dat){
    n = nrow(dat)
    p = ncol(dat)
    rank.dat =  dat # matrix for ranking
    for (i in 1:p){
      rank.dat[,i] = rank(dat[,i])
    }
    U = rank.dat/(n+1)
    qnorm(U)
  }


n.workers <- list(cor = 10)
if (sim.type == "single"){
  # get similarity matrices ######################################################
  # 
  #  if (do.pca.correction){
  #   ap.all <- applyCorrection(t(datExpr.noz)); datExpr.noz <- t(q_normalize(ap.all$dat.correct)); rm(ap.all)
  #   ap.1 <- applyCorrection(t(de.1)); de.1 <- t(q_normalize(ap.1$dat.correct)); rm(ap.1)
  #   ap.2 <- applyCorrection(t(de.2)); de.2 <- t(q_normalize(ap.2$dat.correct)); rm(ap.2)    
  # } 
  
  s.mat <- parCor(mat = datExpr.noz, method = which.cor, do.par = T, n.workers = n.workers$cor)
  # a.mat <-  sim2adj(s.mat, soft.power = 2, network.type = which.network)
  s.1 <- parCor(mat = de.1, method = which.cor, do.par = T, n.workers = n.workers$cor)
  s.2 <- parCor(mat = de.2, method = which.cor, do.par = T, n.workers = n.workers$cor)
  
  # clear NAs
  s.mat[is.na(s.mat)] <- 0
  s.1[is.na(s.1)] <- 0
  s.2[is.na(s.2)] <- 0
} else if (sim.type == "bin"){

  
  datExpr.noz.bin <- t(be.mat); rownames(datExpr.noz.bin) <- paste0("v", seq(1,nrow(datExpr.noz.bin)))
  de.1.bin <-  t(be.mat.ref); rownames(de.1.bin) <- paste0("v", seq(1,nrow(de.1.bin)))
  de.2.bin <-  t(be.mat.comp); rownames(de.2.bin) <- paste0("v", seq(1,nrow(de.2.bin)))
  
  # clean empties
  if (do.pca.correction){
    de.1.bin <- de.1.bin[complete.cases(de.1.bin), ]
    de.2.bin <- de.2.bin[complete.cases(de.2.bin), ]
    
    ap.all <- applyCorrection(t(datExpr.noz.bin)); datExpr.noz.bin <- t(q_normalize(ap.all$dat.correct)); rm(ap.all)
    ap.1 <- applyCorrection(t(de.1.bin)); de.1.bin <- t(q_normalize(ap.1$dat.correct)); rm(ap.1)
    ap.2 <- applyCorrection(t(de.2.bin)); de.2.bin <- t(q_normalize(ap.2$dat.correct)); rm(ap.2)    
  }
  
  
  s.mat <- parCor(mat = datExpr.noz.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)
  # a.mat <-  sim2adj(s.mat, soft.power = 2, network.type = which.network)
  s.1 <- parCor(mat = de.1.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)
  s.2 <- parCor(mat = de.2.bin, method = which.cor, do.par = T, n.workers = n.workers$cor)
  
  # clear NAs
  s.mat[is.na(s.mat)] <- 0
  s.1[is.na(s.1)] <- 0
  s.2[is.na(s.2)] <- 0
}


```


```{r get soft power, fig.width=10, fig.height=7}

sft <- getSoftThreshold2(s.mat, power =c(seq(1,20, by = 1)), 
                         network.type = which.network, rescale.adjacency = F, n.cores = 4, nBreaks = 10)

if (print.inline){
  cowplot::plot_grid(plotlist = sft$distribution.plot, ncol = 5)
}

```

```{r optimal soft power plot}

if (print.inline){
  print(sft$optimization.plot)
}

```


```{r bias similarity matrix}

bias.similarity  <- F

if (bias.similarity){
  # since group-wise comparison involves splitting data into smaller partitions, we're going to introduce a bias that attempts to stabilize the data
  n.ref <- sum(so.query@meta.data[["group.query"]] %in% reference.group)
  n.comp <- sum(so.query@meta.data[["group.query"]] %in% comparison.group)
  
  s.1 <- (s.1 * (n.ref/(n.ref + n.comp))) + (s.mat * (n.comp/(n.ref + n.comp)))
  s.2 <- (s.2 * (n.ref/(n.ref + n.comp))) + (s.mat * (n.comp/(n.ref + n.comp)))  
}

```


```{r calculate network connectivity, include = FALSE}

# get soft power
sft.opt <- sft[["results"]]
if (sum(sft.opt$r2 < -0.9) > 0){
  best.power <- sft.opt$sf[which(sft.opt$r2 < -0.9)[1]] 
} else {
  best.power <- sft[["powerEstimate"]]
}
if (is.na(best.power)) best.power <- 1

# run WCGNA ####################################################################
output.all <- runWGCNA(e.mat = datExpr.noz, s.mat = s.mat, cor.metric = which.cor, 
                       soft.power = best.power, use.TOM = T, 
                       network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)

output.1 <- NULL
output.1 <- runWGCNA(e.mat = de.1, s.mat = s.1, cor.metric = which.cor, 
                     soft.power = best.power, use.TOM = T, 
                     network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)  

output.2 <- NULL
output.2 <- runWGCNA(e.mat = de.2, s.mat = s.2, cor.metric = which.cor, 
                     soft.power = best.power, use.TOM = T, 
                     network.type = which.network, TOMDenom  = "min", TOM.type = TOM.type, rescale.adjacency = F)  

# unpack output ################################################################
s.mat <- output.all[["s.mat"]] # similar matrix
a.mat <- output.all[["a.mat"]] # adjacency matrix
w.mat <- output.all[["w.mat"]] # topological overlap matix
d.mat <- output.all[["d.mat"]] # disimilarity matix

s.1 <- output.1[["s.mat"]]
a.1 <- output.1[["a.mat"]]
w.1 <- output.1[["w.mat"]]
d.1 <- output.1[["d.mat"]] 

s.2 <- output.2[["s.mat"]]
a.2 <- output.2[["a.mat"]]
w.2 <- output.2[["w.mat"]]
d.2 <- output.2[["d.mat"]] 

```




```{r TOM scaling}

# TOM matrices of different datasets may have different statistical properties. Since consensus is defined as teh component-wise minimum of two-TOMs, a bias may results. Simple scaling can mitigate the effects of different statistical properties to some degree. TOM are scales such that 95th percentile equals the 95th percentile of the female TOM. 

# scale TOM matrices
w.1 <- scaleTOM(query.TOM = w.1, reference.TOM = w.2, reference.percentile = 0.95)

reference.percentile = 0.95

# recompute the distance matrix
d.mat <- 1-w.mat
d.1 <- 1-w.1
d.2 <- 1-w.2

# compute consensus topological overlap
w.co <- pmin(w.1, w.2) # component-wise parallel minimum of TOMs
w.dis <- pmax(w.1, w.2)
d.co <- 1-w.co
d.dis <- 1-w.dis

pprod <- function(..., na.rm = FALSE) {
  plus_na_rm <- function(x, y) ifelse(is.na(x), 0, x) * ifelse(is.na(y), 0, y)
  Reduce(if(na.rm) plus_na_rm else '*', list(...))
}

peuc <- function(..., na.rm = T) {
  plus_na_rm <- function(x, y) sqrt((x^2) + (y^2))
  Reduce(if(na.rm) plus_na_rm else '*', list(...))
}

w.mean <- peuc(w.1, w.2)
w.mean <- w.mean/max(w.mean, na.rm = T)
d.mean <- 1-w.mean

```


```{r connectivity comparison, fig.height = 4, fig.width=14}

# quantile normalization of 2 vectors (Hicks 2014) #############################

# quantile normalization
x.s1 <- getConnectivity(s.1, gene.names = colnames(a.1))$wi
y.s2 <- getConnectivity(s.2, gene.names = colnames(a.2))$wi
df.xy.s <- qNorm(x.s1, y.s2, genes = colnames(a.1))

x.a1 <- getConnectivity(a.1, gene.names = colnames(a.1))$wi
y.a2 <- getConnectivity(a.2, gene.names = colnames(a.2))$wi
df.xy.a <- qNorm(x.a1, y.a2, genes = colnames(a.1))

x.w1 <- getConnectivity(w.1, gene.names = colnames(a.1))$wi
y.w2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.xy.w <- qNorm(x.w1, y.w2, genes = colnames(a.1))

# generate plots ###############################################################

# similarity-based connectivity plots
plt.input.xy.s <- df.xy.s %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("Similarity (", reference.group , ")")) + ylab(paste0("Similarity (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("Similarity") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 

# adjacency-based connectivity plots
plt.input.xy.a <- df.xy.a %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("Adjacency (", reference.group , ")")) + ylab(paste0("Adjacency (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("Adjacency") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 

# TOM-based connectivity plots
plt.input.xy.w <- df.xy.w %>%
  ggplot(aes(x.old, y.old)) + geom_point() +  geom_smooth(color = "skyblue") + geom_abline(slope = 1) + 
  xlab(paste0("TOM (", reference.group , ")")) + ylab(paste0("TOM (", comparison.group , ")")) + 
  theme_classic() +   ggtitle("TOM") + 
  ggrepel::geom_text_repel(aes(x.old, y.old, label =ifelse(top.old ,as.character(genes),'')), size = 2.5, color = "black") 


if (print.inline){
  # fig.height = 10, fig.width=10
  cowplot::plot_grid(plt.input.xy.s, 
                     plt.input.xy.a, 
                     plt.input.xy.w, 
                     ncol = 3)
}

```


```{r, fig.width=10, fig.height=3}

library(flashClust)
# get dendrograms
geneTree.all <- dist2hclust(d.mat)
geneTree.co <- dist2hclust(d.co)
geneTree.1 <- dist2hclust(d.1)
geneTree.2 <- dist2hclust(d.2)
geneTree.dif <- dist2hclust(d.dis)
geneTree.mean <- dist2hclust(d.mean)

if (print.inline){
  par(mfrow = c(1,6))
  plot(geneTree.all, xlab = "", sub = "", main = "All", labels = F, hang = 0.04)
  plot(geneTree.co, xlab = "", sub = "", main = "Consensus", labels = F, hang = 0.04)
  plot(geneTree.1, xlab = "", sub = "", main = paste0("Group 1: ", reference.group), labels = F, hang = 0.04)
  plot(geneTree.2, xlab = "", sub = "", main = paste0("Group 2: ", comparison.group), labels = F, hang = 0.04)
  plot(geneTree.dif, xlab = "", sub = "", main = paste0("Differential"), labels = F, hang = 0.04)
  plot(geneTree.mean, xlab = "", sub = "", main = paste0("pmean"), labels = F, hang = 0.04)
}
```

```{r specfiy which meta network to evaluate}

# specify how to combine networks
if (which.metanet == "consensus"){
  w.co <- w.co
  d.co <- 1-w.co  
  geneTree.co <- geneTree.co
} else if (which.metanet== "differential"){
  w.co <- w.dis
  d.co <- 1-w.co    
  geneTree.co <- geneTree.dif
} else if (which.metanet == "total"){
  w.co <- w.mat
  d.co <- 1-w.co  
  geneTree.co <- geneTree.all  
} else if (which.metanet == "mean"){
  w.co <- w.mean
  d.co <- 1-w.co   
  geneTree.co <- geneTree.mean
}
```



```{r dendro cuts, message=FALSE, warning=FALSE}

pam.resp.dend <- F
cut.height <- NULL


# determine number of modules based on refrence dataset
p2h <- capture.output(mColorh.1 <- optimalDS(tree = geneTree.1, d.mat = d.1, 
                                             genes  = rownames(a.1), minClusterSize  = min.cluster.size, 
                                             method = "hybrid", cut.height = cut.height, pam.respects.dendro = pam.resp.dend))
p2h <- capture.output(mColorh.2 <- optimalDS(tree = geneTree.2, d.mat = d.2, 
                                             genes  = rownames(a.2), minClusterSize  = min.cluster.size, 
                                             method = "hybrid", cut.height = cut.height, pam.respects.dendro = pam.resp.dend))
p2h <- capture.output(mColorh.all <- optimalDS(tree = geneTree.all, d.mat= d.mat, 
                                               genes  = rownames(a.mat), minClusterSize  = min.cluster.size, 
                                               method = "hybrid", cut.height = cut.height, pam.respects.dendro = pam.resp.dend))
p2h <- capture.output(mColorh.co <- optimalDS(tree = geneTree.co, d.mat= d.co, 
                                              genes  = rownames(a.mat), minClusterSize  = min.cluster.size, 
                                              method = "hybrid", cut.height = cut.height, pam.respects.dendro = pam.resp.dend))

# select modules based off best clustering above
which.deepcut <- "ds.4"
modules.1a = mColorh.1[ ,which.deepcut]
modules.2a = mColorh.2[ ,which.deepcut]
modules.all <- mColorh.all[ ,which.deepcut]
modules.coa <- mColorh.co[ ,which.deepcut]

if (print.inline){
  # plot dendrograms (with module labels)
  plotDendroAndColors(geneTree.all, mColorh.all[,1:5], paste("dpSplt =", 0:4), main = "All", dendroLabels = F)
  plotDendroAndColors(geneTree.co, mColorh.co[,1:5], paste("dpSplt =", 0:4), main = "Consensus", dendroLabels = F)
  plotDendroAndColors(geneTree.1, mColorh.1[,1:5], paste("dpSplt =", 0:4), 
                      main = paste0("Group 1: ", reference.group), dendroLabels = F)
  plotDendroAndColors(geneTree.2, mColorh.2[,1:5], paste("dpSplt =", 0:4), 
                      main = paste0("Group 2: ", comparison.group), dendroLabels = F)
}

```



```{r Comparing networks with different module definitions}

modules.COA <- modules.coa
modules.ALL <- modules.all
modules.coa <- modules.COA
modules.1b = as.vector(matchLabels(modules.1a,  modules.coa))
modules.2b = as.vector(matchLabels(modules.2a,  modules.coa))
modules.cob = as.vector(matchLabels(modules.coa,  modules.coa))
modules.all = as.vector(matchLabels(modules.ALL,  modules.coa))

if (print.inline){
  plotDendroAndColors(geneTree.all, modules.all, "All", dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main="All dendrogram")
  plotDendroAndColors(geneTree.co, modules.cob, paste0("Consensus\n", reference.group, "+", comparison.group), dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main="Consensus dendrogram")
  plotDendroAndColors(geneTree.1, modules.1b, paste0("Group 1: ", reference.group), dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main=paste0("Group 1: ", reference.group))
  plotDendroAndColors(geneTree.2, modules.2b, paste0("Group 2: ", comparison.group), dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main=paste0("Group 2: ", comparison.group))
}

common.modules <- intersect(modules.1b, modules.2b)
m1.u <- unique(modules.1b)
m2.u <- unique(modules.2b)
g1.specific.modules <- m1.u[!(m1.u %in% common.modules)]
g2.specific.modules <- m2.u[!(m2.u %in% common.modules)]

module.sets <- list(all = unique(modules.all),
                    group.1 = unique(modules.1b), 
                    group.2 = unique(modules.2b),
                    consensus = unique(modules.cob))

module.sets.v2 <- list(all = unique(modules.all),
                       consensus = unique(modules.cob))

if (print.inline){
  ggVennDiagram::ggVennDiagram(module.sets) + ggtitle("Network Preservations")
}

# get robust consensus modules (all else set to grey)
# consensus.modules <-intersect(modules.all, intersect(modules.cob, intersect(modules.1b, modules.2b)))
modules.consensus <- modules.cob
consensus.modules <-modules.consensus

# modules.consensus[!(modules.consensus %in% consensus.modules)] <- "grey"
modules.1b[!(modules.1b %in% modules.consensus)] <- "grey"
modules.2b[!(modules.2b %in% modules.consensus)] <- "grey"
modules.all[!(modules.all %in% modules.consensus)] <- "grey"

# get mapping df for late
df.map.all <- data.frame(module = modules.consensus, genes = mColorh.all[ ,"genes"])

```




```{r matrix distributions, fig.width=15, fig.height=4}

if (print.inline){
  par(mfrow = c(1,4))
  hist(datExpr.noz, main = "Expression", xlab = "Expression")
  hist(s.mat[s.mat != 1], main = "Similarity (correlation)", xlab = "Similarity")
  hist(a.mat[a.mat != 1], main = "Adjacency", xlab = "Adjacency")
  hist(w.mat[w.mat != 1], main = "TOM", xlab = "TOM")
}

```


```{r preservation of group1 network in group2}


if (print.inline){
  plotDendroAndColors(geneTree.1, modules.1b, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
                      guideHang=0.05, main="Gene dendrogram and module colors (Group 1 -> Group 1)")
  plotDendroAndColors(geneTree.1, modules.cob, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
                      guideHang=0.05, main="Gene dendrogram and module colors (Group 1 -> consensus)")
  
  plotDendroAndColors(geneTree.2, modules.2b, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
                      guideHang=0.05, main="Gene dendrogram and module colors (Group 2 -> Group 2)")
  plotDendroAndColors(geneTree.2, modules.cob, "Modules", dendroLabels=FALSE, hang=0.03, addGuide=TRUE,
                      guideHang=0.05, main="Gene dendrogram and module colors (Group 2 -> consensus)")
}


```

```{r eigenGenes}

library(irlba)

# ME activity of group 1
which.module.membership <- modules.consensus


getME <- function(mat, module.membership, scale.ME = F){
  
  ME <- matrix(nrow = nrow(mat), ncol = length(unique(module.membership)))
  for (i in 1:length(unique(module.membership))){
    current.mod <- unique(module.membership)[i]
    mat.sub <- mat[ ,colnames(mat) %in% colnames(mat)[module.membership %in% current.mod]]
    
    svd.out <- irlba(mat.sub, nv = 1)
    PrinComps <- svd.out[["u"]][ ,1]
    
    scaledExpr = scale((mat.sub))
    averExpr = rowMeans(scaledExpr, na.rm = TRUE)
    corAve = cor(averExpr,PrinComps, 
                 use = "p")
    if (!is.finite(corAve)) corAve = 0
    if (corAve < 0) PrinComps = -PrinComps
    
    # center and scale
    if (scale.ME){
      PrinComps <- scale(PrinComps)
    }
    
    ME[ ,i] <- PrinComps
  }
  colnames(ME) <- paste0("ME", unique(module.membership))
  ME <- as.data.frame(ME)
  rownames(ME) <- rownames(mat)
  
  return(list(
    ME = ME,
    colors = names(table(module.membership))
  ))
}

de.1[is.na(de.1)] <- 0
ME_1.list <- getME(de.1, which.module.membership)
ME_1A <- ME_1.list$ME
colorsA1 <-  ME_1.list$colors

de.2[is.na(de.2)] <- 0
ME_2.list <- getME(de.2, which.module.membership)
ME_2A <- ME_2.list$ME
colorsA2 <-  ME_2.list$colors

datExpr.noz[is.na(datExpr.noz)] <- 0
ME.all.list <- getME(datExpr.noz, which.module.membership)
ME.all <- ME.all.list$ME
colors.all <-  ME.all.list$colors



```

```{r ME activity analysis, fig.width= 8, fig.height=4}

# prep ME activity data
df.ME.all <- ME.all
ME.names <-  colnames(ME.all)
df.ME.all$id <- rownames(df.ME.all)
df.ME.all.long <-pivot_longer(df.ME.all, ME.names)
df.ME.all.long <- df.ME.all.long %>%  filter(!(name %in% "MEgrey")) 

df.meta <- so.query@meta.data
df.meta$id <- rownames(df.meta)
df.meta.sub <- df.meta[ ,c("cluster.group", "id", "cluster.orig")]
df.meta.sub$cluster.group <- gsub("[0-9]*_", "", df.meta.sub$cluster.group ) # introduced here
so.query@meta.data$cg <- df.meta.sub$cluster.group

# merge ME activity and module identities
df.ME.all.long.merge <- merge(df.ME.all.long, df.meta.sub, by = "id")

# monitor this segment...may need to be revisited. 
if (nrow(df.ME.all.long.merge) == 0){
  df.ME.all.long$id <- gsub("[.].", "", df.ME.all.long$id)
  df.meta.sub$id <- gsub("-.", "", df.meta.sub$id)
  df.ME.all.long.merge <- merge(df.ME.all.long, df.meta.sub, by = "id")
  stopifnot((nrow(df.ME.all.long.merge) > 0))
}



# enforce reference/comparison order
u.groups <- unique(df.ME.all.long.merge$cluster.group)
if (length(u.groups) == 2){
  u.groups.ordered <-c(u.groups[grepl(reference.group, u.groups)], u.groups[grepl(comparison.group, u.groups)])
} else {
  warning("More than 2 unique groups detected. Network analysis is void.")
}

df.ME.all.long.merge$cluster.group <- factor(df.ME.all.long.merge$cluster.group, u.groups.ordered)

# get summary
df.ME.sum <- df.ME.all.long.merge %>%
  group_by(name, cluster.group) %>%
  summarize(mean.ME = mean(value),
            median.ME = median(value),
            sd.ME = sd(value),
            n.ME = length(value),
            raw.values = list(value))

# consolidated view
plt.dif.box <- df.ME.all.long.merge %>%
  ggplot(aes(x = name, y = value, fill = cluster.group)) +
  geom_boxplot() + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1)) +
  # geom_hline(yintercept = 0, linetype = "dashed") + 
  scale_fill_manual(values=c("skyblue", "tomato")) + 
  theme_bw() + xlab("groups") + ylab("Module Activity (Eigenvalue)") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + ggtitle("Module Activity")

# stratified view
plt.dif.box.1 <- df.ME.all.long.merge %>%
  ggplot(aes(x = cluster.group, y = value, fill = cluster.group)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free_y") + 
  scale_fill_manual(values=c("skyblue", "tomato")) + 
  theme_bw() + xlab("groups") + ylab("Module Activity (Eigenvalue)")

if (print.inline){
  # print(plt.dif.box.1)
  
  # fig.width= 8, fig.height=4
  print(plt.dif.box.1)
}

```

```{r ME differential expression, fig.height = 4, fig.width=12}

# get unique groups
u.groups <- unique(as.character(levels((so.query@meta.data[["group.query"]]))))

# get ME activity for each group and merge
df.ME.sum.1 <- df.ME.sum[  grepl(reference.group, df.ME.sum$cluster.group), ]
df.ME.sum.2 <- df.ME.sum[  grepl(comparison.group, df.ME.sum$cluster.group), ]
df.ME.sum.merge <- merge(df.ME.sum.1, df.ME.sum.2, by = c( "name"))

# get ME connectivity for each group and merge
which.mat <- "w" # s: s.mat, a: a.mat, w: w.mat

if (which.mat == "w"){
  mat.1 <- w.1
  mat.2 <- w.2
} else if (which.mat == "a") {
  mat.1 <- a.1
  mat.2 <- a.2  
} else if (which.mat == "s") {
  mat.1 <- s.1
  mat.2 <- s.2  
}

# get connectivity scores
df.ME.k.1 <- getConnectivity(mat.1, rownames(a.1))
df.ME.k.2 <- getConnectivity(mat.2, rownames(a.2))

# quantile normalization of connectivity
# df.ME.qNorm <- qNorm(df.ME.k.1$wi, df.ME.k.2$wi, df.ME.k.2$genes)
# df.ME.k.1$wi <- df.ME.qNorm$x.new
# df.ME.k.2$wi <- df.ME.qNorm$y.new

# merge connecitivty
df.ME.k.merge <- merge(df.ME.k.1, df.ME.k.2, by = "genes")

# get gene and modules
df.gene2module <-  namedList2longDF(getModuleGenes(modules.cob, SubGeneNames, add.prefix = F),
                                    name.header = "module", value.header = "genes")
df.ME.k.merge <- merge(df.ME.k.merge, df.gene2module, by = "genes")

# summary statistics for ME activity
df.ME.sum.merge <- df.ME.sum.merge %>%
  group_by(name) %>%
  mutate(ME.dif.mean = mean.ME.y - mean.ME.x,
         ME.dif.median = median.ME.y - median.ME.x,
         pVal = wilcox.test(unlist(raw.values.x), unlist(raw.values.y))[["p.value"]]) 


which.connect <- "r" # r: ranks, w: wi

if (which.connect == "r"){
  df.ME.k.sum.merge <- df.ME.k.merge %>%
    group_by(module) %>%
    summarize(ME.dif.mean = mean(rank.y) - mean(rank.x),
              ME.dif.median = median(rank.y) - median(rank.x),
              pVal = wilcox.test(rank.y, rank.x)[["p.value"]])  
} else if (which.connect == "w"){
  df.ME.k.sum.merge <- df.ME.k.merge %>%
    group_by(module) %>%
    summarize(ME.dif.mean = mean(wi.y) - mean(wi.x),
              ME.dif.median = median(wi.y) - median(wi.x),
              pVal = wilcox.test(wi.y, wi.x)[["p.value"]])    
}

# FDR correction
df.ME.sum.merge$pAdj <- p.adjust(df.ME.sum.merge$pVal, method = "BH", n = length(df.ME.sum.merge$pVal))
df.ME.k.sum.merge$pAdj <- p.adjust(df.ME.k.sum.merge$pVal, method = "BH", n = length(df.ME.k.sum.merge$pVal))

# node volcano plot
sig.exp <-df.ME.sum.merge$name[ df.ME.sum.merge$pVal < 0.05] 
sig.exp <- unique(gsub("ME", "", sig.exp))
plt.dif.volc <- df.ME.sum.merge %>%
  ggplot(aes(x = ME.dif.median, y = -log10(pAdj), size = -log10(pAdj), color = ME.dif.median)) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Differential ME Activity (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(pAdj)") + 
  geom_hline(yintercept = -log10(0.05), linetype = "dashed")  +
  geom_vline(xintercept = 0, linetype = "dashed")  +
  ggrepel::geom_text_repel(aes(ME.dif.median,  -log10(pAdj), label =name), size = 3, color = "black") +
  ggtitle("Differential ME Activity") + 
  scale_colour_gradientn("Difference", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.ME.sum.merge$ME.dif.median), 0, max(df.ME.sum.merge$ME.dif.median))))) + theme(legend.position="bottom") + guides(size=guide_legend("-log10(pAdj)"), color = FALSE)

# rank volcano plot
sig.con <- unique(df.ME.k.sum.merge$module[ df.ME.k.sum.merge$pVal < 0.05]) 
plt.rank.volc <- df.ME.k.sum.merge %>%
  ggplot(aes(x = ME.dif.median, y = -log10(pAdj), size = -log10(pAdj), color = ME.dif.median)) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Differential ME Connectivity (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(pAdj)") + 
  geom_vline(xintercept = 0, linetype = "dashed")  +
  ggrepel::geom_text_repel(aes(ME.dif.median,  -log10(pAdj), label =module), size = 3, color = "black") +
  ggtitle("Differential ME Connectivity") + 
  scale_colour_gradientn("Difference", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.ME.k.sum.merge$ME.dif.median), 0, max(df.ME.k.sum.merge$ME.dif.median))))) + theme(legend.position="bottom") + guides(size=guide_legend("-log10(pAdj)"), color = FALSE)

if (min(df.ME.k.sum.merge$pAdj) < 0.05) plt.rank.volc <- plt.rank.volc +  geom_hline(yintercept = -log10(0.05), linetype = "dashed")


# pairwise comparison
df.me.activity <- df.ME.sum.merge[ ,c("name", "ME.dif.median")]
colnames(df.me.activity) <- c("module", "x")
df.me.activity$module <- gsub("ME", "", df.me.activity$module)
df.me.connect <- df.ME.k.sum.merge[ ,c("module", "ME.dif.median")]
colnames(df.me.connect) <- c("module", "y")
df.me.merge <- merge(df.me.activity, df.me.connect, by = "module") 

# euclidean distance from origin
df.me.merge$x.s <- (df.me.merge$x - mean(df.me.merge$x))/sd(df.me.merge$x)
df.me.merge$y.s <- (df.me.merge$y - mean(df.me.merge$y))/sd(df.me.merge$y)
df.me.merge$z.s <- sqrt(((df.me.merge$x.s)^2) + ((df.me.merge$y.s)^2))

df.me.merge$label <- ""
df.me.merge$label[df.me.merge$module %in% unique(c(sig.con, sig.exp))] <- df.me.merge$module[df.me.merge$module %in% unique(c(sig.con, sig.exp))]
plt.dif.rank.comp <- df.me.merge %>%
  ggplot(aes(x,y, size = z.s)) + 
  geom_point(alpha = 0.5) + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  theme_classic() + 
  ggrepel::geom_text_repel(aes(x,y, label =label), size = 3, color = "black") +
  xlab(paste0("Differential Activity\n", comparison.group, "-", reference.group)) + 
  ylab(paste0("Differential Connectivity\n", comparison.group, "-", reference.group)) +
  labs(title = paste0("Modular Sector Plot"), subtitle = paste0(comparison.group, "-", reference.group),
       caption = "Labeled nodes: p<0.05")  + 
  theme(legend.position = "none")

if (print.inline){
  cowplot::plot_grid(plt.dif.volc, plt.rank.volc,plt.dif.rank.comp,  ncol = 3)
}

```

```{r ME activity heatmap}

me.exp.mat <- (datExpr.noz)
me.exp.mat <- me.exp.mat[ ,!(modules.cob %in% "grey")]
modules.all.sub <- modules.cob[!(modules.cob %in% "grey")]
membership.all.sub <- rep(NA, nrow(ME.all))
ME.all.rownames <- rownames(ME.all)
membership.all.sub[ME.all.rownames %in% df.meta$id[df.meta$group.query %in% reference.group] ] <- reference.group
membership.all.sub[ME.all.rownames %in% df.meta$id[df.meta$group.query %in% comparison.group] ] <- comparison.group

# monitor this segment...may need to be revisited.
if (sum(is.na(membership.all.sub)) == length(membership.all.sub)){
  ME.all.rownames <- gsub("[.].", "",rownames(ME.all))
  df.meta$id.v2 <- gsub("-.", "",df.meta$id)

  membership.all.sub[ME.all.rownames %in% df.meta$id.v2[df.meta$group.query %in% reference.group] ] <- reference.group
  membership.all.sub[ME.all.rownames %in% df.meta$id.v2[df.meta$group.query %in% comparison.group] ] <- comparison.group

  stopifnot( (sum(is.na(membership.all.sub)) < length(membership.all.sub)))
}

grouping.mem <- as.data.frame(membership.all.sub)
names(grouping.mem) <- "Group"

```


```{r group prediction, fig.width= 12, fig.height=4, warning = FALSE, message = FALSE}

# omit grey module
ME.all.sub <- ME.all[ ,!(colnames(ME.all) %in% "MEgrey")]

# prep data for model fitting
all.data <- as.data.frame(ME.all.sub)
all.data$group <- (membership.all.sub)
all.data$group[all.data$group == reference.group] <- 0
all.data$group[all.data$group == comparison.group] <- 1
all.data$group <- as.factor(all.data$group)

# partition data into test and training sets
split <- createDataPartition(y = all.data$group,p = 0.8,list = FALSE)
train <- all.data[split, ]
test <- all.data[-split, ]

# fit logistic regressio model
model <- glm(group ~ ., family = binomial(link = 'logit'), data = train)

# get model stats
model.coef <- summary(model)
model.anova <- anova(model, test = 'Chisq')
model.anova[ , "Pr(>Chi)"] <- model.anova[ , "Pr(>Chi)"]  + 1e-20

# model stat wrangling
df.model.1 <- as.data.frame(model.coef[["coefficients"]])
df.model.1$terms <- rownames(df.model.1)
colnames(df.model.1) <- c("Estimate", "SE", "z.model", "p.model", "terms")
df.model.2 <- model.anova
df.model.2$terms <- rownames(df.model.2)
colnames(df.model.2) <- c("df", "Deviance", "resid.df", "resid.dev", "p.anova", "terms")
df.model.merge <- merge(df.model.1, df.model.2, by = "terms")
df.model.merge$varExplained <- df.model.merge$Deviance / sum(df.model.merge$Deviance)

# compute model perormance using test set
log_predict <- predict(model,newdata = test,type = "response")
log_predict <- ifelse(log_predict > 0.5,1,0)
df.prediction <- as.data.frame(table(test$group,log_predict))

# plot confusion matrix
a1 <- as.numeric(as.character(test$group))
a2 <- as.numeric(as.character(log_predict))
df.a12 <- data.frame(x = a1, y = a2)
df.a12 <- df.a12[complete.cases(df.a12), ]

plt.confusion <- ggplot(data =  df.prediction, mapping = aes(x = Var1, y = log_predict)) +
  geom_tile(aes(fill = Freq), colour = "white") +
  geom_text(aes(label = sprintf("%1.0f",Freq)), vjust = 1) +
  scale_fill_gradient(low = "white", high = "steelblue") + 
  xlab("True Label") + ylab("Predicted Label") + 
  labs(title = ("Confusion Matrix"), subtitle = paste0("AUC=", signif(Metrics::auc(df.a12$x,df.a12$y), 2)," (20% validation set)")) + 
  theme(legend.position = "none")

# plot model volcano plot
plt.logitModel <- df.model.merge %>%
  ggplot(aes(x = Estimate, y = -log10(p.model), size = varExplained, color = -log10(p.anova))) +
  geom_point(stat = "identity") +
  theme_classic() + 
  xlab(paste0("Logit Model Coefficient (", comparison.group, " - ", reference.group, ")")) + 
  ylab("-log10(p.model), Model Coefficient") + 
  geom_vline(xintercept = 0, linetype = "dashed")  +
  ggrepel::geom_text_repel(aes(Estimate,  -log10(p.model), label =terms), size = 3, color = "black") + 
  labs(title = "Logistic Regression", subtitle = "80% training set") + theme(legend.position="bottom")

if (min(df.model.merge$p.model) < 0.05) plt.logitModel <- plt.logitModel + geom_hline(yintercept = -log10(0.05), linetype = "dashed")

# min(df.model.merge$p.model)
# merge plots

model.anova$var.exp <- model.anova$Deviance / sum(model.anova$Deviance, na.rm = T)
model.anova$terms <- rownames(model.anova)
model.anova <- model.anova[!(model.anova$terms %in% "NULL"), ]
model.anova$terms <- gsub("ME", "", model.anova$terms)

colnames(model.anova)[colnames(model.anova) %in% "Pr(>Chi)"] <- "pVal"
# model.anova$pVal <- model.anova$pVal + 1e-20
model.anova$pVal.log <- -log10(model.anova$pVal)

model.anova$padj <- p.adjust(model.anova$pVal, method = "BH", n = length(model.anova$pVal))
importance.order <- (model.anova %>% dplyr::arrange(-var.exp))$term

plt.var.exp <- model.anova %>%
  ggplot(aes(reorder(terms, var.exp), var.exp, fill = pVal.log)) + 
  geom_bar(stat = "identity") + 
  coord_flip() + 
  theme_classic() + 
  xlab("Module") + 
  ylab(paste0("Variance Explained\n", reference.group, " vs. ", comparison.group)) + labs(fill = "-log10(p)") + 
  ggtitle("Variance Explained")


if (print.inline){
  # fig.width= 12, fig.height=4
  cowplot::plot_grid(plt.logitModel, plt.confusion, plt.var.exp, ncol = 3)
}

```


```{r misc functions}

module.membership <- modules.consensus
# clean fora output function
cleanForaOutput <- function(fora.output, my.entrez){
  suppressMessages({
    suppressWarnings({
      fora.output$set <- lapply(fora.output$overlapGenes, 
                                mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
      fora.output$set <- lapply(fora.output$set, paste,collapse = ", ")
      fora.output[ ,c("pval", "padj")] <- signif( fora.output[ ,c("pval", "padj")], 3)
      fora.output <- fora.output %>% dplyr::select(-c("overlapGenes"))
    })
  })
  return(fora.output)
}

results.co.hub.p <- NULL;
results.co.hub.bh <- NULL;
```

```{r}

  getTopTOM <- function(w.mat, module.genes){
    w.mat.cur <- w.mat[rownames(w.mat) %in% module.genes, colnames(w.mat) %in% module.genes]
    diag(w.mat.cur) <- NA
    w.s <- (w.mat.cur - median(w.mat.cur, na.rm = T) ) /mad(w.mat.cur, na.rm = T)
    mat.log <- apply(w.s, 1, function(x) x >2 )
    mat.log[is.na(mat.log)] <- F
    mat.row <- apply(mat.log, 1, function(x) any(x, na.rm = T))
    top.w.genes <- rownames(w.s)[mat.row]    
    return(top.w.genes)
  }

```


```{r get hub genes}
# get ME names
df.me <- ME.all
colnames(df.me) <- gsub("ME", "", colnames(df.me))
module.names <- colnames(df.me)
df.me$cells <- rownames(df.me)


plt.hub.list <- list()
hub.list <- list()
for (i in 1:length(module.names)){
  module.genes <- rownames(a.mat)[which.module.membership %in% module.names[i]]
  wc <- w.mat[rownames(w.mat) %in% module.genes, colnames(w.mat) %in% module.genes]
  df.wc <- getConnectivity(wc, rownames(wc) )
  
  hub.genes <- df.wc$genes[(df.wc$wi - median(df.wc$wi))/mad(df.wc$wi) > 2] 
  df.wc$is.hub <- "grey"
  df.wc$is.hub[df.wc$genes %in% hub.genes] <- "tomato"
  
  plt.hub <- df.wc %>%
    ggplot(aes(x = rank(wi), y = wi, label = genes)) +
    geom_text(size = 2, color = df.wc$is.hub) +
    theme_miko() +
    xlab("Hub Gene Rank") +
    ylab("Connectivity") +
    labs(title = "Network Hub Genes", subtitle = module.names[i])
  
  hub.list[[module.names[i]]] <- hub.genes
  plt.hub.list[[module.names[i]]] <- plt.hub
  
}

# 
# plt.hub.list
  
```


```{r go enrich, warning=FALSE, message=FALSE}

# run go enrichment
all.genes <- colnames(de.1)

# get genes
module.list.all <- getModuleGenes(modules.all, SubGeneNames, add.prefix = F)
module.list.co <- getModuleGenes(modules.cob, SubGeneNames, add.prefix = F)

# get mapping
my.symbol <- rownames(w.mat)
my.entrez <- sym2entrez(my.symbol, my.species =which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]
g2e.list <- my.entrez$ENTREZID
names(g2e.list) <- my.entrez$SYMBOL

# get annotations
pathways.go <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = c("GO"), ontology = c("BP", "CC", "MF"), species =  which.species)

# get all unique entrez
all.entrez <- unlist(unique(pathways.go))
all.hub <- unlist(hub.list)

gene.universe <- unique(rownames(w.mat))
gene.universe <- unique(g2e.list[gene.universe])
gene.universe <- gene.universe[gene.universe %in% all.entrez]

hub.universe <- unique(g2e.list[all.hub])
pathways.hub <- getAnnotationPathways(query.genes = hub.universe, db = c("GO"), ontology = c("BP", "CC", "MF"), species =  which.species)
hub.universe <- hub.universe[hub.universe %in% unlist(unique(pathways.hub))]

# res.h.list <- list()
# GOenrichmentAnalysis()

n.enrich <- 16
cl <- parallel::makeCluster(n.enrich)
doParallel::registerDoParallel(cl)

res.h.list <- list()
res.h.list <- foreach(i = 1:length(module.list.co), .packages = c("dplyr", "fgsea"))  %dopar% {
  # for (i in 1:length(module.list.co)){
  
  # warning(paste0("progress: ", round(100*i/length(module.list.co)), "%\n"))
  mod.name.current <- names(module.list.co)[i]
  
  current.genes <- module.list.co[[mod.name.current]]
  current.hub <- hub.list[[mod.name.current]]
  # current.genes <-  getTopTOM(w.mat, current.genes)
  
  current.genes <- unique(g2e.list[current.genes])
  current.genes <- current.genes[current.genes %in% gene.universe]
  current.hub <- unique(g2e.list[current.hub])
  current.hub <- current.hub[current.hub %in% hub.universe]
  
  # gene.universe2 <- c(gene.universe[!(gene.universe %in% current.genes)], current.hub)
  
  res.hyper <-  fora(pathways = pathways.go, genes = current.genes, universe = gene.universe, minSize = 1, maxSize = Inf)
  res.hub <-  fora(pathways = pathways.hub, genes = current.hub, universe = hub.universe, minSize = 1, maxSize = Inf)

  return(list(
    res.hyper = res.hyper,
    res.hub = res.hub
  ))
  
}

names(res.h.list) <- names(module.list.co)

stopCluster(cl)

results.co.p <- results.co.bh <- NULL
for (i in 1:length(res.h.list)){
  
  df.enrich.cur <- res.h.list[[i]]$res.hyper
  df.enrich.hub.cur <- res.h.list[[i]]$res.hub
  df.enrich.cur$module <- df.enrich.hub.cur$module <- names(res.h.list)[i]
  df.enrich.cur$which.module.genes <- "all"
  df.enrich.hub.cur$which.module.genes <- "hub"
  
  results.co.p <- bind_rows(results.co.p, (df.enrich.cur[df.enrich.cur$pval< 0.05]))
  results.co.p <- bind_rows(results.co.p, (df.enrich.hub.cur[df.enrich.hub.cur$pval< 0.05]))
  results.co.bh <- bind_rows(results.co.bh, (df.enrich.cur[df.enrich.cur$padj< 0.1]))
  results.co.bh <- bind_rows(results.co.bh, (df.enrich.hub.cur[df.enrich.hub.cur$padj< 0.1]))
}
# rm(res.h.list)

results.co.p <- cleanForaOutput(results.co.p, my.entrez = my.entrez)
results.co.bh <- cleanForaOutput(results.co.bh, my.entrez = my.entrez)


```


```{r geom split helper}

GeomSplitViolin <- ggproto(
  "GeomSplitViolin", 
  GeomViolin, 
  draw_group = function(self, data, ..., draw_quantiles = NULL) {
    data <- transform(data, 
                      xminv = x - violinwidth * (x - xmin), 
                      xmaxv = x + violinwidth * (xmax - x))
    grp <- data[1,'group']
    newdata <- plyr::arrange(
      transform(data, x = if(grp%%2==1) xminv else xmaxv), 
      if(grp%%2==1) y else -y
    )
    newdata <- rbind(newdata[1, ], newdata, newdata[nrow(newdata), ], newdata[1, ])
    newdata[c(1,nrow(newdata)-1,nrow(newdata)), 'x'] <- round(newdata[1, 'x']) 
    if (length(draw_quantiles) > 0 & !scales::zero_range(range(data$y))) {
      stopifnot(all(draw_quantiles >= 0), all(draw_quantiles <= 1))
      quantiles <- ggplot2:::create_quantile_segment_frame(data, draw_quantiles)
      aesthetics <- data[rep(1, nrow(quantiles)), setdiff(names(data), c("x", "y")), drop = FALSE]
      aesthetics$alpha <- rep(1, nrow(quantiles))
      both <- cbind(quantiles, aesthetics)
      quantile_grob <- GeomPath$draw_panel(both, ...)
      ggplot2:::ggname("geom_split_violin", 
                       grid::grobTree(GeomPolygon$draw_panel(newdata, ...), quantile_grob))
    } else {
      ggplot2:::ggname("geom_split_violin", GeomPolygon$draw_panel(newdata, ...))
    }
  }
)

geom_split_violin <- function (mapping = NULL, 
                               data = NULL, 
                               stat = "ydensity", 
                               position = "identity", ..., 
                               draw_quantiles = NULL, 
                               trim = TRUE, 
                               scale = "area", 
                               na.rm = FALSE, 
                               show.legend = NA, 
                               inherit.aes = TRUE) {
  layer(data = data, 
        mapping = mapping, 
        stat = stat, 
        geom = GeomSplitViolin, 
        position = position, 
        show.legend = show.legend, 
        inherit.aes = inherit.aes, 
        params = list(trim = trim, 
                      scale = scale, 
                      draw_quantiles = draw_quantiles, 
                      na.rm = na.rm, ...)
  )
}

```



```{r network graph}

library(igraph)

difNetworkGraph <- function(w.mat, w.1, w.2, module.genes, z.all, z.sub, connectivity.quantile = 0.9){
  
  # get tom matrices ###########################################################
  w.1.sub <- w.1[rownames(w.1) %in% module.genes, colnames(w.1) %in% module.genes]
  w.2.sub <- w.2[rownames(w.2) %in% module.genes, colnames(w.2) %in% module.genes]
  w.mat.sub <- w.mat[rownames(w.mat) %in% module.genes, colnames(w.mat) %in% module.genes]
  
  # get connectivity ###########################################################
  df.con <- getConnectivity(w.mat = w.mat.sub, gene.names = rownames(w.mat.sub))
  
  # preprocess #################################################################
  w.dif <- w.2.sub - w.1.sub
  w.graph <- igraph::graph_from_adjacency_matrix(adjmatrix = w.dif, mode = "undirected", diag = T, weighted = T)
  w.df.dif <- igraph::as_data_frame(w.graph)
  
  w.df.dif$delta.link <- w.df.dif$weight
  w.df.dif <- w.df.dif %>% dplyr::select(-c("weight"))
  
  # construct graph ############################################################
  diag(w.mat.sub) <- 0
  w.graph <- igraph::graph_from_adjacency_matrix(adjmatrix = w.mat.sub, mode = "undirected", diag = T, weighted = T)
  w.df.top <- igraph::as_data_frame(w.graph)
  
  gg.z <- z.all
  gg.z$name <- gg.z$genes
  gg.z <- merge(gg.z, df.con, by = "genes")
  
  gg.z$node.type <- "no.change"
  gg.z$node.type[gg.z$dif > 1.96] <- "up.regulated"
  gg.z$node.type[gg.z$dif < -1.96] <- "down.regulated"
  
  w.df.top <- merge(w.df.top, w.df.dif)
  sub.names <- unique(z.sub$genes, df.con$genes[df.con$label])
  w.df.top <- w.df.top[(w.df.top$from %in% sub.names) &  (w.df.top$to %in% sub.names), ]
  
  g.mat <- igraph::graph_from_data_frame(d = w.df.top, directed = F, vertices = gg.z)
  edge.thres <- quantile(E(g.mat)$weight, probs = connectivity.quantile, na.rm = T)
  g.mat <- igraph::delete_edges(g.mat, which(E(g.mat)$weight < edge.thres))
  
  # clean graph ################################################################
  if (length(sub.names) > 20){
  Isolated = which(igraph::degree(g.mat)==0)
  g.mat =igraph:: delete.vertices(g.mat, Isolated)    
  }

  # get scale limits 
  max.cor.dif <- signif(max(abs(w.df.top$delta.link), na.rm = T), 2)
  default.cor.dif.limit <- 0.2
  if (max.cor.dif > default.cor.dif.limit){
    default.cor.dif.limit <- max.cor.dif
  }
  
  # color palette 
  col.node <- c("up.regulated" = "tomato", 
                "no.change" = "grey80", 
                "down.regulated" =  "skyblue")
  # create plot ################################################################
  # alpha = scMiko::rescaleValues(weight, 0.3, 1)
  plt.graph <- g.mat %>%
    ggplot(aes(x = x, y = y, xend = xend, yend = yend)) +
    geom_edges(aes(color = delta.link, size = scMiko::rescaleValues(weight, 0.1, 1))) + 
    scale_colour_gradient2("Delta\nConnectivity",low = "skyblue", mid = "grey80", 
                           high = "tomato" , midpoint = 0,na.value = "transparent", limits = c(-default.cor.dif.limit, default.cor.dif.limit)) +
    new_scale("color") +
    geom_nodes(aes(fill = (node.type), size =  10*scMiko::rescaleValues(wi, 0.1, 1)), shape = 21, color = "grey60") +
    scale_fill_manual(name = "Delta\nExpression", values =col.node) +
    geom_nodetext(aes(label = name), size = 3) + scale_size_identity() +
    theme_blank() +  guides(alpha=FALSE) + 
    labs(caption = "node size = hub connectivity; linkage width = gene-gene connectivity")

  return(plt.graph)
}

```


```{r dash all, fig.height = 10, fig.width=18, warning = FALSE, message=FALSE}


# get matrices to visualize #####################################################
if (!exists("ag.mat")){
  ag.mat <- aggGroupExpression(
    so.query,
    which.data = "data",  which.assay = DefaultAssay(so.query),
    which.center = "mean",  which.group = "cg"
  )
}

if (!exists("sd.mat")){
  sd.mat <- aggGroupExpression(
    so.query,
    which.data = "data",  which.assay = DefaultAssay(so.query),
    which.center = "sd",   which.group = "cg"
  )
}

# scale similarity matrix
sn.1 <- s.1
sn.2 <- scaleTOM(query.TOM = s.2, reference.TOM = s.1, reference.percentile = 0.95)
# sn.1 <- s.1
# sn.2 <- s.2


ag.mat <- ag.mat[ag.mat$genes %in% rownames(a.mat), ]
sd.mat <- sd.mat[sd.mat$genes %in% rownames(a.mat), ]

z.mat <- ag.mat;
z.mat[ ,reference.group] <-z.mat[ ,reference.group]/ sd.mat[ ,reference.group]
z.mat[ ,comparison.group] <-z.mat[ ,comparison.group]/ sd.mat[ ,comparison.group]
z.mat$dif <- (ag.mat[ ,comparison.group] - ag.mat[ ,reference.group])/(sqrt((sd.mat[ ,comparison.group]^2)+(sd.mat[ ,reference.group]^2)))
z.mat$dif <- z.mat$dif / sd(z.mat$dif)
z.mat$avg.exp <- (ag.mat[ ,reference.group] + ag.mat[ ,comparison.group])/2

# get ME activity data #########################################################
df.ma <- df.ME.all.long.merge
df.ma$module <- gsub("ME", "", df.ma$name)

# get umap #####################################################################
df.umap <- data.frame(so.query@reductions[["umap"]]@cell.embeddings)
colnames(df.umap) <- c("x", "y")
df.umap$cells <- rownames(df.umap)
df.umap$cells <- gsub("\\.", "-", df.umap$cells)

plt.cluster.umap <- cluster.UMAP(so.query) + theme_miko(legend = T)

# get ME #######################################################################
df.me <- ME.all
colnames(df.me) <- gsub("ME", "", colnames(df.me))
module.names <- colnames(df.me)
df.me$cells <- rownames(df.me)
df.me$cells <- gsub("\\.", "-", df.me$cells)

# merge
df.umap <- merge(df.umap, df.me,by = "cells")

dash.list <- list()
for (i in 1:length(module.names)){
  # for (i in 1:10){
  
  if (module.names[i] == "grey") next
  
  n.genes <-sum(which.module.membership %in% module.names[i]) 
  
  # get top GO enrichements ####################################################
  results.co.p.cur <- results.co.p[results.co.p$module %in% module.names[i], ]
  results.co.p.cur <- (results.co.p.cur %>% dplyr::arrange(pval))[1:10, ]
  
  for (j in 1:nrow(results.co.p.cur)){
    if (!is.null(unlist(results.co.p.cur$set[j]))){
      current.gene.set <- gsub(" ", "", unlist(strsplit(unlist(results.co.p.cur$set[j]), ",")))
      if (length(current.gene.set) > 5){
        current.gene.set <- paste0(paste(current.gene.set[1:5], collapse = ", "), "...") 
      } else {
        current.gene.set <- paste(current.gene.set, collapse = ", ")
      }
      results.co.p.cur$set[j] <- current.gene.set      
    } else {
      results.co.p.cur$set[j] <- ""
    }
  }
  
  results.co.p.cur$hub.set <- "black"
  results.co.p.cur$hub.set[results.co.p.cur$which.module.genes %in% "hub"] <- "tomato"
  
  results.co.p.cur$path.trun <- stringr::str_trunc(results.co.p.cur$pathway, 40)
  results.co.p.cur$path.trun <- paste0(results.co.p.cur$path.trun, " (", results.co.p.cur$overlap, "/", results.co.p.cur$size, ")")
   results.co.p.cur$path.trun <- paste0( results.co.p.cur$path.trun,"\n",results.co.p.cur$set)
  results.co.p.cur <- results.co.p.cur[!is.na(results.co.p.cur$pathway), ]
  plt.module.go <- results.co.p.cur %>%
    ggplot(aes(x = -log10(pval), y = reorder(path.trun, -log1p(pval)), fill = -log1p(pval))) + 
    geom_bar(stat = "identity", color =  results.co.p.cur$hub.set) + 
    geom_point(aes(x = -log10(padj), y = reorder(path.trun, -log1p(pval)))) + 
    theme_miko(legend = T) + 
    viridis::scale_fill_viridis() + 
    geom_vline(xintercept = -log10(0.05), linetype = "dashed") +
     geom_vline(xintercept = -log10(0.2), linetype = "dashed", color = "grey") + ylab("") + 
    xlab("-log(p)") + labs(title = "Module Enrichment", subtitle = "GO Ontology", 
                           fill = "-log(p)", 
                           caption = "bar: p, dot: p adjusted.\nblack line: -log(0.05), grey line: -log(0.20).\nblack border = all genes; red border = hub genes.")
  
  
  # differential ME activity ###################################################
  df.ma.sub <- df.ma[df.ma$module %in% module.names[i], ]
  
  ref.mean <- mean(df.ma.sub$value[df.ma.sub$cluster.group %in% reference.group], na.rm = T)
  comp.mean <- mean(df.ma.sub$value[df.ma.sub$cluster.group %in% comparison.group], na.rm = T)
  
  df.ma.sum <- df.ma.sub %>%
    group_by(cluster.orig, cluster.group) %>%
    summarize(values = list(value))
  df.ma.sum.wide <- pivot_wider(df.ma.sum, names_from = cluster.group, values_from = values)
  
  df.ma.sum.wide$pval <- NA
  for (j in 1:nrow(df.ma.sum.wide)){
    val1 <- as.numeric(unlist(df.ma.sum.wide[j ,comparison.group]))
    val2 <- as.numeric(unlist(df.ma.sum.wide[j ,reference.group]))
    if ((length(val1) == 0) | (length(val2) == 0)) next
    df.ma.sum.wide$pval[j] <- wilcox.test(val1, val2)[["p.value"]]
  }
  
  df.ma.sum.wide$sig.lab <- ""
  df.ma.sum.wide$sig.lab[df.ma.sum.wide$pval < 0.05] <- "*"
  df.ma.sum.wide$sig.lab[df.ma.sum.wide$pval < 0.01] <- "**"
  df.ma.sum.wide$sig.lab[df.ma.sum.wide$pval < 0.001] <- "***"
  lab.position = -(max(df.ma.sub$value) * 0.05)
  
    
  # 
  ve.group.discrimination <- signif(model.anova$var.exp[model.anova$terms %in% module.names[i]] , 3) * 100
  p.group.discrimination <- signif(model.anova$padj[model.anova$terms %in% module.names[i]] , 3)
  
  df.ma.sub$cluster.group <- factor(df.ma.sub$cluster.group, levels = c(reference.group, comparison.group))
  plt.me.dif <- ggplot(df.ma.sub, aes(x = cluster.orig, y = value, fill = cluster.group))+
    geom_split_violin(trim = T, alpha = .5)+
    ggthemes::scale_fill_ptol() + 
    ylab("Eigenmodule Activity") + 
    geom_hline(yintercept = c(ref.mean, comp.mean),linetype = "dashed",  color =  c(ggthemes::ptol_pal()(2))) + 
    xlab("Cluster") + theme_miko(legend = T)  + 
    geom_text(data = df.ma.sum.wide, aes(x = cluster.orig, y = lab.position, label = sig.lab), inherit.aes = F) + 
    stat_summary(fun.y = mean, fun.ymin = mean, fun.ymax = mean,
                 geom = "crossbar",
                 width = 0.25,
                 position = position_dodge(width = .25)) + 
    labs(title = "EigenModule Activity", subtitle = paste0(reference.group , " vs. ", 
                                                           comparison.group, ", ",
                                                           ve.group.discrimination, "% variance explained, q = ", p.group.discrimination),
         fill = "Group", caption = "Dashed lines: Group means\nwilcoxon test: p<0.05*, p<0.01**, p<0.001***") 
  
  
  
  # expression heatmap #########################################################
  
  module.genes <- rownames(a.mat)[which.module.membership %in% module.names[i]]
  z.mat.sub <- z.mat[z.mat$genes %in%  module.genes, ]
  z.mat.all <- z.mat.sub
  z.mat.sub <- z.mat.sub %>% dplyr::arrange(-dif)

  
  n.all <- nrow(z.mat.sub)
  mean.z <- mean(z.mat.sub$dif, na.rm = T)
  if (nrow(z.mat.sub) > 60) {
    z.mat.sub <- bind_rows(
      (z.mat.sub %>% dplyr::filter(dif < 0) %>% dplyr::arrange(dif))[1:30, ],
      (z.mat.sub %>% dplyr::filter(dif > 0) %>% dplyr::arrange(-dif))[1:30, ]
    )
  }
  n.sub <- nrow(z.mat.sub)
  
  max.min <- min(z.mat.sub$dif, na.rm = T)
  max.max <- max(z.mat.sub$dif, na.rm = T)
  ribbon.range <- c(-1.96, 1.96)
  if (max.min > 0) ribbon.range[1] <- 0
  if (max.max < 0) ribbon.range[2] <- 0
  df.ribbon <- data.frame (xmin=ribbon.range[1], xmax=ribbon.range[2], ymin=-Inf, ymax=Inf)
  
  z.mat.sub$is.hub <- "black"
  z.mat.sub$is.hub[z.mat.sub$genes %in% hub.list[[module.names[i]]]] <- "tomato"
  
  
  
  plt.mod.gene.dif <- z.mat.sub %>%
    ggplot(aes(x = dif, y = reorder(genes, dif), fill = abs(dif))) + 
    geom_rect(data = df.ribbon, alpha=0.1, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax), inherit.aes = FALSE) + 
    geom_segment(aes(xend = 0, yend  = reorder(genes, dif)), color = z.mat.sub$is.hub) + 
    geom_point(pch=21, aes(size = abs(avg.exp))) + 
    theme_miko(legend = T) + 
    xlab("Delta Expression (z)") + ylab("") +
    labs(title = "Differential Expression", 
         subtitle = paste0(comparison.group, "-", reference.group, " (", n.sub, "/", n.all, " shown)"), fill = "|z|", size =  "Mean\nExpression",
         caption = "Dashed red line: mean(z)\nGrey area: p>0.05\nRed stem: hub gene") + 
    geom_vline(xintercept = 0) + 
    geom_vline(xintercept = mean.z, linetype = "dashed",color = "red") + 
    viridis::scale_fill_viridis(option ="B")   
  
  # network plot ###############################################################
  
  is.success <- F
  
  if (length(module.genes) < 6) {
    cq <- 0.5
  } else {
    cq <- 0.75
  }

  try({
  pltNet <- difNetworkGraph(w.co, sn.1, sn.2, module.genes = module.genes, z.all = z.mat.all, z.sub = z.mat.sub, connectivity.quantile = cq)
  pltNet <- pltNet + theme_void() + theme(legend.position="bottom", legend.box = "vertical") 
  is.success <- T
  }, silent = T)

  if (!is.success) pltNet <- NULL

  
  # UMAP #######################################################################
  plt.umap <-  df.umap %>%
    dplyr::arrange(get(module.names[i])) %>%
    ggplot(aes(x = x, y = y, color = get(module.names[i]))) + 
    geom_point(size = autoPointSize(nrow(df.umap))) + 
    viridis::scale_color_viridis(option = "B") + 
    theme_miko(legend = T) + 
    labs(title = module.names[i], color = "Activity", subtitle = paste0(n.genes, " genes")) + 
    xlab("UMAP 1") + ylab("UMAP 2")
  
  
  plt.left <- cowplot::plot_grid(plt.umap, plt.cluster.umap, ncol = 1, align = "v")
  plt.middle <- cowplot::plot_grid(plt.module.go, plt.me.dif, ncol = 1)
  plt.right <- plt.mod.gene.dif
  plt.rr <- pltNet
  # plt.rr <- cowplot::plot_grid(plt.hub, pltNet, ncol = 1, rel_heights = c(2,4))
  plt.all <- cowplot::plot_grid(plt.left, plt.middle, plt.right,plt.rr,  ncol = 4, rel_widths = c(1, 1.5, 1, 1), align = "hv")
  
  if (print.inline){
    print(plt.all)
    # dash.list
  }
  
  dash.list[[module.names[i]]] <- plt.all
}

dash.list <- dash.list[importance.order]

if (print.inline){
  print(plt.all)
  # dash.list[1:10]
}

  
```


```{r  compositional changes, fig.height = 8, fig.width=10}


df.meta <- so.query@meta.data
df.umap <- data.frame(so.query@reductions[["umap"]]@cell.embeddings); colnames(df.umap) <- c("x","y")
df.umap$group <- df.meta$group.query; df.umap$cluster <- df.meta$seurat_clusters

df.meta.comp <- df.meta %>%
  group_by(seurat_clusters, group.query) %>%
  tally()

df.meta.comp <- df.meta.comp %>%
  group_by(group.query) %>%
  mutate(f = n/sum(n))

df.meta.comp <- df.meta.comp %>%
  group_by(seurat_clusters) %>%
  mutate(f.norm = f/sum(f))



df.propr.test <- NULL
u.clust <- as.character(unique(df.meta.comp$seurat_clusters))
for (i in 1:length(u.clust)){
  
  df.meta.comp.cur <- df.meta.comp[df.meta.comp$seurat_clusters %in% u.clust[i], ]
  
  n.all <- sum(df.meta.comp.cur$n, na.rm = T)
  n1 <- df.meta.comp.cur$n[df.meta.comp.cur$group.query %in% reference.group]
  n2 <- df.meta.comp.cur$n[df.meta.comp.cur$group.query %in% comparison.group]
  
  if (length(n1) == 0) n1 <- df.meta.comp.cur$n[df.meta.comp.cur$group.query %in% reference.group] <- 0
  if (length(n2) == 0) n2 <- df.meta.comp.cur$n[df.meta.comp.cur$group.query %in% comparison.group] <- 0

  p1 <- df.meta.comp.cur$f.norm[df.meta.comp.cur$group.query %in% reference.group]
  p2 <- df.meta.comp.cur$f.norm[df.meta.comp.cur$group.query %in% comparison.group]
  
 if (length(p1) == 0) p1 <- df.meta.comp.cur$f.norm[df.meta.comp.cur$group.query %in% reference.group] <- 0
  if (length(p2) == 0) p2 <- df.meta.comp.cur$f.norm[df.meta.comp.cur$group.query %in% comparison.group] <- 0
  
  f1 <- n1/(n1+n2)
f2 <- n2/(n1+n2)
  
  s1 <- sqrt(p1*(1-p1)/n.all)
  s2 <- sqrt(p2*(1-p2)/n.all)
  sp <- sqrt((s1^2) + (s2^2))
  z <- (p1-p2)/sp
  pval <- signif(2*pnorm(-abs(z)), 3)

  df.propr.test <- bind_rows(df.propr.test, 
                             data.frame(
                               cluster = u.clust[i],
                               n1 = n1,
                               n2 = n2,
                               f1 = f1, 
                               f2 = f2,
                               n.all = n.all,
                               prop1 = p1,
                               prop2 = p2,
                               prop.dif = p2 - p1,
                               z = z,
                               p = pval
                             ))
  
}

df.propr.test$q <- p.adjust(df.propr.test$p, method = "BH")
df.propr.test$sig <- ""
df.propr.test$sig[df.propr.test$q < 0.05] <- "*"
df.propr.test$sig[df.propr.test$q < 0.01] <- "**"
df.propr.test$sig[df.propr.test$q < 0.001] <- "***"

df.umap <- merge(df.umap, df.propr.test, by = "cluster")


plt.bar.comp <- df.meta.comp %>%
  ggplot(aes(x = seurat_clusters, y = f.norm, fill = group.query)) + 
  geom_bar(stat = "identity") + 
  ggthemes::scale_fill_ptol() + 
  theme_miko(legend = T) + 
  xlab("Cluster") + ylab("Relative Contribution") + 
  labs(fill = "Group") + 
  geom_hline(yintercept = 0.5, linetype = "dashed") + 
  geom_text(data = df.propr.test, aes(x = cluster, y = -0.05, label = sig), inherit.aes = F) + 
  geom_text(data = df.propr.test, aes(x = cluster, y = 0.95, label = signif(prop1, 2)), size = 2, inherit.aes = F) + 
  geom_text(data = df.propr.test, aes(x = cluster, y = 0.05, label = signif(prop2, 2)), size = 2, inherit.aes = F)  + 
  labs(title = "Relative Composition", subtitle = paste0(reference.group , " vs. ", comparison.group))

df.propr.test$is.sig <- "grey"
df.propr.test$is.sig[df.propr.test$q < 0.05] <- "pink"
df.propr.test$dif.rank <- rank(df.propr.test$prop.dif)
df.propr.test <- df.propr.test %>% dplyr::arrange(dif.rank)

low.high.threshold <- 0.25
df.r1 <- data.frame(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = -low.high.threshold)
df.r2 <- data.frame(xmin = -Inf, xmax = Inf, ymin = -low.high.threshold, ymax = low.high.threshold)
df.r3 <- data.frame(xmin = -Inf, xmax = Inf, ymin = low.high.threshold, ymax = Inf)
plt.dot.comp <- df.propr.test %>%
  ggplot(aes(x = dif.rank, y = prop.dif, label = cluster)) + 
  geom_rect(data = df.r1, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), inherit.aes = F, fill = scales::muted("blue"), alpha = 0.2) + 
  geom_rect(data = df.r2, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), inherit.aes = F, fill = "grey", alpha = 0.2) + 
  geom_rect(data = df.r3, aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), inherit.aes = F, fill = scales::muted("red"), alpha = 0.2) + 
  geom_point(size = 5, shape = 21,  aes(fill =prop.dif)) + 
  geom_text(size = 2) + 
  geom_hline(yintercept = c(0), linetype = "dashed") + 
  theme_miko(legend = T) + 
  scale_fill_gradient2( low = scales::muted("blue"), mid = "grey90", high = scales::muted("red")) + 
  labs(title = "Differences", subtitle = paste0("Red: ", comparison.group , " > ", reference.group, "; Blue: ", reference.group , " > ", comparison.group), fill =  "Composition\nChange") + 
  ylab(paste0("Composition Difference (", comparison.group,  "-", reference.group, ")")) + 
  xlab("Rank") 


# scDC 

plt.umap.comp1 <- cluster.UMAP(so.query) + theme_miko(legend = F) + labs(title = "UMAP", subtitle = "stratified by clusters")



plt.umap.comp2 <- df.umap %>%
  ggplot(aes(x = x, y = y, color = prop.dif)) + 
  geom_point(size = autoPointSize(nrow(df.umap))) + 
  scale_color_gradient2( low = scales::muted("blue"), mid = "grey90", high = scales::muted("red")) + 
  theme_miko(legend = T) + labs(title = "UMAP", subtitle = paste0("Red: ", comparison.group , " > ", reference.group, "; Blue: ", reference.group , " > ", comparison.group), color = "Composition\nChange") + 
  xlab("UMAP 1") + ylab("UMAP 2")


p1.comp <- cowplot::plot_grid(plt.umap.comp1, plt.umap.comp2, ncol = 2, rel_widths = c(0.85, 1), align = "h")
p2.comp <- cowplot::plot_grid(plt.bar.comp, plt.dot.comp, ncol = 2, rel_widths = c(2,1), align = "h")

plt.compositional.analysis <- cowplot::plot_grid(p1.comp, p2.comp, ncol = 1, align = "hv")

if (print.inline){
  print(plt.compositional.analysis)
}

```




```{r prep ma data,  fig.width = 12, fig.height = 8}

df.ma.sum2 <- df.ma %>%
  group_by(cluster.group, cluster.orig, module) %>%
  summarize(x = mean(value))
colnames(df.ma.sum2) <- c("group", "cluster", "module", "x")

df.ma.sum2 <- merge(df.ma.sum2, df.propr.test, by = "cluster")

colnames(df.meta.comp) <- c("cluster", "group", "n", "f", "f.norm")
df.ma.sum3 <- merge(df.ma.sum2, df.meta.comp, by = c("cluster", "group"))

df.ma.sum3$pgroup <- "constant"
df.ma.sum3$pgroup[df.ma.sum3$prop.dif > low.high.threshold] <- "up"
df.ma.sum3$pgroup[df.ma.sum3$prop.dif < -low.high.threshold] <- "down"
df.ma.sum3$pgroup <- factor(df.ma.sum3$pgroup, levels = c("down", "constant", "up"))
df.ma.sum3$module <- factor(df.ma.sum3$module, levels = c(importance.order))

# df.ma.sum3 %>%
#   ggplot(aes(x = group, y = x, fill = pgroup)) + 
#   geom_boxplot() + 
#    theme_miko(legend = T) + facet_wrap(~module, scales = "free_y")


# df.ma.sum3 %>%
#   dplyr::filter(group == comparison.group) %>%
#   ggplot(aes(x = x, y = prop.dif)) + 
#     geom_smooth() + 
#   geom_text(aes(label = cluster)) + 
#    theme_miko(legend = T) + facet_wrap(~module, scales = "free")

# aes(color = group, fill  = group)
# colnames(df.ma.sum3)
```


```{r prep glmnet data}

df.ma.slim <- df.ma.sum3[ ,c("cluster","group", "module","x", "prop.dif", "pgroup", "n.all")]

df.ma1 <- df.ma.slim[df.ma.slim$group %in% reference.group, ]
df.ma2 <- df.ma.slim[df.ma.slim$group %in% comparison.group, ]
colnames(df.ma1) <- c("cluster","group1", "module","x1", "prop.dif", "pgroup", "n")
colnames(df.ma2) <- c("cluster","group2", "module","x2", "prop.dif", "pgroup", "n")

df.ma.merge <- merge(df.ma1, df.ma2, by = c("cluster","module", "prop.dif", "pgroup", "n"))
df.ma.merge$x.dif <- df.ma.merge$x2 - df.ma.merge$x1

df.ma.merge1 <- df.ma.merge[ ,c("cluster", "module","n", "x1", "prop.dif")]
df.ma.merge1$module <- paste0(df.ma.merge1$module, ".ACT")
df.ma.merge1.wide <- pivot_wider(df.ma.merge1, names_from = "module", values_from = "x1")

df.ma.merge2 <- df.ma.merge[ ,c("cluster", "module","n", "x.dif", "prop.dif")]
df.ma.merge2$module <- paste0(df.ma.merge2$module, ".DIF")
df.ma.merge2.wide <- pivot_wider(df.ma.merge2, names_from = "module", values_from = "x.dif")

df.ma.merge.f <- df.ma.merge1.wide

dmmf.weights <- df.ma.merge.f$n
dmmf.y <- df.ma.merge.f$prop.dif
df.ma.merge.f <- df.ma.merge.f %>% dplyr::select(-c("n", "prop.dif", "cluster"))
df.ma.merge.f$y <- dmmf.y


```


```{r glmnet helpder function}



glmnetPlots <- function(dfmms, which.s, m.weights, d.weights){
  
  fit = glmnet(x = as.matrix(dfmms %>% dplyr::select(-c("y"))), 
               y = dfmms$y, 
               weights = m.weights, 
               lambda=which.s)
  
  # get model coefficients #######################################################
  coef.names <- rownames(coef(fit, s = which.s, exact = FALSE))
  coef.apprx = as.numeric(coef(fit, s = which.s, exact = FALSE))
  sig.coef <- coef.names[which((coef.apprx > 0) | (coef.apprx < 0))]
  sig.coef <- sig.coef[sig.coef != "(Intercept)"]
  
  glm.model <- stats::glm(y ~  . , data = dfmms[ ,c(sig.coef, "y")],
                          family = gaussian, weights = d.weights)

  # Module predictions ###########################################################
  df.res <- data.frame(x = dfmms$y, 
                       y.net = predict(fit, as.matrix(dfmms %>% dplyr::select(-y)), s = which.s), 
                       weight = d.weights)
  colnames(df.res) <- c("x",  "y.net", "weight")
  
  plt.model.performance <- df.res %>%
    ggplot() + 
    geom_smooth(aes(x = x, y = y.net), method = "lm", color = scales::muted("red")) +
    geom_point(aes(x = x, y = y.net, size = weight), color = scales::muted("red")) + 
    geom_abline(slope = 1) + theme_miko(legend = T) + 
    xlab("Observed") + ylab("Predicted") + 
    labs(title = "Model Performance", subtitle = "Compositional Differences", size = "N Cells")
  
  plt.model.coef <- sjPlot::plot_model(glm.model, colors = "gs") +
    xlab("Model Coefficients") + ylab("Coefficient Name") + labs(title = "Model Coefficients", subtitle = "Compositional Differences") +
    theme_miko(legend = T) + geom_hline(yintercept = 0, linetype = "dashed")
  
  plt.cv.fit <- df.cv.fit %>%
    ggplot(aes(x = log(lambda), y = cv)) + 
    geom_point() + 
    xlab("log(Lambda)") + 
    ylab("Error, MSE") + 
    labs(title = "Lambda Optimization", subtitle = paste0("GLMnet cross-validation; lambda = ", signif(which.s, 3))) + 
    theme_miko(legend = T) + 
    geom_vline(xintercept = log(which.s))
  
  
  plt.mod.perform.sum <- cowplot::plot_grid(plt.cv.fit, plt.model.performance, plt.model.coef, ncol = 3)
  
  return(plt.mod.perform.sum)
  
}

```

```{r glmnet regression, fig.width = 12, fig.height = 4, warning = FALSE, message  = FALSE, include = FALSE}

# 
# cl <- parallel::makeCluster(12)
# doParallel::registerDoParallel(cl)
# 
# df.ma.merge.scaled <- as.data.frame(apply(df.ma.merge.f, 2, function(x) scale(x)))
# 
# # cross-validation #############################################################
# model.weights <- NULL; # dmmf.weights
# cvfit = cv.glmnet(x = as.matrix(df.ma.merge.scaled %>% dplyr::select(-c("y"))), 
#                   y = df.ma.merge.scaled$y, 
#                   weights = model.weights , #dmmf.weights
#                   type.measure = "default", 
#                   parallel = T,
#                   relax = F,
#                   lambda = exp(seq(-10, 0, by = 0.2)),
#                   nfolds = 100)
# 
# # stop workers
# parallel::stopCluster(cl)
# 
# df.cv.fit <- data.frame(
#   lambda = cvfit[["lambda"]], 
#   cv = cvfit[["cvm"]],
#   cv.up = cvfit[["cvup"]],
#   cv.down = cvfit[["cvlo"]]
# )
# 
# # fit glmnet model #############################################################
# which.s1 <- df.cv.fit$lambda[which.min((df.cv.fit$cv))]
# 
# min.cv <- min(df.cv.fit$cv)
# max.cv <- max(df.cv.fit$cv)
# cv.threshold <- min.cv + ((max.cv - min.cv)/10)
# which.s2 <- df.cv.fit$lambda[which.min(abs(df.cv.fit$cv - cv.threshold))]
# 
# 
# which.s3 <- cvfit[["lambda.1se"]]

plt.mod.perform.sum1 <- plt.mod.perform.sum2 <- plt.mod.perform.sum3 <- plt.mod.perform.sum4 <- plt.mod.perform.sum5 <- NULL

try({
  plt.mod.perform.sum1 <- glmnetPlots(dfmms = df.ma.merge.scaled, which.s =  which.s1, m.weights = model.weights, d.weights = dmmf.weights)
}, silent = T)
try({
  plt.mod.perform.sum2 <- glmnetPlots(dfmms = df.ma.merge.scaled,which.s = which.s2, m.weights = model.weights, d.weights = dmmf.weights)
}, silent = T)
try({
  plt.mod.perform.sum3 <- glmnetPlots(dfmms = df.ma.merge.scaled,which.s = exp(-6), m.weights = model.weights, d.weights = dmmf.weights)
}, silent = T)
try({
  plt.mod.perform.sum4 <- glmnetPlots(dfmms = df.ma.merge.scaled,which.s = exp(-10), m.weights = model.weights, d.weights = dmmf.weights)
}, silent = T)

try({
  plt.mod.perform.sum5 <- glmnetPlots(dfmms = df.ma.merge.scaled,which.s = which.s3, m.weights = model.weights, d.weights = dmmf.weights)
}, silent = T)

if (print.inline){
  print(plt.mod.perform.sum1)
  print(plt.mod.perform.sum2)
  print(plt.mod.perform.sum3)
  print(plt.mod.perform.sum4)
  print(plt.mod.perform.sum5)
}

```


```{r}

# deg.genes.pool <- unique(c(rownames(df.deg.pool), rownames(a.mat)))
# 
# # ag.mat
# ag.mat.clust <- aggGroupExpression(
#   so.query,
#   which.data = "data",
#   which.assay = DefaultAssay(so.query),
#   which.center = "mean",
#   which.group = "seurat_clusters",
#   do.parallel = F
# )
# 
# ag.mc.sub <- ag.mat.clust[ag.mat.clust$genes %in% deg.genes.pool, ]
# rownames(ag.mc.sub) <- ag.mat.clust$genes
# ag.mc.sub <- ag.mc.sub %>% dplyr::select(-c("genes")) 
# ag.mc.sub.t <- t(ag.mc.sub)
# ag.mc.sub.t$cluster <- as.numeric(gsub("c", "", rownames(ag.mc.sub.t)))
# 
# ag.mc.sub.t.merge <- merge(ag.mc.sub.t, df.propr.test, by = "cluster")

```


```{r get module genes}

module.list.co <- getModuleGenes(modules.cob, SubGeneNames, add.prefix = F)
module.list.all <- getModuleGenes(modules.all, SubGeneNames, add.prefix = F)

module.df.co <- namedList2wideDF(module.list.co)
module.df.all <- namedList2wideDF(module.list.all)

```


```{r connectivity, fig.width=10, fig.height=4}
# get connectivity
df.con <- getConnectivity(w.co, gene.names = colnames(a.mat))

# get connectivity scores
df.con.1 <- getConnectivity(w.1, rownames(a.1))
df.con.2 <- getConnectivity(w.2, rownames(a.2))

df.deg.pool$genes <- rownames(df.deg.pool)
df.con.merge <- merge(df.con.1, df.con.2, by = "genes")
df.con.deg <- merge(df.deg.pool, df.con, by = "genes")
df.delta.con.deg <- merge(df.deg.pool, df.con.merge, by = "genes")

df.delta.con.deg$wi.x.norm <- df.delta.con.deg$wi.x
df.delta.con.deg$wi.y.norm <- df.delta.con.deg$wi.y
df.delta.con.deg$delta.rank <- df.delta.con.deg$wi.y.norm - df.delta.con.deg$wi.x.norm

df.delta.con.deg$composite.score <- (((df.delta.con.deg$avg_log2FC - mean(df.delta.con.deg$avg_log2FC)) / sd(df.delta.con.deg$avg_log2FC))  + ((df.delta.con.deg$delta.rank - mean(df.delta.con.deg$delta.rank)) / sd(df.delta.con.deg$delta.rank))) / 2
rank.limit <- max(c(abs(min(df.delta.con.deg$composite.score)), abs(max(df.delta.con.deg$composite.score))))

label.top.n <-15
top.delta <- c(top_n(df.delta.con.deg, label.top.n, avg_log2FC)$genes,
               top_n(df.delta.con.deg, label.top.n, -avg_log2FC)$genes,
               top_n(df.delta.con.deg, label.top.n, delta.rank)$genes,
               top_n(df.delta.con.deg, label.top.n, -delta.rank)$genes,
               top_n(df.con.deg, label.top.n, wi)$genes)
top.delta <- unique(top.delta)

plt.2 <- df.delta.con.deg %>%
  ggplot(aes(x = avg_log2FC, y = delta.rank,color = composite.score,  size = -log1p(p_val_adj) * 0.5, text = genes)) +
  geom_point(alpha = 0.5) +
  xlab("log FC") +
  ylab(paste0("Delta Rank Connectivity (", comparison.group, "-", reference.group, ")")) +
  geom_vline(xintercept = 0 , linetype = "dashed") +
  geom_hline(yintercept = 0 , linetype = "dashed") +
  labs(title = "DEG vs. Connectivity", subtitle = "CS = mean(standardized delta node & link)", size = "-log(p)") +
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")") ) +
  theme_classic() +
  scale_colour_gradientn("CS", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.delta.con.deg$composite.score), 0, max(df.delta.con.deg$composite.score))))) +
  ggrepel::geom_text_repel(aes(avg_log2FC, delta.rank,
                               label =ifelse(genes %in% top.delta ,as.character(genes),'')), size = 2.5, color = "black") 


df.delta.con.deg$mean.rank <- (df.delta.con.deg$wi.x.norm + df.delta.con.deg$wi.y.norm)/2

# df.con.deg$logp <- 
plt.3 <- df.con.deg %>%
  ggplot(aes(x = avg_log2FC, y = rank(wi) ,color =avg_log2FC, size = -log1p(p_val_adj) , text = genes)) +
  geom_point(alpha = 0.5) +
  ylab("Connectivity Rank") +
  theme_classic() +
  geom_vline(xintercept = 0 , linetype = "dashed") +
  labs(title = "DEG Rank Plot", subtitle = "Ranked by Network Connectivity", size = "-log(p)") + 
  xlab(paste0("logFC (", comparison.group, "-", reference.group, ")")) +
  ggrepel::geom_text_repel(aes(avg_log2FC, rank(wi), label =ifelse(genes %in% top.delta ,as.character(genes),'')), size = 2.5, color = "black") +
  scale_colour_gradientn("logFC", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(df.con.deg$avg_log2FC), 0, max(df.con.deg$avg_log2FC)))))

df.delta.con.deg$top.connect <- F
df.delta.con.deg$top.connect[df.delta.con.deg$mean.rank >  nrow(df.delta.con.deg)-20] <- T
df.delta.con.deg$sig.flag <- F
df.delta.con.deg$sig.flag[df.delta.con.deg$delta.rank >  1.96*sd(df.delta.con.deg$delta.rank)] <- T
df.delta.con.deg$sig.flag[df.delta.con.deg$delta.rank < -1.96*sd(df.delta.con.deg$delta.rank)] <- T

if (print.inline){
  cowplot::plot_grid(plt.2, plt.3, ncol = 2)
}

```


```{r connectivity and expression overview, fig.width=10, fig.height=4}

# Distribution of connectivities
plt.overview.1 <- df.delta.con.deg %>%
  ggplot() + 
  geom_density(aes(wi.x), alpha = 0.5, fill = "skyblue") + 
  geom_density(aes(wi.y), alpha = 0.5, fill = "tomato") + 
  theme_classic() + 
  xlab("Quantile Normalized Connectivity, wi") + 
  labs(title = ("Network Connectivity Distribution"), subtitle = paste0(reference.group, " (blue) vs. ", comparison.group, " (red)\np=", signif(wilcox.test(df.delta.con.deg$wi.x, df.delta.con.deg$wi.y)[["p.value"]], 3)))



# Distribution of expression differences
plt.overview.2 <- df.delta.con.deg %>%
  ggplot() + 
  geom_density(aes(avg_log2FC, fill = "logFC"), alpha = 0.5) + 
  geom_density(aes(pct.1 - pct.2, fill = "deltaFraction"), alpha = 0.5) + 
  theme_classic() + 
  xlab(paste0("logFC (", comparison.group , "-", reference.group , ")")) + 
  geom_vline(xintercept= 0, linetype = "dashed") +    
  scale_fill_manual("", 
                    breaks = c("logFC", "deltaFraction"),
                    values = c("logFC"="black", "deltaFraction"="grey")) + 
  labs(title = ("Expression Difference Distribution"), subtitle = paste0(comparison.group, "-", reference.group))

if (print.inline){
  cowplot::plot_grid(plt.overview.1, plt.overview.2, ncol = 2)
}
```

```{r delta node enrichment, fig.height = 8, fig.width=10}

# Connections DEG ##############################################################
x.w1 <- getConnectivity(w.1, gene.names = colnames(a.1))$wi
y.w2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.con.deg.cur <- data.frame(genes = colnames(a.1), w.ref = x.w1, w.comp  = y.w2, dif = y.w2-x.w1)
if (is.null(df.con.deg.cur)) next
df.con.deg.cur <- df.con.deg.cur[complete.cases(df.con.deg.cur),]

# prep gene list (match to EntrezID, sort)
gene.list <- df.con.deg.cur$dif
names(gene.list) <- df.con.deg.cur$genes
match.ind <- match(names(gene.list), my.entrez$SYMBOL)
names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
gene.list = sort(gene.list, decreasing = TRUE)

# clean list
df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
df.ent <- df.ent[complete.cases(df.ent), ]
df.ent <- df.ent[!is.infinite(df.ent$values), ]
gene.list.clean <- df.ent$values
names(gene.list.clean) <- df.ent$names

# pathway gsea enrichment
gse.deg.wiRank.pathway <- fgsea::fgsea(pathways.go, gene.list.clean, nperm=1000, maxSize=500)

if (nrow(gse.deg.wiRank.pathway) == 0) next

gse.deg.wiRank.pathway$cluster <- "all"

gse.pathway.degWi <- gse.deg.wiRank.pathway
gse.pathway.degWi[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.degWi[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.degWi.all <- gse.pathway.degWi[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]

# Expression DEG ##############################################################

x.e1 <- dif.mat[ ,reference.group]; y.e2 <- dif.mat[ ,comparison.group]
# y.e2 <- getConnectivity(w.2, gene.names = colnames(a.2))$wi
df.exp.deg.cur <- data.frame(genes = dif.mat$gene, e.ref = x.e1, e.comp  = y.e2, dif = y.e2-x.e1)
if (is.null(df.exp.deg.cur)) next
df.exp.deg.cur <- df.exp.deg.cur[complete.cases(df.exp.deg.cur),]

# prep gene list (match to EntrezID, sort)
gene.list <- df.exp.deg.cur$dif
names(gene.list) <- df.exp.deg.cur$genes
match.ind <- match(names(gene.list), my.entrez$SYMBOL)
names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
gene.list = sort(gene.list, decreasing = TRUE)

# clean list
df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
df.ent <- df.ent[complete.cases(df.ent), ]
df.ent <- df.ent[!is.infinite(df.ent$values), ]
gene.list.clean <- df.ent$values
names(gene.list.clean) <- df.ent$names

# pathway gsea enrichment
gse.deg.expRank.pathway <- fgsea::fgsea(pathways.go, gene.list.clean, nperm=1000, maxSize=500)

if (nrow(gse.deg.expRank.pathway) == 0) next

gse.deg.expRank.pathway$cluster <- "all"

gse.pathway.degExp <- gse.deg.expRank.pathway

gse.pathway.degExp[ ,c("ES","NES", "pval", "padj")] <- signif(gse.pathway.degExp[ ,c("ES","NES", "pval", "padj")], 3)
gse.pathway.degExp.all <- gse.pathway.degExp[ ,c("cluster", "pathway", "ES","NES", "pval", "padj", "nMoreExtreme", "size")]

# Merge and Plot ##############################################################

gsea.deg.merge <- merge(gse.pathway.degExp.all, gse.pathway.degWi.all, by = "pathway")
gsea.deg.merge$NES.mean <- (gsea.deg.merge$NES.x + gsea.deg.merge$NES.y)/2
gsea.deg.merge$NES.dif <- (gsea.deg.merge$NES.x - gsea.deg.merge$NES.y)
gsea.deg.merge$p.mean <- (gsea.deg.merge$pval.x + gsea.deg.merge$pval.y)/2

# plot top enrichments (bar plot)
top.n.enrich <- 10
gsea.degWi.sig.top <- bind_rows(top_n(gsea.deg.merge, top.n.enrich, NES.mean),
                                top_n(gsea.deg.merge, top.n.enrich, -NES.mean)) 


top.n.enrich.merge<- 5
gsea.deg.merge.topMean <- bind_rows(top_n(gsea.deg.merge, top.n.enrich.merge, NES.mean),
                                    top_n(gsea.deg.merge, top.n.enrich.merge, -NES.mean)) 
gsea.deg.merge.topDif <- bind_rows(top_n(gsea.deg.merge, top.n.enrich.merge, NES.dif),
                                   top_n(gsea.deg.merge, top.n.enrich.merge, -NES.dif)) 


# compare enrichment based on differen ranking schemes
gsea.deg.merge$label <- F
gsea.deg.merge$label[gsea.deg.merge$pathway %in% gsea.deg.merge.topMean$pathway] <- T
gsea.deg.merge$label[gsea.deg.merge$pathway %in% gsea.deg.merge.topDif$pathway] <- T

plt.gsea.comp <- gsea.deg.merge %>%
  ggplot(aes(x = NES.x, y = NES.y, color = (NES.mean), size = 1/abs(NES.dif), text = pathway)) + 
  geom_point() + 
  xlab(paste0("GSEA score (differential expression)\n", comparison.group, "-", reference.group)) + 
  ylab(paste0("GSEA score (differential connectivity)\n", comparison.group, "-", reference.group)) + 
  theme_classic() + 
  geom_hline(yintercept = 0) + 
  geom_vline(xintercept = 0) + 
  ggrepel::geom_text_repel(aes(NES.x, NES.y, label =ifelse(label ,as.character(pathway),'')), size = 2.5, color = "black") +
  labs(title = "Delta Node Enrichment", subtitle = "DEG vs Connectivity-based Ranking") + 
  scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(gsea.deg.merge$NES.mean), 0, max(gsea.deg.merge$NES.mean))))) + 
  theme_miko(legend = T)

if (print.inline){
  print(plt.gsea.comp)
}



```

```{r, fig.width=10, fig.height=10}

top.n.terms <- 5
df.top.link <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.x > 0) %>% dplyr::arrange(pval.x))[1:top.n.terms],
                         (gsea.deg.merge %>% dplyr::filter(NES.x < 0) %>% dplyr::arrange(pval.x))[1:top.n.terms])

df.top.node <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.y > 0) %>% dplyr::arrange(pval.y))[1:top.n.terms],
                         (gsea.deg.merge %>% dplyr::filter(NES.y < 0) %>% dplyr::arrange(pval.y))[1:top.n.terms])

df.top.net <- bind_rows((gsea.deg.merge %>% dplyr::filter(NES.mean > 0) %>% dplyr::arrange(p.mean))[1:top.n.terms],
                        (gsea.deg.merge %>% dplyr::filter(NES.mean < 0) %>% dplyr::arrange(p.mean))[1:top.n.terms])

df.top.all <- bind_rows(df.top.link, df.top.node, df.top.net)


plt.e.node.linkage <- df.top.net %>%
  ggplot(aes(x = reorder(pathway,NES.mean),  y = NES.mean, fill = -log10(p.mean))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment (Consensus)\nNode + Linkage Scores") + 
  xlab("") + 
  ylab(paste0("Consensus GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

plt.e.node <- df.top.node %>%
  ggplot(aes(x = reorder(pathway,NES.y),  y = NES.y, fill = -log10(pval.y))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment\nNode Scores") + 
  xlab("") + 
  ylab(paste0("Node GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

plt.e.linkage <- df.top.link %>%
  ggplot(aes(x = reorder(pathway,NES.x),  y = NES.x, fill = -log10(pval.x))) + 
  geom_bar(stat = "identity") + coord_flip() + 
  ggtitle("GSEA Enrichment\nLinkage Scores") + 
  xlab("") + 
  ylab(paste0("Linkage GSEA Score\n", comparison.group, "-", reference.group)) + 
  theme_classic()

if (print.inline){
  # fig.height=10, fig.width=10
  cowplot::plot_grid(plt.e.node.linkage, plt.e.node, plt.e.linkage, ncol = 1, align = "v")
}

```


```{r network-level gsea, fig.width=8, fig.height=7}


gsea.pathway.dot <- unique(df.top.all[ ,c("pathway", "NES.x", "NES.y", "NES.mean", "pval.x", "pval.y", "p.mean")])
gsea.pathway.dot <- gsea.pathway.dot %>% dplyr::arrange(NES.mean)
gsea.pathway.dot$rank.pool <- seq(1, nrow(gsea.pathway.dot))
ordered.path.names <- as.character(gsea.pathway.dot$pathway)

gpd.long.n <- pivot_longer(gsea.pathway.dot, cols = c("NES.x", "NES.y", "NES.mean"))
gpd.long.n$name[gpd.long.n$name %in% "NES.x"] <- "Link"
gpd.long.n$name[gpd.long.n$name %in% "NES.y"] <- "Node"
gpd.long.n$name[gpd.long.n$name %in% "NES.mean"] <- "Node+Link"
gpd.long.p <- pivot_longer(gsea.pathway.dot, cols = c("pval.x", "pval.y", "p.mean"))
gpd.long.p$name[gpd.long.p$name %in% "pval.x"] <- "Link"
gpd.long.p$name[gpd.long.p$name %in% "pval.y"] <- "Node"
gpd.long.p$name[gpd.long.p$name %in% "p.mean"] <- "Node+Link"

gpd.long.merge <- merge(gpd.long.n, gpd.long.p, by = c("pathway", "name"))

gpd.long.merge$name <- factor(gpd.long.merge$name, levels = c("Node", "Link", "Node+Link"))
gpd.long.merge$pathway <- factor(gpd.long.merge$pathway, levels =ordered.path.names)
plt.gsea.dot <- gpd.long.merge %>%
  # filter(pathway %in% top.path, type %in% c("node", "link", "pool")) %>%
  ggplot(aes(x = name, y =pathway, color = value.x, size = -log10(value.y))) + 
  geom_point()  + 
  scale_colour_gradientn("NES", colours=c("skyblue", "grey90", "tomato"),na.value = "transparent",
                         values=c(rescaleValues(c(min(gpd.long.merge$value.x), 0, max(gpd.long.merge$value.x))))) +
  labs(title = ("Differential Network Enrichment (GSEA)"), subtitle = paste0(comparison.group, " (red) - ", reference.group, " (blue)"),
       size = "-log(p)") +
  theme_miko(legend = T) +
  ylab("") +  xlab("Network Feature") 


# print plot
if (print.inline){
  print(plt.gsea.dot)
}
```



```{r heatmap top deg}

# get expression matrix
exp.mat.all <- getExpressionMatrix(so.query, which.data = which.data, only.variable = T)

# map cell id to group
df.idMap <- data.frame(group = so.query@meta.data[["group.query"]], cell.id = colnames(so.query))
u.group <- as.character(unique(df.idMap$group))
idMap.list <- list()
for (i in 1:length(u.group)) idMap.list[[u.group[i]]] <- as.character(df.idMap$cell.id[df.idMap$group == u.group[i]])

# downsample expression matrix 
max.cell.per.group <- 100
sample.ind.1 <- sample(idMap.list[[reference.group]], max.cell.per.group, replace = F)
sample.ind.2 <- sample(idMap.list[[comparison.group]], max.cell.per.group, replace = F)
sample.ind <- c(sample.ind.1, sample.ind.2)
exp.mat.sub <- exp.mat.all[ ,sample.ind]

# get DEG genes
top.n.deg <- 30
df.deg.enr <- df.deg.pool
df.deg.enr$genes <- rownames(df.deg.enr)
deg.top <- top_n(df.deg.enr, top.n.deg, (avg_log2FC))$genes
deg.bottom <- top_n(df.deg.enr, top.n.deg, -(avg_log2FC))$genes
deg.genes <- c(deg.top, deg.bottom)


# get DCG genes
top.n.hub <- 60
hub.genes <- as.character(top_n(df.con.deg, top.n.hub, (wi))$genes)

# filter matrix
exp.mat.deg <- exp.mat.sub[rownames(exp.mat.sub) %in% deg.genes  , ]
exp.df.deg <- as.data.frame(exp.mat.deg)

# exp.mat.dcg <- exp.mat.sub[rownames(exp.mat.sub) %in% dcg.genes  , ]
# exp.df.dcg <- as.data.frame(exp.mat.dcg)

exp.mat.hub <- exp.mat.sub[rownames(exp.mat.sub) %in% hub.genes  , ]
exp.df.hub <- as.data.frame(exp.mat.hub)

# get group ids
df.id <- data.frame(cell.id = colnames(exp.df.deg))
df.id$group <- NA
df.id$group[df.id$cell.id %in% idMap.list[[reference.group]]] <- reference.group
df.id$group[df.id$cell.id %in% idMap.list[[comparison.group]]] <- comparison.group
grouping.df <- as.data.frame(df.id$group)


```


```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M10", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)


if (!(clog.update.success)){
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M10_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


UMAP
===================================== 

Row {.tabset}
-------------------------------------

### UMAP

```{r plt.umap_by_c1, fig.width=8, fig.height=6}
plt.umap_group <- plt.umap_group + theme_miko(legend = T)

plot.name <- paste0("M10_umap", ".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.umap_group, 
        fig.width = 8, fig.height = 6, save.flag = save.pdf)

print(plt.umap_group)

```

### Reclustered

```{r plt.umap_by_c2, fig.width=15, fig.height=5}
cowplot::plot_grid(p1.dim + ggtitle("Re-Clustered UMAP: Group Strata") + theme_miko(legend = T), 
                   p2.dim+ ggtitle("Re-Clustered UMAP: Cluster Strata") + theme_miko(legend = T))
```

Within-Cluster (DEG)
===================================== 

Within-cluster group-wise differential-differential expression analyses. 

Row {.tabset}
-------------------------------------

```{r plt overall deg, fig.width = 12, fig.height = 5}

try({
  plot.name <- paste0("M10_overall_deg", ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.bin.deg.ann, 
          fig.width = 12, fig.height = 5, save.flag = save.pdf)
  print(plt.bin.deg.ann)
  
}, silent = T)

```


```{r paired, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 6}

paired_out <- NULL
paired_out <- lapply(seq_along(plt.pairwise.list), function(i) {
  
  try({
    s1 <- names(plt.pairwise.list)[i]
    
    s2 <- paste("plt.pairwise.list[[", i, "]]", sep = "")
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 7, fig.height = 6}", paste("paired_deg", i, sep = ""))) 
    a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  }, silent = T)
})

# plt.pairwise.list[[1]]

```

`r try({paste0(knitr::knit(text = paste(paired_out, collapse = '\n')))}, silent = T)`

```{r}

try({
  

for (i in 1:length(plt.pairwise.list)){
  s1 <- names(plt.pairwise.list)[i]
  plot.name <- paste0("M10_deg_markers_" ,s1, ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.pairwise.list[[i]], 
          fig.width = 7, fig.height = 6, save.flag = save.pdf)
}
  
}, silent = T)

```


Between-Cluster (DEG)
===================================== 

Cluster vs. rest-of-population differential expression analyses. Enrichments shown for upregulated genes (i.e., logFC > 0) only. 

Row {.tabset}
-------------------------------------



```{r nc cc plots, warning = FALSE, message = FALSE,fig.width=14, fig.height=5}

bwc_out <- NULL

try({
  

bwc_out <- lapply(seq_along(cc.nc.list), function(i) {
  
  try({
    s1 <- names(cc.nc.list)[i]
    
    s2 <- paste("cc.nc.list[[", i, "]]", sep = "")
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=14, fig.height=5, message=FALSE, warning=FALSE}", paste("paired_ceg", i, sep = ""))) 
    a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  }, silent = T)
})

}, silent = T)

```

`r try({paste0(knitr::knit(text = paste(bwc_out, collapse = '\n')))}, silent = T)`



```{r save conserved markers plot}
try({

for (i in 1:length(cc.nc.list)){
  s1 <- names(cc.nc.list)[i]
  plot.name <- paste0("M10_conserved_markers_" ,s1, ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  cc.nc.list[[i]], 
          fig.width = 14, fig.height = 5, save.flag = save.pdf)
}
  
}, silent = T)

  
```



Network Construction
===================================== 

Row {.tabset}
-------------------------------------

### Power Optimization

```{r power opt}
try({
  plot.name <- paste0("M10_sft_optimization" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  sft$optimization.plot, 
          fig.width = 6, fig.height = 5, save.flag = save.pdf)
  
  print(sft$optimization.plot)
}, silent = T)
```

### Node-Linkage Distributions

```{r node linkage,fig.width=16, fig.height=10}
try({
  cowplot::plot_grid(plotlist = sft$distribution.plot, ncol = 5)

}, silent = T)
```


### Module Clusters

Clustered TOM matrix is hierarchially-clustered and adaptive pruning method is applied to identify gene modules. Consensus modules are determind by taking parallel-component max/min of two paired matrices. 

```{r module clusters 2}
try({
  plotDendroAndColors(geneTree.co, modules.cob, "Consensus", dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main="Consensus dendrogram")
  plotDendroAndColors(geneTree.1, modules.1b, "Group 1", dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main=paste0("Group 1: ", reference.group))
  plotDendroAndColors(geneTree.2, modules.2b, "Group 2", dendroLabels=FALSE, hang=0.03,
                      addGuide=TRUE, guideHang=0.05, main=paste0("Group 2: ", comparison.group))
}, silent = T)

```

### Dendrograms

Hierarchially-clustered TOM matrices.

```{r, fig.width=15, fig.height=4}

par(mfrow = c(1,3))
plot(geneTree.co, xlab = "", sub = "", main = "Consensus", labels = F, hang = 0.04)
plot(geneTree.1, xlab = "", sub = "", main = paste0("Group 1: ", reference.group), labels = F, hang = 0.04)
plot(geneTree.2, xlab = "", sub = "", main = paste0("Group 2: ", comparison.group), labels = F, hang = 0.04)

```

### Module Preservation

Module gene set overlap between datasets. 

```{r mod preservations, fig.width=8, fig.height=4}
try({
  plt.ven <- ggVennDiagram::ggVennDiagram(module.sets) + ggtitle("Network Preservations")
  
  plot.name <- paste0("M10_module_venndiagram" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.ven, 
          fig.width = 8, fig.height = 4, save.flag = save.pdf)
  
  print(plt.ven)
}, silent = T)
```

### Matrix Distributions

Distributions of expression matrix, similarity matrix, adjacency matrix and TOM. 

```{r mat distributions, fig.width=15, fig.height=4}

# fig.width=15, fig.height=4
if (sim.type  == "bin"){
  dem <- datExpr.noz.bin
} else if (sim.type == "single"){
  dem <- datExpr.noz
}

try({
  par(mfrow = c(1,4))
  hist(dem, main = "Expression")
  hist(s.mat, main = "Similarity (correlation)")
  hist(a.mat, main = "Adjacency")
  hist(w.mat, main = "TOM")
}, silent = T)
```

### Nodes and Links

Distribution of quantile-normalized connectivity and differential expression/fraction of genes. 

```{r net overview, fig.width=10, fig.height=4}

try({
  plt.distributions <- cowplot::plot_grid(plt.overview.1, plt.overview.2, ncol = 2, rel_widths = c(1,1.2))
  
  plot.name <- paste0("M10_connection_deg_distributions" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.distributions, 
          fig.width = 10, fig.height = 4, save.flag = save.pdf)
  
  print(plt.distributions)
}, silent = T)


```




Differential Network Analysis
===================================== 

Row {.tabset}
-------------------------------------

### DEG Volcano

Volcano plot illustrating differentially-expressed gene Modules. 

```{r deg volc, fig.width=14, fig.height=5}

try({
  plt.deg.volcano <- cowplot::plot_grid(plt.dif.volc, plt.rank.volc,plt.dif.rank.comp,  ncol = 3)
  
  plot.name <- paste0("M10_deg_volcano_plot" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.deg.volcano, 
          fig.width = 14, fig.height = 5, save.flag = save.pdf)
  
  print(plt.deg.volcano)
  
}, silent = T)

```

### DEG Box

Box plots illustrate paired module activity levels. 

```{r deg box, fig.width=12, fig.height=8}

try({
  plot.name <- paste0("M10_ME_activity_boxplot" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.dif.box.1, 
          fig.width = 12, fig.height = 8, save.flag = save.pdf)
  
  print(plt.dif.box.1)
}, silent = T)
```


### DCG Scatter

Comparison of pre- and post- quantile normlized similarity, adjacency and TOM-based connectivities for each sample. 

```{r, fig.height = 4, fig.width=14}

plt.connectivity.comp <- cowplot::plot_grid(plt.input.xy.s, 
                   plt.input.xy.a, 
                   plt.input.xy.w, 
                   ncol = 3)

plot.name <- paste0("M10_connectivity_comparison" ,".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.connectivity.comp, 
        fig.width = 14, fig.height = 4, save.flag = save.pdf)

print(plt.connectivity.comp)


```

### Logistic Classifier

Logistic regression-based classifier was trained (80% training set) and performance was evaluated on test set (20%). Variance explained by each classifier coeffcient (ie., module) is ranked. 
```{r logistic regression, fig.width=16, fig.height=6}

plt.logit.combo <- cowplot::plot_grid(plt.logitModel, plt.confusion, plt.var.exp, ncol = 3)

plot.name <- paste0("M10_logistic_regression" ,".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.logit.combo, 
        fig.width = 16, fig.height = 6, save.flag = save.pdf)

print(plt.logit.combo)

```


Heatmaps
===================================== 

Row {.tabset}
-------------------------------------

### Eigenmodule Activity

Eigenmodule activity for each cell, hierarchially-clustered. Sample identity is shown and can be used to determine how well modules can discriminate sample identity. 

```{r eigenmodule heatmap}

try({
  
  
  gm.current <- grouping.mem
  rownames(gm.current) <- rownames(ME.all.sub)
  u.g <- unique(grouping.mem$group); u.g <- u.g[!is.na(u.g)]
  ann.list <- list(group = c(g1 = "grey", g2 = "black"))
  names(ann.list$group) <- u.g
  
  colnames(ME.all.sub) <- gsub("ME", "", colnames(ME.all.sub))
  
  plt.ME.all.sub <- pheatmap::pheatmap(ME.all.sub, 
                                       color = rev(colorRampPalette(RColorBrewer::brewer.pal(9, "RdBu"))(100)),
                                       scale = "column",
                                       show_rownames = F,
                                       annotation_row = gm.current,
                                       annotation_colors = ann.list,
                                       main = "Eigenmodule Activity (module x cell)", silent = T)
  
  plt.ME.all.sub <- ggplotify::as.ggplot(plt.ME.all.sub)
  
  plot.name <- paste0("M10_ME_activity_heatmap" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.ME.all.sub, 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
  
  print(plt.ME.all.sub)
  
}, silent = T)

```  

### DEG

Heatmap of top differentially-expressed genes. 

```{r deg heatmap, fig.height=8, fig.width=10}

try({
  
  gm.current <- grouping.df
  colnames(gm.current) <- "group"
  rownames(gm.current) <- colnames(exp.df.deg)
  u.g <- unique(gm.current$group); u.g <- u.g[!is.na(u.g)]
  ann.list <- list(group = c(g1 = "grey", g2 = "black"))
  names(ann.list$group) <- u.g
  
  plt.exp.df.deg <- pheatmap::pheatmap(exp.df.deg, 
                                       color = viridis(20),
                                       show_colnames = F,
                                       annotation_col = gm.current,
                                       annotation_colors = ann.list,
                                       main = "Differential Expression (cell x genes)", silent = T)
  
  plt.exp.df.deg <- ggplotify::as.ggplot(plt.exp.df.deg)
  
  plot.name <- paste0("M10_deg_expression_heatmap" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.exp.df.deg, 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
  
  print(plt.exp.df.deg)
}, silent = T)

```  




### Hub

Expression heatmap of top connected (hub) genes. 

```{r hub heatmap, fig.height=8, fig.width=10}

try({
  
  gm.current <- grouping.df
  colnames(gm.current) <- "group"
  rownames(gm.current) <- colnames(exp.df.hub)
  u.g <- unique(gm.current$group); u.g <- u.g[!is.na(u.g)]
  ann.list <- list(group = c(g1 = "grey", g2 = "black"))
  names(ann.list$group) <- u.g
  
  plt.exp.df.hub <- pheatmap::pheatmap(exp.df.hub, 
                                       color = viridis(20),
                                       show_colnames = F,
                                       annotation_col = gm.current,
                                       annotation_colors = ann.list,
                                       main = "Hub Gene Expression (cell x genes)", silent = T)
  plt.exp.df.hub <- ggplotify::as.ggplot(plt.exp.df.hub)
  
  plot.name <- paste0("M10_hub_expression_heatmap" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.exp.df.hub, 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
  
  print(plt.exp.df.hub)
  
}, silent = T)



```  



Network Modules
===================================== 

### Module Enrichment (pAdj)

```{r module enrichment bh}

try({
  if (!is.null(results.co.bh)){
    datatable(results.co.bh, 
              filter = 'top',
              extensions = 'Buttons',
              options = list(pageLength = 50,
                             dom = 'Bfrtip', 
                             buttons = c('copy', 'csv', 'pdf')))
  }
}, silent = T)

```

### Module Enrichment (pVal)

```{r module enrichment pval}

try({
  if (!is.null(results.co.p)){
    datatable(results.co.p, 
              filter = 'top',
              extensions = 'Buttons',
              options = list(pageLength = 50,
                             dom = 'Bfrtip', 
                             buttons = c('copy', 'csv', 'pdf')))
  }
}, silent = T)

```


Dash
===================================== 

Row {.tabset}
-------------------------------------



```{r dash summary,  message=FALSE, warning=FALSE, fig.width=18, fig.height=8}

dash_out <- lapply(seq_along(dash.list), function(i) {
  
  s1 <- names(dash.list)[i]
  
  s2 <- paste("print(dash.list[[", i, "]])", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=18, fig.height=8, message=FALSE, warning=FALSE}", paste("dash", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(dash_out, collapse = '\n')))`


```{r save dash}

for (i in 1:length(dash.list)){
  s1 <- names(dash.list)[i]
  plot.name <- paste0("M10_summary" ,s1, ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  dash.list[[i]], 
          fig.width = 18, fig.height = 8, save.flag = save.pdf)
}

```


Compositional Analysis
===================================== 

Row {.tabset}
-------------------------------------

### Differential Composition

```{r plot comp,fig.height = 8, fig.width=10}

print(plt.compositional.analysis)

plot.name <- paste0("M10_compositional_analysis" , ".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.compositional.analysis, 
        fig.width = 10, fig.height = 8, save.flag = save.pdf)
```

### GLMnet Regression (v1)

Prediction of compositional difference using module eigengene activities as model covariates. lambda  = minimum lambda. 

```{r plotplt.mod.perform.sum1,fig.height = 4, fig.width=12}

try({

  plot.name <- paste0("M10_glmnet_regression_v1" , ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  plt.mod.perform.sum1,
          fig.width = 12, fig.height = 4, save.flag = save.pdf)
}, silent = T)

 print(plt.mod.perform.sum1)  

```


### GLMnet Regression (v2)

Prediction of compositional difference using module eigengene activities as model covariates. lambda = 10% above minimal lambda.

```{r plotplt.mod.perform.sum2,fig.height = 4, fig.width=12}

try({
  plot.name <- paste0("M10_glmnet_regression_v2" , ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  plt.mod.perform.sum2,
          fig.width = 12, fig.height = 4, save.flag = save.pdf)
}, silent = T)

  print(plt.mod.perform.sum2)

```


### GLMnet Regression (v3)

Prediction of compositional difference using module eigengene activities as model covariates. lambda = exp(-6).

```{r plotplt.mod.perform.sum30,fig.height = 4, fig.width=12}

try({
  plot.name <- paste0("M10_glmnet_regression_v3" , ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  plt.mod.perform.sum3,
          fig.width = 12, fig.height = 4, save.flag = save.pdf)
}, silent = T)

  print(plt.mod.perform.sum3)

```

### GLMnet Regression (v4)

Prediction of compositional difference using module eigengene activities as model covariates. lambda = exp(-10). 

```{r plotplt.mod.perform.sum40,fig.height = 4, fig.width=12}

try({


  plot.name <- paste0("M10_glmnet_regression_v4" , ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  plt.mod.perform.sum4,
          fig.width = 12, fig.height = 4, save.flag = save.pdf)
}, silent = T)

  print(plt.mod.perform.sum4)

```

### GLMnet Regression (v5)

Prediction of compositional difference using module eigengene activities as model covariates. lambda = 1 se within minimal lambda. 

```{r plotplt.mod.perform.sum50,fig.height = 4, fig.width=12}

try({


  plot.name <- paste0("M10_glmnet_regression_v5" , ".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  plt.mod.perform.sum5,
          fig.width = 12, fig.height = 4, save.flag = save.pdf)
}, silent = T)

  print(plt.mod.perform.sum5)

```

Network Enrichment
===================================== 

Row {.tabset}
-------------------------------------

### Differential Link/Node

Differential expression and connectivity illustrated. Top genes are labeled. 

```{r dif con deg,  fig.width=12, fig.height=6}

try({
  plt.2 <- plt.2 + theme_miko()
  plt.3 <- plt.3 + theme_miko()
  plt.dif.link.node<- cowplot::plot_grid(plt.2, plt.3, ncol = 2)
  
  plot.name <- paste0("M10_differential_gene_expression_linkage" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.dif.link.node, 
          fig.width = 12, fig.height = 6, save.flag = save.pdf)
  
  print(plt.dif.link.node)
  
}, silent = T)

```


### Node Enrichment

Differentially-expressed genes were annotated by GSEA, with genes ranked by p value (x axis) or connectivity (y axis). Enrichments with inconsistent signs (i.e., upper left and lower right quadrants) were omitted from further consideration. Plot is interactive (scroll over points for gene info, click and draft to zoom in). 

```{r deg node, fig.width=10, fig.height=7}

try({

  plt.gsea.comp <- plt.gsea.comp + theme_miko(legend = T)
  
  plot.name <- paste0("M10_differential_network_enrichment_scatterplot" ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.gsea.dot, 
          fig.width = 10, fig.height = 7, save.flag = save.pdf)
  
  print(plt.gsea.comp)
}, silent = T)

```




### Enrichment Dot

Dot plot of Node- and Link-based GSEA annotations. 

```{r plt.dif.net enrich, fig.width=8, fig.height=7}

try({
  
  plot.name <- paste0("M10_differential_network_enrichment_dotplot" ,".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.gsea.dot, 
        fig.width = 8, fig.height = 7, save.flag = save.pdf)

  print(plt.gsea.dot)
}, silent = T)
```


### Enrichment Bar

```{r, fig.height=14, fig.width=10}

plt.ebar <- cowplot::plot_grid(plt.e.node.linkage, plt.e.node, plt.e.linkage, ncol = 1, align = "v")

plot.name <- paste0("M10_module_GO_enrichment_barplot" ,".pdf")
savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
        plot.handle =  plt.ebar, 
        fig.width = 10, fig.height = 14, save.flag = save.pdf)

print(plt.ebar)

    # write.csv(gsea.pathway.dot.out, file = paste0(output.path, "Tables/", "gsea_consensus_node_link_enrichments.csv"), 
          # row.names = T) 

```


### GSEA network

```{r}
try({
  if (!is.null(gsea.pathway.dot)){
    
    gsea.pathway.dot.out <- gsea.pathway.dot
    colnames(gsea.pathway.dot.out) <- c("pathway", "NES.node", "NES.link", "NES.consensus", "p.node", "p.link", "p.consensus", "rank.consensus")
    gsea.pathway.dot.out[ ,c("NES.node", "NES.link", "NES.consensus", "p.node", "p.link", "p.consensus")] <- signif(gsea.pathway.dot.out[ ,c("NES.node", "NES.link", "NES.consensus", "p.node", "p.link", "p.consensus")], 3)
    
    write.csv(gsea.pathway.dot.out, file = paste0(output.path, "Tables/", "gsea_consensus_node_link_enrichments.csv"), 
          row.names = T) 
    
    # gsea.pathway.dot.out <- gsea.pathway.dot.out[gsea.pathway.dot.out$p.consensus <= 0.05, ]
    datatable(gsea.pathway.dot.out, 
              filter = 'top',
              extensions = 'Buttons',
              options = list(pageLength = 50,
                             dom = 'Bfrtip', 
                             buttons = c('copy', 'csv', 'pdf')))
  }
}, silent = T)


# colnames(gsea.pathway.dot.out)
```



Gene Sets
===================================== 

Row {.tabset}
-------------------------------------

```{r}

df.module.list <- list(all = module.df.all,
                       consensus = module.df.co
                       # group.1 = module.df.1,
                       # group.2 = module.df.2
                       # hub.genes = df.topGenesKME
                       )

out <- flex.multiTabTables(df.module.list, "df.module.list")

write.csv(module.df.co, file = paste0(output.path, "Tables/", "module_genes.csv"), 
          row.names = T) 

# write.csv(df.topGenesKME, file = paste0(output.path, "Tables/", "module_hub_genes.csv"), 
          # row.names = T) 

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


```{r save analysis log and Rdata results}



# additional log entries
df.log <- addLogEntry("which data used", which.data, df.log, "which.data")

df.log <- addLogEntry("variable genes only?", use.var, df.log, "use.var")

df.log <- addLogEntry("N genes in network", length(SubGeneNames), df.log, "length(SubGeneNames)")

df.log <- addLogEntry("TOM Type", TOM.type, df.log, "TOM.type")

df.log <- addLogEntry("Network Type", which.network, df.log, "which.network")

df.log <- addLogEntry("N Genes Considered", nrow(w.mat), df.log, "")


df.log <- addLogEntry("Correlation Type", which.cor, df.log, "which.cor")

df.log <- addLogEntry("Optimal soft power (complete dataset)", best.power, df.log, "best.power")
# df.log <- addLogEntry("Optimal soft power (reference group)", best.power.1, df.log, "best.power.1")
# df.log <- addLogEntry("Optimal soft power (comparison group)", best.power.2, df.log, "best.power.2")

df.log <- addLogEntry("Deep cut (tree pruning)", which.deepcut, df.log, "which.deepcut")

# df.log <- addLogEntry("Delta kME threshold", delta.kme.threshold, df.log, "delta.kme.threshold")

# df.log <- addLogEntry("Edges/module shown in network plot", top.n.interactions, df.log, "top.n.interactions")
df.log <- addLogEntry("meta network method", which.metanet, df.log, "which.metanet")

df.log <- addLogEntry("Reference Group", reference.group, df.log, "reference.group")
df.log <- addLogEntry("Comparison Group", comparison.group, df.log, "comparison.group")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")


df.log_Module_10 <- df.log


```


```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 10)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_10)

```


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_10, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
# if (save.pdf){
#   try({
#     pdf.list <- list.files (path = paste0(output.path, "PDF/") )
#     pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
#     
#     pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
#   }, silent = T)
# }
# 

```
