---
title: "Cell Annotation"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "GSVA", "scMiko",
                   "plyr", "dplyr", "tidyr", "reshape2", "preprocessCore", "stringr", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggExtra", "grid", "ggrepel", "future", 
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "ddpcr", "tm", "homologene", "plotly", "parallel", "doParallel", "foreach", "quantreg")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```



```{r analysis specifications}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"
dir.reference <- "Reference_Datasets/"

# Query input
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module1_p7_mesoderm_110620.Rdata"
# input.file <- "Module1_Neftel_ss2_GBM_160120.Rdata"
# input.file <- "Module2_integrated_p4789_allGBM_210720.Rdata"
input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"

# specify reference genesets
which.references <- c("MCA_50", "Zhang_2019", "Panglao.Mm", "VastDB",  "cycling.seurat", 
                      "cancerSEA", "immune.signatures", "immuneSubtype", "GBM")

# specify cluster resolution
cluster.resolution <- 0.45 # OPTIONAL; range 0 to inf (default = 1)

so.input.species <- "Mm" # eREQUIRED; Hs, Mm


# Data subsampling
subsample_factor <- 0.2 # OPTIONAL; range 0 to 1 (default = 1)
min.geneset.size <- 3 # recommended: 2 (for TF classification, set to 1)

# print inline
print.inline <- FALSE # OPTIONAL; TRUE/FALSE

# specify number of workers for parallelization
n.workers <- list(
  scoring = 6,
  deg = 1
)

#logical indicating whether to generate gene expression dot plots (computationally intensive)
show.gene.exp <- T 

# save PDF
save.pdf <- T

# I MAde A CHANGE

```


```{r specify input references}

# import geneset path file
all.references <- read.csv("M05_genesets.csv")

# get input references
query.references <- all.references[all.references$names %in% which.references, ]
csv_input <- as.list(as.vector(query.references$files))
names(csv_input) <- as.vector(query.references$names)

```


```{r load data}

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}
if (!exists("input.file")) stop("input.file is not specified")

# load query dataset
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

so.query <- prepSeurat(so)
rm(so)

invisible(gc())
current.assay <- DefaultAssay(so.query)

```

```{r}

# Neftel 2019 preprocessing
# a <- names(so.query@active.ident)
# a <- gsub(".", "", stringr::str_extract(a, "[a-zA-Z]*[0-9]*"))
# a <- stringr::str_extract(a, "[a-zA-Z]*[0-9]*")
# table(a)
```



```{r data subsetting and clustering}

# check species
if (so.input.species != unique(so.query@meta.data[["Organism"]])) {
  if (length(unique(so.query@meta.data[["Organism"]])) == 1) {
     so.input.species <- unique(so.query@meta.data[["Organism"]])
     warning("Incorrect input species was provided, and was updated to reflect what was available in seurat object.\n")
  } else if (length(unique(so.query@meta.data[["Organism"]])) > 1)  {
    warning("Input species could not be verfied and is being used as-is.\n")
  }
}

# cluster data
so.query <- setResolution(so.query, cluster.resolution)

# subsample 
stopifnot(exists("subsample_factor"))
if (subsample_factor < 1){
  so.query <- downsampleSeurat(so.query, subsample.factor = subsample_factor)
}

# subset data
if (exists("subset.df")){
  so.query <- subsetSeurat(so.query, subset.df)
}


```

```{r prep gene list}

# prep gene list
try({gNames.list <- prepGeneList(so.query, objects())}, silent = T)


```


```{r analysis log}

# Initiate and fill analysis Log
df.log <- initiateLog("5, Cell Annotation")
df.log <- addLogEntry("Query File (.Rdata)", input.file, df.log, "input.file")
df.log <- addLogEntry("Default Assay", current.assay, df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Input species", so.input.species, df.log, "so.input.species")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r cluster results, warning = FALSE}

# plot umap by cluster
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = "seurat_clusters", label = TRUE)  + 
  labs(title = "UMAP", subtitle = "Stratified by Clusters") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

# plot umap by barcodes
plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = "Barcode")  + 
  labs(title = "UMAP", subtitle = "Stratified by Barcodes") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T) + ggthemes::scale_color_ptol()

# plot umap by subset labels
plt.umap_by_subset <- DimPlot(so.query, reduction = "umap", group.by = "subset_group")  + 
  ggtitle(label = "UMAP") + 
  xlab("UMAP 1") + ylab("UMAP 2")  + theme_miko(legend = T) + ggthemes::scale_color_ptol()


if (print.inline){
  print(plt.umap_by_cluster)
  print(plt.umap_by_barcode)
  print(plt.umap_by_subset)
}

```




```{r normalized and scale data}

if (DefaultAssay(so.query) == "integrated"){
  DefaultAssay(so.query) <- "RNA"
  so.query <-NormalizeData(so.query, verbose = FALSE)
  so.query <- ScaleData(so.query, verbose = FALSE)
}

current.assay =  DefaultAssay(so.query)

```


```{r function for long to wide annotation table}

# function to convert long to wide df
long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster_membership ~ predicted_labels, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster_membership)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster_membership
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```



```{r get species appropriate gene symbol}

genes4species <- function(x, target.species) {
  if (target.species == "Hs") {
    y <- toupper(x)
  } else if (target.species == "Mm") {
    y <- tolower(x)
    substr(y, 1, 1) <- toupper(substr(y, 1, 1))
  }
  return (y)
  
}


```





```{r plot cluster composition alt}

# alternative function to plot cluster composition
plot.cluster_composition_alt <- function(df.cluster_annotations, other_threshold = 0.05, set_color = 2, lab_color = NULL, label_order = NULL){
  levels(df.cluster_annotations$predicted_labels) <- c(levels(df.cluster_annotations$predicted_labels), "other")
  df.cluster_annotations$predicted_labels[df.cluster_annotations$freq < other_threshold] <- as.character("other")
  
  # create graph to visualize representation across clusters
  u_predictions <- unique(df.cluster_annotations$predicted_labels)
  n_subgroups <- length(u_predictions)
  
  if (is.null(lab_color)){
    color_count <- max(n_subgroups)
    my_cols = colorRampPalette(brewer.pal(8, paste("Set", set_color, sep = "")))(color_count)
  } else {
    my_cols <- lab_color
  }
  
  if (is.null(label_order)){
    label_order <- unique(df.cluster_annotations$predicted_labels)
  } 
  
  
  # ensure that clusters are ordered numerically
  reordered_clusters <- order(as.numeric(as.vector(df.cluster_annotations$cluster_membership)))
  df.cluster_annotations <- df.cluster_annotations[reordered_clusters, ]
  df.cluster_annotations$cluster_membership <- as.numeric(as.vector(df.cluster_annotations$cluster_membership))
  cluster_chart_labels <- unique(df.cluster_annotations$cluster_membership)
  
  plt.cluster_composition <- ggplot(df.cluster_annotations, aes(x = cluster_membership, fill = factor(predicted_labels, levels = label_order), y = freq)) +
    geom_bar(position = "fill", stat = "identity") + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    xlab("Cluster ID") + ylab("Cluster Representation") + ggtitle("Cluster Annotations")
  
  return(plt.cluster_composition)
}

```




```{r cluster composition by barcode, warning = FALSE}

# get barcode labels and clusters
cluster_membership <- as.vector(so.query@meta.data[["seurat_clusters"]])
barcode_labels <- as.vector(so.query@meta.data[["Barcode"]])
df.bar_codes <- data.frame(cluster_membership, barcode_labels)

# tally up cluster compositions
df.all_barcodes <- df.bar_codes %>% 
  dplyr::group_by(cluster_membership, barcode_labels) %>%
  tally() %>% 
  dplyr::mutate(freq = n / sum(n)) 

u_barcodes <- unique(df.all_barcodes$barcode_labels)

if (length(u_barcodes) > 1) {
  
  # convert long to wide (cell type table)
  df_for_wide_barcodes <- df.all_barcodes
  colnames(df_for_wide_barcodes)[colnames(df_for_wide_barcodes) == "barcode_labels"] <- "predicted_labels"
  df.all_barcodes_wide <- long2wide(df_for_wide_barcodes)
  
  # plot cluster compositio by barcode
  df.cluster_annotations_barcodes <- df.all_barcodes
  colnames(df.cluster_annotations_barcodes)[colnames(df.cluster_annotations_barcodes) == "barcode_labels"] <- "predicted_labels"
  
  plt.cluster_composition_barcodes <- plot.cluster_composition_alt(df.cluster_annotations_barcodes, 
                                                                   other_threshold = 0)
  
  plt.cluster_composition_barcodes <- plt.cluster_composition_barcodes + 
    theme_miko(legend = T) + 
    ggthemes::scale_fill_ptol("Barcode") + 
    labs(title = "Cluster Composition", subtitle = "Stratified by Barcodes")
} else {
  df_for_wide_barcodes <- data.frame()
  df.all_barcodes_wide <- data.frame()
  df.cluster_annotations_barcodes <- data.frame()
  plt.cluster_composition_barcodes <- c()
  
}


```


```{r convert to symbol}

gene.rep <-  checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))

# so.temp <- so.query
if (gene.rep == "ensembl"){
  so.query <- ens2sym.so(so = so.query, gNames.list = gNames.list,  convert.RNA = TRUE)
  gene.rep <-  checkGeneRep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
}


```



```{r prep gene set helper function}

prepGeneSet <- function(gs.file, gs.dir, gs.species, gs.available.genes){
  
  gs.data <- read.csv(paste(gs.dir, gs.file, sep = ""), header = TRUE)
  gs.long <- pivot_longer(gs.data, colnames(gs.data))
  
  #clean up
colnames(gs.long) <- c("set", "genes")
  gs.long$genes <- as.character(gs.long$genes)
  gs.long <- gs.long[complete.cases(gs.long), ]
  gs.long <- gs.long[gs.long[ ,2] != "", ]
  gs.long$genes <- trimws(as.character(gs.long$genes))
  gs.long$set <- rmvCSVprefix(gs.long$set)
  
  
  # get correct speices
  if (gs.species == "Hs"){
    gs.long$genes <- toupper(gs.long$genes)
  } else if (gs.species == "Mm"){
    gs.long$genes <- firstup(gs.long$genes)
  }
  
  
  

  
  # keep only genes that are availale in seurat object
  gs.long <- gs.long[gs.long$genes %in% gs.available.genes, ]
  
  # wrangle into named list
  split_tibble <- function(tibble, column = 'col') {
    tibble %>% split(., .[,column]) %>% lapply(., function(x) x[,setdiff(names(x),column)])
  }
  
  dflist <- purrr::map(split_tibble(gs.long, 'set'), "genes")
  
  return(dflist)
}




```

```{r prep all signatures}

signatures.symbol <- list()
so.df.list <- list()

df.gs.statistics <- NULL
gs.list <- list()

# get available genes
av.genes <- rownames(so.query)

# get correct speices
if (so.input.species == "Hs"){
  av.genes <-  toupper(av.genes) 
} else if (so.input.species == "Mm"){
  av.genes <-  firstup(av.genes) 
}

for (i in 1:length(csv_input)){
  # get set name
  csv.label <- names(csv_input)[i]
  
  # import and prep data
  signatures.symbol[[csv.label]] <- prepGeneSet(gs.file = csv_input[i], 
                                                gs.dir = paste0(data.path, "Reference_Datasets/"), 
                                                gs.species = so.input.species, 
                                                gs.available.genes = av.genes)
  
  # get gene set statistics
  df.gs.statistics <- bind_rows(df.gs.statistics, 
                                data.frame(
                                  set = csv.label,
                                  annotation = names( signatures.symbol[[csv.label]]),
                                  n.genes = unlist(lapply(signatures.symbol[[csv.label]], function(x) length(x)))
                                ))
  df.gs.statistics$annotation <- rmvCSVprefix(df.gs.statistics$annotation)
  
  # store list in df for flex output
  gs.list[[csv.label]] <- namedList2wideDF( signatures.symbol[[csv.label]])
  
  if (!is.null( signatures.symbol[[csv.label]])){
    cur.sig <- signatures.symbol[[csv.label]]
    signatures.symbol[[csv.label]] <- cur.sig
  } else {next}
}


```


```{r reformat prediction scores}

format.results <- function(scores, score.name){
  reformated.scores <- as.data.frame(scores)
  reformated.scores$cell <- rownames(reformated.scores)
  reformated.scores.long <- pivot_longer(reformated.scores, colnames(reformated.scores)[1:(length(colnames(reformated.scores))-1)])
  reformated.scores.long$cluster.prediction <- paste(reformated.scores.long$cell, "-c", reformated.scores.long$name, sep = "")
  reformated.scores.long <- reformated.scores.long[ ,c("cluster.prediction", "value")]
  colnames(reformated.scores.long) <- c("cluster.prediction", score.name)
  
  return(reformated.scores.long)
}


```


```{r processing function}

rcnames.2d <- function (score.mat, exp.mat, sig){
  rownames(score.mat) <- names(sig)
  colnames(score.mat) <- colnames(exp.mat)
  score.mat <- as.data.frame(score.mat)
}
```


```{r cluster differentials}

# get expression  matrix
ef.mat <- as.matrix(so.query@assays[[DefaultAssay(so.query)]]@data)
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# initiate empty matrices
logfc.mat <- matrix(nrow = nrow(so.query), ncol = length(u.clust))
pct.mat <- matrix(nrow = nrow(so.query), ncol = length(u.clust))
e.mat <- matrix(nrow = nrow(so.query), ncol = length(u.clust))
f.mat <- matrix(nrow = nrow(so.query), ncol = length(u.clust))

# get cluster-level aggregate scores
for (i in 1:length(u.clust)){
  which.cells <- sc.meta %in% u.clust[i]
  
  # log expression
  e1 <- log(rowMeans(expm1(x = ef.mat[, which.cells])) + 1)
  e.mat[ ,i] <- e1
  
  # logfc
  e2 <- log(rowMeans(expm1(x = ef.mat[, !which.cells])) + 1)
  logfc.mat[ ,i] <- e1 - e2
  
  # expressing fraction
  f1 <- rowMeans(ef.mat[, which.cells] > 0)
  f.mat[ ,i] <- f1
  
  # pct difference
  f2 <- rowMeans(ef.mat[, !which.cells] > 0)
  pct.mat[ ,i] <- f1-f2
  
}

# assign col and row names
colnames(e.mat) <- colnames(logfc.mat) <-  colnames(f.mat) <-  colnames(pct.mat) <- u.clust
rownames(e.mat) <- rownames(logfc.mat) <-  rownames(f.mat) <-  rownames(pct.mat) <- rownames(ef.mat)

# cast to data.frame
df.lfc.wide <- data.frame(gene = rownames(ef.mat), data.frame(logfc.mat)); colnames(df.lfc.wide) <- c("gene", u.clust)
df.pd.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(pct.mat)); colnames(df.pd.wide) <- c("gene", u.clust)
df.e.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(e.mat)); colnames(df.e.wide) <- c("gene", u.clust)
df.f.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(f.mat)); colnames(df.f.wide) <- c("gene", u.clust)

# wide to long
df.lfc.long <- pivot_longer(df.lfc.wide, colnames(df.lfc.wide)[2:ncol(df.lfc.wide)]); 
df.pd.long <- pivot_longer(df.pd.wide, colnames(df.pd.wide)[2:ncol(df.pd.wide)])
df.e.long <- pivot_longer(df.e.wide, colnames(df.e.wide)[2:ncol(df.e.wide)])
df.f.long <- pivot_longer(df.f.wide, colnames(df.f.wide)[2:ncol(df.f.wide)])

# assign col names to long dataframe
colnames(df.lfc.long) <- colnames(df.pd.long) <- colnames(df.e.long) <- colnames(df.f.long) <- c("gene", "cluster", "value")

# ensure clusters are ordered factors
df.lfc.long$cluster <- factor(df.lfc.long$cluster, levels = u.clust)
df.pd.long$cluster <- factor(df.pd.long$cluster, levels = u.clust)
df.e.long$cluster <- factor(df.e.long$cluster, levels = u.clust)
df.f.long$cluster <- factor(df.f.long$cluster, levels = u.clust)

```


```{r assign annotation scores UPDATED, fig.width = 10, fig.height = 12, warning=F, message=F}

# get cluster memberships
cluster.lab <- "seurat_clusters"
cluster.membership <- so.query@meta.data[[cluster.lab]]

# get unique clusters
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]

# initiate score lists
e.score.list <- list()
expr.score.list <- list()
per.score.list <- list()
logfc.score.list <- list()
pd.score.list <- list()
sc.mod.score.list <- list()

# start cluster
cl <- parallel::makeCluster(n.workers$scoring)
doParallel::registerDoParallel(cl)


# iterate through each gene signature list
score.results <- foreach(i = 1:length(signatures.symbol), .packages = c("scMiko", "Seurat", "dplyr", "purrr", "GSVA"))  %dopar% {
#for (i in 1:length(signatures.symbol)){
  
  
  # initiate score data frames
  e.score <- NULL
  expr.score <- NULL
  mod.score <- NULL
  per.score <- NULL
  logfc.score <- NULL
  pctdif.score <- NULL
  df.n.gene <- NULL
  
  
  # get current signautre list
  which.sig <- names(signatures.symbol)[i]
  sig <- signatures.symbol[[which.sig]] 
  
  # clean lists
  list.lengths <- unlist(lapply(sig, length))
  sig <- sig[list.lengths >= min.geneset.size]
  
  #####################
  # calculate gene-expression percentage (per scores) and Avg Exp scores (expr scores)
  per.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  expr.score <- matrix(nrow = length(sig), ncol =length(u.clust))
  logfc.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  pctdif.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  
  if (length(sig) > 0){
    
    for (j in 1:length(sig)){
      
      per.dot.score <- NULL
      per.dot.null <- NULL
      if (sum(rownames(ef.mat) %in% sig[[j]]) > 0){
        # get features for current signature
        cur.features <- unique(rownames(ef.mat)[rownames(ef.mat) %in% sig[[j]]])
        
        # get geneset size
        n.genes.total <- length(sig[[j]])
        n.genes.available <- length(cur.features)
        df.n.gene <- bind_rows(df.n.gene, data.frame(ref.set = which.sig,
                                                     cell = names(sig)[j],
                                                     n.genes.total = n.genes.total,
                                                     n.genes.available, n.genes.available))
        
        per.mat.sub <- df.f.long[df.f.long$gene %in% cur.features, ]
        exp.mat.sub <- df.e.long[df.e.long$gene %in% cur.features, ]
        lfc.mat.sub <- df.lfc.long[df.lfc.long$gene %in% cur.features, ]
        pct.mat.sub <- df.pd.long[df.pd.long$gene %in% cur.features, ]
        
        per.exp <- as.data.frame(per.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        per.score[j,] <- as.vector(per.exp$mean.exp)
        
        # avg expression (observed)
        av.exp <- (exp.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        expr.score[j,] <- as.vector(av.exp$mean.exp)
        
        pd.exp <- (pct.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        pctdif.score[j,] <- as.vector(pd.exp$mean.exp)
        
        lfc.exp <- (lfc.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        logfc.score[j,] <- as.vector(lfc.exp$mean.exp)
        
      } else {
        per.score[j,] <- 0
        expr.score[j,] <- 0
        logfc.score[j,] <- 0
        pctdif.score[j,] <- 0
      }
    }
    
    per.score <- rcnames.2d(per.score, e.mat, sig)
    expr.score <- rcnames.2d(expr.score, e.mat, sig)
    logfc.score <- rcnames.2d(logfc.score, e.mat, sig)
    pctdif.score <- rcnames.2d(pctdif.score, e.mat, sig)
    
    ###############################
    # calculate GSVA scores
    e.score <- gsva(expr = e.mat, gset.idx.list = sig , method = "zscore",verbose = F)
    
    ##################################
    # store results 
    
    list(
      exp = expr.score,
      gsva = e.score,
      per = per.score,
      logfc = logfc.score,
      pd =pctdif.score,
      sc = expr.score,
      df.n.gene = df.n.gene
    )
    
    
  } else {
    list(
      exp = NULL,
      gsva = NULL,
      per = NULL,
      logfc = NULL,
      pd =NULL,
      sc = NULL,
      df.n.gene = NULL
    )
  } 
  
} 

# stop workers
parallel::stopCluster(cl)

df.n.gene <- NULL
# unpack results
for (i in 1:length(signatures.symbol)){
  which.sig <- names(signatures.symbol)[i]
  sig <- signatures.symbol[[which.sig]] 
  
  # clean lists
  list.lengths <- unlist(lapply(sig, length))
  sig <- sig[list.lengths >= min.geneset.size]
  
  if (length(sig) == 0) next
  
  e.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$gsva, e.mat, sig)
  expr.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$exp, e.mat, sig)
  per.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$per, e.mat, sig)
  pd.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$pd, e.mat, sig)
  logfc.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$logfc, e.mat, sig)
  sc.mod.score.list[[which.sig]] <- score.results[[i]]$sc
  df.n.gene <-  bind_rows(df.n.gene, score.results[[i]]$df.n.gene)
}


```


```{r DEG analysis using module scores}

# get cell-level annotation scores 

sc.mod.all <- NULL
sig.names.all <- c()
for (i in 1:length(signatures.symbol)){
  
  # get current signautre list
  which.sig <- names(signatures.symbol)[i]
  sig <- signatures.symbol[[which.sig]] 
  
  # clean lists
  list.lengths <- unlist(lapply(sig, length))
  sig <- sig[list.lengths >= min.geneset.size]
  
  if (length(sig) == 0) next
  
  for (j in 1:length(sig)){
    sig.name <- names(sig)[j]
    sig.features <- sig[[sig.name]]
    sc.mod.all <-  rbind(sc.mod.all, colMeans(ef.mat[rownames(ef.mat) %in% sig.features, ]))
    sig.names.all[length(sig.names.all) + 1] <- sig.name
  }
}

# assign annotation names
rownames(sc.mod.all) <- sig.names.all

sc.mod.all <- as.data.frame(t(sc.mod.all))
rownames(sc.mod.all) <- colnames(so.query)
so.deg <- CreateSeuratObject(
  counts = t(sc.mod.all),
  project = "module.score.DEG",
  assay = "RNA",
  min.cells = 0,
  min.features = 0,
  names.field = 1,
  names.delim = "_",
  meta.data = NULL
)

# get original seurat clusters
so.deg@meta.data[["seurat_clusters"]] <- so.query@meta.data[["seurat_clusters"]]
Idents(so.deg) <- so.deg@meta.data[["seurat_clusters"]]

if (n.workers$deg > length(u.clusters)) n.workers$deg <- length(u.clusters)

deg.gene <- FindAllMarkers.Parallel(object = so.deg, 
                                    n.work = n.workers$deg,
                                    only.pos = T, 
                                    min.pct = 0,
                                    test.use = "MAST",
                                    logfc.threshold = 0, 
                                    max.cells.per.ident = 200,
                                    return.thresh = 1, #1 ensures all genes are returned
                                    verbose = T)

# data wrangling
deg.gene$pDif <- deg.gene$pct.1 - deg.gene$pct.2
deg.gene$euc <- (((deg.gene$pDif/max(deg.gene$pDif))^2)  +  ((deg.gene$avg_logFC/max(deg.gene$avg_logFC))^2))
deg.gene$log.p <- -log10(deg.gene$p_val)
deg.gene$u.label <- paste0("c", deg.gene$cluster, "-", deg.gene$gene)
top.dg.v1 <- deg.gene %>% group_by(cluster) %>%  top_n(1, euc)
deg.gene$label.v1 <- ""
deg.gene$label.v1[deg.gene$u.label %in% top.dg.v1$u.label] <- deg.gene$u.label[deg.gene$u.label %in% top.dg.v1$u.label]
top.dg.v2 <- deg.gene %>%  top_n(15, euc)
deg.gene$label.v2 <- ""
deg.gene$label.v2[deg.gene$u.label %in% top.dg.v2$u.label] <- deg.gene$u.label[deg.gene$u.label %in% top.dg.v2$u.label]


deg.gene.sig <- deg.gene[deg.gene$p_val_adj < 0.05, ]

# plot
plt.deg.mod.1 <- deg.gene.sig %>%
  ggplot(aes(x = avg_logFC, y = pDif, color = cluster, size = log.p)) + 
  geom_point(data = deg.gene, aes(x = avg_logFC, y = pDif), color = "grey", size = 1) + 
  geom_point() + 
  theme_miko(legend = T) + 
  xlab('logFC (cluster n - other)') + 
  ylab('expressing fraction difference (cluster n - other)') + 
  labs(title = "Differential Module Analysis", subtitle = "colored: p < 0.05; grey: non-significant") + 
  ggrepel::geom_text_repel(aes(label = label.v1)) 

plt.deg.mod.2 <- deg.gene.sig %>%
  ggplot(aes(x = avg_logFC, y = pDif, color = cluster, size = log.p)) + 
  geom_point(data = deg.gene, aes(x = avg_logFC, y = pDif), color = "grey", size = 1) + 
  geom_point() + 
  theme_miko(legend = T) + 
  xlab('logFC (cluster n - other)') + 
  ylab('expressing fraction difference (cluster n - other)') + 
  labs(title = "Differential Module Analysis", subtitle = "colored: p < 0.05; grey: non-significant") + 
  ggrepel::geom_text_repel(aes(label = label.v2)) 

deg.mod.final <- deg.gene.sig[ , c( "avg_logFC", "p_val","p_val_adj","pct.1", "pct.2",  "pDif", "euc", "cluster", "gene")]
colnames(deg.mod.final) <- c( "avg_logFC", "p_val","p_val_adj","pct.1", "pct.2",  "pct.Dif", "dist.Origin", "Cluster", "Annotation")
deg.mod.final[ ,c("p_val", "avg_logFC", "pct.1", "pct.2", "p_val_adj", "pct.Dif", "dist.Origin")] <- signif(deg.mod.final[ ,c("p_val", "avg_logFC", "pct.1", "pct.2", "p_val_adj", "pct.Dif", "dist.Origin")], 3)

if (print.inline){
  print(plt.deg.mod.1)
  print(plt.deg.mod.2)
  # deg.mod.final
}

# clean baggage 
rm(so.deg)


```

```{r merge results df}

#merge 
df.n.gene <- unique(df.n.gene[ ,c("ref.set", "cell", "n.genes.total", "n.genes.available")])

```


```{r data wrangle}

# compare null to results

wrangleHelper <- function(score.list){
  h1.h0.merge <- NULL
  for (i in 1:length(score.list)){
    cur.h1 <-  format.results(score.list[[i]], "H1") 
    h1.h0.merge.cur <- cur.h1
    h1.h0.merge <- bind_rows(h1.h0.merge, h1.h0.merge.cur)
  }
  colnames(h1.h0.merge)[colnames(h1.h0.merge) %in% "cluster.prediction"] <- "pred"
  h1.h0.merge$cell <- gsub("-.*", "", h1.h0.merge$pred)
  h1.h0.merge$ratio <- h1.h0.merge$H1 
  h1.h0.merge <- merge(h1.h0.merge, df.n.gene)
  return(h1.h0.merge)
}

df.dist.expr <- wrangleHelper(expr.score.list)
df.dist.gsva <- wrangleHelper(e.score.list)
df.dist.per <- wrangleHelper(per.score.list)
df.dist.logfc <- wrangleHelper(logfc.score.list)
df.dist.pd <- wrangleHelper(pd.score.list)


```



```{r}

vstScoreThreshold  <- function(x, y, label, set, percentile.threshold = 0.95, 
                               spline.df = 3, quantile.norm = T, loess.center = T, loess.span = 5, center.by.group = T){
  
  # purpose: scale and normalize gene set scores 
  # step 1: loess-centering
  #     - ensures that data is not biased and that no outliers skew score distributions
  # step 2: variance-stabilizing transform based on quantile spline regression
  #
  # output: normalized and scaled geneset scores 
  
  # prepare data
  df <- data.frame(x = x, x.log = log(x), y = y,
                   annotation = label, ref.set = set)
  df$cluster <- gsub("-", "", stringr::str_extract(df$annotation, "-c[0-9]*")) 
  
  uni.clust <- unique(df$cluster)
  uni.clust <- uni.clust[order(uni.clust)]
  
  u.set <- unique(df$ref.set)
  
  # loess-centering
  if (loess.center){
    if (center.by.group){
      # for (i in 1:length(unique(u.set))){
      #   error.loess.mean <- loess(y ~ x.log, df[df$ref.set %in% u.set[i], ])
      #   pred <- predict(error.loess.mean, data.frame(x.log = df$x.log[df$ref.set %in% u.set[i]]), se = TRUE)[["fit"]]
      #   df$y.centered[df$ref.set %in% u.set[i]] <-  df$y[df$ref.set %in% u.set[i]] - pred
      # } 
      for (i in 1:length(uni.clust)){
        error.loess.mean <- loess(y ~ x.log, df[df$cluster %in% uni.clust[i], ], span = loess.span)
        pred <- predict(error.loess.mean, data.frame(x.log = df$x.log[df$cluster %in% uni.clust[i]]), se = TRUE)[["fit"]]
        df$y.centered[df$cluster %in% uni.clust[i]] <-  df$y[df$cluster %in% uni.clust[i]] - pred
        
        # df %>%
        #   filter(cluster == uni.clust[i]) %>%
        #   ggplot(aes(x = x, y = y.centered)) + 
        #   geom_point()
      } 
    } else {
      error.loess.mean <- loess(y ~ x.log, df)
      pred <- predict(error.loess.mean, data.frame(x.log = df$x.log), se = TRUE)[["fit"]]
      df$y.centered <-  df$y - pred 
    }
    
  } else {
    df$y.centered <- df$y
  }
  
  # quantile-regression based variance stabilization
  if (quantile.norm){
    
    # import splines packages
    if (!require(splines)) stop("splines package not found")
    
    
    for (i in 1:length(uni.clust)){
      
      score.selection <- df$cluster %in% uni.clust[i]
      
      # fit quantile spline regression
      rqfit95 <- rq(y.centered ~ bs((x), df = spline.df), data = df[df$cluster %in% uni.clust[i], ], tau = c(percentile.threshold))
      rqfit05 <- rq(y.centered ~ bs((x), df = spline.df), data = df[df$cluster %in% uni.clust[i], ], tau = c(1-percentile.threshold))
      
      # predict quantiles
      df$qr95[score.selection] <- predict(rqfit95, data.frame(x = (df$x[score.selection])))
      df$qr05[score.selection] <- predict(rqfit05, data.frame(x = (df$x[score.selection])))
      
      # apply transformation
      score.up.selection <- score.selection & (df$y.centered > 0)
      df$ratio[score.up.selection] <- df$y.centered[score.up.selection]/df$qr95[score.up.selection]
            score.down.selection <- score.selection & (df$y.centered < 0)
      df$ratio[score.down.selection] <- df$y.centered[score.down.selection]/(-1*df$qr05[score.down.selection])
      
      # get residuals
      df$residuals95[score.selection] <- rqfit95[["residuals"]]
      df$residuals05[score.selection] <- rqfit05[["residuals"]]
      
      #df$z.sig[score.selection]  <- (df$ratio[score.selection] - mean(df$ratio[score.selection] )) / sd(df$ratio[score.selection] )
      df$z.sig[score.selection]  <- df$ratio[score.selection] * 1.96 
      df$p.val[score.selection] <- 2*pnorm(abs(df$z.sig[score.selection]), lower.tail = F)
      df$sigUp[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] > 0)
      df$sigDown[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] < 0)
    }

    
    df$color <- "grey"
    df$color[df$sigUp ] <- "tomato"
    df$color[df$sigDown ] <- "skyblue"
    
    plt.vstScore2 <- df %>%
      ggplot(aes(x, y.centered)) +
      geom_point() +
      geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
      stat_quantile(formula = y ~ bs(x, df = spline.df), quantiles = c(1-percentile.threshold, percentile.threshold), linetype = "dashed", color = "tomato", size = 1) +
      theme_miko(legend = F) + 
      ylab("Annotation Score (loess-centered)") + 
      xlab("Geneset Size (N)") + 
      labs(title = "Variance-Stabilizing Transform", subtitle = paste0("Quant.Regression; B-Spline"))
    
    plt.vstScore <- df %>%
      ggplot(aes(x, z.sig)) + 
      geom_point(color =  df$color) + 
      geom_hline(yintercept = 0, color = "grey", linetype = "dashed") + 
      geom_hline(yintercept = c(1.96), color = "tomato", linetype = "dashed") + 
      geom_hline(yintercept = c(-1.96), color = "skyblue", linetype = "dashed") + 
      theme_miko() + 
      labs(title = "Annotation Scores", subtitle = "Var.Stabilized Scores") + 
      xlab("Geneset Size (N)") + 
      ylab("Z-Score")
    
  } else {
    df$ratio   <- df$y.centered
    df$residuals   <- df$y.centered
    df$z.sig  <- (df$y.centered - mean(df$y.centered )) / sd(df$y.centered )
    
    plt.vstScore <- df %>%
      ggplot(aes(x, z.sig)) + 
      geom_point() + 
      geom_hline(yintercept = 0, color = "grey", linetype = "dashed") + 
      geom_hline(yintercept =c(1.96), color = "tomato", linetype = "dashed") + 
      theme_miko()
    
    plt.vstScore2 <- NULL
  }
  
  list(
    results = df,
    plot = plt.vstScore,
    plot.trans = plt.vstScore2
  )
  
}


```




```{r score processing, warning = FALSE, fig.width=14, fig.height=6}

# process scores
vst.exp.list <- vstScoreThreshold(x = df.dist.expr$n.genes.available, y = df.dist.expr$ratio, 
                                     label = df.dist.expr$pred, set = df.dist.expr$ref.set, quantile.norm = T, loess.center = T)
vst.gsva.list <- vstScoreThreshold(x = df.dist.gsva$n.genes.available, y = df.dist.gsva$ratio, 
                                      label = df.dist.gsva$pred, set = df.dist.gsva$ref.set, quantile.norm = T, loess.center = T)
vst.per.list <- vstScoreThreshold(x = df.dist.per$n.genes.available, y = df.dist.per$ratio, 
                                     label = df.dist.per$pred, set = df.dist.per$ref.set, quantile.norm = T, loess.center = T)

vst.logfc.list <- vstScoreThreshold(x = df.dist.logfc$n.genes.available, y = df.dist.logfc$ratio, 
                                       label = df.dist.logfc$pred, set = df.dist.logfc$ref.set, quantile.norm = T, loess.center = T)
vst.pd.list <- vstScoreThreshold(x = df.dist.pd$n.genes.available, y = df.dist.pd$ratio, 
                                    label = df.dist.pd$pred, set = df.dist.pd$ref.set, quantile.norm = T, loess.center = T)


# merge results
vst.list <-  list(exp = vst.exp.list$results, 
                  gsva = vst.gsva.list$results, 
                  per= vst.per.list$results, 
                  logfc = vst.logfc.list$results,
                  pd = vst.pd.list$results)

vst.merge <- NULL
for (i in 1:length(vst.list)){
  
  score.name <- names(vst.list)[i]
  if (is.null(vst.merge)){
    vst.merge <- vst.list[[score.name]][ ,c("ref.set", "annotation", "x", "z.sig")]
    colnames(vst.merge) <- c("ref.set", "annotation", "n.genes", score.name )
  } else {
    cur.set <- vst.list[[score.name]][ ,c("ref.set", "annotation", "x", "z.sig")]
    colnames(cur.set) <- c("ref.set", "annotation", "n.genes", score.name )
    vst.merge <- merge(vst.merge, cur.set, by = c("ref.set", "annotation",  "n.genes"), all = T)
  }
  
}

vst.merge$uni.identifier <- paste0(vst.merge$annotation, "-", vst.merge$ref.set)
vst.merge <- vst.merge[!duplicated(vst.merge$uni.identifier), ]
vst.merge$composite <- apply(vst.merge[ ,names(vst.list)], 1, mean, na.rm = T)
vst.merge[ ,c(names(vst.list), "composite")] <- signif(vst.merge[ ,c(names(vst.list), "composite")], 3)


plt.vstComposite <- vst.merge %>%
  ggplot(aes(x = (n.genes), y = composite)) + 
  geom_hline(yintercept = 0,  color = "grey") + 
  geom_point() + 
  theme_miko() + 
  xlab("Genes/Set (log10 N)") + 
  ylab("Scores (variance stablized residuals)") 


# pooled plot
plt.score.thresholds.resids <- cowplot::plot_grid(vst.exp.list$plot.trans + labs(title = "Expression"),
                                                  vst.gsva.list$plot.trans  + labs(title = "GSVA"),
                                                  vst.per.list$plot.trans  + labs(title = "Expression Fraction"),
                                                  vst.logfc.list$plot.trans  + labs(title = "log FC"),
                                                  vst.pd.list$plot.trans  + labs(title = "Pct Differences"),
                                                  ncol = 3)

plt.score.thresholds <- cowplot::plot_grid(vst.exp.list$plot + labs(title = "Expression"),
                                           vst.gsva.list$plot  + labs(title = "GSVA"),
                                           vst.per.list$plot  + labs(title = "Expression Fraction"),
                                           vst.logfc.list$plot  + labs(title = "log FC"),
                                           vst.pd.list$plot  + labs(title = "Pct Differences"),
                                           ncol = 3)


# score correlation plots
plt.rank.cor <- GGally::ggpairs(vst.merge[ ,c(names(vst.list), "composite")], title="correlogram with ggpairs()", 
                                lower = list(continuous = GGally::wrap("points", alpha = 1), 
                                             combo = GGally::wrap("dot_no_facet", alpha = 1))) +
  theme_bw() + 
  ggtitle("Score Correlations")

if (print.inline){
  # plt.score.thresholds
  # plt.score.thresholds.resids
  
  cowplot::plot_grid(plt.score.thresholds, plt.score.thresholds.resids)
}

# get cluster ID
vst.merge$cluster <- gsub("-", "", stringr::str_extract(vst.merge$annotation, "-c[0-9]*"))
vst.merge$cell.type <- gsub("-c[0-9]*", "", vst.merge$annotation)


vst.merge.final <- vst.merge[ ,c("cluster", "cell.type", "ref.set", "n.genes","exp","gsva","per","logfc", "pd", "composite")]

vst.merge.final$z.comp <- signif(apply(vst.merge.final[ ,c("exp","gsva","per","logfc", "pd")], 1, function(x) mean(x, na.rm = T) / sd(x, na.rm = T)), 3)
vst.merge.final$cv.comp <- signif(apply(vst.merge.final[ ,c("exp","gsva","per","logfc", "pd")], 1, function(x) sd(x, na.rm = T) / mean(x, na.rm = T)), 3)

```


```{r assess size biases, fig.width = 8, fig.height = 6}

plt.score.box <- list()
plt.score.density <- list()

for (i in 1:length(vst.list)){
  
  which.score <- names(vst.list)[i]
  
  # wilcox test
  tt.p <- signif(wilcox.test(vst.list[[which.score]]$x[vst.list[[which.score]]$sigUp], vst.list[[which.score]]$x[!vst.list[[which.score]]$sigUp])[["p.value"]], 3)
  
  # bonferroni correction
  tt.p <- tt.p*5
  if (tt.p > 1) tt.p <- 1
  
  
  plt.score.box[[which.score]] <- vst.list[[which.score]] %>%
    ggplot(aes(x = sigUp, y = log(x), fill = sigUp)) + 
    geom_boxplot()+ 
    ylab("Geneset Size, log(N)") + 
    xlab("Significant") + 
    theme_miko() + 
    ggthemes::scale_fill_ptol() + 
    labs(title = which.score, subtitle = paste0("p.adj=", tt.p))
  
}

title_gg <- ggplot()+ 
  labs(title = "Geneset Size Bias Assessment", subtitle = "Size differences assessed by Ranked Sum Test") + 
  theme_grey() + 
  theme(plot.title = element_text(face= "bold"))
body_gg <- cowplot::plot_grid(plotlist = plt.score.box)

plt.size_bias <- cowplot::plot_grid(title_gg, body_gg, ncol = 1, rel_heights = c(0.15, 1))

if (print.inline){
 # fig.width = 8, fig.height = 6
  print(plt.size_bias)
}

  
```

```{r wordclouds, fig.width = 15, fig.height =5}

sig.thresh <- 1.96
vst.merge.cloud <- vst.merge.final
vst.merge.cloud$sig.lenient <- F
vst.merge.cloud$sig.lenient[vst.merge.cloud$exp > sig.thresh | 
                              vst.merge.cloud$gsva > sig.thresh |
                              vst.merge.cloud$per > sig.thresh | 
                              vst.merge.cloud$logfc > sig.thresh | 
                              vst.merge.cloud$pd > sig.thresh] <- T


psum <- function(x) Reduce("+",x)
vst.merge.cloud$n.sigUp <- 0
vst.merge.cloud$n.sigUp <- psum(data.frame(vst.merge.cloud$exp > sig.thresh , 
                                           vst.merge.cloud$gsva > sig.thresh ,
                                           vst.merge.cloud$per > sig.thresh ,
                                           vst.merge.cloud$logfc > sig.thresh ,
                                           vst.merge.cloud$pd > sig.thresh))
vst.merge.cloud$n.sigDown <- 0
vst.merge.cloud$n.sigDown <- psum(data.frame(vst.merge.cloud$exp < -1*sig.thresh , 
                                             vst.merge.cloud$gsva < -1*sig.thresh ,
                                             vst.merge.cloud$per < -1*sig.thresh ,
                                             vst.merge.cloud$logfc < -1*sig.thresh ,
                                             vst.merge.cloud$pd < -1*sig.thresh))

vst.merge.cloud$sig.stringent <- F
vst.merge.cloud$sig.stringent[vst.merge.cloud$exp > sig.thresh & 
                                vst.merge.cloud$gsva > sig.thresh &
                                vst.merge.cloud$per > sig.thresh & 
                                vst.merge.cloud$logfc > sig.thresh & 
                                vst.merge.cloud$pd > sig.thresh] <- T

vst.merge.cloud$colorUp <- "grey"
hue.col <- 0
vst.merge.cloud$colorUp[vst.merge.cloud$n.sigUp >= 1] <- colorspace::sequential_hcl(4, h = hue.col)[3]
vst.merge.cloud$colorUp[vst.merge.cloud$n.sigUp >= 3] <-  colorspace::sequential_hcl(4, h = hue.col)[2]
vst.merge.cloud$colorUp[vst.merge.cloud$n.sigUp >= 5] <- colorspace::sequential_hcl(4, h = hue.col)[1]

vst.merge.cloud$colorDown <- "grey"
vst.merge.cloud$colorDown[vst.merge.cloud$n.sigDown >= 1] <- colorspace::sequential_hcl(4)[3]
vst.merge.cloud$colorDown[vst.merge.cloud$n.sigDown >= 3] <- colorspace::sequential_hcl(4)[2]
vst.merge.cloud$colorDown[vst.merge.cloud$n.sigDown >= 5] <- colorspace::sequential_hcl(4)[1]

if (print.inline){
  
  u.cl <- paste("c", u.clusters, sep = "")
  # cols <- rev(c("#d73027",

  for (i in 1:length(u.cl)){
    
    vst.merge.subset <- vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]
    if (nrow(vst.merge.subset) >0){
      par(mfrow = c(1,2))
      wordcloud::wordcloud(words = vst.merge.subset$cell,
                           freq =  round((vst.merge.subset$composite + abs(min(vst.merge.subset$composite)))*20), min.freq = -5,
                           max.words=20, random.order=FALSE, rot.per=0, scale = c(1.3, 0.01),
                           colors= vst.merge.subset$colorUp, ordered.colors = T)
            wordcloud::wordcloud(words = vst.merge.subset$cell,
                           freq =  round((-1*vst.merge.subset$composite + abs(min(-1*vst.merge.subset$composite)))*20), min.freq = -5,
                           max.words=20, random.order=FALSE, rot.per=0, scale = c(1.3, 0.01),
                           colors= vst.merge.subset$colorDown, ordered.colors = T)
    } 
  }  
}

vst.merge.lenient <- vst.merge.final[vst.merge.cloud$sig.lenient, ]


```

```{r deg evaluation, warning = FALSE, fig.width=8, fig.height=8}

# Find fraction of DEGs present in each geneset ##########################################

deg.gene.sub <- df.lfc.long[(df.pd.long$value > 0.5) | (df.lfc.long$value > 1), ]

deg.list <- deg.gene.sub %>%
  arrange(cluster) %>%
  group_by(cluster) %>%
  dplyr::summarize(
    genes = list(gene)
  )

deg.list <- apply(deg.list[ ,"genes"], 1, function(x) unlist(x))
names(deg.list) <- paste0("c", seq(0, length(deg.list)-1))

collapse.set <- c()
for (i in 1:length(signatures.symbol)){
  collapse.set <- c(collapse.set, signatures.symbol[[i]])
}

fraction.deg <- lapply(deg.list, function(x) lapply(collapse.set, function(y) sum(x %in% y)/length(x)))

df.fct.deg <- purrr::map_dfc(fraction.deg, function(x) unlist(x))
df.fct.deg <- as.data.frame(df.fct.deg)
rownames(df.fct.deg) <- make.unique(names(fraction.deg[[1]]))

df.fct.deg.wide <- df.fct.deg
df.fct.deg.wide$annotation <- rownames(df.fct.deg)
df.fct.deg.long <- pivot_longer(df.fct.deg.wide, cols = colnames(df.fct.deg))

df.top.deg <- (df.fct.deg.long %>%
  group_by(name) %>%
  arrange(-value))


n.col.max <- nrow(df.top.deg)
if (n.col.max > 50) n.col.max <- 50
top.terms <- unique(df.top.deg$annotation)[c(1:n.col.max)]

df.fct.deg.hm <- df.fct.deg[df.fct.deg.wide$annotation %in% top.terms, ]
  df.fct.deg.hm.scaled <- apply(df.fct.deg.hm, 2, function(x) x <- tryCatch({rescaleValues(x)}, error = function (e){x})) 
  

if (print.inline){

  pheatmap::pheatmap(df.fct.deg.hm, 
                     main = "Fraction of DEGs present in Genesets\n x: cluster; y: annotation; z: DEG fraction",
                     color = viridis::inferno(10))
  
    pheatmap::pheatmap(df.fct.deg.hm.scaled, 
                     main = "Fraction of DEGs present in Genesets\n x: cluster; y: annotation; z: DEG fraction",
                     color = viridis::inferno(10))
}

```


```{r plot signature gene expressions, message=FALSE, warning=FALSE, fig.width = 10, fig.height = 10}

all.signatures.list <- list()

if (length(signatures.symbol) > 0){
  for (i  in 1:length(signatures.symbol)){
    cur.signature.list.name <- names(signatures.symbol)[i]
    cur.signature.list <- signatures.symbol[[cur.signature.list.name]]
    signature.df <- NULL
    for (j in 1:length(cur.signature.list)){
      if (length(cur.signature.list[[j]])>0){
        cur.signature.name <- names(cur.signature.list)[j]
        cur.signature.df <- as.data.frame(unlist(cur.signature.list[[cur.signature.name]]))
        cur.signature.df$signature <- cur.signature.name
        cur.signature.df <- cur.signature.df[ ,c(2,1)]
        colnames(cur.signature.df) <- c("signature", "genes")
        signature.df <- bind_rows(signature.df,cur.signature.df )
      }
    }
    
    all.signatures.list[[cur.signature.list.name]] <- signature.df
  }
}

plt.signature.subset <- TRUE # (flag specifying whether to plot all or just subset)

# top N signatures
# top signatures
# df.sig2plt <- unique((vst.merge.final %>% arrange(-composite) %>% top_n(90, composite))[ ,c("cell.type", "ref.set")])
df.sig2plt <- unique((vst.merge.cloud %>% dplyr::filter(sig.lenient,composite > 1) %>% dplyr::arrange(-composite))[ ,c("cell.type", "ref.set")])
if (nrow(df.sig2plt) > 50) df.sig2plt <- df.sig2plt[1:50, ]

signature.dot.list <- list()
if (plt.signature.subset){
  for (i in 1:length(all.signatures.list)){
    which.sig <- names(all.signatures.list)[i]
    if (which.sig %in% df.sig2plt$ref.set){
      df.sig2plt.cur <- df.sig2plt[df.sig2plt$ref.set %in% which.sig, ]
      signature.dot.list[[which.sig]] <- all.signatures.list[[which.sig]][all.signatures.list[[which.sig]]$signature %in% df.sig2plt.cur$cell,]
    }
  }
} else {
  signature.dot.list <- all.signatures.list
}

signature.dot.list.all <- list()
signature.dot.list.all[["all"]] <- NULL
for (i in 1:length(signature.dot.list)){
  signature.dot.list.all[["all"]] <- bind_rows( signature.dot.list.all[["all"]], signature.dot.list[[i]])
}

signature.dot.list.all[["all"]] <- unique(signature.dot.list.all[["all"]])

plt.expression.all.dotplots <- list()
if (show.gene.exp){
  
  for (i in 1:length(signature.dot.list.all)){
    
    cur.signature.list.name <- names(signature.dot.list.all)[i]
    plt.expression.dotplot <- list()
    signature.df <- signature.dot.list.all[[i]]
    u.signatures <- as.vector(unique(signature.df$signature))
    for (j in 1:length(u.signatures)){
      
      cur.signature.df <- signature.df %>% dplyr::filter(signature == u.signatures[j])
      cur.signature.genes <- as.vector(cur.signature.df$genes)
      
      n.genes <- length(cur.signature.genes)
      
      if (n.genes < 11) xlab.size <- 15
      if (n.genes > 10) xlab.size <- 12
      if (n.genes > 40) xlab.size <- 10
      if (n.genes > 50) xlab.size <- 9
      if (n.genes > 60) xlab.size <- 8
      if (n.genes > 70) xlab.size <- 7
      if (n.genes > 80) xlab.size <- 6
      
      plt.expression.dotplot[[u.signatures[j]]] <-  DotPlot(so.query, features = cur.signature.genes, dot.scale = 8,
                                                            cols="RdBu") + 
        RotatedAxis() + 
        ylab("Clusters") + 
        labs(title = u.signatures[j], subtitle = paste0(length(cur.signature.genes), " Genes")) +
        theme(axis.text.x=element_text(size=xlab.size, angle = 75))
      
      if ((print.inline) & (j < 21)) 
        print( plt.expression.dotplot[[u.signatures[j]]])
    }
    
    plt.expression.all.dotplots[[cur.signature.list.name]] <- plt.expression.dotplot
  }
  
  
}

```


```{r prep matrix for expression heatmap, include = FALSE}

agg.mat <- aggGroupExpression(so.query)

try({var1 <-  so.query@assays[["RNA"]]@var.features}, silent = T)
try({var2 <- so.query@assays[["SCT"]]@var.features}, silent = T)
try({var3 <- so.query@assays[["integrated"]]@var.features}, silent = T)

if (exists("var1") && length(var1) > 0) var.features <- var1
if (exists("var2") && length(var2) > 0) var.features <- var2
if (exists("var3") && length(var3) > 0) var.features <- var3

if (exists("var.features")){
  agg.mat <- agg.mat[agg.mat$genes %in% var.features, ]
  agg.mat <- agg.mat[!duplicated(agg.mat$genes), ]
  rownames(agg.mat) <- agg.mat$genes
  agg.mat <- agg.mat %>% dplyr::select(-c("genes"))
  
  plt.hm <- ggplotify::as.ggplot(pheatmap::pheatmap(agg.mat, show_rownames = F,
                                                    main = "Expression Matrix\nx=clusters, y=genes, z=expression", scale = "row"))
  
} else {
  plt.hm <- NULL
}

if (print.inline){
  print(plt.hm)
}


```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M05", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M05_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```

cluster UMAP
===================================== 

```{r plt.umap_by_c}
print(plt.umap_by_cluster)
savePDF(file.name = paste0(output.path, "PDF/", "M05_umap_cluster.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```


Barcodes
===================================== 

Row {data-height=600}
-------------------------------------

### Barcode Identities
```{r plt.umap_by_barcode}
print(plt.umap_by_barcode)
savePDF(file.name = paste0(output.path, "PDF/", "M05_umap_barcode.pdf"), plot.handle = plt.umap_by_barcode, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```

Row {.tabset}
-------------------------------------

### Cluster Composition (Barcodes)
```{r plt.cluster_composition_barcodes, fig.width=13, fig.height=4}
print(plt.cluster_composition_barcodes)
savePDF(file.name = paste0(output.path, "PDF/", "M05_cluster_composition_barplot.pdf"), plot.handle = plt.cluster_composition_barcodes, 
        fig.width = 13, fig.height = 4, save.flag = save.pdf)
```

### Cluster Composition (Table)
```{r df.all_barcodes_wide}

datatable(df.all_barcodes_wide, filter="top", extensions = 'Buttons',
          options = list(pageLength = 50, 
                         autoWidth = TRUE,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))


```


Score Distributions
===================================== 

Annotation scores were loess-centered and variances were stabilized using 95% quantile B-spline regression to eliminate size-biased. 

Row {.tabset}
-------------------------------------

### Annotation Scores
```{r Score Distributions, fig.width=12, fig.height=6, warning = F, message=F}

print(plt.score.thresholds)
savePDF(file.name = paste0(output.path, "PDF/", "M05_annotation_scores.pdf"), plot.handle = plt.score.thresholds, 
        fig.width = 12, fig.height = 6, save.flag = save.pdf)

```

### Variance-Stabilizing Transform
```{r Score Distributions v2, fig.width=12, fig.height=6, warning = F, message=F}

print(plt.score.thresholds.resids)
savePDF(file.name = paste0(output.path, "PDF/", "M05_vst_scores.pdf"), plot.handle = plt.score.thresholds.resids, 
        fig.width = 12, fig.height = 6, save.flag = save.pdf)

```


### Score Correlations
```{r Gene-Set Size Relation, fig.width=8, fig.height=7, warning = F, message=F}

print(plt.rank.cor)
savePDF(file.name = paste0(output.path, "PDF/", "M05_score_correlations.pdf"), plot.handle = plt.rank.cor, 
        fig.width = 8, fig.height = 7, save.flag = save.pdf)

```

### Geneset Size Bias Assessment
```{r geneset_size_bias_assessment, fig.width=8, fig.height=6, warning = F, message=F}

print(plt.size_bias)
savePDF(file.name = paste0(output.path, "PDF/", "M05_geneset_size_bias_assessment.pdf"), plot.handle = plt.size_bias, 
        fig.width = 8, fig.height = 8, save.flag = save.pdf)

```





Annotation Scores
===================================== 

EXP: Gene set (average) expression, GSVA: Gene set variation analysis, PER: Expressing Fraction (average), LOGFC: log fold-change, PD: difference between percentage of expression cells,  COMPOSITE: Average of component scores

Row {.tabset}
-------------------------------------

### Scores (significant)

```{r lenient filter tab,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}


try({vst.merge.lenient <- vst.merge.lenient %>% dplyr::select(-c("gen"))}, silent = T)
datatable(vst.merge.lenient, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(vst.merge.lenient, file = paste0(output.path, "Tables/", "annotation_scores_significant.csv"), 
          row.names = F) 


```


### Scores (no filter)

```{r no filter tab,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

try({vst.merge.final <- vst.merge.final %>% dplyr::select(-c("gen"))}, silent = T)
datatable(vst.merge.final, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(vst.merge.final, file = paste0(output.path, "Tables/", "annotation_scores_all.csv"), 
          row.names = F) 

```

Word Clouds (Cell)
===================================== 

Red: enriched annotations; Blue: depleted annotations; Word size ~ composite score; Word transparency ~ confidence.

Row {.tabset}
-------------------------------------

```{r Clouds}

u.cl <- unique(as.numeric(as.character((cluster.membership))))
u.cl <- u.cl[order(u.cl)]
u.cl <- paste("c", u.cl, sep = "")

out_word <- lapply(seq_along(u.cl), function(i) {
  
  table.name <- u.cl[i]
  
  
  
  s4 <-   paste("par(mfrow = c(1,2))
  wordcloud::wordcloud(words = vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$cell,
                       freq =  round((vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$composite)*50), min.freq = 0,
                       max.words=20, random.order=FALSE, rot.per=0, scale = c(1.3, 0.01),
                       colors= vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$colorUp, ordered.colors = T)
  wordcloud::wordcloud(words = vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$cell,
                       freq =  round((vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$composite)*-50), min.freq = 0,
                       max.words=20, random.order=FALSE, rot.per=0, scale = c(1.3, 0.01),
                       colors= vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[" ,i, "], ]$colorDown, ordered.colors = T)", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
# vst.merge.subset$gen

```

`r paste(knitr::knit(text = paste(out_word, collapse = '\n')))`

```{r pdf Clouds,include = FALSE}

for (i in 1:length(u.cl)){
  plot.name <- paste0("M05_wordcloud_", u.cl[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle =  wordcloud::wordcloud(words = vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]$cell,
                                              freq =  round((vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]$composite)*50), min.freq = 0,
                                              max.words=30, random.order=FALSE, rot.per=0, scale = c(1.5, .2),
                                              colors= vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]$colorUp, ordered.colors = T),
          fig.width = 5, fig.height = 5, save.flag = save.pdf)
}

```


Differential Module Scores
===================================== 

differential analysis of annotation scores. Independent of earlier composite scoring (intended as indepenent annotation method).

Row {.tabset}
-------------------------------------

### Differential Scores 1

Top annotation for each cluster is shown.

```{r plt.deg.mod.1}

print(plt.deg.mod.1)
savePDF(file.name = paste0(output.path, "PDF/", "M05_differential_genesets_1.pdf"), plot.handle = plt.deg.mod.1, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```

### Differential Scores 2

Top N annotations are shown. 

```{r plt.deg.mod.2}

print(plt.deg.mod.2)

savePDF(file.name = paste0(output.path, "PDF/", "M05_differential_genesets_2.pdf"), plot.handle = plt.deg.mod.2, 
        fig.width = 7, fig.height = 5, save.flag = save.pdf)
```

### DEG Table

```{r deg.mod.final}

datatable(deg.mod.final,
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(deg.mod.final, file = paste0(output.path, "Tables/", "differential_genesets_statistics.csv"), 
          row.names = F) 

```

Differential Genes
===================================== 

Row {.tabset}
-------------------------------------

### Fraction of differential genes in each geneset

```{r fdgg, fig.width = 10, fig.height=8}

plt.hm.genedeg <- ggplotify::as.ggplot(  pheatmap::pheatmap(df.fct.deg.hm, 
                                                            main = "Fraction of DEGs present in Genesets\n x: cluster; y: annotation; z: DEG fraction",
                                                            color = viridis::inferno(10)))

```

```{r pdf fdgg}

try({
  savePDF(file.name = paste0(output.path, "PDF/", "M05_fraction_DEG_in_genesets.pdf"), 
          plot.handle = plt.hm.genedeg, 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
}, silent = T)

```

### Fraction of differential genes in each geneset (rescaled)

```{r fdgg2, fig.width = 10, fig.height=8}

plt.hm.genedeg.scale <- ggplotify::as.ggplot(  pheatmap::pheatmap(df.fct.deg.hm.scaled, 
                                                            main = "Fraction of DEGs present in Genesets\n x: cluster; y: annotation; z: DEG fraction (scaled)",
                                                            color = viridis::inferno(10)))

```

```{r pdf fdgg2}

try({
  savePDF(file.name = paste0(output.path, "PDF/", "M05_fraction_DEG_in_genesets_rescaled.pdf"), 
          plot.handle = plt.hm.genedeg.scale, 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
}, silent = T)

```

### Expression Table

```{r, fig.width = 10, fig.height=8}


df.e.wide[, c(2:ncol(df.e.wide))] <- apply(df.e.wide[, c(2:ncol(df.e.wide))], 2, signif, 3)
df.e.wide.var <- df.e.wide[df.e.wide$gene %in% var.features, ]
datatable(df.e.wide.var,
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.e.wide.var, file = paste0(output.path, "Tables/", "expression_table.csv"), 
          row.names = F) 
```
### LFC Table

```{r, fig.width = 10, fig.height=8}

df.lfc.wide[, c(2:ncol(df.lfc.wide))] <- apply(df.lfc.wide[, c(2:ncol(df.lfc.wide))], 2, signif, 3)
df.lfc.wide.var <- df.lfc.wide[df.lfc.wide$gene %in% var.features, ]
datatable(df.lfc.wide.var,
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.lfc.wide, file = paste0(output.path, "Tables/", "lfc_table.csv"), 
          row.names = F) 

```

### Expression Fraction Table

```{r, fig.width = 10, fig.height=8}


df.f.wide[, c(2:ncol(df.f.wide))] <- apply(df.f.wide[, c(2:ncol(df.f.wide))], 2, signif, 3)
df.f.wide.var <- df.f.wide[df.f.wide$gene %in% var.features, ]
datatable(df.f.wide.var,
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.f.wide, file = paste0(output.path, "Tables/", "expressing_fraction_table.csv"), 
          row.names = F) 
```

### Expression Fraction Difference Table

```{r, fig.width = 10, fig.height=8}


df.pd.wide[, c(2:ncol(df.pd.wide))] <- apply(df.pd.wide[, c(2:ncol(df.pd.wide))], 2, signif, 3)
df.pd.wide.var <- df.pd.wide[df.pd.wide$gene %in% var.features, ]
datatable(df.pd.wide.var,
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.pd.wide, file = paste0(output.path, "Tables/", "expressing_fraction_difference_table.csv"), 
          row.names = F) 
```

Gene Expression 
===================================== 

Row {.tabset}
-------------------------------------

### Heatmap

```{r exp mat, warning = F, message = F}

try({
  print(plt.hm)
}, silent = T)


```

```{r pdf heat}

try({
  savePDF(file.name = paste0(output.path, "PDF/", "M05_expression_heatmap.pdf"), 
          plot.handle = (plt.hm), 
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
}, silent = T)

```


```{r ph4 expression dotplots, include = FALSE, message=FALSE, warning=FALSE}

if (show.gene.exp){
  
  out.sig <- tryCatch({
    
    
    out.sig <- lapply(seq_along(plt.expression.all.dotplots), function(i) {
      
      
      a1 <- knitr::knit_expand(text = sprintf("\nExpr | %s", paste(names(plt.expression.all.dotplots)[i])))
      a2 <- knitr::knit_expand(text = "\n=====================================")
      a3 <- knitr::knit_expand(text = "\nRow {.tabset}")
      a4 <- knitr::knit_expand(text = "\n-------------------------------------")
      
      out2 <- lapply(seq_along(plt.expression.all.dotplots[[i]]), function(j) {
        
        s1 <- paste("plt.expression.all.dotplots[[", i, "]][[",j ,"]]", sep = "")
        
        b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", names(plt.expression.all.dotplots[[i]])[j])) # tab header
        b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=10, fig.height=10, message=FALSE, warning=FALSE}", paste("expression.dot", i, j, sep = ""))) 
        b3 <- knitr::knit_expand(text = sprintf("\n%s",s1)) 
        b4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
        
        out2 <- paste(b1, b2, b3, b4, collapse = '\n')
        return(out2) # collapse together all lines with newline separator
        
      })
      
      a5 <- paste(knitr::knit(text = paste(out2, collapse = '\n')))
      
      out.sig <- paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
      return(out.sig)
      
    })
    
  }, error = function(e) {
    out.sig <- NULL
    return(out.sig)
  })
  
  
} else {
  out.sig <- NULL
}

```

`r paste(knitr::knit(text = paste(out.sig, collapse = '\n')))`


```{r pdf dotplots,include = FALSE}

for (i in 1:length(plt.expression.dotplot)){
  plot.name <- paste0("M05_dotplot_", names(plt.expression.dotplot)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.expression.dotplot[[i]], 
          fig.width = 10, fig.height = 10, save.flag = save.pdf)
}

```

Gene Sets
===================================== 

Row {.tabset}
-------------------------------------

### Summary
```{r}

datatable(df.gs.statistics, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.gs.statistics, file = paste0(output.path, "Tables/", "geneset_summary.csv"), 
          row.names = F) 
```

```{r res4, echo = FALSE, eval = TRUE, message=TRUE, warning=FALSE}
out <- flex.multiTabTables(gs.list, "gs.list")
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


```{r save genelists}

for (i in 1:length(gs.list)){
  table.name <- paste0("genelist_", names(gs.list)[i], ".csv")
  write.csv(gs.list[[1]], file = paste0(output.path, "Tables/",table.name), 
            row.names = F) 
}
```



```{r save analysis log and Rdata results}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", (elapsed.time), df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_5 <- df.log


```




```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 5)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_5)

```


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_5, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  
  pdf.list <- list.files (path = paste0(output.path, "PDF/") )
  pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
  pdf.list <- pdf.list[validUTF8(pdf.list)]
  pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
}

```

