---
title: "Cell Annotation"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    source_code: embed
    theme: flatly
    navbar:
      - { title: "scPipeline", href: "https://github.com/NMikolajewicz/scPipeline" }
      - { title: "scMiko", href: "https://github.com/NMikolajewicz/scMiko" }  
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", 
        paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", 
      paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "GSVA", "scMiko", "presto",
                   "plyr", "dplyr", "tidyr", "reshape2", "preprocessCore", "stringr", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggExtra", "grid", "ggrepel", "future", "gridGraphics", "ggwordcloud", "scales",
                   "org.Mm.eg.db", "org.Hs.eg.db", "ddpcr", "tm", "homologene", "parallel", "doParallel", "foreach", "quantreg")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```




```{r analysis specifications}

parameter.list <- list(
  input.file = "R443_M02_NM2_p9_GBM_PR_integrated_SCTrerun_110521.Rdata",
  which.references = c("cancerSEA", "immune.signatures", "immuneSubtype", "GBM",  
                       "cycling.seurat", "immune.Monaco", "invitro.GBM", "MCA_50", "Zhang_2019", "Panglao.Hs"),
  cluster.resolution = 1, # OPTIONAL; range 0 to inf (default = 1)
  clean.clusters = T,
  subsample_factor = 1, # OPTIONAL; range 0 to 1 (default = 1)
  min.geneset.size = 3, # recommended: 3 (for TF classification, set to 1)
  composite.components = c("exp",  "per", "gsva", "logfc", "pd"), # "exp", "gsva", "per", "logfc", "pd" "gsva"
  vst = T, 
  pathway.db = "Bader", # options: Bader, GO
  n.workers = list(
    scoring = 12
  ),
  save.pdf = T,
  print.inline = FALSE ,
  update.log = T
  
)



# parameter.list$composite.components <- c("exp",  "per", "gsva") #"exp", "gsva", "per", "logfc", "pd" "gsva",
# parameter.list$vst <- T #"exp", "gsva", "per", "logfc", "pd"

# Query input
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R4_M02_BC2_M02_p467891011_Mm_allGBM_010920.Rdata"
# input.file <- "R6_M02_BC2_allGBM_271020.Rdata"
# input.file <- "R308_M27_NM2_M02_BC2_allGBM_immune_tier2_251120.Rdata"
# input.file <- "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata"
# input.file <- "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
# input.file <- "R410_M02_NM2_celsius_all_renca_rpca_filtered_240321.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file <- "R291_M01_NM2_Rambow_Melanoma_221120.Rdata"

# "neural.dif.HH", 
# specify reference genesets
# "MCA_50", "Zhang_2019", "Panglao.Mm", "VastDB",  "cycling.seurat",, , "neural.dif.HH"

# "Kidney_Healthy_Mm", 

# ,  "invitro.GBM", "Zeisel2018_brainDev"
# which.references <- c("cancerSEA", "immune.signatures", "immuneSubtype", "GBM",  "MCA_50", "Zhang_2019", "Panglao.Mm",   "VastDB", "cycling.seurat", "immune.Monaco", "Kidney_Healthy_Mm", "msigdb_Mm")



```





```{r specify input references}

# import geneset path file
all.references <- read.csv("M05_genesets.csv", stringsAsFactors = F)

# get input references
query.references <- all.references[all.references$names %in% parameter.list$which.references, ]
csv_input <- as.list(as.vector(query.references$files))
names(csv_input) <- as.vector(query.references$names)

```


```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"
dir.reference <- "Reference_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}


if (!("input.file" %in% names(parameter.list))) stop("input.file is not specified")

# load query dataset
message("Importing data...")
if ((!grepl(".Rdata|.RData", parameter.list$input.file)) & !(grepl(".rds", parameter.list$input.file))){
  parameter.list$input.file <- paste0(parameter.list$input.file, ".Rdata")
} 
if (grepl(".Rdata|.RData", parameter.list$input.file)){
  load(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""));
} else if (grepl(".rds", parameter.list$input.file)) {
  so <- readRDS(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""))
}


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species = NULL, resolution= parameter.list$cluster.resolution, subset.data = NULL, 
                         subsample = parameter.list$subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

# clean clusters
if (parameter.list$clean.clusters) so.query <- cleanCluster(so.query, return.plots = F)
parameter.list$species <- detectSpecies(so.query)

```


```{r analysis log}

message("Updating analysis log...")

# Initiate and fill analysis Log
df.log <- initiateLog("5, Cell Annotation")
df.log <- addLogEntry("Query File (.Rdata)", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Default Assay", current.assay, df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Species", parameter.list$species, df.log, "species")
df.log <- addLogEntry("Clusters cleaned", parameter.list$clean.clusters, df.log, "clean.clusters")
df.log <- addLogEntry("Minimum gene set size", parameter.list$min.geneset.size, df.log, "min.geneset.size")
df.log <- addLogEntry("n workers, scoring", parameter.list$n.workers$scoring, df.log, "scoring")
df.log <- addLogEntry("Composite components", paste(parameter.list$composite.components, collapse = ", "), df.log, "composite.components")
df.log <- addLogEntry("Reference gene sets", paste(parameter.list$which.references, collapse = ", "), df.log, "which.references")
df.log <- addLogEntry("Variance stabilizing transform", parameter.list$vst, df.log, "vst")
df.log <- addLogEntry("Gene set enrichment database", parameter.list$pathway.db, df.log, "pathway.db")
df.log <- addLogEntry("PDF saved", parameter.list$save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("PDF saved", parameter.list$save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("Update log", parameter.list$update.log, df.log, "update.log")

```


```{r get prior history log}

# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r cluster results, warning = FALSE}

plt.umap_by_cluster <-cluster.UMAP(so.query) + 
  labs(title = "UMAP", subtitle = "Stratified by Clusters") +
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T)

# plot umap by barcodes
plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = "Barcode")  + 
  labs(title = "UMAP", subtitle = "Stratified by Barcodes") + 
  xlab("UMAP 1") + ylab("UMAP 2") + theme_miko(legend = T) 

if (parameter.list$print.inline){
  print(plt.umap_by_cluster)
  print(plt.umap_by_barcode)
}

```

```{r function for long to wide annotation table}

# function to convert long to wide df
long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster_membership ~ predicted_labels, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster_membership)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster_membership
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```



```{r get species appropriate gene symbol}

genes4species <- function(x, target.species) {
  if (target.species == "Hs") {
    y <- toupper(x)
  } else if (target.species == "Mm") {
    y <- tolower(x)
    substr(y, 1, 1) <- toupper(substr(y, 1, 1))
  }
  return (y)
  
}


```


```{r plot cluster composition alt}

# alternative function to plot cluster composition
plot.cluster_composition_alt <- function(df.cluster_annotations, other_threshold = 0.05, set_color = 2, lab_color = NULL, label_order = NULL){
  levels(df.cluster_annotations$predicted_labels) <- c(levels(df.cluster_annotations$predicted_labels), "other")
  df.cluster_annotations$predicted_labels[df.cluster_annotations$freq < other_threshold] <- as.character("other")
  
  # create graph to visualize representation across clusters
  u_predictions <- unique(df.cluster_annotations$predicted_labels)
  n_subgroups <- length(u_predictions)
  
  if (is.null(lab_color)){
    color_count <- max(n_subgroups)
    my_cols = colorRampPalette(brewer.pal(8, paste("Set", set_color, sep = "")))(color_count)
  } else {
    my_cols <- lab_color
  }
  
  if (is.null(label_order)){
    label_order <- unique(df.cluster_annotations$predicted_labels)
  } 
  
  
  # ensure that clusters are ordered numerically
  reordered_clusters <- order(as.numeric(as.vector(df.cluster_annotations$cluster_membership)))
  df.cluster_annotations <- df.cluster_annotations[reordered_clusters, ]
  df.cluster_annotations$cluster_membership <- as.numeric(as.vector(df.cluster_annotations$cluster_membership))
  cluster_chart_labels <- unique(df.cluster_annotations$cluster_membership)
  
  plt.cluster_composition <- ggplot(df.cluster_annotations, aes(x = cluster_membership, fill = factor(predicted_labels, levels = label_order), y = freq)) +
    geom_bar(position = "fill", stat = "identity") + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    xlab("Cluster ID") + ylab("Relative Abundance") + ggtitle("Cluster Annotations")
  
  return(plt.cluster_composition)
}

```




```{r cluster composition by barcode, warning = FALSE}

# get barcode labels and clusters
cluster_membership <- as.vector(so.query@meta.data[["seurat_clusters"]])
barcode_labels <- as.vector(so.query@meta.data[["Barcode"]])
df.bar_codes <- data.frame(cluster_membership, barcode_labels)

# tally up cluster compositions
df.all_barcodes <- df.bar_codes %>% 
  dplyr::group_by(cluster_membership, barcode_labels) %>%
  tally() %>% 
  dplyr::mutate(freq = n / sum(n)) 

u_barcodes <- unique(df.all_barcodes$barcode_labels)

if (length(u_barcodes) > 1) {
  
  # convert long to wide (cell type table)
  df_for_wide_barcodes <- df.all_barcodes
  colnames(df_for_wide_barcodes)[colnames(df_for_wide_barcodes) == "barcode_labels"] <- "predicted_labels"
  df.all_barcodes_wide <- long2wide(df_for_wide_barcodes)
  
  # plot cluster compositio by barcode
  df.cluster_annotations_barcodes <- df.all_barcodes
  colnames(df.cluster_annotations_barcodes)[colnames(df.cluster_annotations_barcodes) == "barcode_labels"] <- "predicted_labels"
  
  plt.cluster_composition_barcodes <- plot.cluster_composition_alt(df.cluster_annotations_barcodes, 
                                                                   other_threshold = 0)
  if (length(u_barcodes) < 13){
    plt.cluster_composition_barcodes <- plt.cluster_composition_barcodes + ggthemes::scale_fill_ptol("Barcode") 
  }
  plt.cluster_composition_barcodes <- plt.cluster_composition_barcodes  + 
    theme_miko(legend = T) + 
    labs(title = "Cluster Composition", subtitle = "Stratified by Barcodes")
} else {
  df_for_wide_barcodes <- data.frame()
  df.all_barcodes_wide <- data.frame()
  df.cluster_annotations_barcodes <- data.frame()
  plt.cluster_composition_barcodes <- c()
  
}

```

```{r prep gene set helper function}

prepGeneSet <- function(gs.file, gs.dir, gs.species, gs.available.genes){
  
  gs.data <- read.csv(paste(gs.dir, gs.file, sep = ""), header = TRUE, stringsAsFactors = F)
  gs.long <- pivot_longer(gs.data, colnames(gs.data))
  
  #clean up
  colnames(gs.long) <- c("set", "genes")
  gs.long$genes <- as.character(gs.long$genes)
  gs.long <- gs.long[complete.cases(gs.long), ]
  gs.long <- gs.long[gs.long[ ,2] != "", ]
  gs.long$genes <- trimws(as.character(gs.long$genes))
  gs.long$set <- rmvCSVprefix(gs.long$set)
  
  
  # get correct speices
  if (gs.species == "Hs"){
    gs.long$genes <- toupper(gs.long$genes)
  } else if (gs.species == "Mm"){
    gs.long$genes <- firstup(gs.long$genes)
  }
  
  # keep only genes that are availale in seurat object
  gs.long <- gs.long[gs.long$genes %in% gs.available.genes, ]
  
  # wrangle into named list
  split_tibble <- function(tibble, column = 'col') {
    tibble %>% split(., .[,column]) %>% lapply(., function(x) x[,setdiff(names(x),column)])
  }
  
  dflist <- purrr::map(split_tibble(gs.long, 'set'), "genes")
  
  return(dflist)
}




```

```{r prep all signatures}

message("Preparing gene sets...")
signatures.symbol <- list()
so.df.list <- list()

df.gs.statistics <- NULL
gs.list <- list()

# get available genes
av.genes <- rownames(so.query)

# get correct speices
if (parameter.list$species == "Hs"){
  av.genes <-  toupper(av.genes) 
} else if (parameter.list$species == "Mm"){
  av.genes <-  firstup(av.genes) 
}

for (i in 1:length(csv_input)){
  # get set name
  csv.label <- names(csv_input)[i]
  
  # import and prep data
  signatures.symbol[[csv.label]] <- prepGeneSet(gs.file = csv_input[i], 
                                                gs.dir = paste0(data.path, "Reference_Datasets/"), 
                                                gs.species = parameter.list$species, 
                                                gs.available.genes = av.genes)
  
  # get gene set statistics
  df.gs.statistics <- bind_rows(df.gs.statistics, 
                                data.frame(
                                  set = csv.label,
                                  annotation = names( signatures.symbol[[csv.label]]),
                                  n.genes = unlist(lapply(signatures.symbol[[csv.label]], function(x) length(x)))
                                ))
  df.gs.statistics$annotation <- rmvCSVprefix(df.gs.statistics$annotation)
  
  # store list in df for flex output
  gs.list[[csv.label]] <- namedList2wideDF( signatures.symbol[[csv.label]])
  
  if (!is.null( signatures.symbol[[csv.label]])){
    cur.sig <- signatures.symbol[[csv.label]]
    signatures.symbol[[csv.label]] <- cur.sig
  } else {next}
}


```


```{r reformat prediction scores}

format.results <- function(scores, score.name){
  reformated.scores <- as.data.frame(scores)
  reformated.scores$cell <- rownames(reformated.scores)
  reformated.scores.long <- pivot_longer(reformated.scores, colnames(reformated.scores)[1:(length(colnames(reformated.scores))-1)])
  reformated.scores.long$cluster.prediction <- paste(reformated.scores.long$cell, "-c", reformated.scores.long$name, sep = "")
  reformated.scores.long <- reformated.scores.long[ ,c("cluster.prediction", "value")]
  colnames(reformated.scores.long) <- c("cluster.prediction", score.name)
  
  return(reformated.scores.long)
}


```


```{r processing function}

rcnames.2d <- function (score.mat, exp.mat, sig){
  rownames(score.mat) <- names(sig)
  colnames(score.mat) <- colnames(exp.mat)
  score.mat <- as.data.frame(score.mat)
}
```




```{r cluster differentials}


message("Getting expression matrices...")

# calculate differentials
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)
df.prest <- presto::wilcoxauc(X = so.query, group_by = "seurat_clusters", assay = "data", seurat_assay = DefaultAssay(so.query))
df.prest$pct.dif <- df.prest$pct_in - df.prest$pct_out

# expression data
e.mat <- pivot_wider(df.prest %>% dplyr::select(feature, group, avgExpr), names_from = group, values_from = avgExpr)
e.mat <- col2rowname(e.mat, "feature"); e.mat <- as.matrix(e.mat[ ,order(as.numeric(colnames(e.mat)))])

# logFC
logfc.mat <- pivot_wider(df.prest %>% dplyr::select(feature, group, logFC), names_from = group, values_from = logFC)
logfc.mat <- col2rowname(logfc.mat, "feature"); logfc.mat <- as.matrix(logfc.mat[ ,order(as.numeric(colnames(logfc.mat)))])

# pct
f.mat <- pivot_wider(df.prest %>% dplyr::select(feature, group, pct_in), names_from = group, values_from = pct_in)
f.mat <- col2rowname(f.mat, "feature"); f.mat <- as.matrix(f.mat[ ,order(as.numeric(colnames(f.mat)))])

# pct.dif
pct.mat <- pivot_wider(df.prest %>% dplyr::select(feature, group, pct.dif), names_from = group, values_from = pct.dif)
pct.mat <- col2rowname(pct.mat, "feature"); pct.mat <- as.matrix(pct.mat[ ,order(as.numeric(colnames(pct.mat)))])

# cast to data.frame
df.lfc.wide <- data.frame(gene = rownames(logfc.mat), data.frame(logfc.mat)); colnames(df.lfc.wide) <- c("gene", u.clust)
df.pd.wide <- data.frame(gene = rownames(pct.mat), as.data.frame(pct.mat)); colnames(df.pd.wide) <- c("gene", u.clust)
df.e.wide <- data.frame(gene = rownames(e.mat), as.data.frame(e.mat)); colnames(df.e.wide) <- c("gene", u.clust)
df.f.wide <- data.frame(gene = rownames(f.mat), as.data.frame(f.mat)); colnames(df.f.wide) <- c("gene", u.clust)

# wide to long
df.lfc.long <- pivot_longer(df.lfc.wide, colnames(df.lfc.wide)[2:ncol(df.lfc.wide)]); 
df.pd.long <- pivot_longer(df.pd.wide, colnames(df.pd.wide)[2:ncol(df.pd.wide)])
df.e.long <- pivot_longer(df.e.wide, colnames(df.e.wide)[2:ncol(df.e.wide)])
df.f.long <- pivot_longer(df.f.wide, colnames(df.f.wide)[2:ncol(df.f.wide)])

# assign col names to long dataframe
colnames(df.lfc.long) <- colnames(df.pd.long) <- colnames(df.e.long) <- colnames(df.f.long) <- c("gene", "cluster", "value")

# ensure clusters are ordered factors
df.lfc.long$cluster <- factor(df.lfc.long$cluster, levels = u.clust)
df.pd.long$cluster <- factor(df.pd.long$cluster, levels = u.clust)
df.e.long$cluster <- factor(df.e.long$cluster, levels = u.clust)
df.f.long$cluster <- factor(df.f.long$cluster, levels = u.clust)
invisible({gc()})

```


```{r expression heatmap, include = FALSE, fig.width = 12, fig.height = 5}


plt.heat.scaled <- NULL
plt.heat.data <- NULL
plt.heat.all <- NULL
try({
  # get var features
  var.features <- so.query@assays[[DefaultAssay(so.query)]]@var.features
  
  # scaled expression plots
  df.s4plt <- as.matrix(df.e.wide %>% dplyr::select(-c("gene")))
  df.s4plt <- df.s4plt[rownames(df.s4plt) %in% var.features, ]
  
  df.s4plt <- t(apply(df.s4plt, 1, function(x) (x-mean(x))/sd(x)))
  
  scale.lim <- 2 
  df.s4plt[df.s4plt > scale.lim] <- scale.lim
  df.s4plt[df.s4plt < (-1*scale.lim)] <- (-1*scale.lim)
  
  my.breaks <- seq((-1*scale.lim), scale.lim, by = 0.01)
  # my.col <- colorRampPalette(c(scales::muted("blue"), "white",scales::muted("red")))(length(my.breaks))
  
  df.s4plt <- df.s4plt[!(apply(df.s4plt, 1, function(x) all(is.na(x)))), ]
  
  plt.heat.scaled <- pheatmap::pheatmap(df.s4plt,
                                        breaks = my.breaks,
                                        color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(length(my.breaks)),
                                        show_rownames = F,
                                        main = "Scaled Expression\nx=cluster, y=gene, z=scaled expression", silent = T)
  
  plt.heat.scaled <- ggplotify::as.ggplot(plt.heat.scaled)
  
  rm(df.s4plt); 
  
}, silent = T)

try({
  # normalized expression plots
  df.e4plt <- as.matrix(df.e.wide %>% dplyr::select(-c("gene")))
  df.e4plt <- df.e4plt[rownames(df.e4plt) %in% var.features, ]
  
  plt.heat.data <- pheatmap::pheatmap(df.e4plt,
                                      show_rownames = F,
                                      main = "Normalized Expression\nx=cluster, y=gene, z=lognorm expression", 
                                      color = viridis::inferno(100),
                                      silent = T)
  
  plt.heat.data <- ggplotify::as.ggplot(plt.heat.data)
  
  
  plt.heat.all <- cowplot::plot_grid(plt.heat.scaled, plt.heat.data)
  
  if (parameter.list$print.inline) print(plt.heat.all)
  
  rm(df.e4plt);
}, silent = T)



```


```{r assign annotation scores UPDATED, fig.width = 10, fig.height = 12, warning=F, message=F}

message("Calculating component scores...")
# get cluster memberships
cluster.lab <- "seurat_clusters"
cluster.membership <- so.query@meta.data[[cluster.lab]]

# get unique clusters
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]

# initiate score lists
e.score.list <- list()
expr.score.list <- list()
per.score.list <- list()
logfc.score.list <- list()
pd.score.list <- list()
sc.mod.score.list <- list()

# start cluster
n.work.score <- parameter.list$n.workers$scoring
if (n.work.score > detectCores()) n.work.score <- detectCores()

cl <- parallel::makeCluster(n.work.score)
doParallel::registerDoParallel(cl)


# iterate through each gene signature list
score.results <- foreach(i = 1:length(signatures.symbol), .packages = c("scMiko", "Seurat", "dplyr", "purrr", "GSVA"))  %dopar% {
  #for (i in 1:length(signatures.symbol)){
  
  
  # initiate score data frames
  e.score <- NULL
  expr.score <- NULL
  mod.score <- NULL
  per.score <- NULL
  logfc.score <- NULL
  pctdif.score <- NULL
  df.n.gene <- NULL
  
  
  # get current signautre list
  which.sig <- names(signatures.symbol)[i]
  sig <- signatures.symbol[[which.sig]] 
  
  # clean lists
  list.lengths <- unlist(lapply(sig, length))
  sig <- sig[list.lengths >= parameter.list$min.geneset.size]
  
  #####################
  # calculate gene-expression percentage (per scores) and Avg Exp scores (expr scores)
  per.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  expr.score <- matrix(nrow = length(sig), ncol =length(u.clust))
  logfc.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  pctdif.score <- matrix(nrow = length(sig), ncol = length(u.clust))
  
  if (length(sig) > 0){
    
    for (j in 1:length(sig)){
      
      per.dot.score <- NULL
      per.dot.null <- NULL
      if (sum(rownames(e.mat) %in% sig[[j]]) > 0){
        # get features for current signature
        cur.features <- unique(rownames(e.mat)[rownames(e.mat) %in% sig[[j]]])
        
        # get geneset size
        n.genes.total <- length(sig[[j]])
        n.genes.available <- length(cur.features)
        df.n.gene <- bind_rows(df.n.gene, data.frame(ref.set = which.sig,
                                                     cell = names(sig)[j],
                                                     n.genes.total = n.genes.total,
                                                     n.genes.available, n.genes.available))
        
        per.mat.sub <- df.f.long[df.f.long$gene %in% cur.features, ]
        exp.mat.sub <- df.e.long[df.e.long$gene %in% cur.features, ]
        lfc.mat.sub <- df.lfc.long[df.lfc.long$gene %in% cur.features, ]
        pct.mat.sub <- df.pd.long[df.pd.long$gene %in% cur.features, ]
        
        per.exp <- as.data.frame(per.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        per.score[j,] <- as.vector(per.exp$mean.exp)
        
        # avg expression (observed)
        av.exp <- (exp.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        expr.score[j,] <- as.vector(av.exp$mean.exp)
        
        pd.exp <- (pct.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        pctdif.score[j,] <- as.vector(pd.exp$mean.exp)
        
        lfc.exp <- (lfc.mat.sub %>% group_by(cluster) %>% summarize(mean.exp= mean(value, na.rm = T)))
        logfc.score[j,] <- as.vector(lfc.exp$mean.exp)
        
      } else {
        per.score[j,] <- 0
        expr.score[j,] <- 0
        logfc.score[j,] <- 0
        pctdif.score[j,] <- 0
      }
    }
    
    per.score <- rcnames.2d(per.score, e.mat, sig)
    expr.score <- rcnames.2d(expr.score, e.mat, sig)
    logfc.score <- rcnames.2d(logfc.score, e.mat, sig)
    pctdif.score <- rcnames.2d(pctdif.score, e.mat, sig)
    
    ###############################
    # calculate GSVA scores
    e.score <- gsva(expr = e.mat, gset.idx.list = sig , method = "zscore",verbose = F)
    
    ##################################
    # store results 
    
    list(
      exp = expr.score,
      gsva = e.score,
      per = per.score,
      logfc = logfc.score,
      pd =pctdif.score,
      sc = expr.score,
      df.n.gene = df.n.gene
    )
    
    
  } else {
    list(
      exp = NULL,
      gsva = NULL,
      per = NULL,
      logfc = NULL,
      pd =NULL,
      sc = NULL,
      df.n.gene = NULL
    )
  } 
  
} 

# stop workers
parallel::stopCluster(cl)

df.n.gene <- NULL
# unpack results
for (i in 1:length(signatures.symbol)){
  which.sig <- names(signatures.symbol)[i]
  sig <- signatures.symbol[[which.sig]] 
  
  # clean lists
  list.lengths <- unlist(lapply(sig, length))
  sig <- sig[list.lengths >= parameter.list$min.geneset.size]
  
  if (length(sig) == 0) next
  
  e.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$gsva, e.mat, sig)
  expr.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$exp, e.mat, sig)
  per.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$per, e.mat, sig)
  pd.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$pd, e.mat, sig)
  logfc.score.list[[which.sig]] <- rcnames.2d(score.results[[i]]$logfc, e.mat, sig)
  sc.mod.score.list[[which.sig]] <- score.results[[i]]$sc
  df.n.gene <-  bind_rows(df.n.gene, score.results[[i]]$df.n.gene)
}


```

```{r merge results df}

#merge 
df.n.gene <- unique(df.n.gene[ ,c("ref.set", "cell", "n.genes.total", "n.genes.available")])

```


```{r data wrangle}

# compare null to results

wrangleHelper <- function(score.list){
  h1.h0.merge <- NULL
  for (i in 1:length(score.list)){
    cur.h1 <-  format.results(score.list[[i]], "H1") 
    h1.h0.merge.cur <- cur.h1
    h1.h0.merge <- bind_rows(h1.h0.merge, h1.h0.merge.cur)
  }
  colnames(h1.h0.merge)[colnames(h1.h0.merge) %in% "cluster.prediction"] <- "pred"
  h1.h0.merge$cell <- gsub("-.*", "", h1.h0.merge$pred)
  h1.h0.merge$ratio <- h1.h0.merge$H1 
  h1.h0.merge <- merge(h1.h0.merge, df.n.gene)
  return(h1.h0.merge)
}

df.dist.expr <- wrangleHelper(expr.score.list)
df.dist.gsva <- wrangleHelper(e.score.list)
df.dist.per <- wrangleHelper(per.score.list)
df.dist.logfc <- wrangleHelper(logfc.score.list)
df.dist.pd <- wrangleHelper(pd.score.list)


```



```{r}

vstScoreThreshold  <- function(x, y, label, set, percentile.threshold = 0.95, 
                               spline.df = 3, quantile.norm = T, loess.center = T, loess.span = 5, center.by.group = T, clip.score = 10){
  
  # purpose: scale and normalize gene set scores 
  # step 1: loess-centering
  #     - ensures that data is not biased and that no outliers skew score distributions
  # step 2: variance-stabilizing transform based on quantile spline regression
  #
  # output: normalized and scaled geneset scores 
  
  # prepare data
  df <- data.frame(x = x, x.log = log(x), y = y,
                   annotation = label, ref.set = set)
  df$cluster <- gsub("-", "", stringr::str_extract(df$annotation, "-c[0-9]*")) 
  
  uni.clust <- unique(df$cluster)
  uni.clust <- uni.clust[order(uni.clust)]
  
  u.set <- unique(df$ref.set)
  
  # loess-centering
  if (loess.center){
    if (center.by.group){
      
      for (i in 1:length(uni.clust)){
        error.loess.mean <- loess(y ~ x.log, df[df$cluster %in% uni.clust[i], ], span = loess.span)
        pred <- predict(error.loess.mean, data.frame(x.log = df$x.log[df$cluster %in% uni.clust[i]]), se = TRUE)[["fit"]]
        df$y.centered[df$cluster %in% uni.clust[i]] <-  df$y[df$cluster %in% uni.clust[i]] - pred
        
      } 
    } else {
      error.loess.mean <- loess(y ~ x.log, df)
      pred <- predict(error.loess.mean, data.frame(x.log = df$x.log), se = TRUE)[["fit"]]
      df$y.centered <-  df$y - pred 
    }
    
    plt.centered <- df %>% ggplot(aes(x = y, y = y.centered)) + geom_point() + 
      labs(x = "Score (Pre-centering)", y = "Score (Post-centering", title = "Score Centering") + 
      geom_abline(linetype = "dashed") + theme_miko()
    
  } else {
    df$y.centered <- df$y
  }
  
  
  
  # quantile-regression based variance stabilization
  if (quantile.norm){
    
    # import splines packages
    if (!require(splines)) stop("splines package not found")
    
    
    for (i in 1:length(uni.clust)){
      
      score.selection <- df$cluster %in% uni.clust[i]
      
      # fit quantile spline regression
      rqfit95 <- rq(y.centered ~ bs((x), df = spline.df), data = df[df$cluster %in% uni.clust[i], ], tau = c(percentile.threshold))
      rqfit05 <- rq(y.centered ~ bs((x), df = spline.df), data = df[df$cluster %in% uni.clust[i], ], tau = c(1-percentile.threshold))
      
      # predict quantiles
      df$qr95[score.selection] <- predict(rqfit95, data.frame(x = (df$x[score.selection])))
      df$qr05[score.selection] <- predict(rqfit05, data.frame(x = (df$x[score.selection])))
      
      # apply transformation
      score.up.selection <- score.selection & (df$y.centered > 0)
      df$ratio[score.up.selection] <- df$y.centered[score.up.selection]/df$qr95[score.up.selection]
      score.down.selection <- score.selection & (df$y.centered < 0)
      df$ratio[score.down.selection] <- df$y.centered[score.down.selection]/(-1*df$qr05[score.down.selection])
      
      # get residuals
      df$residuals95[score.selection] <- rqfit95[["residuals"]]
      df$residuals05[score.selection] <- rqfit05[["residuals"]]

      df$z.sig[score.selection]  <- df$ratio[score.selection] * 1.96 
      df$p.val[score.selection] <- 2*pnorm(abs(df$z.sig[score.selection]), lower.tail = F)
      df$sigUp[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] > 0)
      df$sigDown[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] < 0)
    }
    
    # truncate scores
    df$z.sig[df$z.sig > clip.score] <- clip.score
    df$z.sig[df$z.sig < -clip.score] <- -clip.score
    
    df$color <- "grey"
    df$color[df$sigUp ] <- "tomato"
    df$color[df$sigDown ] <- "skyblue"
    
    plt.vstScore2 <- df %>%
      ggplot(aes(x, y.centered)) +
      geom_point() +
      geom_hline(yintercept = 0, linetype = "dashed", color = "grey") +
      stat_quantile(formula = y ~ bs(x, df = spline.df), quantiles = c(1-percentile.threshold, percentile.threshold), linetype = "dashed", color = "tomato", size = 1) +
      theme_miko(legend = F) + 
      ylab("Annotation Score (loess-centered)") + 
      xlab("Geneset Size (N)") + 
      labs(title = "Variance-Stabilizing Transform", subtitle = paste0("Quant.Regression; B-Spline"))
    
    plt.vstScore <- df %>%
      ggplot(aes(x, z.sig)) + 
      geom_point(color =  df$color) + 
      geom_hline(yintercept = 0, color = "grey", linetype = "dashed") + 
      geom_hline(yintercept = c(1.96), color = "tomato", linetype = "dashed") + 
      geom_hline(yintercept = c(-1.96), color = "skyblue", linetype = "dashed") + 
      theme_miko() + 
      labs(title = "Annotation Scores") + 
      xlab("Gene set size (N)") + 
      ylab("Z-Score")
    
  } else {
    
     for (i in 1:length(uni.clust)){
      
      score.selection <- df$cluster %in% uni.clust[i]
      
            df$ratio[score.selection]   <- df$y.centered[score.selection]
        df$residuals[score.selection]   <- df$y.centered[score.selection]
      df$z.sig[score.selection]  <- (df$y.centered[score.selection] - mean(df$y.centered[score.selection], na.rm = T)) / sd(df$y.centered[score.selection], na.rm = T)
      
            df$p.val[score.selection] <- 2*pnorm(abs(df$z.sig[score.selection]), lower.tail = F)
      df$sigUp[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] > 0)
      df$sigDown[score.selection] <- (df$p.val[score.selection] < 0.05) & (df$z.sig[score.selection] < 0)
    
      
     }
        df$z.sig[df$z.sig > clip.score] <- clip.score
    df$z.sig[df$z.sig < -clip.score] <- -clip.score
    
    df$color <- "grey"
    df$color[df$sigUp ] <- "tomato"
    df$color[df$sigDown ] <- "skyblue"
    
    
        plt.vstScore <- df %>%
      ggplot(aes(x, z.sig)) + 
      geom_point(color =  df$color) + 
      geom_hline(yintercept = 0, color = "grey", linetype = "dashed") + 
      geom_hline(yintercept = c(1.96), color = "tomato", linetype = "dashed") + 
      geom_hline(yintercept = c(-1.96), color = "skyblue", linetype = "dashed") + 
      theme_miko() + 
      labs(title = "Annotation Scores") + 
      xlab("Gene set size (N)") + 
      ylab("Z-Score")

    plt.vstScore2 <- NULL
  }
  
  list(
    results = df,
    plot = plt.vstScore,
    plot.trans = plt.vstScore2
  )
  
}


```


```{r score processing, warning = FALSE, fig.width=14, fig.height=6}

if (parameter.list$vst){
  message("Variance stabilizing and standardizing component scores...")
} else {
  message("Standardizing component scores...")
}
# process scores
vst.exp.list <- vstScoreThreshold(x = df.dist.expr$n.genes.available, y = df.dist.expr$ratio, 
                                  label = df.dist.expr$pred, set = df.dist.expr$ref.set, 
                                  quantile.norm = parameter.list$vst, loess.center = parameter.list$vst)
vst.gsva.list <- vstScoreThreshold(x = df.dist.gsva$n.genes.available, y = df.dist.gsva$ratio, 
                                   label = df.dist.gsva$pred, set = df.dist.gsva$ref.set, 
                                   quantile.norm = parameter.list$vst, loess.center = parameter.list$vst)
vst.per.list <- vstScoreThreshold(x = df.dist.per$n.genes.available, y = df.dist.per$ratio, 
                                  label = df.dist.per$pred, set = df.dist.per$ref.set, 
                                  quantile.norm = parameter.list$vst, loess.center = parameter.list$vst)

vst.logfc.list <- vstScoreThreshold(x = df.dist.logfc$n.genes.available, y = df.dist.logfc$ratio, 
                                    label = df.dist.logfc$pred, set = df.dist.logfc$ref.set, 
                                    quantile.norm = parameter.list$vst, loess.center = parameter.list$vst)
vst.pd.list <- vstScoreThreshold(x = df.dist.pd$n.genes.available, y = df.dist.pd$ratio, 
                                 label = df.dist.pd$pred, set = df.dist.pd$ref.set, 
                                 quantile.norm = parameter.list$vst, loess.center = parameter.list$vst)


# merge results
vst.list <-  list(exp = vst.exp.list$results, 
                  gsva = vst.gsva.list$results, 
                  per= vst.per.list$results, 
                  logfc = vst.logfc.list$results,
                  pd = vst.pd.list$results)

vst.merge <- NULL
for (i in 1:length(vst.list)){
  
  score.name <- names(vst.list)[i]
  if (is.null(vst.merge)){
    vst.merge <- vst.list[[score.name]][ ,c("ref.set", "annotation", "x", "z.sig")]
    colnames(vst.merge) <- c("ref.set", "annotation", "n.genes", score.name )
  } else {
    cur.set <- vst.list[[score.name]][ ,c("ref.set", "annotation", "x", "z.sig")]
    colnames(cur.set) <- c("ref.set", "annotation", "n.genes", score.name )
    vst.merge <- merge(vst.merge, cur.set, by = c("ref.set", "annotation",  "n.genes"), all = T)
  }
  
}

vst.merge$uni.identifier <- paste0(vst.merge$annotation, "-", vst.merge$ref.set)
vst.merge <- vst.merge[!duplicated(vst.merge$uni.identifier), ]


which.scores <- names(vst.list)[names(vst.list) %in% parameter.list$composite.components]
if (length(which.scores) == 0) which.scores <- names(vst.list)

message("Calculating composite scores...")
vst.merge$composite <- apply(vst.merge[ ,which.scores], 1, mean, na.rm = T)
vst.merge[ ,c(names(vst.list), "composite")] <- signif(vst.merge[ ,c(names(vst.list), "composite")], 3)


plt.vstComposite <- vst.merge %>%
  ggplot(aes(x = (n.genes), y = composite)) + 
  geom_hline(yintercept = 0,  color = "grey") + 
  geom_point() + 
  theme_miko() + 
  xlab("Genes/Set") + 
  ylab("Composite Scores") 


# pooled plot
if (parameter.list$vst){
  plt.score.thresholds.resids <- cowplot::plot_grid(vst.exp.list$plot.trans + labs(title = "Expression"),
                                                    vst.gsva.list$plot.trans  + labs(title = "GSVA"),
                                                    vst.per.list$plot.trans  + labs(title = "Expression Fraction"),
                                                    vst.logfc.list$plot.trans  + labs(title = "log FC"),
                                                    vst.pd.list$plot.trans  + labs(title = "Pct Differences"),
                                                    ncol = 5)



plt.score.thresholds <- cowplot::plot_grid(vst.exp.list$plot + labs(title = "Expression", y = "Standardized Component Score"),
                                           vst.gsva.list$plot  + labs(title = "GSVA", y = "Standardized Component Score"),
                                           vst.per.list$plot  + labs(title = "Expression Fraction", y = "Standardized Component Score"),
                                           vst.logfc.list$plot  + labs(title = "Log FC", y = "Standardized Component Score"),
                                           vst.pd.list$plot  + labs(title = "Pct Differences", y = "Standardized Component Score"),
                                           ncol = 5)
} else {
  plt.score.thresholds.resids <- plt.score.thresholds <- NULL
}

# score correlation plots
  plt.rank.cor <- GGally::ggpairs(vst.merge[ ,c(which.scores, "composite")], title="correlogram with ggpairs()", 
                                lower = list(continuous = GGally::wrap("points", alpha = 1), 
                                             combo = GGally::wrap("dot_no_facet", alpha = 1))) +
  theme_bw() + 
  ggtitle("Score Correlations")

# get cluster ID
vst.merge$cluster <- gsub("-", "", stringr::str_extract(vst.merge$annotation, "-c[0-9]*"))
vst.merge$cell.type <- gsub("-c[0-9]*", "", vst.merge$annotation)

message("Calculating consensus scores...")
vst.merge.final <- vst.merge[ ,c("cluster", "cell.type", "ref.set", "n.genes","exp","gsva","per","logfc", "pd", "composite")]
vst.merge.final$z.comp <- signif(apply(vst.merge.final[ ,which.scores], 1, function(x) mean(x, na.rm = T) / sd(x, na.rm = T)), 3)
vst.merge.final$z.comp[((is.infinite(vst.merge.final$z.comp)) | (vst.merge.final$z.comp > 10))] <- 10
vst.merge.final$z.comp[((vst.merge.final$z.comp <= -10))] <- -10
vst.merge.final$cv.comp <- abs(signif(apply(vst.merge.final[ ,which.scores], 1, 
                                            function(x) sd(x, na.rm = T) / mean(x, na.rm = T)), 3))

```



```{r highlight umap clusters}

df.umap.cluster <- data.frame(so.query@reductions[["umap"]]@cell.embeddings)
colnames(df.umap.cluster) <- c("x", "y")

df.umap.cluster$cluster <- so.query@meta.data[["seurat_clusters"]]
plt.cluster.umap <- list()
for (i in 1:length(u.clusters)){
  
  cluster.name <- u.clusters[i]
  
  df.umap.cluster$do.color <- "grey"
  df.umap.cluster$do.color[df.umap.cluster$cluster %in% cluster.name] <- "tomato"
  
  df.umap.cluster <- df.umap.cluster %>% dplyr::arrange(do.color)
  
  plt.cluster.umap[[paste0("c", cluster.name)]] <- df.umap.cluster %>% 
    ggplot(aes(x = x, y = y)) + 
    geom_point(color = df.umap.cluster$do.color, size = autoPointSize(nrow(df.umap.cluster))) + 
    theme_miko() + 
    theme_void() + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = paste0("Cluster ", cluster.name))
  
  
  if (parameter.list$print.inline) print( plt.cluster.umap[[paste0("c", cluster.name)]] )
}

```



```{r wordclouds, fig.width = 15, fig.height =5, include = FALSE, warning = FALSE, message = FALSE}

message("Generating annotation wordclouds...")

sig.thresh <- 1.96
vst.merge.cloud <- vst.merge.final
vst.merge.cloud$sig.lenient <- F
vst.merge.cloud$n.sigUp <- 0
vst.merge.cloud$n.sigDown <- 0

# vst.merge.cloud$sig.lenient 
psum <- function(x) Reduce("+",x)
for (i in 1:length(which.scores)){
 vst.merge.cloud$sig.lenient <-  vst.merge.cloud$sig.lenient | vst.merge.cloud[ ,which.scores[i]] >= sig.thresh
 vst.merge.cloud$n.sigUp <- psum(data.frame(vst.merge.cloud$n.sigUp , vst.merge.cloud[ ,which.scores[i]] >= sig.thresh))
 vst.merge.cloud$n.sigDown <- psum(data.frame(vst.merge.cloud$n.sigDown , vst.merge.cloud[ ,which.scores[i]] <= -1*sig.thresh))
}

vst.merge.cloud$sig.stringent <- vst.merge.cloud$n.sigUp == length(which.scores)

vst.merge.lenient <- vst.merge.cloud %>% dplyr::filter(n.sigUp >= 1)

# map score to color


# all.col1 <- CustomPalette(low = "grey", high = muted("red"), mid = NULL, k = 3)
# up.col <- div_gradient_pal(low = all.col1[1], mid = all.col1[2], high=all.col1[3], space="Lab")
# all.col2 <- CustomPalette(low = muted("blue"), high = "grey", mid = NULL, k = 3)
# down.col <- div_gradient_pal(low = all.col2[1], mid = all.col2[2], high=all.col2[3], space="Lab")
# vst.merge.cloud$colorUp[vst.merge.cloud$z.comp >= 0] <- up.col(rescale(vst.merge.cloud$z.comp[vst.merge.cloud$z.comp >= 0]))
# vst.merge.cloud$colorDown[vst.merge.cloud$z.comp <= 0] <- down.col(rescale(vst.merge.cloud$z.comp[vst.merge.cloud$z.comp <= 0]))

u.cl <- paste("c", u.clusters, sep = "")
plt.ww.list <- list()

show.w <- 15
for (i in 1:length(u.cl)){
  
  vst.merge.subset <- vst.merge.cloud[vst.merge.cloud$cluster %in% u.cl[i], ]
  
  
  if (nrow(vst.merge.subset) >0){
    
    df.f1 <- vst.merge.subset %>%
      dplyr::top_n(show.w, composite)
    
    df.f1$cell.type <- gsub("_|-", " ", df.f1$cell.type)
    df.f1$cell.type <- stringr::str_wrap(df.f1$cell.type, 40)

    w1 <- df.f1 %>%
      ggplot(aes(label = cell.type, color = z.comp, size = abs(composite))) +
      geom_text_wordcloud(scale_size_area = 40, rm_outside = TRUE, eccentricity = 1, show.legend = T) +
      theme_minimal() +
      labs(title  = "Enriched", size = "Composite", color = "Consensus") + 
      theme(plot.title = element_text(hjust = 0.5)) + 
      theme(legend.position = "bottom") + 
      scale_color_gradient(low = "grey", high = scales::muted("red"), breaks = seq(0, 10, by = 2), limits = c(0,10)) + 
      scale_size(breaks = seq(0, 10, by = 5), limits = c(0,10)) + theme(
        legend.title = element_text(color = "black", size = 10),
        legend.text = element_text(color = "black", size = 8) ,
                legend.box.background = element_rect(colour = "black")
      )
    
    df.f2 <- vst.merge.subset %>%
      dplyr::top_n(show.w, -composite)
    
        df.f2$cell.type <- gsub("_|-", " ", df.f2$cell.type)
    df.f2$cell.type <- stringr::str_wrap(df.f2$cell.type, 40)
    w2 <- df.f2 %>%
      ggplot(aes(label = cell.type, color = abs(z.comp), size = abs(composite))) +
      geom_text_wordcloud(scale_size_area = 40, rm_outside = TRUE, eccentricity = 1, show.legend = T) +
      theme_minimal() + 
      labs(title  = "Depleted", size = "-Composite", color = "-Consensus") + 
      theme(plot.title = element_text(hjust = 0.5))  + 
      theme(legend.position = "bottom") + 
      scale_color_gradient(low = "grey", high = scales::muted("blue"), breaks = seq(0, 10, by = 2), limits = c(0,10)) + 
      scale_size(breaks = seq(0, 10, by = 5), limits = c(0,10)) + theme(
        legend.title = element_text(color = "black", size = 10),
        legend.text = element_text(color = "black", size = 8),
        legend.box.background = element_rect(colour = "black")
      )

    plt.ww.list[[u.cl[[i]]]] <- cowplot::plot_grid(plt.cluster.umap[[u.cl[i]]],w1, w2, ncol = 3) 
    if (parameter.list$print.inline) {
      print( plt.ww.list[[u.cl[[i]]]])   
    }
  } 
}  

```


```{r plot signature gene expressions, message=FALSE, warning=FALSE, fig.width = 15, fig.height = 10}

message("Generating dotplots...")

# wrangle genesets into workable format
all.signatures.list <- list()
if (length(signatures.symbol) > 0){
  for (i  in 1:length(signatures.symbol)){
    cur.signature.list.name <- names(signatures.symbol)[i]
    cur.signature.list <- signatures.symbol[[cur.signature.list.name]]
    signature.df <- NULL
    for (j in 1:length(cur.signature.list)){
      if (length(cur.signature.list[[j]])>0){
        cur.signature.name <- names(cur.signature.list)[j]
        cur.signature.df <- as.data.frame(unlist(cur.signature.list[[cur.signature.name]]))
        cur.signature.df$signature <- cur.signature.name
        cur.signature.df <- cur.signature.df[ ,c(2,1)]
        colnames(cur.signature.df) <- c("signature", "genes")
        signature.df <- bind_rows(signature.df,cur.signature.df )
      }
    }
    
    all.signatures.list[[cur.signature.list.name]] <- signature.df
  }
}

plt.signature.subset <- TRUE # (flag specifying whether to plot all or just subset)

# select top genesets to visualize
df.sig2plt.cluster <- unique((vst.merge.cloud %>% dplyr::group_by(cluster) %>% dplyr::top_n(5, composite))[ ,c("cell.type", "ref.set")])
df.sig2plt <- unique((vst.merge.cloud %>% dplyr::filter(sig.lenient,composite > 1) %>% dplyr::arrange(-composite))[ ,c("cell.type", "ref.set")])
if (nrow(df.sig2plt) > 50) df.sig2plt <- df.sig2plt[1:50, ]
df.sig2plt <- unique(bind_rows(df.sig2plt, df.sig2plt.cluster))

# geneset pathway enrichement
u.ref <- unique(df.sig2plt$ref.set)
gene.dot.list <- list()
for (i in 1:length(u.ref)){
gene.dot.list <- c(gene.dot.list, signatures.symbol[[u.ref[i]]][df.sig2plt$cell.type[df.sig2plt$ref.set %in% u.ref[i]]])
}
gene.dot.list <- gene.dot.list[order(names(gene.dot.list))]
dot.hg <- runHG(gene.list = gene.dot.list, gene.universe = rownames(so.query), species = parameter.list$species, pathway.db = parameter.list$pathway.db)
dot.hg.sum <- summarizeHG(dot.hg, show.n = 15)

signature.dot.list <- list()
if (plt.signature.subset){
  for (i in 1:length(all.signatures.list)){
    which.sig <- names(all.signatures.list)[i]
    if (which.sig %in% df.sig2plt$ref.set){
      df.sig2plt.cur <- df.sig2plt[df.sig2plt$ref.set %in% which.sig, ]
      signature.dot.list[[which.sig]] <- all.signatures.list[[which.sig]][all.signatures.list[[which.sig]]$signature %in% df.sig2plt.cur$cell,]
    }
  }
} else {
  signature.dot.list <- all.signatures.list
}
signature.dot.list.all <- list()
signature.dot.list.all[["all"]] <- NULL
for (i in 1:length(signature.dot.list)){
  signature.dot.list.all[["all"]] <- bind_rows( signature.dot.list.all[["all"]], signature.dot.list[[i]])
}

signature.dot.list.all[["all"]] <- unique(signature.dot.list.all[["all"]])


#logical indicating whether to generate gene expression dot plots (computationally intensive)
show.gene.exp <- T 

# generate plots
plt.expression.all.dotplots <- list()
if (show.gene.exp){
  
  for (i in 1:length(signature.dot.list.all)){
    
    cur.signature.list.name <- names(signature.dot.list.all)[i]
    plt.expression.dotplot <- list()
    signature.df <- signature.dot.list.all[[i]]
    u.signatures <- as.vector(unique(signature.df$signature))
    for (j in 1:length(u.signatures)){
      
      cur.signature.df <- signature.df %>% dplyr::filter(signature == u.signatures[j])
      cur.signature.genes <- as.vector(cur.signature.df$genes)
      
      n.genes <- length(cur.signature.genes)
      
      if (n.genes < 11) xlab.size <- 15
      if (n.genes > 10) xlab.size <- 12
      if (n.genes > 40) xlab.size <- 10
      if (n.genes > 50) xlab.size <- 9
      if (n.genes > 60) xlab.size <- 8
      if (n.genes > 70) xlab.size <- 7
      if (n.genes > 80) xlab.size <- 6
      
      p1 <- DotPlot(so.query, features = cur.signature.genes, dot.scale = 8, cols="RdBu") +
        theme_miko(legend =T)  +
        theme(legend.position = "bottom") + 
        RotatedAxis() + 
        ylab("Cell Cluster") + 
        labs(title = u.signatures[j], subtitle = "Dotplot",  caption = paste0(length(cur.signature.genes), " Genes")) +
        theme(axis.text.x=element_text(size=xlab.size, angle = 75)) 
      
      vst.merge.cloud.cur <- vst.merge.cloud %>% dplyr::filter(cell.type == u.signatures[j])
      vst.merge.cloud.cur$cluster2 <- (gsub("c", "", vst.merge.cloud.cur$cluster))
      vst.merge.cloud.cur$cluster <- factor(vst.merge.cloud.cur$cluster, 
                                            levels = paste0("c",  unique(vst.merge.cloud.cur$cluster2)[order(as.numeric(unique(vst.merge.cloud.cur$cluster2)))]))
      p2 <- vst.merge.cloud.cur %>% ggplot(aes(x = cluster, y = composite)) + 
        geom_hline(yintercept = 2, linetype = "dashed") + 
        geom_bar(stat = "identity") + coord_flip() + labs(title = "", subtitle = "Composite Score", y = "Composite Score", x = "Cell Cluster") + theme_miko() 
      
      p3 <- dot.hg.sum$plots[[ u.signatures[j]]] + labs(title = "", subtitle = "Gene Set Enrichment") + theme(legend.position = "bottom")
      # dot.hg.sum$plots$
      
      if (is.null(p3)){
        plt.expression.dotplot[[u.signatures[j]]] <- cowplot::plot_grid(p1, p2, nrow =1,align = "h", axis = "tb", rel_widths = c(2,1), labels = "AUTO")
      } else {
        plt.expression.dotplot[[u.signatures[j]]] <- cowplot::plot_grid(p1, p2,p3,  nrow =1,align = "h", axis = "tb", 
                                                                        rel_widths = c(2,1, 1.25), labels = "AUTO")
      }
      

      

      
      if ((parameter.list$print.inline) & (j < 21)) 
        print( plt.expression.dotplot[[u.signatures[j]]])
    }
    
    plt.expression.all.dotplots[[cur.signature.list.name]] <- plt.expression.dotplot
  }
  
  
}


plt.expression.all.dotplots$all <- plt.expression.all.dotplots$all[order(names(plt.expression.all.dotplots[["all"]]))]

```


```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
if (parameter.list$update.log){
  try({
  run.id <-  updateCentralLog(Module = "M05", input.data = parameter.list$input.file, input.subset = NA, pdf.flag = parameter.list$save.pdf)
  clog.update.success <-  T
}, silent = F)
}



if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M05_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (parameter.list$save.pdf) dir.create(paste0(output.path, "PDF/"))

```

Sample Overview
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Uniform manifold approximation and projection** (UMAP) used to dimensional reduce and visualize data while maintaining global transcriptomic structure. Clusters were determined using unsupervised Louvain community detection.

**Sample Overview**\
Cells, n: `r ncol(so.query)`\
Genes, n: `r nrow(so.query)`\
Variable genes, n: `r length(VariableFeatures(so.query))`\

UMI/cell, median: `r round(median(so.query@meta.data[["nCount_RNA"]]))`\
genes/cell, median: `r round(median(so.query@meta.data[["nFeature_RNA"]]))`\

Clusters, n: `r ulength(so.query$seurat_clusters)`\
Resolution: `r parameter.list$cluster.resolution`\
Species: `r parameter.list$species`

Row {.tabset}
-------------------------------------

### Cluster UMAP

```{r plt.umap_by_c, fig.width = 7, fig.height = 6}
print(plt.umap_by_cluster)
savePDF(file.name = paste0(output.path, "PDF/", "M05_umap_cluster.pdf"), plot.handle = plt.umap_by_cluster, 
        fig.width = 7, fig.height = 5, save.flag = parameter.list$save.pdf)
```



### Sample UMAP

Representation of cell populations across samples. 

```{r plt.umap_by_barcode}

try({
  print(plt.umap_by_barcode)
  savePDF(file.name = paste0(output.path, "PDF/", "M05_umap_barcode.pdf"), plot.handle = plt.umap_by_barcode, 
          fig.width = 7, fig.height = 5, save.flag = parameter.list$save.pdf) 
}, silent = T)

```



### Sample Representation (plot)

Relative abundance of samples across each cell cluster. 

```{r plt.cluster_composition_barcodes, fig.width=13, fig.height=4}

try({
  print(plt.cluster_composition_barcodes)
  savePDF(file.name = paste0(output.path, "PDF/", "M05_cluster_composition_barplot.pdf"), plot.handle = plt.cluster_composition_barcodes, 
          fig.width = 13, fig.height = 4, save.flag = parameter.list$save.pdf)  
}, silent = T)

```

### Sample Representation (table)

```{r df.all_barcodes_wide}

datatable(df.all_barcodes_wide, filter="top", extensions = 'Buttons',
          options = list(pageLength = 50, 
                         autoWidth = TRUE,
                         dom = 'Bfrtip',
                         buttons = c('copy', 'csv', 'pdf')))


```


### Expression Heatmap

```{r exp mat, fig.width = 12, fig.height =5,  warning = FALSE, message = FALSE}

try({
  print(plt.heat.all)
}, silent = T)


```

```{r pdf heat}

try({
  savePDF(file.name = paste0(output.path, "PDF/", "M05_expression_heatmap.pdf"), 
          plot.handle = (plt.heat.all), 
          fig.width = 12, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)

```


Annotation Scores
===================================== 


Sidebar {.sidebar data-width=400}
-------------------------------------

**Cell Annotation Scoring**: Annotate cell clusters using cell-type-specific genesets.\

**Method**: *Consensus scores* and *composite scores* are calculated as follows:\
**Step 1**: Calculate cluster-level *component scores*.\
Scores are calculated for each gene set using each of the following methods:\
* Exp: Gene set (average) expression\
* Per: Expressing Fraction (average)\
* GSVA: Gene set variation analysis\
* LogFC: Log fold-change (average)\
* Pd: Difference in expressing fraction (average)\
**Step 2**: Center scores.\
For each scoring method, component scores are stratified by cluster the relationship between gene set size and component score is fitted using loess regression. The residuals are *centered component scores*.\
**Step 3**: Perform variance stabilization and standardization.\
Centered component scores are stratified by scoring method and cluster, and a variance stabilizing transform is applied using quantile B-spline regression. The scores are then standardized to obtain *standardized component scores*.\
**Step 4**: Determine *composite score*.\
Calculate the *mean* for each set of  standardized component scores to be used to rank cell-type annotations.\ 
**Step 5**: Determine *consensus score*.\
Calculate the *Z-score* for each set of  standardized component scores as measure of consistency across scoring methods\


Row {.tabset data-height=550}
-------------------------------------

```{r Clouds}

u.cl <- unique(as.numeric(as.character((cluster.membership))))
u.cl <- u.cl[order(u.cl)]
u.cl <- paste("c", u.cl, sep = "")

out <- NULL

try({
  
  out <- lapply(seq_along(plt.ww.list), function(i) {
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.ww.list)[i])) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=15, fig.height=5}", paste(i, "detailed_tab"))) 
    a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.ww.list[[%d]])", i)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
  
}, silent = T)

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


Row {.tabset data-height=500}
-------------------------------------

### Scores (top annotations)

```{r lenient filter tab,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}


# vst.merge.final
vst.merge.lenient <- vst.merge.lenient[ ,c("cluster", "cell.type", "ref.set", "n.genes", "exp", "gsva", "per", "logfc", "pd",  "composite", "z.comp")]
colnames(vst.merge.lenient) <- c("cluster", "cell.type", "set", "n.genes", "exp", "gsva", "per", "logfc", "pd",  "composite", "consensus")

try({vst.merge.lenient <- vst.merge.lenient %>% dplyr::select(-c("gen"))}, silent = T)
datatable(vst.merge.lenient, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

if (parameter.list$save.pdf){
write.csv(vst.merge.lenient, file = paste0(output.path, "Tables/", "annotation_scores_significant.csv"), 
          row.names = F) 
}


```


### Scores (all annotations)

```{r no filter tab,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}


colnames(vst.merge.final) <- c("cluster", "cell.type", "set", "n.genes", "exp", "gsva", "per", "logfc", "pd",  "composite", "consensus", "cv.comp")
vst.merge.final <- vst.merge.final %>% dplyr::select(-c("cv.comp"))

try({vst.merge.final <- vst.merge.final %>% dplyr::select(-c("gen"))}, silent = T)
datatable(vst.merge.final, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

if (parameter.list$save.pdf){
  write.csv(vst.merge.final, file = paste0(output.path, "Tables/", "annotation_scores_all.csv"), 
          row.names = F) 
}


```


### Component Score Plots
```{r Score Distributions, fig.width=25, fig.height=5, warning = F, message=F}

print(plt.score.thresholds)
savePDF(file.name = paste0(output.path, "PDF/", "M05_annotation_scores.pdf"), plot.handle = plt.score.thresholds, 
        fig.width = 25, fig.height = 5, save.flag = parameter.list$save.pdf)

```


### Component Score Correlations
```{r Gene-Set Size Relation, fig.width=8, fig.height=7, warning = F, message=F}

print(plt.rank.cor)
savePDF(file.name = paste0(output.path, "PDF/", "M05_score_correlations.pdf"), plot.handle = plt.rank.cor, 
        fig.width = 8, fig.height = 7, save.flag = parameter.list$save.pdf)

```

```{r pdf Clouds,include = FALSE}

for (i in 1:length(u.cl)){
  plot.name <- paste0("M05_wordcloud_", u.cl[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name),
          plot.handle = plt.ww.list[[u.cl[i]]],
          fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
}

```



Gene set Expression
===================================== 


Sidebar {.sidebar}
-------------------------------------

**Gene set expression**: Visualize top cell-type-specific gene sets based on composite scoring. 

**A**| Dotplot visualizing gee expression across different cell clusters.\
**B**| Cluster-level gene set composite scores.\
**C**| Gene set enrichment using hypergeometric over-representation analysis. 

Row {.tabset}
-------------------------------------

```{r expr dotplot}

      out2 <- lapply(seq_along(plt.expression.all.dotplots[[1]]), function(j) {
        
        s1 <- paste("plt.expression.all.dotplots[[", 1, "]][[",j ,"]]", sep = "")
        
        b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", names(plt.expression.all.dotplots[[1]])[j])) # tab header
        b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=15, fig.height=10, message=FALSE, warning=FALSE}", 
                                                paste("expression.dot", 1, j, sep = ""))) 
        b3 <- knitr::knit_expand(text = sprintf("\n%s",s1)) 
        b4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
        
        paste(b1, b2, b3, b4, collapse = '\n')

      })
    

```

`r paste(knitr::knit(text = paste(out2, collapse = '\n')))`

```{r pdf dotplots,include = FALSE}

for (i in 1:length(plt.expression.dotplot)){
  plot.name <- paste0("M05_dotplot_", names(plt.expression.dotplot)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.expression.dotplot[[i]], 
          fig.width = 10, fig.height = 10, save.flag = parameter.list$save.pdf)
}

```

Geneset Tables
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Gene sets**: Gene sets used in the current analysis are provided in tables. 

Row {.tabset}
-------------------------------------

### Summary
```{r}

datatable(df.gs.statistics, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

if (parameter.list$save.pdf){
write.csv(df.gs.statistics, file = paste0(output.path, "Tables/", "geneset_summary.csv"), 
          row.names = F) 
}
```

```{r res4, echo = FALSE, eval = TRUE, message=TRUE, warning=FALSE}
out <- flex.multiTabTables(gs.list, "gs.list")
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


```{r save genelists}

for (i in 1:length(gs.list)){
  table.name <- paste0("genelist_", names(gs.list)[i], ".csv")
  
  if (parameter.list$save.pdf){
  write.csv(gs.list[[1]], file = paste0(output.path, "Tables/",table.name), 
            row.names = F) 
  }
}
```



```{r save analysis log and Rdata results}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", (elapsed.time), df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_5 <- df.log


```




```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 5)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_5)

```


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_5, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

```{r get cell genesets from msigdbr}
# 
# a <- msigdbr_collections()
# df.msd <- msigdbr(species = msd.species, category = msigdb.collection)
# getAnnotationPathways()
# 
# 
# cell.types <- msigdbr(species = "Homo sapiens", category = "C8")
# 
# 
# # colnames(cell.types)
# gs <- cell.types[ ,c("gs_name", "gene_symbol")]
# 
# 
# # gs.wide <- pivot_wider(names_from = "gs_name", values_from = "gene_symbol")
# u.set <- unique(gs$gs_name)
# 
# gene.list <- list()
# for (i in 1:length(u.set)){
#   gene.list[[u.set[i]]] <- gs$gene_symbol[gs$gs_name %in% u.set[i]]
# }
# 
# 
# df.wide <- namedList2wideDF(gene.list)
# 
# # msigdb_cell_types_mouse.csv
# flex.asDT(df.wide)

```