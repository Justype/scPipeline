---
title: "Module Identification"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    self_contained: true
    source_code: embed
    theme: 
      bootswatch: flatly
    navbar:
      - { title: "scMiko", href: "https://nmikolajewicz.github.io/scMiko/" }     
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", 
        paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", 
      paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", "DT", "scales", "STRINGdb","dplyr", "NNLM", "BiocGenerics", "IRanges", "AnnotationDbi",
                   "tidyr", "RColorBrewer", "ggplot2", "heatmaply",
                   "flexdashboard", "future", "BiocParallel",
                   "parallel", "doParallel", "foreach", "iterators")

# load packages
suppressMessages(suppressWarnings(lapply(packages2load, library, character.only = TRUE, quietly = T)))

```



```{r analysis specifications}


# parameter specification
parameter.list <- list(
  # input.file = "M01_NM2_R1_test_300720.Rdata",
  # input.file = "R650_M02_NM2_p14_Meso_FZD2_2000g_integrated_rpca_241021.Rdata",
  # input.file = "R651_M02_NM2_p14_Meso_FZD7_2000g_integrated_rpca_241021.Rdata",
  input.file = "C:/Users/Owner/Dropbox/PDF Projects - JM/Data/scRNA-seq/01_sci-RNA-seq3_Hong_Kevin_Jason/NM_HH/Mesoderm/Papers/Tyser 2021 Dataset/so_tyser2021_220621.rds",
  # input.file = "C:/Users/Owner/Dropbox/PDF Projects - JM/Data/scRNA-seq/01_sci-RNA-seq3_Hong_Kevin_Jason/NM_HH/Mesoderm/Papers/Cao 2020 Dataset/so_cao2020.rds",
  
  cluster.resolution = 0.5, #0.5
  subsample_factor = 1,
  subsample_n = 1000,
  subset.data = NA,
  batch.feature = NA, #"Barcode", # correct for batch feature (set to NA if unspecified)
  feature.selection.method = "hvg", #options: expr, hvg, deviance (Default is expr)
  max.features = 2000, # max number of features to include in network (NA recommended)
  min.pct = 0.5, # large net: 0.1; small net: 0.5 -  min gene expression (applicable only if select.method = "expr")
  data.type = "pearson", #options: pearson (SCTransform), deviance (deviance for count data based on multinomial null model)
  purity.optimization.step.size = 0.05,
  pathway.db = "GO", #Bader, GO
  filter.parameters =  list(
    include = NULL,
    omit = NULL
  ), 
  
  general.weight.by.var = F,
  general.pca.cum.sum = 0.9,
  general.umap.knn = 10,
  general.cluster.purity = 0.8,
  general.scale.free.topology = T,
  general.ica = T,
  general.nmf = T,
  general.nmf.k = c(5, 10, 15),
  general.robust.pca = F,
  
  # misc parameters
  n.workers = 4,
  print.inline = F,
  save.pdf = F,
  update.log = F,
  rprofile.dir = F,
  developer = F
)


```



```{r load data, warning = FALSE}

set.seed(1023)

# Specify data directories
if (parameter.list$rprofile.dir){
  
  dir.preprocessed <- "Preprocessed_Datasets/"
  
  if (!exists("data.path") & !exists("user")) {
    stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
  }
}

miko_message("Importing data...")
if ((!grepl(".Rdata|.RData", parameter.list$input.file)) & !(grepl(".rds", parameter.list$input.file))){
  parameter.list$input.file <- paste0(parameter.list$input.file, ".Rdata")
} 

if (parameter.list$rprofile.dir){
  if (grepl(".Rdata|.RData", parameter.list$input.file)){
    load(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""));
  } else if (grepl(".rds", parameter.list$input.file)) {
    so <- readRDS(paste(data.path, dir.preprocessed, parameter.list$input.file, sep = ""))
  }  
} else {
  if (grepl(".Rdata|.RData", parameter.list$input.file)){
    load(parameter.list$input.file);
  } else if (grepl(".rds", parameter.list$input.file)) {
    so <- readRDS(parameter.list$input.file);
  }
}


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

if ("subsample_n" %in% names(parameter.list)){
  if (ncol(so) > parameter.list$subsample_n){
    parameter.list$subsample_factor <- parameter.list$subsample_n/ncol(so)
  }
}


# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species =  parameter.list$species, 
                         resolution= parameter.list$cluster.resolution, 
                         subset.data = parameter.list$subset.data, 
                         subsample = parameter.list$subsample_factor, 
                         terms2drop = t2d, 
                         rmv.pattern = "so", keep.default.assay.only = F)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

parameter.list$species <- detectSpecies(so.query)

```

```{r filter clusters}

if ("filter.parameters" %in% names(parameter.list)){
  so.query <- clusterFilter(so.query, include = parameter.list$filter.parameters$include, omit = parameter.list$filter.parameters$omit)
  so.query@meta.data[["seurat_clusters"]] <- factor(as.numeric(as.character(so.query@meta.data[["seurat_clusters"]])))
  Idents(object = so.query) <- 'seurat_clusters'
}


```

```{r analysis log, include = FALSE, }

miko_message("Updating analysis log...")

# Initiate and fill analysis Log
df.log <- initiateLog("Module Detection")
df.log <- addLogEntry("PDF saved", parameter.list$save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("Update Central Log", parameter.list$update.log, df.log, "update.log")
df.log <- addLogEntry("Print Inline", parameter.list$print.inline, df.log, "print.inline")

df.log <- addLogEntry("Input file", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Subsample N (max)", parameter.list$subsample_n, df.log, "subsample_n")
df.log <- addLogEntry("data subset", parameter.list$subset.data, df.log, "subset.data")
df.log <- addLogEntry("species", parameter.list$species, df.log, "species")
df.log <- addLogEntry("Batch feature", parameter.list$batch.feature, df.log, "batch.feature")
df.log <- addLogEntry("Data type", parameter.list$data.type, df.log, "data.type")


df.log <- addLogEntry("Feature selection method", parameter.list$feature.selection.method, df.log, "feature.selection.method")
df.log <- addLogEntry("Max number of features", parameter.list$max.features,  df.log, "max.features")
df.log <- addLogEntry("Minimum expr. fraction (only if feature.selection.method = expr)", parameter.list$min.pct, df.log, "min.pct")
df.log <- addLogEntry("Step size in cluster purity search", parameter.list$purity.optimization.step.size, df.log, "purity.optimization.step.size")
df.log <- addLogEntry("Pathway database for enrichment analysis", parameter.list$pathway.db, df.log, "pathway.db")

df.log <- addLogEntry("General| robust PCA", parameter.list$general.robust.pca, df.log, "general.robust.pca")
df.log <- addLogEntry("General| weigh PCA by variance", parameter.list$general.weight.by.var, df.log, "general.weight.by.var")
df.log <- addLogEntry("General| Variance explained by PCA", parameter.list$general.pca.cum.sum, df.log, "general.pca.cum.sum")
df.log <- addLogEntry("General| KNN", parameter.list$general.umap.knn, df.log, "general.umap.knn")
df.log <- addLogEntry("General| Target modular purity", parameter.list$general.cluster.purity, df.log, "general.cluster.purity")
df.log <- addLogEntry("General| Scale-free topology enforced", parameter.list$general.scale.free.topology, df.log, "general.scale.free.topology")

```

```{r get past module logs, include = FALSE}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r recode barcodes, warning = FALSE}

if (exists("barcode.list") && (length(barcode.list) > 0)){
  
  df.meta <- so.query@meta.data
  
  # relabel barcodes
  bc.list <-barcode.list
  df.meta$bc <- NA
  for (i in 1:length(bc.list)){
    pattern <- bc.list[[i]]
    pattern.replace <- names(bc.list)[i]
    df.meta$bc[grepl(pattern, df.meta$Barcode)] <- pattern.replace
  }
  so.query@meta.data <- df.meta
  
} else {
  u.bc <- unique(so.query@meta.data[["Barcode"]])
  bc.list <- list()
  for (i in 1:length(u.bc)){
    bc.list[[i]] <- u.bc[i]
  }
  names(bc.list) <- u.bc
  so.query@meta.data[["bc"]] <- so.query@meta.data[["Barcode"]]
}

```

```{r Network analysis - 1 - feature selection, warning = FALSE}

if ("batch.feature" %in% names(parameter.list)){
  batch_feature <- parameter.list$batch.feature
} else {
  batch_feature <- NULL
}

which.rep.common <- findNetworkFeatures(object = so.query, method = parameter.list$feature.selection.method, 
                                        n_features =  parameter.list$max.features, 
                                        min_pct = parameter.list$min.pct, split_var = "seurat_clusters", 
                                        batch_feature = batch_feature, verbose = T)


```

```{r Network analysis - 2 - generate network, warning = FALSE, include = FALSE}

try({
  so.query <- GetResidual(object = so.query, features = which.rep.common, verbose = T, assay = DefaultAssay(so.query))
}, silent = T)

so.gene <- runSSN(object = so.query , 
                  features = which.rep.common, 
                  scale_free = parameter.list$general.scale.free.topology, 
                  robust_pca = parameter.list$general.robust.pca, 
                  data_type = parameter.list$data.type, 
                  reprocess_sct = F, 
                  slot = c("scale"), 
                  batch_feature = batch_feature, 
                  do_scale = F, do_center = F, 
                  pca_var_explained = parameter.list$general.pca.cum.sum, 
                  optimize_resolution = T, 
                  target_purity = parameter.list$general.cluster.purity, 
                  step_size =  parameter.list$purity.optimization.step.size,
                  n_workers = parameter.list$n.workers, verbose = T)

if (parameter.list$general.scale.free.topology){
  plt.sft <- cowplot::plot_grid(so.gene@misc$scale_free$optimization.plot,
                                so.gene@misc$scale_free$distribution.plot[[as.character(so.gene@misc$scale_free$powerEstimate)]])
} else {
  plt.sft <- NULL
}


if (parameter.list$print.inline) {
  cluster.UMAP(so.gene)
  plt.sft
}

```

```{r run ICA, warning = FALSE}

if (parameter.list$general.ica){
  so.query <- runICA(object = so.query, 
                     features = colnames(so.gene),
                     max_cells = 20000, verbose = T)
}

```

```{r run NMF, warning = FALSE}

if (parameter.list$general.nmf){
  miko_message("Running NMF...")
  
  if (ncol(so.query) > 20000){
    set.seed(1023)
    so.nmf <- so.query[,sample(colnames(so.query), 20000)]
  } else {
    so.nmf <- so.query
  }
  
  nmf.genes <- list()
  
  for (i in parameter.list$general.nmf.k){
    
    miko_message(paste0("\tk = ", i), time = F)
    
    so.nmf <- runNMF(object = so.nmf, assay = DefaultAssay(so.nmf), k = i, raster = F,  features = colnames(so.gene), feature.min.pct = 0, n.threads = 8, max.iter = 50, gene.cutoff = 0.5, gene.n = NA, sample.name = "", pathway.db = parameter.list$pathway.db, verbose = F, do.enrichment = F)
    
    
    ncur <- so.nmf@reductions[[paste0("nmf_k", i)]]@misc[["genes"]] 
    names(ncur) <- paste0("k", i, "_" , names(ncur))
    nmf.genes <- c(nmf.genes, ncur)
  }
  
  so.nmf <- consolidateNMF(object = so.nmf, reduction_key = "nmf")
  so.query@reductions[["nmf"]] <- so.nmf@reductions$nmf_all
  
  rm(so.nmf); invisible({gc()});
}


```



```{r prune clusters}

parameter.list$prune.threshold <- 0.1
mod.list   <- pruneSSN(object = so.gene, graph = "RNA_snn_power", prune.threshold = parameter.list$prune.threshold)
df.con.l2   <- pruneSSN(object = so.gene, graph = "RNA_snn_power", prune.threshold = parameter.list$prune.threshold, return.df = T)

plt.prune <- df.con.l2 %>%
  ggplot(aes(x = wi_l2)) +
  geom_histogram(bins = 30) +
  geom_vline(xintercept = parameter.list$prune.threshold, linetype = "dashed", color = "tomato") +
  labs(x = "Degree (L2 norm)", y = "Count", title = "Network Pruning", subtitle = paste0(signif(100*sum(df.con.l2$wi_l2 <=  parameter.list$prune.threshold)/nrow(df.con.l2), 3), "% (", sum(df.con.l2$wi_l2 <=  parameter.list$prune.threshold), "/", nrow(df.con.l2), ") genes pruning" )) +   theme_miko(grid = T)


do.prune.umap  <- F
if (do.prune.umap){
  
  gene.umap <- getUMAP(so.gene)[["df.umap"]]
  gene.umap$retain <- gene.umap$var %in% unique(unlist(mod.list))
  
  plt.pruneumap <- plt.general.connectivitiy +
    geom_point(data = gene.umap, aes(x = x, y = y, color = retain), size = 0.5) +   scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "tomato"))
  
  
  if (parameter.list$print.inline){
    plt.pruneumap
    plt.prune
  }
  
}

```


```{r Network analysis - 9 - network connectivity prep}

message("Preparing connectivity objects...")
meso.connectivity.list <- SSNConnectivity(so.gene, gene.list = mod.list, 
                                          quantile_threshold = 0.9, raster_dpi = 200)

# generate connectivity plots
plt.general.connectivitiy <- meso.connectivity.list$plot_edge
plt.general.net <- meso.connectivity.list$plot_network

if (parameter.list$print.inline){
  print(plt.general.connectivitiy)
  print(plt.general.net)
}


```




```{r Network analysis - 4 - color palettes, warning = FALSE}

# general network #######################
so.gene@meta.data$seurat_clusters <- as.character(so.gene@meta.data$seurat_clusters)
so.gene@meta.data$seurat_clusters[which(!c(colnames(so.gene) %in% unique(unlist(mod.list))))] <- "other"
# wnnUMAP.list.meso <- getUMAP(so.gene, umap.key = "umap", size = 0.05)
# df.wnn.umap.meso <- wnnUMAP.list.meso$df.umap
# df.wnn.umap.meso$seurat_clusters[is.na(df.wnn.umap.meso$seurat_clusters)] <- "other"
# 
# df.wnn.umap.meso.sum  <- df.wnn.umap.meso %>%
#   dplyr::group_by(seurat_clusters) %>%
#   dplyr::summarize(x.mean = median(x), y.mean = median(y), .groups = 'drop')
# plt.wnn.umap.meso <- wnnUMAP.list.meso$plt.umap +
#   xlab("geneUMAP 1") + ylab("geneUMAP 2") +
#   geom_text(data = df.wnn.umap.meso.sum, aes(x = x.mean, y = y.mean, label = seurat_clusters), inherit.aes = F) + 
#   labs(title = "Transcriptional Network", subtitle = paste0(ncol(so.gene), " genes"))
# 
# # get color palettes for each gene module
# u.mod.p13 <- unique(as.numeric(as.character(so.gene@meta.data$seurat_clusters)))
# u.mod.p13 <- u.mod.p13[!is.na(u.mod.p13)]
# u.mod.p13 <- u.mod.p13[order(u.mod.p13)]
# p13.col <- categoricalColPal(labels = u.mod.p13)
# 
# p13.col <- c(p13.col, "lightgrey")
# names(p13.col) <- c(u.mod.p13, "other")
# plt.wnn.umap.meso <- plt.wnn.umap.meso + scale_color_manual(values = p13.col) + labs(color = "Module")  + guides(color = guide_legend(override.aes = list(size = 5)))
# 
# 
# if (parameter.list$print.inline) {
#   plt.wnn.umap.meso
# }


```



```{r Network analysis - 5 - network expression plots, fig.width=10, fig.height=4, warning = FALSE}

# plt.net.expr.general <- SSNExpression(cell.object = so.query, 
#                                       gene.object = so.gene, 
#                                       features = mod.list,
#                                       connectivity.plot = plt.general.connectivitiy)
```

```{r Network analysis - 6 - combine network expression plots, fig.width= 35, fig.height=30, warning = FALSE}

# if (parameter.list$print.inline) {
#   plt.clut.net.general.highlight <- cowplot::plot_grid(plotlist = plt.net.expr.general, ncol = 3)
#   plt.clut.net.general.highlight
# }

```




```{r summarize gene modules}

plt.ssn.gene.all <- summarizeModules(cell.object = so.query, gene.object = so.gene,
                                     gene.list = mod.list,
                                     module.type = "ssn", 
                                     n.workers = parallel::detectCores(), 
                                     connectivity_plot = plt.general.connectivitiy)
plt.ssn.gene <- pbapply::pblapply(plt.ssn.gene.all$plt.summary, function(x){ cowplot::plot_grid(
  cowplot::plot_grid(
    x$cell.umap +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(plot.subtitle = element_text(hjust = 0.5)), 
    x$gene.umap +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(plot.subtitle = element_text(hjust = 0.5)), nrow = 1, labels = c("A", "B")),
  cowplot::plot_grid(x$bp.enrich, x$mf.enrich, x$cc.enrich, nrow = 1, labels = c("C", "D", "E")),
  ncol = 1
)})
plt.ssn.gene.hm.expr <- heatmaply::heatmaply((plt.ssn.gene.all$data.heatmap), scale = "column",
                                             scale_fill_gradient_fun = scale_fill_miko(),
                                             xlab = "Module", ylab = "Cluster", main = "SSN Module Activity")


if (parameter.list$print.inline) {
  print(plt.ssn.gene)
  plt.ssn.gene.hm.expr
}

if (parameter.list$general.ica){
  plt.ica.gene.all <- summarizeModules(cell.object = so.query, gene.object = so.gene,
                                       module.type = "ica", reduction = "ica",
                                       n.workers = parallel::detectCores(), 
                                       connectivity_plot = plt.general.connectivitiy)
  # plt.ica.gene <- plt.ica.gene.all$plt.summary
  plt.ica.gene <- pbapply::pblapply( plt.ica.gene.all$plt.summary, function(x){ cowplot::plot_grid(
    cowplot::plot_grid(
      x$cell.umap +
        theme(plot.title = element_text(hjust = 0.5)) +
        theme(plot.subtitle = element_text(hjust = 0.5)), 
      x$gene.umap +
        theme(plot.title = element_text(hjust = 0.5)) +
        theme(plot.subtitle = element_text(hjust = 0.5)), nrow = 1, labels = c("A", "B")),
    cowplot::plot_grid(x$bp.enrich, x$mf.enrich, x$cc.enrich, nrow = 1, labels = c("C", "D", "E")),
    ncol = 1
  )})
  plt.ica.gene.hm.expr <- heatmaply::heatmaply((plt.ica.gene.all$data.heatmap), scale = "column",
                                               scale_fill_gradient_fun = scale_fill_miko(),
                                               xlab = "Module", ylab = "Cluster", main = "ICA Module Activity")
  if (parameter.list$print.inline) {
    print(plt.ica.gene)
    plt.ica.gene.hm.expr
  }
}

if (parameter.list$general.nmf){
  plt.nmf.gene.all <- summarizeModules(cell.object = so.query, gene.object = so.gene,
                                       module.type = "nmf", reduction = "nmf",
                                       n.workers = parallel::detectCores(), 
                                       connectivity_plot = plt.general.connectivitiy) 
  # plt.nmf.gene <- plt.nmf.gene.all$plt.summary
  plt.nmf.gene <- pbapply::pblapply(plt.nmf.gene.all$plt.summary, function(x){ cowplot::plot_grid(
    cowplot::plot_grid(
      x$cell.umap +
        theme(plot.title = element_text(hjust = 0.5)) +
        theme(plot.subtitle = element_text(hjust = 0.5)), 
      x$gene.umap +
        theme(plot.title = element_text(hjust = 0.5)) +
        theme(plot.subtitle = element_text(hjust = 0.5)), nrow = 1, labels = c("A", "B")),
    cowplot::plot_grid(x$bp.enrich, x$mf.enrich, x$cc.enrich, nrow = 1, labels = c("C", "D", "E")),
    ncol = 1
  )})
  plt.nmf.gene.hm.expr <- heatmaply::heatmaply((plt.nmf.gene.all$data.heatmap), 
                                               scale_fill_gradient_fun = scale_fill_miko(), scale = "column",
                                               xlab = "Module", ylab = "Cluster", main = "NMF Module Activity")
  if (parameter.list$print.inline) {
    print(plt.nmf.gene)
    # plt.nmf.gene.hm.expr
    # plt.nmf.gene.hm.expr2
    
    # scale = "column",
  }
}


a <- plt.nmf.gene.all$plt.summary$k5_NMF1

```




```{r Fig 4LMN}
# 
# # m3 GABA; #m4 Excitatory
# do.signature <- F
# if (do.signature){
#   
#   mod.list <- readRDS("manno2021_modlist_fig4.rds")
#   so.ps <- readRDS("C:/Users/Owner/Dropbox/PDF Projects - JM/Data/scRNA-seq/01_sci-RNA-seq3_Hong_Kevin_Jason/NM_HH/Mesoderm/Papers/Pijuan-Sala 2019 Dataset/so_pijuan-sala2019.rds")
#   load(paste0(data.path,"Preprocessed_Datasets/",  "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"))
#   so.ts <- readRDS("C:/Users/Owner/Dropbox/PDF Projects - JM/Data/scRNA-seq/01_sci-RNA-seq3_Hong_Kevin_Jason/NM_HH/Mesoderm/Papers/Tyser 2021 Dataset/so_tyser2021_220621.rds")
#   
#   sc.res <- signatureCoherence(object = so.query, genelist = list(m5 = mod.list$m16 ))
#   sc.ps_res <- signatureCoherence(object = downsampleSeurat(so.ps, subsample.n = 30000), genelist = list(m5 = mod.list$m16 ))
#   sc.han_res <- signatureCoherence(object = so, genelist = list(m5 = mod.list$m16 ))
#   sc.ts_res <- signatureCoherence(object = so.ts, genelist = list(m5 = toupper(mod.list$m16 )))
#   
#   # coherence plots
#   sc.res$coherence.plots
#   sc.ps_res$coherence.plots
#   sc.ts_res$coherence.plots
#   
#   # genesets
#   coh_gene <- list(
#     manno2021 = sc.res$genelist.coherent$m5,
#     tyser2021 =  firstup(sc.ts_res$genelist.coherent$m5),
#     pijuansala2019 = sc.ps_res$genelist.coherent$m5
#   )
#   
#   # ven diagram
#   ggVennDiagram::ggVennDiagram(coh_gene)
#   # savePDF("venn_angiogen.pdf", ggVennDiagram::ggVennDiagram(coh_gene))
#   
#   mod.list.coh <- list(m5_raw = sc.han_res$genelist$m5 , 
#                        m5_con = intersect(intersect( sc.res$genelist.coherent$m5, firstup(sc.ts_res$genelist.coherent$m5)), sc.ps_res$genelist.coherent$m5))
#   
#   so.ts <- AddSModuleScore(so.ts, features =  lapply(mod.list.coh, firstup))
#   so.query <- AddSModuleScore(so.query, features =  mod.list.coh)
#   so.ps <- AddSModuleScore(so.ps, features =  mod.list.coh)
#   
#   pltu1 <-     FeaturePlot(so.query, "Clusterm5_con", raster = F) + 
#     scale_color_gradient2(low =scales::muted("blue"), high = scales::muted("red")) +
#     theme_void() + theme(legend.position = "none")
#   
#   pltu2 <-    FeaturePlot(so.ts, "Clusterm5_con", raster = F) + 
#     scale_color_gradient2(low =scales::muted("blue"), high = scales::muted("red")) + theme_miko(legend = F) +
#     theme_void() + theme(legend.position = "none")
#   
#   
#   pltu3 <-   FeaturePlot(so.ps, "Clusterm5_con", raster = F) + 
#     scale_color_gradient2(low =scales::muted("blue"), high = scales::muted("red")) + theme_miko(legend = F) +
#     theme_void() + theme(legend.position = "none")
#   
#   # savePDF("manno_angio_umap.pdf", pltu1, fig.width = 5, fig.height = 4)
#   # savePDF("tyser_angio_umap.pdf", pltu2, fig.width = 5, fig.height = 4)
#   # savePDF("ps_angio_umap.pdf", pltu3, fig.width = 5, fig.height = 5)
#   
# }


```
```{r, fig.width=4, fig.height=10}
# 
# if (do.signature){
#   sc.res$coherence.plots
#   # sc.han_res$coherence.plots
#   sc.ps_res$coherence.plots
#   sc.ts_res$coherence.plots
#   
#   
#   
#   savePDF("manno_angiogenesis_coh.pdf", sc.res$coherence.plots, fig.width=4, fig.height=10)
#   savePDF("ps_angiogenesis_coh.pdf", sc.ps_res$coherence.plots, fig.width=4, fig.height=10)
#   savePDF("ts_angiogenesis_coh.pdf", sc.ts_res$coherence.plots, fig.width=4, fig.height=10)
# }
```

```{r}
# 
# # TF enrichment (optional) https://www.bioconductor.org/packages/release/bioc/vignettes/enrichTF/inst/doc/enrichTF.html#3_How_TF_Enrichment_Works
# 
# do.validation <- F
# figUpdate <- function(a){
#   a <-  a  + theme_void()
#   a[["layers"]][[1]][["aes_params"]][["size"]] <- 0.01
#   return(a)
# }
# # savePDF("m9_ochocka_umap.pdf",figUpdate( mod.res.meso$gene.net.auc$plot.list$c9), fig.width = 6, fig.height = 5)
# # savePDF("m19_ochocka_umap.pdf",figUpdate( mod.res.meso$gene.net.auc$plot.list$c19), fig.width = 6, fig.height = 5)
# # savePDF("m17_ochocka_umap.pdf",figUpdate( mod.res.meso$gene.net.auc$plot.list$c17), fig.width = 6, fig.height = 5)
# # savePDF("m20_ochocka_umap.pdf",figUpdate( mod.res.meso$gene.net.auc$plot.list$c20), fig.width = 6, fig.height = 5)
# 
# 
# if (do.validation){
#   gquery <- mod.list$m19
#   # gquery <- c(mod.list$m11, mod.list$m8)
#   # tcell.gene
#   
#   gresult <- citationCheck(
#     gene.query = gquery,
#     search.query = "inflammation|inflamed|immune|macrophage|monocyte|interferon|ifn|ifng|innate immunity|virus|viral|interferon-gamma|interferon-beta|interleukin|cytokine",
#     # search.query = "macrophage|monocyte|immune|phagocyte",
#     # search.query = "microglia|mg|monocyte|macrophage",
#     # search.query = "T cell|T cells|T-cell|T-cells|TNF|TCR|adaptive immunity|NK|natural killer|NKT", # |NK|natural killer|NKT
#     delay = 0.5,
#     mindate = 2000,
#     maxdate = 2021,
#     verbose = T
#   )
#   df.pub <- gresult$df.pubmed
#   gresult$plt.pubmed
#   
#   novel_gene <- df.pub$gene[df.pub$n.publications == 0]
#   # novel_gene <- c( 'Khdc1a','Klra9', 'Gm33104', 'Sdcbp2', 'Gm12840', 
#   #                  'Sdf4', 'Gm29243', 'Slain1', 'Tcrg-C1', 'Tcrg-C2', 
#   #                  'Tcrg-C4', 'Gm2682', 'Plcxd2') 
#   novel_gene
#   exprUMAP(so.query, novel_gene[1])
#   exprUMAP(so.query, novel_gene[2])
#   exprUMAP(so.query, novel_gene[4])
#   exprUMAP(so.query, novel_gene[5])
#   exprUMAP(so.query, novel_gene[7])
#   
#   
#   
#   # savePDF("m19_Ms4a4c_ochocka_umap.pdf",exprUMAP(so.query, novel_gene[8]), fig.width = 6, fig.height = 5)
#   # exprUMAP(so.query, novel_gene[16])
#   
#   exprUMAP(so.query, "Crybb1") # Microglia-specific (m1)
#   # exprUMAP(so.query, 'Klra9')  # NK cell specific
#   # exprUMAP(so.query, 'Slain1')
#   # exprUMAP(so.query, 'Sdcbp2')
#   # exprUMAP(so.query, 'Plcxd2')
#   exprUMAP(so.query, 'Gm33104')
# }
# 
# 
# 
# ```
# ```{r, fig.width=4, fig.height=10}
# 
# if (do.validation){
#   plt.pub <- df.pub %>%
#     ggplot(aes(y = rank(n.publications), x = n.publications)) + 
#     geom_point(pch = 21, color = "black", fill ="grey") + 
#     labs(x = "N Publications", y = "Rank") + 
#     theme_miko(grid= F) + scale_x_log10()
#   plt.pub
#   
#   
#   # savePDF("pub_citation_ochocka_m19.pdf", plt.pub, fig.width=4, fig.height=10)
#   # scale_x_log10()
# }
# 


```


```{r prep final tables, fig.width=10, fig.height=7}

# General network 
df.general.net <- meso.connectivity.list$df.snn.umap
df.general.net <- df.general.net[ ,c("genes", "x", "y", "seurat_clusters", "wi")]
colnames(df.general.net) <- c("gene", "umap.x", "umap.y",  "module", "degree")

# if (parameter.list$general.ica){
df.general.ssn.gene.list <- namedList2wideDF(plt.ssn.gene.all$module.genes)
# }

if (parameter.list$general.ica){
  df.general.ica.gene.list <- namedList2wideDF(plt.ica.gene.all$module.genes)
}


if (parameter.list$general.nmf){
  df.general.nmf.gene.list <- namedList2wideDF(plt.nmf.gene.all$module.genes)
}

# plt.snn.gene.all

```

```{r jaccard similarity , fig.width=20, fig.height=7}

# jaccard similarity between genesets

if (parameter.list$general.ica){
  j.mat.gene <- jaccardSimilarityMatrix(c(plt.ica.gene.all$module.genes, plt.ssn.gene.all$module.genes))
  plt.j.gene <- ggplotify::as.ggplot(pheatmap::pheatmap(j.mat.gene[grepl("m", rownames(j.mat.gene)), grepl("IC", colnames(j.mat.gene))], silent = T,
                                                        color = CustomPalette(low = "white", high = "tomato", mid = NULL, k = 50))) 
  
  plt.j.gene <- plt.j.gene + labs(title = "Jaccard similarity of SSN- and ICA-derived genesets", 
                                  subtitle = "x: IC geneset; y: SSN geneset; z: jaccard similarity") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(plot.subtitle = element_text(hjust = 0.5))
}

if (parameter.list$general.nmf){
  j.nmf.mat.gene <- jaccardSimilarityMatrix(c(plt.nmf.gene.all$module.genes, plt.ssn.gene.all$module.genes))
  plt.j.nmf.gene <- ggplotify::as.ggplot(pheatmap::pheatmap(j.nmf.mat.gene[grepl("m", rownames(j.nmf.mat.gene)), grepl("NMF", colnames(j.nmf.mat.gene))], silent = T,
                                                            color = CustomPalette(low = "white", high = "tomato", mid = NULL, k = 50))) 
  
  plt.j.nmf.gene <- plt.j.nmf.gene + labs(title = "Jaccard similarity of SNN- and NMF-derived gene modules", 
                                          subtitle = "x: NMF geneset; y: SSN geneset; z: jaccard similarity") +
    theme(plot.title = element_text(hjust = 0.5)) +
    theme(plot.subtitle = element_text(hjust = 0.5))
}


if (parameter.list$general.ica & parameter.list$general.nmf){
  plt.j.summary <- cowplot::plot_grid(plt.j.gene, plt.j.nmf.gene)
} else if (!parameter.list$general.ica & parameter.list$general.nmf){
  plt.j.summary <- plt.j.nmf.gene
} else if (parameter.list$general.ica & !parameter.list$general.nmf){
  plt.j.summary <- plt.j.gene
} else {
  plt.j.summary <- NULL
}


if (parameter.list$print.inline) {
  print(plt.j.summary)
  
}
```



```{r STRING PPI analysis, include = FALSE}

# library(STRINGdb)
ppi.success <- F
try({
  
  ppiEnrich <- function(gene.list, species, verbose = T){
    
    # load library
    require(STRINGdb, quietly = T)
    
    miko_message("Initializing STRING database...", verbose = verbose)
    # initialize constructor
    suppressWarnings({
      suppressMessages({
        if (species == "Hs"){
          string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="")
        } else if (species == "Mm"){
          string_db <- STRINGdb$new( version="11", species=10090, score_threshold=400, input_directory="")
        }
      })
    })
    
    miko_message("Retrieving gene mappings...", verbose = verbose)
    # get symbol to id mapping
    invisible({
      suppressWarnings({
        suppressMessages({
          all.genes <- unique(unlist(gene.list))
          string_map <- string_db$map( data.frame(gene = all.genes), "gene", removeUnmappedRows = TRUE ) 
        })
      })      
    })
    
    
    miko_message("Calculating PPI enrichments...", verbose = verbose)
    # calculate enrichments for each gene module
    df.ppi.enrichment <- NULL
    for (i in 1:length(gene.list)){
      
      module.name <- names(gene.list)[i]
      gene.input <- (string_map %>% dplyr::filter(toupper(gene) %in% toupper(gene.list[[module.name]])))$STRING_id
      
      if (length(gene.input) == 0) next
      
      p.ppi <- string_db$get_ppi_enrichment(gene.input)
      
      if (is.null(p.ppi[["enrichment"]])) next
      
      df.ppi.enrichment <- bind_rows(
        df.ppi.enrichment, 
        data.frame(
          module = module.name,
          p = p.ppi$enrichment,
          observed = p.ppi$edges,
          expected = p.ppi$lambda
        )
      )
    }
    
    
    # which entries missing:
    which.missing <- c()
    which.missing <- names(gene.list)[!(names(gene.list) %in% df.ppi.enrichment$module)]
    if (length(which.missing) > 0){
      for (i in 1:length(which.missing)){
        df.ppi.enrichment <- bind_rows(df.ppi.enrichment,
                                       data.frame(
                                         module = which.missing[i],
                                         p = 1,
                                         observed = 0,
                                         expected = 0
                                       ))
      }
      
    }
    
    # calculate ratio and fdr
    df.ppi.enrichment$ratio <-(df.ppi.enrichment$observed + 1) /   (df.ppi.enrichment$expected + 1)
    df.ppi.enrichment$fdr <- p.adjust(df.ppi.enrichment$p)
    df.ppi.enrichment$fdr[is.na(df.ppi.enrichment$fdr)] <- 1
    
    miko_message("Generating summary plot...", verbose = verbose)
    # generate erichment plot
    plt.ppi.enrich <- df.ppi.enrichment %>%
      ggplot(aes(x = (ratio), y = reorder(module, ratio), color = fdr < 0.05)) + #observed
      geom_vline(xintercept = 1, linetype = "dashed") +
      geom_point(size = 5) + 
      geom_segment(aes(x = 1, xend = ratio, y = reorder(module, ratio), yend = reorder(module, ratio))) + 
      labs(x=  "PPI Enrichment (observed/exected)", y  = "Network Module",
           title = "PPI Enrichment", subtitle = "STRING v11.0 database") + 
      scale_color_manual(values = c("TRUE" = "tomato", "FALSE" = "grey")) + 
      theme_miko(legend = T, grid = T) 
    
    
    miko_message("PPI enrichment complete!", verbose = verbose)
    # return results
    return(list(
      df.result = df.ppi.enrichment,
      plot.enrichment = plt.ppi.enrich
    ))
  }
  
  
  general.ppi.enrich <- ppiEnrich(gene.list = mod.list, species = parameter.list$species, verbose = T)
  ppi.success <- T
}, silent = T)



if (ppi.success){
  plt.general.net.graph <- cowplot::plot_grid(plt.general.net + theme(legend.position = "none"), 
                                              general.ppi.enrich$plot.enrichment + 
                                                theme(legend.position = "bottom"), 
                                              rel_widths = c(1,0.5), nrow = 1)
  
} else {
  plt.general.net.graph <- plt.general.net + theme(legend.position = "none")
}

```



```{r validation analysis}
# do.validation <- F
# 
# if (do.validation){
#   
#   ref.gs <- c(plt.ica.gene.all[["ica.module.genes"]], plt.nmf.gene.all[["nmf.module.genes"]])
#   
#   bhg_m2r <- runHG(gene.list = mod.list, gene.universe = colnames(so.gene), species = parameter.list$species, my.pathway = ref.gs, my.pathway.representation = "SYMBOL")
#   
#   bhg_r2m <- runHG(gene.list = ref.gs, gene.universe = colnames(so.gene), species = parameter.list$species, my.pathway = mod.list, my.pathway.representation = "SYMBOL")
#   
#   bhg_sum_m2r <- summarizeHG(bhg_m2r)
#   bhg_sum_r2m <- summarizeHG(bhg_r2m)
#   
#   df.bhg_m2r <- bhg_sum_m2r$results
#   df.bhg_r2m <- bhg_sum_r2m$results
#   
#   df.bhg.sum_m2r <- df.bhg_m2r %>%
#     dplyr::mutate(sig = padj < 0.05) %>%
#     dplyr::group_by(geneset) %>%
#     dplyr::summarize(rep = sum(sig) > 0)
#   
#   df.bhg.sum_r2m <- df.bhg_r2m %>%
#     dplyr::mutate(sig = padj < 0.05) %>%
#     dplyr::group_by(geneset) %>%
#     dplyr::summarize(rep = sum(sig) > 0)
#   
#   
#   which.unique <- df.bhg.sum_m2r$geneset[!df.bhg.sum_m2r$rep]
#   
#   
#   # bhg_sum$plots
#   
#   # compare scale_free vs no scale_free ########################################
#   
#   raw_res <- SSNResolution(object = so.gene, graph = "RNA_snn",
#                            target.purity = parameter.list$general.cluster.purity, start.res = 1, verbose = F,
#                            step.size = parameter.list$purity.optimization.step.size, target.level = "global", max.iter = 100)
#   sf_res <- best.reg.general
#   
#   so.gene_raw <- RunUMAP(so.gene, dims = 1:n.dim, n.neighbors = parameter.list$general.umap.knn, reduction  = "pca")
#   so.gene_raw <- FindClusters(so.gene_raw,  resolution = raw_res, modularity.fxn = 1, algorithm =1)
#   
#   # graph.name = "RNA_nn",
#   
#   so.gene_sf <- FindClusters(so.gene, graph.name = "RNA_snn_power", resolution = sf_res, modularity.fxn = 1, algorithm =1)
#   
#   
#   
#   ari <-   fossil::adj.rand.index(as.numeric(as.factor(so.gene_raw@meta.data$seurat_clusters)), 
#                                   group2 = as.numeric(as.factor(so.gene_sf@meta.data$seurat_clusters)))
#   
#   
#   cluster.UMAP(so.gene_raw)
#   cluster.UMAP(so.gene_sf)
#   
#   
#   mod.list_sc   <- pruneClusters(object = so.gene_sf, graph = "RNA_snn_power", prune.threshold = 0.1)
#   mod.list_raw   <- pruneClusters(object = so.gene_raw, graph = "RNA_snn", prune.threshold = 0.1)
#   
#   bhg_sc <- runHG(gene.list = mod.list_sc, gene.universe = colnames(so.gene), 
#                   species = parameter.list$species, my.pathway = ref.gs, my.pathway.representation = "SYMBOL")
#   bhg_raw <- runHG(gene.list = mod.list_raw, gene.universe = colnames(so.gene), 
#                    species = parameter.list$species, my.pathway = ref.gs, my.pathway.representation = "SYMBOL")  
#   
#   
#   
#   bhg_sum_sc <- summarizeHG(bhg_sc)
#   bhg_sum_raw <- summarizeHG(bhg_raw)
#   
#   df.bhg_sc <- bhg_sum_sc$results
#   df.bhg_raw <- bhg_sum_raw$results
#   
#   df.bhg.sum_sc <- df.bhg_sc %>%
#     dplyr::mutate(sig = padj < 0.05) %>%
#     dplyr::group_by(geneset) %>%
#     dplyr::summarize(rep = sum(sig) > 0)
#   
#   df.bhg.sum_raw <- df.bhg_raw %>%
#     dplyr::mutate(sig = padj < 0.05) %>%
#     dplyr::group_by(geneset) %>%
#     dplyr::summarize(rep = sum(sig) > 0)
#   
#   do.cao2019 <- F
#   if (do.cao2019){
#     
#     parameter.list$species <- "Mm"
#     go_sf <- runHG(gene.list = lapply(mod.list_sc, firstup), gene.universe = firstup(rownames(so.query)), species = parameter.list$species)
#     go_raw <- runHG(gene.list = lapply(mod.list_raw, firstup), gene.universe =  firstup(rownames(so.query)), species = parameter.list$species)  
#     go_ica <- runHG(gene.list = lapply(plt.ica.gene.all[["ica.module.genes"]], firstup), 
#                     gene.universe =  firstup(rownames(so.query)), species = parameter.list$species)  
#     go_nmf <- runHG(gene.list = lapply(plt.nmf.gene.all[["nmf.module.genes"]], firstup), 
#                     gene.universe =  firstup(rownames(so.query)), species = parameter.list$species) 
#     
#     general.ppi.sf <- ppiEnrich(gene.list = lapply(mod.list_sc, firstup), species = parameter.list$species, verbose = T)
#     general.ppi.raw <- ppiEnrich(gene.list = lapply(mod.list_raw, firstup), species = parameter.list$species, verbose = T)
#     general.ppi.nmf <- ppiEnrich(gene.list = lapply(plt.nmf.gene.all[["nmf.module.genes"]], firstup), species = parameter.list$species, verbose = T)
#     general.ppi.ica <- ppiEnrich(gene.list = lapply(plt.ica.gene.all[["ica.module.genes"]], firstup), species = parameter.list$species, verbose = T) 
#     
#   } else {
#     go_sf <- runHG(gene.list = mod.list_sc, gene.universe = rownames(so.query), species = parameter.list$species)
#     go_raw <- runHG(gene.list = mod.list_raw, gene.universe = rownames(so.query), species = parameter.list$species)  
#     go_ica <- runHG(gene.list = plt.ica.gene.all[["ica.module.genes"]], 
#                     gene.universe = rownames(so.query), species = parameter.list$species)  
#     go_nmf <- runHG(gene.list = plt.nmf.gene.all[["nmf.module.genes"]], 
#                     gene.universe = rownames(so.query), species = parameter.list$species)
#     
#     general.ppi.sf <- ppiEnrich(gene.list = mod.list_sc, species = parameter.list$species, verbose = T)
#     general.ppi.raw <- ppiEnrich(gene.list = mod.list_raw, species = parameter.list$species, verbose = T)
#     general.ppi.nmf <- ppiEnrich(gene.list = plt.nmf.gene.all[["nmf.module.genes"]], species = parameter.list$species, verbose = T)
#     general.ppi.ica <- ppiEnrich(gene.list = plt.ica.gene.all[["ica.module.genes"]], species = parameter.list$species, verbose = T) 
#     
#   }
#   
#   
#   
#   
#   go_sf.sum <- summarizeHG(go_sf)
#   go_raw.sum <- summarizeHG(go_raw)
#   go_ica.sum <- summarizeHG(go_ica)
#   go_nmf.sum <- summarizeHG(go_nmf)
#   
#   
#   sig.terms_sf <- unique(go_sf.sum$results$pathway[go_sf.sum$results$padj < 0.05])
#   sig.terms_raw <- unique(go_raw.sum$results$pathway[go_raw.sum$results$padj < 0.05])
#   sig.terms_ica <- unique(go_ica.sum$results$pathway[go_ica.sum$results$padj < 0.05])
#   sig.terms_nmf <- unique(go_nmf.sum$results$pathway[go_nmf.sum$results$padj < 0.05])
#   
#   
#   ggVennDiagram::ggVennDiagram(list(
#     sf = sig.terms_sf,
#     raw = sig.terms_raw,
#     ica = sig.terms_ica,
#     nmf = sig.terms_nmf
#   ))
#   
#   
#   
#   df.go_sf <- go_sf.sum[["results"]] %>% 
#     dplyr::group_by(geneset) %>% dplyr::summarise(score = (sum(padj < 0.05) > 0))
#   # %>% dplyr::summarize(score = sum(score)/ length(score))
#   
#   df.go_raw <- go_raw.sum[["results"]] %>% 
#     dplyr::group_by(geneset) %>% dplyr::summarise(score = (sum(padj < 0.05) > 0))
#   
#   df.go_nmf <- go_ica.sum[["results"]] %>% 
#     dplyr::group_by(geneset) %>% dplyr::summarise(score = (sum(padj < 0.05) > 0))
#   
#   df.go_ica <- go_nmf.sum[["results"]] %>% 
#     dplyr::group_by(geneset) %>% dplyr::summarise(score = (sum(padj < 0.05) > 0))
#   
#   
#   general.ppi.sf$plot.enrichment
#   general.ppi.raw$plot.enrichment
#   general.ppi.nmf$plot.enrichment
#   general.ppi.ica$plot.enrichment
#   
#   
#   df.string <- data.frame(
#     type = c("net_raw", "net_sf", "nmf", "ica"),
#     string_ratio = c(  median(general.ppi.raw$df.result$ratio),
#                        median(general.ppi.sf$df.result$ratio),
#                        median(general.ppi.nmf$df.result$ratio),
#                        median(general.ppi.ica$df.result$ratio)),
#     go_logp = c(  mean(df.go_sf$score),
#                   mean(df.go_raw$score),
#                   mean(df.go_nmf$score),
#                   mean(df.go_ica$score))
#   )
#   
#   df.string %>%
#     ggplot(aes(x = reorder(type, -string_ratio), y = string_ratio)) +
#     geom_bar(stat = "identity")
#   
#   median(general.ppi.sf$df.result$ratio)
#   median(general.ppi.raw$df.result$ratio)
#   median(general.ppi.nmf$df.result$ratio)
#   median(general.ppi.ica$df.result$ratio)
#   
#   
#   res <-    list(
#     genelist = list(
#       sf = mod.list_sc,
#       raw = mod.list_raw,
#       nmf = plt.ica.gene.all[["ica.module.genes"]],
#       ica = plt.nmf.gene.all[["nmf.module.genes"]]
#     ),
#     ppi = list(
#       sf = general.ppi.sf,
#       raw = general.ppi.raw,
#       nmf = general.ppi.nmf,
#       ica = general.ppi.ica
#     ),
#     enrich = list(
#       sf = go_sf.sum,
#       raw = go_raw.sum,
#       nmf = go_nmf.sum,
#       ica = go_ica.sum        
#     ),
#     similarity = list(
#       sf = so.gene@graphs[["RNA_snn_power"]],
#       raw = so.gene@graphs[["RNA_snn"]],
#       nmf = nmf_object,
#       ica = ica.res.gene            
#     ),
#     gene.universe = rownames(so.query),
#     net.universe = colnames(so.gene)
#   )
#   
#   
#   
#   # res
#   
#   
#   
#   # saveRDS(res, file = "cao2019_net_res_v2_021121.rds")
#   
#   # Q which approach retrieves the most unique terms/processes?
#   
#   #     go_sf.sum <- summarizeHG(go_sf)
#   # go_raw.sum <- summarizeHG(go_raw)
#   # go_ica.sum <- summarizeHG(go_ica)
#   # go_nmf.sum <- summarizeHG(go_nmf)
#   
# }
# 
# 
# 
# # enchmarking with known interacting pairs
# # To test the ability of UMAP distance, and other distance metrics, to capture known interactions, we used a curated consensus set of protein complexes derived from two large, high-throughput mass spectrometry datasets and GO interactions2. The consensus set was transformed into a pairwise Boolean interaction matrix based on whether or not each pair had been observed together in the known complex set. Using the subset of pairs that were found in the set of 1484 single-gene deletion transcriptome datasets, for each gene pair, we calculated Euclidean distance in UMAP space. We then used these distances, along with labels for true and false interacting gene pairs derived from gold standard interaction datasets, to generate receiver operating characteristic (ROC) and precision/recall curves with the PRROC package in R27.


```




```{r pan data evaluation, fig.width=20, fig.height=5}
# 
# if (do.validation){
#   
#   # res_tyser <- readRDS("tyser2021_net_res_011121.rds")
#   
#   moduleStat <- function(res, species){
#     
#     gs <- res$genelist
#     
#     hg <- pbapply::pblapply((lapply(res$enrich, function(x) x$results)), function(x) x$pathway[x$padj < 0.001])
#     pathname <- unique(unlist(hg))
#     
#     my.symbol <- res$net.universe
#     my.entrez <- sym2entrez(my.symbol, my.species = species)
#     my.entrez <- my.entrez[complete.cases(my.entrez), ]
#     
#     e2s <- my.entrez$SYMBOL
#     names(e2s) <- as.character(my.entrez$ENTREZID)
#     
#     pathways <- getAnnotationPathways(query.genes = my.entrez$ENTREZID, db = "Bader", ontology = "BP", species =species)
#     pathways_sub <- pathways[pathname]
#     pathway_gene <- pbapply::pblapply(pathways_sub, function(x) e2s[as.character(x)])
#     pathway_gene <- pbapply::pblapply(pathway_gene, function(x) x[!is.na(x)])
#     pathway_gene <- pathway_gene[unlist(lapply(pathway_gene, length)) > 0]
#     
#     
#     sf.genes <- gs$sf;  raw.genes <- gs$raw;
#     names(sf.genes) <- paste0("sf_", names(sf.genes))
#     names(raw.genes) <- paste0("raw_", names(raw.genes))
#     
#     gs_query <- c(raw.genes, sf.genes, gs$nmf, gs$ica); names(gs_query) <- paste0("query_", names(gs_query))
#     jmat <- jaccardSimilarityMatrix(gene.sets = gs_query, y = pathway_gene)
#     # jmat_sub <- jmat 
#     jmat_sub_raw <- jmat[grepl("query_raw", rownames(jmat)), !grepl("query_sf|query_raw|NMF|ICM", colnames(jmat))]
#     jmat_sub_sf <- jmat[grepl("query_sf", rownames(jmat)), !grepl("query_sf|query_raw|NMF|ICM", colnames(jmat))]
#     jmat_sub_nmf <- jmat[grepl("NMF", rownames(jmat)), !grepl("query_sf|query_raw|NMF|ICM", colnames(jmat))]
#     jmat_sub_ica <- jmat[grepl("ICM", rownames(jmat)), !grepl("query_sf|query_raw|NMF|ICM", colnames(jmat))]
#     
#     
#     centerf <- median
#     ppi <- res$ppi
#     df.stat <- data.frame(
#       type = c("raw", "sf", "nmf", "ica"),
#       recovery = c(centerf(apply(jmat_sub_raw, 2, max)), centerf(apply(jmat_sub_sf, 2, max)), 
#                    centerf(apply(jmat_sub_nmf, 2, max)), centerf(apply(jmat_sub_ica, 2, max))),
#       relevance = c(centerf(apply(jmat_sub_raw, 1, max)), centerf(apply(jmat_sub_sf, 1, max)), 
#                     centerf(apply(jmat_sub_nmf, 1, max)), centerf(apply(jmat_sub_ica, 1, max))),
#       ppi.recovery = c(centerf(ppi[["raw"]][["df.result"]][["ratio"]]),  centerf(ppi[["sf"]][["df.result"]][["ratio"]]), 
#                        centerf(ppi[["nmf"]][["df.result"]][["ratio"]]), centerf(ppi[["ica"]][["df.result"]][["ratio"]]))
#     )
#     
#     
#     
#     
#     
#     
#     # PPI stats
#     # ppi <- res$ppi
#     
#     return(df.stat)
#     
#     
#     
#   }
#   
#   
#   getModularity <- function(res, set = ""){
#     
#     require(igraph)
#     
#     raw.graph <- res$similarity$raw
#     sf.graph <- res$similarity$sf
#     
#     raw.igraph <- graph_from_adjacency_matrix(
#       adjmatrix = as.matrix(raw.graph),
#       mode = c("undirected"),
#       weighted = T
#     )
#     
#     sf.igraph <- graph_from_adjacency_matrix(
#       adjmatrix = as.matrix(sf.graph),
#       mode = c("undirected"),
#       weighted = T
#     )
#     
#     raw_mod <- modularity(cluster_louvain(graph = raw.igraph, weights = NULL))
#     sf_mod <-modularity(cluster_louvain(graph = sf.igraph, weights = NULL))
#     
#     df.modularity = data.frame(
#       type = c("raw", "sf"),
#       modularity =c(raw_mod, sf_mod),
#       set = set
#     )
#     
#     return(df.modularity)
#     
#   }
#   
#   
#   
#   
#   
#   res_tyser <- readRDS("tyser2021_net_res_011121.rds")
#   res_han <- readRDS("han2021_net_res_011121.rds")
#   res_ochocka <- readRDS("ochocka2021_net_res_011121.rds")
#   res_cao2020 <- readRDS("cao2020_net_res_011121.rds")
#   res_ps2019 <- readRDS("ps2019_net_res_011121.rds")
#   res_zeisel <- readRDS("zeisel2018_net_res_021121.rds")
#   res_manno <- readRDS("manno2021_net_res_021121.rds")
#   res_cao2019 <- readRDS("cao2019_net_res_v2_021121.rds")
#   
#   res_cao2019[["genelist"]] <- lapply(res_cao2019[["genelist"]], function(x) lapply(x, firstup))
#   res_cao2019[["gene.universe"]] <- firstup(res_cao2019[["gene.universe"]]); 
#   res_cao2019[["net.universe"]] <- firstup(res_cao2019[["net.universe"]])
#   
#   df.stat.tyser <- moduleStat(res_tyser, species = "Hs"); df.stat.tyser$set <- "Tyser2021"
#   df.stat.han <- moduleStat(res_han, species = "Mm"); df.stat.han$set <- "Han2021"
#   df.stat.ochocka <- moduleStat(res_ochocka, species = "Mm"); df.stat.ochocka$set <- "Ockocka2021"
#   df.stat.cao2020 <- moduleStat(res_cao2020, species = "Hs"); df.stat.cao2020$set <- "Cao2020"
#   df.stat.ps2020 <- moduleStat(res_ps2019, species = "Mm"); df.stat.ps2020$set <- "Pijuan-Sala2019"
#   df.stat.zeisel <- moduleStat(res_zeisel, species = "Mm"); df.stat.zeisel$set <- "Zeisel2018"
#   df.stat.manno <- moduleStat(res_manno, species = "Mm"); df.stat.manno$set <- "Manno2021"
#   df.stat.cao2019 <- moduleStat(res_cao2019, species = "Mm"); df.stat.cao2019$set <- "Cao2019"
#   
#   df.stat <- bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(df.stat.tyser, df.stat.han), df.stat.ochocka), df.stat.cao2020), df.stat.ps2020), df.stat.zeisel), df.stat.manno), df.stat.cao2019)
#   
#   
#   df.mod.tyser <-  getModularity(res_tyser, "Tyser2021")
#   df.mod.han <-  getModularity(res_han, "Han2021")
#   df.mod.ochocka <- getModularity(res_ochocka, "Ochocka2021")
#   df.mod.cao2020 <-  getModularity(res_cao2020, "Cao2020")
#   df.mod.ps2019 <-  getModularity(res_ps2019, "Pijuan-Sala2019")
#   df.mod.zeisel <-  getModularity(res_zeisel, "Zeisel2018")
#   df.mod.manno <-  getModularity(res_manno, "Manno2021")
#   df.mod.cao2019 <-  getModularity(res_cao2019, "Cao2019")
#   
#   df.mod <- bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(bind_rows(df.mod.tyser, df.mod.han), df.mod.ochocka), df.mod.cao2020), df.mod.ps2019), df.mod.zeisel), df.mod.manno), df.mod.cao2019)
#   
#   
#   
#   
#   df.stat.sum <- df.stat %>%  dplyr::group_by(set) %>% 
#     dplyr::mutate(ppi.norm = ppi.recovery/sum(ppi.recovery),
#                   rec.norm = recovery/sum(recovery)) %>% 
#     dplyr::group_by(type) %>% 
#     dplyr::summarize(ppi.sum = mean(ppi.norm),
#                      rec.sum = mean(rec.norm))
#   
#   plt.recovery <- df.stat %>%
#     dplyr::group_by(set) %>%
#     # dplyr::mutate(rec.norm = recovery/recovery[type == "sf"]) %>%
#     dplyr::mutate(type = factor(type, levels = c("raw", "sf", "ica", "nmf"))) %>%
#     dplyr::mutate(rec.norm = recovery/sum(recovery)) %>%
#     # ggplot(aes(x = reorder(type, -rec.norm) , y  = rec.norm, fill = set)) +
#     ggplot(aes(x = type , y  = rec.norm, fill = set)) +
#     geom_bar(stat= "identity", position = "dodge") +
#     geom_hline(yintercept = df.stat.sum$rec.sum) +
#     labs(x = "Module Type", y = "Recovery (Relative)") +
#     theme_miko(grid = T, legend = T, fill.palette = "ptol") +
#     coord_cartesian(ylim = c(0.15, 0.35)) + 
#     labs(title = "GO Term Recovery", subtitle = "Comparison of module detection methods")
#   
#   plt.ppi <- df.stat %>%
#     dplyr::group_by(set) %>%
#     dplyr::mutate(ppi.norm = ppi.recovery/sum(ppi.recovery)) %>%
#     dplyr::mutate(type = factor(type, levels = c("raw", "sf", "ica", "nmf"))) %>%
#     # dplyr::mutate(ppi.norm = ppi.recovery/ppi.recovery[type == "sf"]) %>%
#     ggplot(aes(x = type , y  = ppi.norm, fill = set)) +
#     # ggplot(aes(x = reorder(type, -ppi.norm) , y  = ppi.norm, fill = set)) +
#     geom_bar(stat= "identity", position = "dodge") +
#     geom_hline(yintercept = df.stat.sum$ppi.sum) +
#     labs(x = "Module Type", y = "PPI Enrichment (Relative)") +
#     theme_miko(grid = T, legend = T, fill.palette = "ptol") +
#     coord_cartesian(ylim = c(0.15, 0.35)) + 
#     labs(title = "PPI Enrichment", subtitle = "Comparison of module detection methods")
#   
#   plt.modularity <- df.mod %>%
#     ggplot(aes(x= reorder(type, modularity), y = modularity)) + 
#     # geom_bar(stat = "identity", position = "dodge") + 
#     geom_boxplot(fill = "grey") + 
#     geom_point(size= 3, aes(color = set)) +
#     geom_line(aes(group = set, color = set), size = 1) + 
#     labs(x = "Module Type", y = "Modularity") + 
#     # ylim()
#     theme_miko(legend = T, grid = T, color.palette  = "ptol") + 
#     labs(title = "Scale-Free Modularity", subtitle = "Raw vs. Scale-Free Topology")
#   # ggthemes::
#   
#   plt.merge <- cowplot::plot_grid(plt.modularity, plt.recovery, plt.ppi, nrow = 1, labels = "AUTO")
#   plt.merge
#   
#   # savePDF("net_vaidation_v2.pdf",plt.merge, fig.width=20, fig.height=5)
#   
#   df.stat <- df.stat %>%
#     dplyr::group_by(set) %>%
#     dplyr::mutate(rec.norm = recovery/sum(recovery))
#   aov.res <- aov(rec.norm ~ type, data = df.stat)
#   summary(aov.res)
#   
#   
#   df.stat <-  df.stat %>%  dplyr::group_by(set) %>% 
#     dplyr::mutate(ppi.norm = ppi.recovery/sum(ppi.recovery),
#                   rec.norm = recovery/sum(recovery))
#   
#   # pairwise.t.test(x = df.stat$rec.norm, g = df.stat$type, p.adjust.method = "BH")
#   #  pairwise.t.test(x = df.stat$ppi.norm, g = df.stat$type, p.adjust.method = "BH")
#   
# }


```


```{r central log}

# update central log

if (parameter.list$developer){
  run.id <- NULL
  if (!exists("user")) user <- "guest"
  
  clog.update.success <- F
  if (parameter.list$update.log){
    try({
      run.id <-  updateCentralLog(Module = "M37", input.data = input.file, input.subset = NA, pdf.flag = parameter.list$save.pdf)
      clog.update.success <-  T
    }, silent = F) 
  }
  
  if (is.null(run.id))  {
    warning("Central log update was unsuccessful :(\n")
    run.id <- paste("M37_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
  }
} else {
  run.id <- paste("output_", gsub(":| ", "", paste0(format(Sys.time(), '%X'))), sep = "", collapse = "")
}


```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
if (parameter.list$save.pdf){
  dir.create(output.path)
  dir.create(paste0(output.path, "Tables/"))
  dir.create(paste0(output.path, "PDF/"))
}


```

```{r flex plot helper function}

flexPlotOutput <- function(header.name, fig.width, fig.height, chunk.name, plot.name, do.print = T){
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", header.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf(paste0("\n```{r %s, message=FALSE, warning=FALSE, fig.width = ",fig.width, ", fig.height= ", fig.height, "}"),  
                                          chunk.name))
  
  if (do.print){
    a3 <- knitr::knit_expand(text = sprintf("\n %s", paste0("print(", plot.name, ")"))) 
  } else {
    a3 <- knitr::knit_expand(text = sprintf("\n %s", plot.name)) 
  }
  
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk'
  out <- paste(a1, a2, a3, a4, collapse = '\n') 
  
  return(out)
}

```


Sample Overview
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Uniform manifold approximation and projection** (UMAP) used to dimensionally reduce and visualize data while maintaining global transcriptomic structure. Clusters were determined using unsupervised Louvain community detection.

**Sample Overview**\
Cells, n: `r ncol(so.query)`\
Genes, n: `r nrow(so.query)`\
Variable genes, n: `r try({length(VariableFeatures(so.query))}, silent = T)`\

UMI/cell, median: `r try({round(median(so.query@meta.data[["nCount_RNA"]]))}, silent = T)`\
genes/cell, median: `r try({round(median(so.query@meta.data[["nFeature_RNA"]]))}, silent = T)`\

Clusters, n: `r ulength(so.query$seurat_clusters)`\
Resolution: `r parameter.list$cluster.resolution`\
Species: `r try({parameter.list$species}, silent = T)`

Row 
-------------------------------------

### UMAP

```{r plt.umap_by_c, fig.width=7, fig.height=6}

plt.umap.final <- cluster.UMAP(so.query) + theme_miko(legend = T) + labs(title = "UMAP", subtitle = paste0(ncol(so.query), " cells | ", ulength(so.query$seurat_clusters), " clusters"))
print(plt.umap.final)
savePDF(file.name = paste0(output.path, "PDF/", "M37_umap_cluster.pdf"), plot.handle = plt.umap.final,
        fig.width = 7, fig.height = 6, save.flag = parameter.list$save.pdf)
```

Module Activity
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Module Activity**

**Description**:  Cluster-level module activities.

**Method**:  Modular activities were computed and average cluster-level expression was visualized on hierarchically-clustered heatmap.\

**Definitions**:\
m| SSN gene modules\
IC| independent-component-derived gene module\
NMF| Non-negative matrix factorization gene module\
k| Number of latent factors derived for NMF.\
c| cell cluster


Row {.tabset data-height=400}
-------------------------------------

### SSN

```{r general network module heatmap, fig.width=10, fig.height=8}

plt.ssn.gene.hm.expr

savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_module_activity.pdf"), plot.handle = plt.ssn.gene.hm.expr,
        fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)

```



```{r general network ICA heatmap, fig.width=10, fig.height=8}

if (parameter.list$general.ica){
  
  # print(plt.ssn.gene.hm.expr)
  out <- flexPlotOutput(header.name = "ICA", fig.width = 10, fig.height = 8, chunk.name = "ica.gene.hm.expr", plot.name = "plt.ica.gene.hm.expr", do.print= F)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_ic_activity.pdf"), plot.handle = plt.ica.gene.hm.expr,
          fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)
}


```

`r if (parameter.list$general.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`


```{r general network NMF heatmap, fig.width=10, fig.height=8}

if (parameter.list$general.nmf){
  out <- flexPlotOutput(header.name = "NMF", fig.width = 10, fig.height = 8, chunk.name = "nmf.gene.hm.expr", plot.name = "plt.nmf.gene.hm.expr", do.print= F)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_nmf_activity.pdf"), plot.handle = plt.nmf.gene.hm.expr,
          fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)
}


```

`r if (parameter.list$general.nmf){paste(knitr::knit(text = paste(out, collapse = '\n')))}`


Functional Annotation
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Transcription Network**

**Description**: Functional annotation of modules. 

**Method**: Scale-free shared nearest neighbor network (SSN) was visualized using gene-centric UMAP representation. In network graph, each node represents individual gene, and linkages represent shared nearest neighbor (SNN) similarity, computed as jaccard similarity of KNN graph. SSN modules, IC-derived and NMF-derived gene-sets were functionally annotated using hypergeometric over-representation analysis. Modular activities were computed and cell-level activities were projected onto cellular UMAP. 

**Figure Legends**:\
**A|** Module activity overlaid on cellular UMAP.\
**B|** SSN network graph, with module-specific features highlighted and top features annotated (based on connectivity).
**C-E|** Functional annotation of gene module using hypergeometric overrepresentation analysis of Gene Ontology (GO) for Biological Processes (**C**), Molecular Functions (**D**), and Cellular Components (**E**)\

**Definitions**:\
m| SSN gene modules\
IC| independent-component-derived gene module\
NMF| Non-negative matrix factorization gene module\
k| Number of latent factors derived for NMF.\
c| cell cluster


Row {.tabset data-height=600}
-------------------------------------

### SSN Network

```{r general network graph, fig.width=9, fig.height=6}

if (!ppi.success){
  print(plt.general.net.graph)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_graph.pdf"), plot.handle = plt.general.net.graph,
          fig.width=9, fig.height=6, save.flag = parameter.list$save.pdf)
}

```

```{r general network graph2, fig.width=12, fig.height=6}

if (ppi.success){
  print(plt.general.net.graph)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_graph.pdf"), plot.handle = plt.general.net.graph,
          fig.width=12, fig.height=6, save.flag = parameter.list$save.pdf)
}

```

```{r general network annotations - modules}
# mod.subnet.gene$



out <- lapply(seq_along(plt.ssn.gene), function(i) {
  
  s1 <- names(plt.ssn.gene)[i]
  s2 <- paste0("plt.ssn.gene[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=10}",  #fig.width = 8, fig.height=8, 
                                          paste("gwnet_enrich_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

for (i in 1:length(plt.ssn.gene)){
  plot.name <- paste0("general_moduleAnnotation_", names(plt.ssn.gene)[i], ".pdf")
  try({
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle =  plt.ssn.gene[[i]], 
            fig.width = 15, fig.height = 10, save.flag = parameter.list$save.pdf)
  }, silent = T)
}


# plt.ssn.gene.all$plt.summary$m0

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r general network annotations - ICA}

if (parameter.list$general.ica){
  out <- lapply(seq_along(plt.ica.gene), function(i) {
    
    s1 <- names(plt.ica.gene)[i]
    s2 <- paste0("plt.ica.gene[[", i, "]]")
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=10}",  #fig.width = 8, fig.height=8, 
                                            paste("ICA_summary_", i, sep = "")))
    a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
  
  
  for (i in 1:length(plt.ica.gene)){
    plot.name <- paste0("general_icaAnnotation_", names(plt.ica.gene)[i], ".pdf")
    try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.ica.gene[[i]], 
              fig.width = 25, fig.height = 5, save.flag = parameter.list$save.pdf)
    }, silent = T)
  }
} 

```

`r if (parameter.list$general.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`


```{r general network annotations - NMF}


# plt.nmf.gene$
if (parameter.list$general.nmf){
  out <- lapply(seq_along(plt.nmf.gene), function(i) {
    
    s1 <- names(plt.nmf.gene)[i]
    s2 <- paste0("plt.nmf.gene[[", i, "]]")
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=10}",  #fig.width = 8, fig.height=8, 
                                            paste("NMF_summary_", i, sep = "")))
    a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
  
  
  for (i in 1:length(plt.nmf.gene)){
    plot.name <- paste0("general_nmfAnnotation_", names(plt.nmf.gene)[i], ".pdf")
    try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.nmf.gene[[i]],
              fig.width = 25, fig.height = 5, save.flag = parameter.list$save.pdf)
    }, silent = T)
  }
} 


```

`r if (parameter.list$general.nmf){paste(knitr::knit(text = paste(out, collapse = '\n')))}`



Gene Sets
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Gene set similarity matrix** represents the jaccard similarity between modules derived by different methods. If only one module detection method was used, this result is not shown.\

**SSN network layout** provides the UMAP coordinates and module membership and connectivity of each gene.\

**SSN gene modules** List of genes belonging to each SSN-derived module. 

**ICA gene modules** List of genes belonging to each ICA-derived module (not shown if ICA was not performed).

**NMF gene modules** List of genes belonging to each NMF-derived module (not shown if NMF was not performed). 

**Definitions**:\
SSN| scale-free shared-nearest neighbors\
ICA| independent-component analysis\
NMF| Non-negative matrix factorization\
k| Number of latent factors derived for NMF.\
c| cell cluster



Row {.tabset}
-------------------------------------



```{r jaccard similarity, fig.width=20, fig.height=7}

try({
  out <- flexPlotOutput(header.name = "Gene set Similarity Matrix", fig.width = 20, fig.height = 7, chunk.name = "jaccard similarity output", plot.name = "plt.j.summary")
  
  if (!is.null(plt.j.summary)){
    savePDF(file.name = paste0(output.path, "PDF/", "M37_geneset_jaccard_similarity.pdf"), plot.handle = plt.j.summary,
            fig.width=20, fig.height=7, save.flag = parameter.list$save.pdf)
  }
  
}, silent = T)

```

`r try({if (!is.null(plt.j.summary)){paste(knitr::knit(text = paste(out, collapse = '\n')))}}, silent = T)`

### SSN network layout

SSN network table. 

```{r general net umap table, fig.width=20, fig.height=7}

flex.asDT(df.general.net)

```


### SSN gene modules

SSN gene modules

```{r general ssn set table, fig.width=20, fig.height=7}

flex.asDT(df.general.ssn.gene.list)

```



### ICA gene modules

ICA gene modules

```{r general ica set table, fig.width=20, fig.height=7}

try({
  flex.asDT(df.general.ica.gene.list)
}, silent = T)

```

### NMF gene modules

NMF gene modules

```{r general nmf set table, fig.width=20, fig.height=7}

try({
  flex.asDT(df.general.nmf.gene.list)
}, silent = T)

```


```{r}

a1 <- knitr::knit_expand(text = sprintf("\n%s", "Scale-Free Topology"))
a2 <- knitr::knit_expand(text = "\n=====================================")
out1 <- paste(a1, a2, collapse = '\n')

```

`r if (( parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(out1, collapse = '\n'))) }`


```{r}

#   a1 <- knitr::knit_expand(text = sprintf("\n%s", "TF Network"))
# a2 <- knitr::knit_expand(text = sprintf("\n%s\n", "====================================="))
a3 <- knitr::knit_expand(text = sprintf("\n%s", "Sidebar {.sidebar}"))
a4 <- knitr::knit_expand(text = sprintf("\n%s\n", "-------------------------------------"))
a5 <- knitr::knit_expand(text = "\n**Scale-Free Topology**\n\n**Description**: A network is scale-free if connectivity densities approximate a power-law distribution. In such a case, the majority of genes have few connections, and relatively few 'hub' genes are highly-interconnected. To enforce a scale-free network topology, a range of soft thresholding powers are evaluated, and the optimal soft-thresholding power is used for network construction.\n\n**Methods**: Adopting the framework from weighted correlation analysis (WGCNA), an adjacency matrix is constructed from the shared nearest neighor (snn) graph. Specifically, the adjaceny matrix is defined as the snn graph raised to the soft-thresholding power. To identify the optimal soft-thresholding power, the scale free topology fit index is calculated as the correlation (R^2) between log transformed N linkages and N nodes for a range of powers. The optimal power is taken as the lowest power for which the scale free topology fit (R^2) exceeds 0.9. The adjacency matrix obtained for ths power is used to construct the network UMAP and identify network gene modules. \n\n**Citation**: Zhang, B., & Horvath, S. (2005). A general framework for weighted gene co-expression network analysis. Statistical applications in genetics and molecular biology, 4(1).")

out2 <- paste(a3, a4,a5, collapse = '\n')

```

`r if ((parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(out2, collapse = '\n'))) }`

```{r scale free}

r1 <- knitr::knit_expand(text = sprintf("\n%s", "Row {.tabset}"))
r2 <- knitr::knit_expand(text = sprintf("\n%s\n", "-------------------------------------"))

row.chunk <- paste(r1, r2,collapse = '\n')

a1 <- knitr::knit_expand(text = sprintf("### %s\n", "General Network"))  # tab header
a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 10, fig.height=5}",  #fig.width = 8, fig.height=8,
                                        paste("gene_scale_free", 1, sep = "")))
a3 <- knitr::knit_expand(text = sprintf("\n %s", "print(plt.sft)"))
a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

a1.chunk <- paste(a1, a2, a3, a4, collapse = '\n') 


try({
  savePDF(file.name = paste0(output.path, "PDF/", "general_scaleFree_parameterOptimization.pdf"), plot.handle =  plt.sft, 
          fig.width = 10, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)


```

`r if ((parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(row.chunk, collapse = '\n'))) }`

`r if ((parameter.list$general.scale.free.topology)){paste(knitr::knit(text = paste(a1.chunk, collapse = '\n')))}`







```{r finalize log}

# Update analysis log
n.cells.analyzed <- nrow(so.gene)
n.genes.general <- ncol(so.gene)
df.log <- addLogEntry("Number of cells analyzed", n.cells.analyzed, df.log, "n.cells.analyzed")
df.log <- addLogEntry("Number of cells in general network", n.genes.general, df.log, "n.genes.general")
df.log <- addLogEntry("Seurat Assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")
df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
if (parameter.list$developer){
  df.log <- addLogEntry("User", user, df.log, "user")
  df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")
}

df.log_Module_37 <- df.log

```



```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 37)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_37)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_37, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

System Info
=====================================

```{r}

pander::pander(sessionInfo())

```
