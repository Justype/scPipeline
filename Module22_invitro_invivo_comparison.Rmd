---
title: "Module22_invitro_invivo_comparison"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform",
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", "ddpcr",  "future")


library("viridis")

# load packages
lapply(packages2load, library, character.only = TRUE)


```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
}

```


```{r parameter specification}

# Specify data directories
dir.preprocessed <- "Preprocessed Datasets/"

# Query input
input.file <- "Module2_DataIntegration_Celsius_T12_invitro_ds4000_rencaSubset_010320.Rdata"
# input.file.invitro <- "Module1_pilot2_invitroRenca_290220.Rdata"
# input.file.invivo <- "Module2_Renca_cell_nuc_sci_T12_4000ds_Celsius_integrated_240220.Rdata"

# Data subsampling
subsample_factor <- 1

cluster.resolution <- 0.3
# subsample_factor.invitro <- 0.5 # OPTIONAL; range 0 to 1 (default = 1)
# subsample_factor.invivo <- 0.05 # OPTIONAL; range 0 to 1 (default = 1)

print.inline <- T

```




```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("21, Cluster Composition")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# # Query
# df.log[nrow(df.log)+1, 1] <- as.character("Input File (in vitro)")
# df.log[nrow(df.log), 2] <- as.character("input.file.invitro")
# df.log[nrow(df.log), 3] <- as.character(input.file.invitro)
# 
# # Query
# df.log[nrow(df.log)+1, 1] <- as.character("Input File (in vivo)")
# df.log[nrow(df.log), 2] <- as.character("input.file.invivo")
# df.log[nrow(df.log), 3] <- as.character(input.file.invivo)
# 
# # subsampling
# df.log[nrow(df.log)+1, 1] <- as.character("Subsample Factor")
# df.log[nrow(df.log), 2] <- as.character("subsample_factor.invitro")
# df.log[nrow(df.log), 3] <- as.character(subsample_factor.invitro)
# 
# # subsampling
# df.log[nrow(df.log)+1, 1] <- as.character("Subsample Factor")
# df.log[nrow(df.log), 2] <- as.character("subsample_factor.invivo")
# df.log[nrow(df.log), 3] <- as.character(subsample_factor.invivo)

 # Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)

# Subsample
df.log[nrow(df.log)+1, 1] <- as.character("Subsample Factor")
df.log[nrow(df.log), 2] <- as.character("subsample_factor")
df.log[nrow(df.log), 3] <- as.character(subsample_factor)



```



```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```



```{r gene representation}

# check what format genes are represented in (ensembl or symbol)
check.gene_rep <- function(cur_gene.list, cur_rep){
  
  ensembl_rep <- sum(as.vector(names(cur_gene.list)) %in% cur_rep)
  symbol_rep <- sum(toupper(as.vector(cur_gene.list)) %in% toupper(cur_rep))
  
  if (ensembl_rep > symbol_rep){
    gene.rep <- "ensembl"
  } else if (symbol_rep > ensembl_rep){
    gene.rep <- "symbol"
  } else {
    gene.rep <- NA
  }
  
  return(gene.rep)
  
}
```


```{r load data}
# 
# # load in vitro data
# load(paste(dir.preprocessed, input.file.invitro, sep = ""))
# 
# so <- fix.barcode.label(so)
# so.vitro <- so
# rm(so)
# 
# # subsample (for dev purposes)
# n.subset <- round(subsample_factor.invitro *ncol(so.vitro))
# cell.ind <- sample(x = seq(1, ncol(so.vitro)), size = n.subset, replace = FALSE, prob = NULL)
# so.vitro <- SubsetData(so.vitro , cells = cell.ind)
# 
# # load in vivo data
# load(paste(dir.preprocessed, input.file.invivo, sep = ""))
# 
# so <- fix.barcode.label(so)
# so.vivo <- so
# rm(so)
# 
# # subsample (for dev purposes)
# n.subset <- round(subsample_factor.invivo *ncol(so.vivo))
# cell.ind <- sample(x = seq(1, ncol(so.vivo)), size = n.subset, replace = FALSE, prob = NULL)
# so.vivo <- SubsetData(so.vivo , cells = cell.ind)

```

```{r}
# load data
load(paste(dir.preprocessed, input.file, sep = ""))

so <- fix.barcode.label(so)
so.query <- so
rm(so)

# subsample (for dev purposes)
n.subset <- round(subsample_factor *ncol(so.query))
cell.ind <- sample(x = seq(1, ncol(so.query)), size = n.subset, replace = FALSE, prob = NULL)
so.query <- SubsetData(so.query , cells = cell.ind)

```

```{r}

# # get expression matrices
# in.vivo.exp <- so.vivo@assays[[DefaultAssay(so.vivo)]]@scale.data
# in.vitro.exp <- so.vitro@assays[[DefaultAssay(so.vitro)]]@scale.data
# 
# # get  in vitro genes
# in.vitro.genes <- rownames(in.vitro.exp)
# in.vitro.rep <- check.gene_rep(gNames.list, in.vitro.genes)
# if (in.vitro.rep == "ensembl") in.vitro.genes <- as.vector(gNames.list[in.vitro.genes])
# rownames(in.vitro.exp) <- in.vitro.genes
# 
# # get in vivo genes
# in.vivo.genes <- rownames(in.vivo.exp)
# in.vivo.rep <- check.gene_rep(gNames.list, in.vivo.genes)
# if (in.vivo.rep == "ensembl") in.vivo.genes <- as.vector(gNames.list[in.vivo.genes])
# rownames(in.vivo.exp) <- in.vivo.genes
# 
# 
# # get common genes
# all.genes <- c(in.vitro.genes, in.vivo.genes)
# common.genes <- unique(all.genes[duplicated(all.genes)])
# # common.genes <- common.genes[common.genes %in% in.vitro.genes]
# # common.genes <- common.genes[common.genes %in% in.vivo.genes]
# 
# 
# # expression subset (based on common gene sets)
# in.vivo.sub <- in.vivo.exp[in.vivo.genes %in% common.genes, ]
# in.vitro.sub <- in.vitro.exp[in.vitro.genes %in% common.genes, ]
# 
# genes.ordered <- rownames(in.vivo.sub)[order(rownames(in.vivo.sub))]
# in.vivo.sub <- in.vivo.sub[genes.ordered, ]
# in.vitro.sub <- in.vitro.sub[genes.ordered, ]
# 
# dim(in.vivo.sub)
# dim(in.vitro.sub)
# 
# dis.mat <- cancor(in.vivo.sub, in.vitro.sub)

```




```{r}

    # heat.object <- gplots::heatmap.2( mat, labCol= colnames(mat),
    #                  trace="none", 
    #                  col= rev(hmcol),
    #                  ColSideColors= cols, 
    #                  breaks = c(min(mat), 
    #                             seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat)),
    #                  distfun = function(x) as.dist(1-cor(t(x))),
    #                  hclustfun = function(x) hclust(x, method="average"),
    #                  main = "Gene Exp Matrix",
    #                  xlab = "Cluster ID")

# sim.mat <- cor(in.vivo.sub, in.vitro.sub)
# 
# colnames(in.vivo.sub) <- rep("invivo", ncol(in.vivo.sub))
# colnames(in.vitro.sub) <- rep("invitro", ncol(in.vitro.sub))
# 
# combined.mat <- cbind(in.vivo.sub,in.vitro.sub )

# dis.mat[["xcoef"]][dis.mat[["xcoef"]] > 2] <- 2
# dis.mat[["xcoef"]][dis.mat[["xcoef"]] < -2] <- -2
# 
#     heat.object <- gplots::heatmap.2( dis.mat[["ycoef"]])
```


```{r}

# # heatmap colors
# hmcol <- colorRampPalette(brewer.pal(9, "RdBu"))(100)
# 
# scale.min = -1
# scale.max = 1 
# 
# scale.breaks <- c(seq(scale.min, scale.max, by = ((scale.max-scale.min)/100)))
# 
# # scale.breaks <- c(seq(min(combined.mat), max(combined.mat), by = ((max(combined.mat)-min(combined.mat))/100)))
# 
# # cluster colors
# # qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
# # col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
# # cols <- sample(col_vector, ncol)
# 
# 
# gplots::heatmap.2( combined.mat,
#                    trace="none", 
#                    col= rev(hmcol),
#                    breaks = scale.breaks,
#                    distfun = function(x) as.dist(1-cor(t(x))),
#                    hclustfun = function(x) hclust(x, method="average"))

```



```{r}


group.field <- "batch" # batch used when using intergration dataset
group.list <- list(in.vivo = ".T",
                   in.vitro  = "invitro")

membership.n <- c()
membership.list <- list()

keep.this <- NULL
for (i in 1:length(group.list)){
  
  cur.group <- names(group.list)[i]
  cur.pattern <- (group.list)[[i]]
  
  u.members <- as.vector(unique(so.query@meta.data[[group.field]][grepl(cur.pattern, so.query@meta.data[[group.field]])]))
  membership.list[[cur.group]] <- u.members
  membership.n[i] <- length(u.members)
  
  if (is.null(keep.this)){
    keep.this <- grepl(cur.pattern, so.query@meta.data[[group.field]])
  } else {
    keep.this <- (keep.this | grepl(cur.pattern, so.query@meta.data[[group.field]]))
  }
  
  so.query@meta.data[["group.query"]][grepl(cur.pattern, so.query@meta.data[[group.field]])] <- cur.group
  
  
}

so.query <-so.query[, keep.this]

```

```{r get clusters}

cur.cluster.resolution <- paste(DefaultAssay(so.query), "_snn_res.", cluster.resolution, sep = "")

if (!(cur.cluster.resolution %in% names(so.query@meta.data))){
    so.query <- FindClusters(object = so.query, 
                             resolution = cluster.resolution, 
                             verbose = 0, 
                             algorithm = 1, 
                             modularity.fxn = 1)
  
}



```


```{r}

so.list <- SplitObject(DietSeurat(so.query), split.by = "group.query")


for (i in 1:length(so.list)){
  DefaultAssay(so.list[[i]]) <- "RNA"
  so.list[[i]]@assays[["SCT"]] <- NULL
  so.list[[i]]@assays[["integrated"]] <- NULL
  
  # standard log-normalization
   so.list[[i]] <- NormalizeData( so.list[[i]])
   so.list[[i]] <- FindVariableFeatures( so.list[[i]], selection.method  = "mvp")
   
   all.genes <- rownames( so.list[[i]])
   so.list[[i]] <- ScaleData( so.list[[i]], features = all.genes)
  
}


exp.mat.raw <- NULL

df.meta.raw <- NULL

for (i in 1:length(so.list)){
  if (i == 1){
    exp.mat.raw <-  so.list[[i]]@assays[[DefaultAssay(so.list[[i]])]]@scale.data
    df.meta.raw <- so.list[[i]]@meta.data
  } else {
    exp.mat.raw <-  cbind(exp.mat.raw, so.list[[i]]@assays[[DefaultAssay(so.list[[i]])]]@scale.data)
    df.meta.raw <- bind_rows(df.meta.raw, so.list[[i]]@meta.data)
  }
}

```


```{r compute correlation matrices}

# library(coop)



# correlation matrices
res.orig <- coop::pcor(so.query@assays[[DefaultAssay(so.query)]]@scale.data)
res.raw.orig <- coop::pcor(exp.mat.raw)

```



```{r prep ordered matrices}

# integrated 
res <- res.orig
id <- so.query@meta.data[["group.query"]]

cluster.id <- as.vector(so.query@meta.data[[cur.cluster.resolution]])
cluster.id.order <- order(as.numeric(as.character((cluster.id))))
u.cluster.ordered <- unique(cluster.id)[order(as.numeric(as.character(unique(cluster.id))))]

# sort and filter matrix
rownames(res) <- cluster.id
colnames(res) <- cluster.id

id.ordered <- id[cluster.id.order]
res <- res[cluster.id.order, cluster.id.order]

res <- res[id.ordered %in% "in.vivo", ]
res <- res[, id.ordered %in% "in.vitro"]




# raw
res.raw <- res.raw.orig
id.raw <- df.meta.raw$group.query

cluster.id.raw <- as.vector(df.meta.raw[,cur.cluster.resolution])
cluster.id.raw.order <- order(as.numeric(as.character((cluster.id.raw))))
u.cluster.raw.ordered <- unique(cluster.id.raw)[order(as.numeric(as.character(unique(cluster.id.raw))))]

# sort and filter matrix
rownames(res.raw) <- cluster.id.raw
colnames(res.raw) <- cluster.id.raw

id.raw.ordered <- id.raw[cluster.id.raw.order]
res.raw <- res.raw[cluster.id.raw.order, cluster.id.raw.order]

res.raw <- res.raw[id.raw.ordered %in% "in.vivo", ]
res.raw <- res.raw[, id.raw.ordered %in% "in.vitro"]


```


```{r}


aggregate.matrix <- function(mat){
  u.rows <- unique(rownames(mat))
  u.cols <- unique(colnames(mat))
  
  agg.mat <- matrix(nrow = length(u.rows), ncol = length(u.cols))
  
  for (i  in 1:length(u.rows)){
    for (j in 1:length(u.cols)){
      agg.mat[i,j] <- mean(mat[(rownames(mat) %in%  u.rows[i]), (colnames(mat) %in%  u.cols[j])])
    }
  }
  
  rownames(agg.mat) <- u.rows
  colnames(agg.mat) <- u.cols
  
  return(agg.mat)
}


agg.mat <- signif(aggregate.matrix(res), 2)
agg.mat.raw <- signif(aggregate.matrix(res.raw), 2)

# u.rows <- unique(rownames(res))
# u.cols <- unique(colnames(res))
# 
# agg.mat <- matrix(nrow = length(u.rows), ncol = length(u.cols))
# 
# for (i  in 1:length(u.rows)){
#   for (j in 1:length(u.cols)){
#     agg.mat[i,j] <- mean(res[(rownames(res) %in%  u.rows[i]), (colnames(res) %in%  u.cols[j])])
#   }
# }
# 
# rownames(agg.mat) <- u.rows
# colnames(agg.mat) <- u.cols
  


```


```{r}

hmcol <- colorRampPalette(brewer.pal(9, "RdBu"))(100)

max.mat <- max(agg.mat)
min.mat <- min(agg.mat)
limit.val <- max(c(abs(max.mat), abs(min.mat)))
limit.val <- 0.3
 scale.breaks <- c(seq(-limit.val, limit.val, by = ((2*limit.val/100))))

gplots::heatmap.2(x = agg.mat, trace = 'none', col = rev(hmcol), Rowv = NA,Colv = NA, ylab = ("in vivo"),  xlab = ("in vitro"), breaks = scale.breaks,  margins = c(4, 4), main = "In vitro vs In vivo")

max.mat.raw <- max(agg.mat.raw)
min.mat.raw <- min(agg.mat.raw)
limit.val.raw <- max(c(abs(max.mat.raw), abs(min.mat.raw)))
limit.val.raw <- 0.3
 scale.breaks <- c(seq(-limit.val.raw, limit.val.raw, by = ((2*limit.val.raw/100))))

gplots::heatmap.2(x = agg.mat.raw, trace = 'none', col = rev(hmcol), Rowv = NA,Colv = NA, ylab = ("in vivo"),  xlab = ("in vitro"), breaks = scale.breaks,  margins = c(4, 4), main = "In vitro vs In vivo")

# gplots::heatmap.2(x = agg.mat, trace = 'none', col = rev(hmcol), Rowv = NA,Colv = NA, ylab = ("in vivo"),  xlab = ("in vitro"), breaks = scale.breaks,  margins = c(4, 4), main = "In vitro vs In vivo", cellnote=agg.mat, notecol = "grey10", notecex = 1)

diag.val <- diag(agg.mat)
diag.val

```


```{r}

# hmcol <- colorRampPalette(brewer.pal(9, "RdBu"))(100)
# 
# max.mat <- max(res)
# min.mat <- min(res)
# 
# limit.val <- max(c(abs(max.mat), abs(min.mat)))
# 
# 
# limit.val <- 0.3
#  scale.breaks <- c(seq(-limit.val, limit.val, by = ((2*limit.val/100))))
# 
# 
# # gplots::heatmap.2(x = res, trace = 'none', col = rev(hmcol), Rowv = NA,ylab = ("in vivo"),  xlab = ("in vitro"), breaks = scale.breaks, labCol = FALSE, margins = c(2, 4), main = "In vitro vs In vivo")
# 
# gplots::heatmap.2(x = res, trace = 'none', col = rev(hmcol), Rowv = NA,Colv = NA, ylab = ("in vivo"),  xlab = ("in vitro"), breaks = scale.breaks,  margins = c(4, 4), main = "In vitro vs In vivo")

```



```{r}

```

