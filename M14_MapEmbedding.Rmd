---
title: "Map Embedding"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r load libraries, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform", "scMiko", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggExtra", "grid", "ggrepel", "ddpcr")

# load packages
invisible({lapply(packages2load, library, character.only = TRUE)})

```

```{r parameter specification}

# TODO
# subset specification not yet implemented (i.e., map.field, cluster.resolution, specific.clusters)

# R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata
input.ref <- data.frame(name = "neuroDif",
                    file = "R173_M02_NM2_M02_neuroDif_sct_p1011_011020.Rdata",
                    cluster.resolution = 1,
                    map.field = "seurat_clusters",
                    subsample_factor = 1, 
                    specific.clusters = NA) # e.g., I(list(c(4,5,6,7,8,14)))


input.query <- list(
  CGR8 = data.frame(
    file = "R71_M01_NM2_p10_CGR8_310820.Rdata",
    map.field = "seurat_clusters",
    cluster.resolution = 1),
  DIV7 = data.frame(
    file = "R65_M01_NM2_p11_neural_DIV7_270820.Rdata",
    map.field = "seurat_clusters",
    cluster.resolution = 1
  )
)

print.inline <- F
save.pdf <- T


```

```{r analysis log}

# Module
df.log <- initiateLog("14, map embedding")
df.log <- addLogEntry("Reference set", (input.ref$name), df.log, as.character(""))
df.log <- addLogEntry("Reference path", (input.ref$file), df.log, as.character(""))
df.log <- addLogEntry("Query set(s)", paste(names(input.query), collapse = ", "), df.log, as.character(""))
df.log <- addLogEntry("Print inline", print.inline, df.log, as.character("print.inline"))
df.log <- addLogEntry("Save PDF(s)", save.pdf, df.log, as.character("save.pdf"))

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r import reference dataset}

dir.preprocessed <- "Preprocessed_Datasets/"
if (!exists("dir.preprocessed")) dir.preprocessed <- ""


# UMAP coord/meta helper function ##############################################

meta.data <- function(object){
  md <- object@meta.data
  md.umap <- data.frame(object@reductions[["umap"]]@cell.embeddings)
  md$x <- md.umap$UMAP_1;
  md$y <- md.umap$UMAP_2;
  if ("orig_cellname" %in% colnames(md)){
    md$cells <- md$orig_cellname
  } else {
    md$cells <- rownames(md)
  }
  return(md)
}

# reference dataset ############################################################
# import reference data
input.path <- paste(data.path, dir.preprocessed, input.ref$file, sep = "")
load(input.path)

# get relevant meta.data
so.ref <- meta.data(so)

# filter based on unique barcodes
if ("orig_cellname" %in% colnames(so.ref)){
  which.cells.table <- data.frame(table(so.ref$orig_cellname))
  which.cells <- as.character(which.cells.table$Var1[which.cells.table$Freq==1])
  which.cells <- rownames(so.ref)[so.ref$orig_cellname %in% which.cells]
} else {
  which.cells.table <- data.frame(table(rownames(so.ref)))
  which.cells <- as.character(which.cells.table$Var1[which.cells.table$Freq==1])
}

# remove duplicate barcodes
so <- subset(so , cells = which.cells)

# subsample
n.subset <- round(input.ref$subsample_factor *ncol(so))
cell.ind <- sample(x = colnames(so), size = n.subset, replace = FALSE, prob = NULL)
so <- subset(so , cells = cell.ind)

# get relevant meta.data
so.ref <- meta.data(so)

if ("orig_cellname" %in% colnames(so.ref)){
  which.cells.table <- data.frame(table(so.ref$orig_cellname))
  which.cells <- as.character(which.cells.table$Var1[which.cells.table$Freq==1])
  so.ref$cells <- so.ref$orig_cellname
} else {
  which.cells.table <- data.frame(table(rownames(so.ref)))
  which.cells <- as.character(which.cells.table$Var1[which.cells.table$Freq==1])
  so.ref$cells <- rownames(so.ref)
}

rm(so); invisible({gc()});



```


```{r import query datasets}


# query datasets ###############################################################
library(doParallel)
library(foreach)

so.list <- list()

n.import <- 4
if (length(input.query) < n.import) n.import <- length(input.query)

cl <- parallel::makeCluster(n.import)
doParallel::registerDoParallel(cl)

so.list <- foreach(i = 1:length(input.query), .packages = c("dplyr", "Seurat"))  %dopar% {
  
  # import data
  input.name <- names(input.query)[i]
  input.current <- input.query[[i]]
  input.path <- paste(data.path, dir.preprocessed, input.current$file, sep = "")
  load(input.path)
  
  cells.current <- colnames(so)[colnames(so) %in% which.cells]
  
  so <- subset(so , cells = cells.current)
  # so.list[[input.name]] <- meta.data(so)
  
  return(meta.data(so))
  # rm(so); invisible({gc()})
  
  
}

stopCluster(cl)
names(so.list) <- names(input.query)
invisible({gc()})

```

```{r specify umap ranges}

ref.range <- c(0,1)
# get umap embeddings
df.embedding <- data.frame(x0 = so.ref$x, y0 = so.ref$y)
df.embedding$x0 <- rescaleValues(df.embedding$x0, new.min = ref.range[1], new.max = ref.range[2])
df.embedding$y0 <- rescaleValues(df.embedding$y0, new.min = ref.range[1], new.max = ref.range[2])
df.embedding$cell <- so.ref$cells
df.embedding$group.ref <- so.ref[ ,input.ref$map.field]

query.range <- c(0.1, 0.9)
df.emb.query <- NULL
for (i in 1:length(so.list)){
df.embedding.current <- data.frame(x = so.list[[i]]$x, y = so.list[[i]]$y)
df.embedding.current$x <- rescaleValues(df.embedding.current$x, new.min = query.range[1], new.max = query.range[2])
df.embedding.current$y <- rescaleValues(df.embedding.current$y, new.min = query.range[1], new.max = query.range[2])

df.embedding.current$cell <- so.list[[i]]$cells
df.embedding.current$group.ref <- so.list[[i]][ ,input.ref$map.field]  
df.embedding.current$name <- names(so.list)[i]
df.emb.query <- bind_rows(df.emb.query, df.embedding.current)
}

```

```{r assemble umap}
# assemble umap on common coordinate system
n.sets <- length(so.list)

window.span <- 1.25

fig.width.height <- c(10,5)

if (n.sets == 1){
  df.emb.query$x <- df.emb.query$x - window.span
  fig.width.height <- c(10,5)
} else if (n.sets == 2){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  df.emb.query <- bind_rows(g1, g2)
  fig.width.height <- c(15,5)
} else if (n.sets == 3){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  df.emb.query <- bind_rows(g1, g2, g3)
  fig.width.height <- c(15,10)
} else if (n.sets == 4){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  g4 <- df.emb.query %>% dplyr::filter(name == names(so.list)[4]) %>% mutate(y = y+window.span)
  df.emb.query <- bind_rows(g1, g2, g3, g4)
  fig.width.height <- c(15,15)
} else if (n.sets == 5){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  g4 <- df.emb.query %>% dplyr::filter(name == names(so.list)[4]) %>% mutate(y = y+window.span)
  g5 <- df.emb.query %>% dplyr::filter(name == names(so.list)[5]) %>% mutate(y = y+window.span, x = x-window.span)
  df.emb.query <- bind_rows(g1, g2, g3, g4, g5)
  fig.width.height <- c(15,15)
} else if (n.sets == 6){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  g4 <- df.emb.query %>% dplyr::filter(name == names(so.list)[4]) %>% mutate(y = y+window.span)
  g5 <- df.emb.query %>% dplyr::filter(name == names(so.list)[5]) %>% mutate(y = y+window.span, x = x-window.span)
  g6 <- df.emb.query %>% dplyr::filter(name == names(so.list)[6]) %>% mutate(y = y+window.span, x = x+window.span)
  df.emb.query <- bind_rows(g1, g2, g3, g4, g5, g6)
  fig.width.height <- c(15,15)
} else if (n.sets == 7){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  g4 <- df.emb.query %>% dplyr::filter(name == names(so.list)[4]) %>% mutate(y = y+window.span)
  g5 <- df.emb.query %>% dplyr::filter(name == names(so.list)[5]) %>% mutate(y = y+window.span, x = x-window.span)
  g6 <- df.emb.query %>% dplyr::filter(name == names(so.list)[6]) %>% mutate(y = y+window.span, x = x+window.span)
  g7 <- df.emb.query %>% dplyr::filter(name == names(so.list)[7]) %>% mutate(y = y-window.span, x = x-window.span)
  df.emb.query <- bind_rows(g1, g2, g3, g4, g5, g6, g7)
  fig.width.height <- c(15,15)
} else if (n.sets == 8){
  g1 <- df.emb.query %>% dplyr::filter(name == names(so.list)[1]) %>% mutate(x = x-window.span)
  g2 <- df.emb.query %>% dplyr::filter(name == names(so.list)[2]) %>% mutate(x = x+window.span)
  g3 <- df.emb.query %>% dplyr::filter(name == names(so.list)[3]) %>% mutate(y = y-window.span)
  g4 <- df.emb.query %>% dplyr::filter(name == names(so.list)[4]) %>% mutate(y = y+window.span)
  g5 <- df.emb.query %>% dplyr::filter(name == names(so.list)[5]) %>% mutate(y = y+window.span, x = x-window.span)
  g6 <- df.emb.query %>% dplyr::filter(name == names(so.list)[6]) %>% mutate(y = y+window.span, x = x+window.span)
  g7 <- df.emb.query %>% dplyr::filter(name == names(so.list)[7]) %>% mutate(y = y-window.span, x = x-window.span)
  g8 <- df.emb.query %>% dplyr::filter(name == names(so.list)[7]) %>% mutate(y = y-window.span, x = x+window.span)
  df.emb.query <- bind_rows(g1, g2, g3, g4, g5, g6, g7, g8)
  fig.width.height <- c(15,15)
}

# combine datasets
df.emb.ref <- data.frame(x = df.embedding$x0, y = df.embedding$y0, 
                         cell = df.embedding$cell, group.ref = df.embedding$group.ref, 
                         name = "reference")
df.integrated.point <- bind_rows(df.emb.ref, df.emb.query)
df.integrated.seg <- merge(df.embedding, df.emb.query, by = "cell")


c2g.map <- df.integrated.seg$name
names(c2g.map) <- df.integrated.seg$cell
df.integrated.point$group <- c2g.map[df.integrated.point$cell]
df.integrated.point <- df.integrated.point[complete.cases(df.integrated.point), ]

```

```{r, fig.height= 5, fig.width= 15}

subsample.seg <- 0.25
df.integrated.seg.sub <- df.integrated.seg[sample(1:nrow(df.integrated.seg), subsample.seg*nrow(df.integrated.seg)), ]

plt.embedding_0_1 <- ggplot() + 
  geom_point(data = df.integrated.point, aes(x = x, y = y, color = group), size = 0.5) + 
  geom_segment(aes(x = x0, y = y0, xend = x, yend = y, color = name), alpha = 0.01, data = df.integrated.seg.sub) + 
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) + 
  ggthemes::scale_color_ptol()

plt.embedding_0_5 <- ggplot() + 
  geom_point(data = df.integrated.point, aes(x = x, y = y, color = group), size = 0.5) + 
  geom_segment(aes(x = x0, y = y0, xend = x, yend = y, color = name), 
               alpha = 0.02, data = df.integrated.seg.sub) + 
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) + 
  ggthemes::scale_color_ptol()

plt.embedding_1 <- ggplot() + 
  geom_point(data = df.integrated.point, aes(x = x, y = y, color = group), size = 0.5) + 
  geom_segment(aes(x = x0, y = y0, xend = x, yend = y, color = name), alpha = 0.1, 
               data = df.integrated.seg.sub[sample(1:nrow(df.integrated.seg.sub), 0.1*nrow(df.integrated.seg.sub)), ]) + 
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) + 
  ggthemes::scale_color_ptol()

if (print.inline) print(plt.embedding_0_1)

# plt.embedding
# plt.embedding_0_5

```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M14", input.data = input.ref$file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M14_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```

UMAP Remapping (a=0.01)
===================================== 

```{r plt.embedding 01, fig.height= 5, fig.width= 15}
print(plt.embedding_0_1)
```

UMAP Remapping (a=0.05)
===================================== 

```{r plt.embedding 05, fig.height= 5, fig.width= 15}
print(plt.embedding_0_5)
```

UMAP Remapping (a=0.1)
===================================== 

```{r plt.embedding 1, fig.height= 5, fig.width= 15}
print(plt.embedding_1)
```

```{r save pdfs}

try({
  savePDF(file.name = paste0(output.path, "PDF/", "M14_map_embedding_alpha0_01.pdf"), 
          plot.handle = (plt.embedding_0_1), 
          fig.width = fig.width.height[1], fig.height = fig.width.height[2], save.flag = save.pdf)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M14_map_embedding_alpha0_05.pdf"), 
          plot.handle = (plt.embedding_0_5), 
          fig.width = fig.width.height[1], fig.height = fig.width.height[2], save.flag = save.pdf)
  
  savePDF(file.name = paste0(output.path, "PDF/", "M14_map_embedding_alpha0_1.pdf"), 
          plot.handle = (plt.embedding_1), 
          fig.width = fig.width.height[1], fig.height = fig.width.height[2], save.flag = save.pdf)
}, silent = T)

```




```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`



Log (Module 14)
===================================== 

```{r table.log_current}

# run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", (elapsed.time), df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_14 <- df.log


knitr::kable(df.log_Module_14)

```

