---
title: "Module20_3D_UMAP"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "ddpcr", "readxl", "future")

# load packages
lapply(packages2load, library, character.only = TRUE)
library(plotly)



```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
  }

```



```{r parameter specification}

# Specify data directories
dir.preprocessed <- "Preprocessed Datasets/"

# Query input
# input.file <- "Module2_p1345_all_differentiation_070220.Rdata"
# input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"
# input.file <- "Module2_p3_p5_renca_tumor_integration_270120.Rdata"
input.file <- "Module1_p4_neural_differentiation_300120.Rdata"

# Rapid marker finding (logical flag)
quick_markers <- TRUE 

# specify cluster resolution
cluster_resolution <- c(0.3)

# print inline
print.inline <- FALSE

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)


```


```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("11, Cluster Markers")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)

# Cluster Resolution
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution")
df.log[nrow(df.log), 2] <- as.character("cluster_resolution")
if (length(cluster_resolution) > 1){
  df.log[nrow(df.log), 3] <- paste(cluster_resolution, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(cluster_resolution)
}

df.log[nrow(df.log)+1, 1] <- as.character("Figures Printed in Notebook")
df.log[nrow(df.log), 2] <- as.character("print.inline")
df.log[nrow(df.log), 3] <- as.character(print.inline)


```



```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```

```{r load data}
# load data
load(paste(dir.preprocessed, input.file, sep = ""))

so <- fix.barcode.label(so)
so.query <- so
rm(so)

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r prep gene list}

if (exists("gNames.list_master")){
  gNames.list <- NULL
  for (i in 1:length(gNames.list_master)){
    gNames.list <- c(gNames.list, gNames.list_master[[i]] )
  }
  
  # gNames.df <-  data.frame(n = as.vector(names(gNames.list)), g = as.vector(gNames.list))
  gNames.df <-  data.frame(n = gsub("\\..*","",as.vector(names(gNames.list))), g = as.vector(gNames.list))
  gNames.df <- unique(gNames.df)
  gNames.list <- as.vector(gNames.df$g)
  names(gNames.list) <- as.vector(gNames.df$n)
} 

# ensure gene list is available
stopifnot(exists("gNames.list"))
```


```{r cluster data}

cur.assay <- DefaultAssay(so.query)

cur.cluster <- paste(cur.assay , "_snn_res." , cluster_resolution, sep = "")

if (!(cur.cluster %in% names(so.query@meta.data))){
  so.query <- FindClusters(object = so.query, 
                           resolution = cluster_resolution, 
                           verbose = 0, 
                           algorithm = 1, 
                           modularity.fxn = 1)
}


plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = cur.cluster, label = TRUE)  + 
    ggtitle(label = paste("Resolution: ", cluster_resolution, sep = "")) +
    xlab("UMAP 1") +
    ylab("UMAP 2")

print(plt.umap_by_cluster)


```

```{r}
# Interacive multimodal 3D UMAP plotting of scRNA sequencing datasets
# The following is a length of code generated to create nice 
# 3D UMAP plots of seurat v3.0.0-v3.1.1 objects utilizing the visualization 
# package plot_ly

# R v3.5.3 (x64 bit) and RStudio v1.2.1335 (x64 bit) were used for running this code :)

# Seurat is a multimodal single Cell RNA seq analysis algorithm created by
# The Satija Lab. For more information please see: https://satijalab.org/seurat/

# Contributors (by their Github handles):
# @Dragonmasterx87 (Dept. of Cell Biology, UM)
# @msaadsadiq (Dept. of Electrical and Computer Engineering, UM)

# https://github.com/Dragonmasterx87/Interactive-3D-Plotting-in-Seurat-3.0.0/blob/master/3D%20UMAP%20Plotting%20v1.3.R
# Install plot_ly
# install.packages('plotly')

# Load plot_ly

# Construct a dataframe using data from your pre-clustered Seurat v3.1.1 object
# Here 'seurat_clusters' is list of numeric cluster identities, you can find it here: yourseuratobject[["seurat_cluster"]], 
# or yourseuratobject$seurat_clusters, where 'yourseuratobject' is a Seurat object created with Seurat v3.1.1 (works for v3.0.0 as well)
so.3d <- so.query

# yourseuratobject <- ThisIsWhateverYourSeuratObjectIsEvenIfItsIntegrated

# Re-run UMAPs that you have accurate calculations for all UMAP(s)
so.3d <- RunUMAP(so.3d,
                 dims = 1:10,
                 n.components = 3L)


```

```{r, fig.width= 15, fig.height= 5}

umap_1 <- so.3d[["umap"]]@cell.embeddings[,1]
umap_2 <- so.3d[["umap"]]@cell.embeddings[,2]
umap_3 <- so.3d[["umap"]]@cell.embeddings[,3]

cluster.membership <- so.query@meta.data[[cur.cluster]]

df.umap <- data.frame(
  x = umap_1,
  y = umap_2,
  z = umap_3,
  cluster = cluster.membership
)

point.alpha = 0.33
plt.umap.xy <- df.umap %>%
  ggplot(aes(x = x, y = y, fill = cluster, color = cluster)) + 
  geom_point(alpha = point.alpha) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
  theme_bw()

plt.umap.xz <- df.umap %>%
  ggplot(aes(x = x, y = z, fill = cluster, color = cluster)) + 
  geom_point(alpha = point.alpha) + 
  xlab("UMAP 1") + ylab("UMAP 3") + 
  theme_bw()

plt.umap.yz <- df.umap %>%
  ggplot(aes(x = y, y = z, fill = cluster, color = cluster)) + 
  geom_point(alpha = point.alpha) + 
  xlab("UMAP 2") + ylab("UMAP 3") + 
  theme_bw()





 ggpubr::ggarrange(plt.umap.xy, plt.umap.xz, plt.umap.yz, nrow = 1)


```



```{r}


# Extract tSNE information from Seurat Object
umap_1 <- so.3d[["umap"]]@cell.embeddings[,1]
umap_2 <- so.3d[["umap"]]@cell.embeddings[,2]
umap_3 <- so.3d[["umap"]]@cell.embeddings[,3]

# Visualize what headings are called so that you can extract them to form a dataframe
# head(Embeddings(object = so.3d, reduction = "umap"))

# Prepare a dataframe for cell plotting
plot.data <- FetchData(object = so.3d, vars = c("UMAP_1", "UMAP_2", "UMAP_3", "seurat_clusters"))

# Make a column of row name identities (these will be your cell/barcode names)
plot.data$label <- paste(plot.data$seurat_clusters)


g <- ggplot_build(plt.umap.xy)
col <- (g$data[[1]]["colour"])[ ,"colour"]

# Plot your data, in this example my Seurat object had 21 clusters (0-20)
plot_ly(data = plot.data, 
        x = ~UMAP_1, y = ~UMAP_2, z = ~UMAP_3, 
        color = ~seurat_clusters, 
        colors = col,
        type = "scatter3d", 
        mode = "markers", 
        alpha = 0.9,
        marker = list(size = 2, width=1), # controls size of points
        text=~label, #This is that extra column we made earlier for which we will use for cell ID
        hoverinfo="text") #When you visualize your plotly object, hovering your mouse pointer over a point shows cell names


```


```{r}

# Say you wanto make a gene-expression 3D plot, where you can plot gene expression against a color scale
# Here using the same seurat object as above, we extract gene expression information for beta-actin 'ACTB'
# Here we concentrate on SCT normalized data, or log normalized RNA NOT raw counts.
# In addition if you want, you may look at normalised-RNA, SCT or integrated slots, to look at gene expression
# Setting your DefaultAssay() will inform R which assay to pick up expression data from.
# DefaultAssay(object = pancreas.integrated)
# DefaultAssay(object = pancreas.integrated) <- "RNA"
# DefaultAssay(object = pancreas.integrated) <- "integrated"
# DefaultAssay(object = pancreas.integrated) <- "SCT"

# create a dataframe
plot.data <- FetchData(object = so.3d, vars = c("UMAP_1", "UMAP_2", "UMAP_3", "Xist"), slot = 'data')

# Say you want change the scale, so that every cell having an expression >1 will be one color
# Basically, you are re-adjusting the scale here, so that any cell having a certain expression will light up on your 3D plot

# First make another column in your dataframe, where all values above 1 are re-assigned a value of 1
# This information is stored in the 'changed' column of your dataframe
plotting.data$changed <- ifelse(test = plotting.data$ACTB <1, yes = plotting.data$ACTB, no = 1)

# Add the label column, so that now the column has 'cellname-its expression value'
plotting.data$label <- paste(rownames(plotting.data)," - ", plotting.data$ACTB, sep="")

# Plot your data, in this example my Seurat object had 21 clusters (0-20), and cells express a gene called ACTB
plot_ly(data = plotting.data, 
        x = ~UMAP_1, y = ~UMAP_2, z = ~UMAP_3, 
        color = ~changed, # you can just run this against the column for the gene as well using ~ACTB, the algorith will automatically scale in that case based on maximal and minimal values
        opacity = .5,
        colors = c('darkgreen', 'red'), 
        type = "scatter3d", 
        mode = "markers",
        marker = list(size = 5, width=2), 
        text=~label,
        hoverinfo="text"
)

# On running this code the HTML output should appear in RStudio. You can save the output as a
# HTML file. Once you have saved, just open the HTML file in any web browser (double click on the html- file
# and if asked select to open with any web browser like google chrome/safari/mozilla/explorer etc).
# It should be have all of the integrated features you saw in the RStudio output file.

# Thank you for reading and using this code to further your scRNAseq analysis!
# If you liked it, dont forget to acknowledge, fork and star!
# Citation information is within the Readme, please dont forget to cite!
# Have a wonderful day!!

```

