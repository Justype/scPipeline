---
title: "Variance Decomposition"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", "DT", "lme4", "variancePartition",
                   "dplyr", "tidyr", "RColorBrewer", "ggplot2", 
                   "flexdashboard", "future", "BiocParallel",
                   "parallel", "doParallel", "foreach")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```



```{r analysis specifications}

# parameter specification
parameter.list <- list(
  # input.file = "M01_NM2_R1_test_300720.Rdata",
  input.file = "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata",
   # input.file = "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata",
  cluster.resolution = 1,
  subsample_factor = 1,
  # subset.data = data.frame(field = "seurat_clusters", subgroups = c(0:20)),
  subset.data = NA,
  species = "Mm",
  TCGA.samples = ""  # specif which tumor types
)

# barcode.list = list(
# GL261 = "GL261", 
# CT2A = "CT2A"
# )


# print inline
print.inline <- FALSE # OPTIONAL; TRUE/FALSE

# save PDF
save.pdf <- T
update.log <- T


```




```{r load data, warning = FALSE}

message("Importing data...")


# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load query dataset
message("Importing data...")
input.file <- parameter.list$input.file
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species =  parameter.list$species, resolution= parameter.list$cluster.resolution, 
                         subset.data = parameter.list$subset.data, 
                         subsample = parameter.list$subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = F)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})


```


```{r analysis log, include = FALSE}

message("Updating analysis log...")

# Initiate and fill analysis Log
df.log <- initiateLog("35, Clean Cluster")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("Update Central Log", update.log, df.log, "update.log")
df.log <- addLogEntry("Print Inline", print.inline, df.log, "print.inline")

df.log <- addLogEntry("Input file", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("data subset", parameter.list$subset.data, df.log, "subset.data")
df.log <- addLogEntry("species", parameter.list$species, df.log, "species")

```


```{r get past module logs, include = FALSE}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r recode barcodes}


if (exists("barcode.list") && (length(barcode.list) > 0)){

df.meta <- so.query@meta.data

# relabel barcodes
bc.list <-barcode.list

df.meta$bc <- NA
for (i in 1:length(bc.list)){
  
  pattern <- bc.list[[i]]
  pattern.replace <- names(bc.list)[i]
  df.meta$bc[grepl(pattern, df.meta$Barcode)] <- pattern.replace
}

so.query@meta.data <- df.meta
  
} else {
  
  
  u.bc <- unique(so.query@meta.data[["Barcode"]])
  bc.list <- list()
  for (i in 1:length(u.bc)){
    bc.list[[i]] <- u.bc[i]
  }
  names(bc.list) <- u.bc
so.query@meta.data[["bc"]] <- so.query@meta.data[["Barcode"]]
}

```

```{r}

message("Getting TCGA data...")


tcga.sample <- "GBM"


if (!exists("df.tcga")) df.tcga <- readRDS("C:/Users/Owner/Dropbox/PDF Projects - JM/Data/tcga/rna_expression_tcga_200420.rds")
if (!exists("tcga.meta")) tcga.meta <- readRDS("C:/Users/Owner/Dropbox/PDF Projects - JM/Data/tcga/patient_metaData_tcga_200420.rds")

# filter samples
which.patients <- grepl(tcga.sample, tcga.meta[["project_id"]])
  
  # tcga.meta[["project_id"]] %in% "Glioblastoma Multiforme"
tcga.meta2 <- tcga.meta[which.patients]
tcga.mat2 <- t(df.tcga[ which.patients, ])


so.genes <- rownames(so.query)
so.genes <- unique(toupper(so.genes))

tcga.mat2 <- tcga.mat2[rownames(tcga.mat2) %in% so.genes, ]

so.tcga <- CreateSeuratObject(counts = tcga.mat2)

str(tcga.mat2)

# df.meta.all <- do.call(cbind.data.frame, tcga.meta)

# df.meta.all <- cbind(tcga.meta)

# get patient meta data
df.meta.all <- data.frame(
  dtd = tcga.meta[["days_to_death"]],
  dtf = tcga.meta[["days_to_last_follow_up"]],
  tumor.grade = tcga.meta[["paper_tumor_grade"]],
  histology = tcga.meta[["paper_Histology"]],
  age = tcga.meta[["age_at_diagnosis"]],
  idh.subtype = tcga.meta[["paper_IDH.status"]],
  mgmt.promoter = tcga.meta[["paper_MGMT.promoter.status"]],
  ch7.10 = tcga.meta[["paper_Chr.7.gain.Chr.10.loss"]],
  ch19.20 = tcga.meta[["paper_Chr.19.20.co.gain"]],
  o.subtype = tcga.meta[["paper_Original.Subtype"]],
  t.subtype = tcga.meta[["paper_Transcriptome.Subtype"]],
  glioma.cluster = tcga.meta[["paper_Pan.Glioma.RNA.Expression.Cluster"]],
  idh.cluster = tcga.meta[["paper_IDH.specific.RNA.Expression.Cluster"]],
  rf.class = tcga.meta[["paper_Random.Forest.Sturm.Cluster"]],
  alive = tcga.meta[["vital_status"]]
)


df.meta.all$time <- df.meta.all$dtf
df.meta.all$time[!is.na(df.meta.all$dtd)] <-df.meta.all$dtd[!is.na(df.meta.all$dtd)]
df.meta.all <- df.meta.all[which.patients, ]


```


```{r combine seurat objects}

so.list = list(
  reference = so.query,
  tcga = so.tcga
)

```


```{r harmonize species}

message("Harmonizing species...\n")
which.species <- "Hs"

if (which.species == "Hs"){
  my.converter <- toupper
} else if (which.species == "Mm") {
  my.converter <- firstup
}

for (i in 1:length(so.list)){
  
  assay.names <- names(so.list[[i]]@assays)
  
  
  for (j in 1:length(assay.names)){
    so.list[[i]]@assays[[assay.names[j]]]@counts@Dimnames[[1]] <- 
      my.converter(so.list[[i]]@assays[[assay.names[j]]]@counts@Dimnames[[1]])
    so.list[[i]]@assays[[assay.names[j]]]@data@Dimnames[[1]] <- 
      my.converter(so.list[[i]]@assays[[assay.names[j]]]@data@Dimnames[[1]]) 
    
       try({rownames(so.list[[1]]@assays[[assay.names[j]]]@scale.data) <- 
      my.converter(rownames(so.list[[1]]@assays[[assay.names[j]]]@scale.data))}, silent = T)   
    
    
    
  }
  
      try({rownames(so.list[[i]]@reductions[["pca"]]@feature.loadings) <- 
      my.converter(rownames(so.list[[i]]@reductions[["pca"]]@feature.loadings))}, silent = T)
}


```

```{r transfer labels}





# get reference indices
ind.reference <- 1
ind.query <- 2

# determine normalization method
available.assays <- (unique(unlist(lapply(so.list, function(x) x@active.assay))))

df.var <- NULL
var.all.list <- list()
for (i in 1:length(so.list)){
  DefaultAssay(so.list[[i]]) <- "RNA"
  so.list[[i]] <- DietSeurat(so.list[[i]], assays = "RNA", graphs = names(so.list[[i]]@graphs),
                             dimreducs = names(so.list[[i]]@reductions))
  # rownames(so.list[[i]]) <-  make.unique(rownames(so.list[[i]]))
  so.list[[i]]@assays[["RNA"]]@counts@Dimnames[[1]] <-make.unique(so.list[[i]]@assays[["RNA"]]@counts@Dimnames[[1]])
  so.list[[i]]@assays[["RNA"]]@data@Dimnames[[1]] <-make.unique(so.list[[i]]@assays[["RNA"]]@data@Dimnames[[1]])
  
  so.list[[i]]@assays[["RNA"]]@meta.features <- data.frame(row.names = (rownames(so.list[[i]])))
  so.list[[i]] <- NormalizeData(so.list[[i]], normalization.method = "LogNormalize", scale.factor = 10000, assay = "RNA")
  so.list[[i]] <- FindVariableFeatures(object = so.list[[i]], selection.method = 'mvp', 
                             mean.cutoff = c(0.1, 8), dispersion.cutoff = c(1, Inf), assay = "RNA")
  
  
  df.var.cur <- so.list[[i]]@assays[["RNA"]]@meta.features
  df.var.cur$gene <- toupper(rownames(df.var.cur))
  
  if (is.null(df.var)){
    df.var <- df.var.cur[ ,c("mvp.dispersion.scaled", "gene")]
    colnames(df.var) <- c(paste0("v", i), "gene")
  } else {
    df.var.cur <- df.var.cur[ ,c("mvp.dispersion.scaled", "gene")]
    colnames(df.var.cur) <- c(paste0("v", i), "gene")   
    df.var <- merge(df.var, df.var.cur, by = "gene")
  }
  
  var.all.list[[i]] <- df.var.cur
  
}

which.norm <- "LogNormalize"


message("Identifying common gene subset...\n")
rownames(df.var) <- df.var$gene
df.var$max.val <- pmax(df.var$v1, df.var$v2)
top.var <- (df.var %>% top_n(3000, max.val))$gene
commmon.genes <- unique(c(top.var, so.list[[1]]@assays[["RNA"]]@var.features, so.list[[2]]@assays[["RNA"]]@var.features))

genes.list <- list()
  so.list[[ind.reference]]@meta.data[["umap.x"]] <- so.list[[ind.reference]]@reductions[["umap"]]@cell.embeddings[,1]
  so.list[[ind.reference]]@meta.data[["umap.y"]] <- so.list[[ind.reference]]@reductions[["umap"]]@cell.embeddings[,2]


message("Finding transfer anchors...\n")
so.anchors2 <- FindTransferAnchors(reference = so.list[[ind.reference]], query = so.list[[ind.query]], 
                                   features = commmon.genes,
   normalization.method = which.norm, reduction = "pcaproject")


k.neighbors <- 5
message("Transferring cluster labels...\n")
cluster.predictions.cluster <- TransferData(anchorset = so.anchors2, 
                            refdata = so.list[[ind.reference]]@meta.data[["seurat_clusters"]], 
                            k.weight = k.neighbors,
                            weight.reduction = "pcaproject")
                            # dims = 1:3z0)

message("Transferring barcode labels...\n")
cluster.predictions.bc <- TransferData(anchorset = so.anchors2, 
                            refdata = so.list[[ind.reference]]@meta.data[["bc"]], 
                            k.weight = k.neighbors,
                            weight.reduction = "pcaproject")
                            # dims = 1:30)

message("Transferring umap coordinates labels...\n")
cluster.predictions.umap <- TransferData(anchorset = so.anchors2, 
                            refdata = t(so.list[[ind.reference]]@reductions[["umap"]]@cell.embeddings), 
                            k.weight = k.neighbors,
                            weight.reduction = "pcaproject")
                            # dims = 1:30)


message("Constructing UMAP data objects...")

# a <- cluster.predictions.umap@data
df.umap.query <- data.frame(t(as.matrix(cluster.predictions.umap@data)))
colnames(df.umap.query) <- c("x", "y")
df.umap.query$cluster <- cluster.predictions.cluster$predicted.id
df.umap.query$barcode <- cluster.predictions.bc$predicted.id
df.umap.query$max.score <- cluster.predictions.cluster$prediction.score.max

df.umap.reference <- data.frame(so.list[[ind.reference]]@reductions[["umap"]]@cell.embeddings)
colnames(df.umap.reference) <- c("x", "y")
df.umap.reference$cluster <- so.list[[ind.reference]]@meta.data[["seurat_clusters"]]
df.umap.reference$barcode <- so.list[[ind.reference]]@meta.data[["bc"]]

```


```{r, fig.width = 10, fig.height = 5}

# ensure clusters are ordered
df.umap.query$cluster <- orderedFactor(df.umap.query$cluster)
df.umap.reference$cluster <- orderedFactor(df.umap.reference$cluster)

n.points <- nrow(df.umap.query) + nrow(df.umap.reference)

message("Generating inital UMAP mappings...")
plt.u.ref <-  ggplot() + 
  geom_point(data = df.umap.query, aes(x = x, y = y), color = "grey80", size = autoPointSize(n.points = n.points)) + 
  geom_point(data = df.umap.reference, aes(x = x, y = y, color = cluster), size = autoPointSize(n.points = n.points)) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
  theme_miko(legend = F) + 
  labs(title = "Reference", caption = "grey: TCGA patients", subtitle = "scRNAseq")

plt.u.query <-  ggplot() + 
  geom_point(data = df.umap.reference, aes(x = x, y = y), color = "grey80", size = autoPointSize(n.points = n.points)) + 
  geom_point(data = df.umap.query, aes(x = x, y = y, color = cluster), size = autoPointSize(n.points = n.points)) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
   theme_miko(legend = T) + 
  labs(title = "Query", caption = "grey: Single Cells", subtitle = "TCGA Bulk RNA")

plt.initial.mapping <- cowplot::plot_grid(plt.u.ref, plt.u.query,ncol = 2, rel_widths = c(1.75, 2))

if (print.inline){
  print(plt.initial.mapping)
}
```


```{r score threhsolding, fig.width = 17, fig.height = 5}

message("Visualizing alignment thresholds...")
alignment.threshold <- 0.7
plt.query.score <-  ggplot() + 
  geom_point(data = df.umap.reference, aes(x = x, y = y), color = "grey80", size = autoPointSize(n.points = n.points)) + 
  geom_point(data = df.umap.query, aes(x = x, y = y, color = max.score), size = autoPointSize(n.points = n.points)) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
   theme_miko(legend = T) + 
  labs(title = "Query", caption = "grey: reference", color = "Alignment Score") + 
  viridis::scale_color_viridis()

plt.score.hist <-  ggplot() + 
  geom_histogram(data = df.umap.query, aes(x = max.score), fill = "grey", color = "black") + 
  xlab("Alignment Score") + ylab("Count") + 
   theme_miko(legend = T) + 
  geom_vline(xintercept = alignment.threshold, linetype = "dashed") + 
  labs(title = "Alignment Scores", subtitle = "Distribution", caption = "dashed: alignment threhsold")

plt.u.query <-  ggplot() + 
  geom_point(data = df.umap.reference, aes(x = x, y = y), color = "grey80", size = autoPointSize(n.points = n.points)) + 
  geom_point(data = df.umap.query %>% dplyr::filter(max.score > alignment.threshold), aes(x = x, y = y, color = cluster), size = autoPointSize(n.points = n.points)) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
   theme_miko(legend = T) + 
  labs(title = "Query", caption = "grey: reference")


plt.u.query <-  ggplot() + 
  geom_point(data = df.umap.reference, aes(x = x, y = y), color = "grey80", size = autoPointSize(n.points = n.points)) + 
  geom_point(data = df.umap.query %>% dplyr::filter(max.score > alignment.threshold), aes(x = x, y = y, color = barcode), size = 3) + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
   theme_miko(legend = T) + 
  labs(title = "Query", caption = "grey: reference")


plt.alignment.threshold <- cowplot::plot_grid(plt.query.score, plt.score.hist, plt.u.query, ncol = 3)

if (print.inline){
  print(plt.alignment.threshold)
}

```





```{r map distributions}

at <- seq(0, 1, by = 0.1)
df.at.all <- NULL
for (i in 1:length(at)){
  
  df.at <- data.frame(
    cells = rownames(df.umap.query),
    cluster = df.umap.query$cluster,
    barcode = df.umap.query$barcode,
    score = df.umap.query$max.score
  )
  
  df.at$aligned <- F
  df.at$aligned[df.at$score > at[i]] <- T
  df.at$cluster2 <- df.at$cluster
  df.at$cluster2[!df.at$aligned] <- "not mapped"
  df.at$bc2 <- df.at$barcode
  df.at$bc2[!df.at$aligned] <- "not mapped"
  df.at$threshold <- at[i]
  df.at.all <- bind_rows(df.at.all, df.at)
}

# order factors
df.at.all$cluster <- orderedFactor(df.at.all$cluster)
df.at.all$cluster2 <- factor(df.at.all$cluster2, levels = c(levels(df.at.all$cluster), "not mapped"))
df.at.all$barcode <- orderedFactor(df.at.all$barcode)
df.at.all$bc2 <- factor(df.at.all$bc2, levels = c(levels(df.at.all$barcode), "not mapped"))
df.at.all$threshold <- factor(df.at.all$threshold , levels = at)

plt.map.distribution <- df.at.all %>%
  ggplot(aes(x = threshold, y = score, fill = cluster2)) + 
  geom_bar(stat = "identity", position = "fill") + 
  theme_miko(legend = T) + 
  xlab("Alignment Threshold") + ylab("Distribution of Mapped Clusters") + 
  labs(title = "Distribution of Mapped Clusters", subtitle = "Clusters specify those in reference data", fill = "Cluster")

plt.bc.distribution <- df.at.all %>%
  ggplot(aes(x = threshold, y = score, fill = bc2)) + 
  geom_bar(stat = "identity", position = "fill") + 
  theme_miko(legend = T) + 
  xlab("Alignment Threshold") + ylab("Distribution of Mapped Barcodes") + 
  labs(title = "Distribution of Mapped Barcodes", subtitle = "Barcodes specify those in reference data", fill = "Barcode")


if (print.inline){
  print(plt.map.distribution)
  
  plt.bc.distribution

}

df.at.all.sum  <- df.at.all %>%
  dplyr::group_by(threshold) %>%
  summarize(pct.mapped = mean(aligned))

plt.prop.mapped <- df.at.all.sum %>%
  ggplot(aes(x = as.numeric(as.character(threshold)), y = pct.mapped)) + 
  geom_point() + 
  geom_path() + theme_miko() + 
  xlab("Alignment Threhsold") + 
  ylab("Proportion of Cells Mapped") + 
  geom_vline(xintercept = alignment.threshold, linetype = "dashed") + 
  labs(title = "Proportion of Cells Mapped to Reference", subtitle = "Mapping determined for range of alignment thresholds")

# plt.prop.mapped

```



```{r summary statistisc, fig.width = 12, fig.height = 5}


prop.mapped <- signif(mean(df.umap.query$max.score > alignment.threshold), 3)
df.meta.merge <- bind_cols(df.umap.query, df.meta.all)

df.meta.merge$cluster2 <- df.meta.merge$cluster 
df.meta.merge$cluster2[df.meta.merge$max.score < alignment.threshold] <- NA
df.meta.merge$barcode2 <- df.meta.merge$barcode 
df.meta.merge$barcode2[df.meta.merge$max.score < alignment.threshold] <- NA

df.meta.cluster <- df.meta.merge %>%
  dplyr::filter(max.score > alignment.threshold) %>%
  dplyr::group_by(cluster2) %>%
  dplyr::summarize(
    p.alive = mean(alive == "Alive", na.rm = T),
    p.dead = mean(alive == "Dead", na.rm = T),
    mean.time = mean(time, na.rm = T),
    sd.time = sd(time, na.rm = T),
    mean.age = mean(age, na.rm = T),
    sd.age = sd(age, na.rm = T),
    n.patients = length(time)
  )

df.meta.bc <- df.meta.merge %>%
  dplyr::filter(max.score > alignment.threshold) %>%
  dplyr::group_by(barcode2) %>%
  dplyr::summarize(
    p.alive = mean(alive == "Alive", na.rm = T),
    p.dead = mean(alive == "Dead", na.rm = T),
    mean.time = mean(time, na.rm = T),
    sd.time = sd(time, na.rm = T),
    mean.age = mean(age, na.rm = T),
    sd.age = sd(age, na.rm = T),
    n.patients = length(time)
  )

plt.1 <- df.meta.merge %>%
  ggplot(aes(x = barcode2, fill = barcode2)) + 
  geom_bar() + 
  theme_miko(legend = T) + 
  geom_text(data = df.meta.bc, aes(y = n.patients + (0.05*nrow(df.meta.merge)), x = barcode2, label = n.patients)) + 
  xlab("Sample") + ylab("N Patients") + 
  labs(title = "Mapping Summary", subtitle = "Predicted 'Samples'", caption = "NA = not mapped", fill = "Sample")

plt.2 <- df.meta.merge %>% 
  ggplot(aes(x = cluster2, fill = cluster2)) + 
  geom_bar() + 
  theme_miko(legend = T) + 
  geom_text(data = df.meta.cluster, aes(y = n.patients + (0.05*nrow(df.meta.merge)), x = cluster2, label = n.patients)) +
  xlab("Cluster") + ylab("N Patients") + 
  labs(title = "Mapping Summary", subtitle = "Predicted 'Clusters'", caption = "NA = not mapped", fill = "Cluster")


cowplot::plot_grid(plt.1, plt.2)
```

```{r}


df.meta.bc <- df.meta.merge %>%
  dplyr::filter(max.score > alignment.threshold) %>%
  dplyr::group_by(barcode2) %>%
  dplyr::summarize(
    p.alive = mean(alive == "Alive", na.rm = T),
    p.dead = mean(alive == "Dead", na.rm = T),
    mean.time = mean(time, na.rm = T),
    sd.time = sd(time, na.rm = T),
    mean.age = mean(age, na.rm = T),
    sd.age = sd(age, na.rm = T),
    n.patients = length(time)
  )


df.meta.merge$barcode3 <- NA
df.meta.merge$barcode3[grepl("0231", df.meta.merge$barcode2)] <- "MBT06"
df.meta.merge$barcode3[grepl("0238", df.meta.merge$barcode2)] <- "BT799"

df.meta.bc2 <- df.meta.merge %>%
  dplyr::filter(max.score > alignment.threshold) %>%
  dplyr::group_by(barcode3) %>%
  dplyr::summarize(
    p.alive = mean(alive == "Alive", na.rm = T),
    p.dead = mean(alive == "Dead", na.rm = T),
    mean.time = median(time, na.rm = T),
    sd.time = mad(time, na.rm = T),
    mean.age = median(age, na.rm = T),
    sd.age = mad(age, na.rm = T),
    n.patients = length(time)
  )

```

