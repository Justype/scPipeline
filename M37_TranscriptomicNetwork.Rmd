---
title: "Transcriptomic Gene Network"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    self_contained: false
    source_code: embed
    theme: flatly
    navbar:
      - { title: "scPipeline", href: "https://github.com/NMikolajewicz/scPipeline" }
      - { title: "scMiko", href: "https://github.com/NMikolajewicz/scMiko" }     
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", 
        paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", 
      paste0(format(Sys.time(), "%d_%b_"), gsub(" ", "_", gsub(":", "_", format(Sys.time(), "%X"))), format(Sys.time(), "_%Y")), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", "DT", "scales", "STRINGdb",
                   "dplyr", "tidyr", "RColorBrewer", "ggplot2", 
                   "flexdashboard", "future", "BiocParallel",
                   "parallel", "doParallel", "foreach", "iterators")

# load packages
suppressMessages(suppressWarnings(lapply(packages2load, library, character.only = TRUE, quietly = T)))

```



```{r analysis specifications}

# parameter specification
parameter.list <- list(
  # input.file = "M01_NM2_R1_test_300720.Rdata",
  input.file = "R554_M02_NM2_p10_p14_CGR8_integrated_byReplicate_rpca_SCTrerun_110821.Rdata",
  # input.file = "R416_M02_NM2_p12_meso_integrated_170421.Rdata",
  # input.file = "branch_p12_meso_020521.rds",
  # input.file = "R65_M01_NM2_p11_neural_DIV7_270820.Rdata",
  # input.file = 	"R65_M01_NM2_p11_neural_DIV7_270820.Rdata",
  # input.file = "p13_renca_clean_300521.rds",
  # input.file = "invivo_GL261_sampleIntegrated_150421.rds",
  # input.file = "invivo_CT2A_sampleIntegrated_150421.rds",
  # input.file = "invivo_GL261_CT2A_sampleIntegrated_150421.rds",
  # input.file = "R443_M02_NM2_p9_GBM_PR_integrated_SCTrerun_110521.Rdata",
  # input.file = "R404_M02_NM2_celsius_renca_rpca_filtered_220321.Rdata",
  cluster.resolution = 0.5, #0.5
  subsample_factor = 1,
  subset.data = NA,
  min.pct = 0.25, # large net: 0.1; small net: 0.5 -  min gene expression (applicable only if variable.only = F)
  variable.only = F, # variable genes only?
  purity.optimization.step.size = 0.05,
  pathway.db = "Bader", #Bader, GO
  filter.parameters =  list(
    include = NULL,
    omit = NULL
  ), 
  
  # TF network parameters
  tf.do.scale = T, # obsolete argument
  tf.do.center = T, # obsolete argument
  tf.weight.by.var = F,
  tf.pca.cum.sum = 0.85,
  tf.umap.knn = 10,
  tf.cluster.purity = 0.8,
  tf.scale.free.topology = T,
  tf.ica = T,
  tf.robust.pca = F,
  
  # general network parameters
  general.do.scale = T, # obsolete argument
  general.do.center = T, # obsolete argument
  general.weight.by.var = F,
  general.pca.cum.sum = 0.85,
  general.umap.knn = 10,
  general.cluster.purity = 0.8,
  general.scale.free.topology = T,
  general.ica = T,
  general.robust.pca = F,
  
  # misc parameters
  print.inline = F,
  save.pdf = T,
  update.log = T
)

```



```{r load data, warning = FALSE}

miko_message("Importing data...")

set.seed(1023)

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load query dataset
input.file <- parameter.list$input.file
if ((!grepl(".Rdata|.RData", input.file)) & !(grepl(".rds", input.file))) input.file <- paste0(input.file, ".Rdata")

if (grepl(".Rdata|.RData", input.file)){
  load(paste(data.path, dir.preprocessed, input.file, sep = ""));
} else if (grepl(".rds", input.file)) {
  so <- readRDS(paste(data.path, dir.preprocessed, input.file, sep = ""))
}


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species =  parameter.list$species, resolution= parameter.list$cluster.resolution, 
                         subset.data = parameter.list$subset.data, 
                         subsample = parameter.list$subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = F)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

parameter.list$species <- detectSpecies(so.query)

```

```{r filter clusters}

if ("filter.parameters" %in% names(parameter.list)){
  so.query <- clusterFilter(so.query, include = parameter.list$filter.parameters$include, omit = parameter.list$filter.parameters$omit)
  
  # TODO ensure that refactorization does not renumber values
  so.query@meta.data[["seurat_clusters"]] <- factor(as.character(so.query@meta.data[["seurat_clusters"]]))
  Idents(object = so.query) <- 'seurat_clusters'
}


```

```{r analysis log, include = FALSE, }

miko_message("Updating analysis log...")

# Initiate and fill analysis Log
df.log <- initiateLog("37, Transcriptomic Network")
df.log <- addLogEntry("PDF saved", parameter.list$save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("Update Central Log", parameter.list$update.log, df.log, "update.log")
df.log <- addLogEntry("Print Inline", parameter.list$print.inline, df.log, "print.inline")

df.log <- addLogEntry("Input file", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("data subset", parameter.list$subset.data, df.log, "subset.data")
df.log <- addLogEntry("species", parameter.list$species, df.log, "species")

df.log <- addLogEntry("Minimum expr. fraction (only if variable.only = F)", parameter.list$min.pct, df.log, "min.pct")
df.log <- addLogEntry("Variable genes only", parameter.list$variable.only, df.log, "variable.only")
df.log <- addLogEntry("Step size in cluster purity search", parameter.list$purity.optimization.step.size, df.log, "purity.optimization.step.size")
df.log <- addLogEntry("Pathway database for enrichment analysis", parameter.list$pathway.db, df.log, "pathway.db")
df.log <- addLogEntry("TF| scale expression", parameter.list$tf.do.scale, df.log, "tf.do.scale")
df.log <- addLogEntry("TF| center expression", parameter.list$tf.do.center, df.log, "tf.do.center")
df.log <- addLogEntry("TF| robust PCA", parameter.list$tf.robust.pca, df.log, "tf.robust.pca")
df.log <- addLogEntry("TF| weigh PCA by variance", parameter.list$tf.weight.by.var, df.log, "tf.weight.by.var")
df.log <- addLogEntry("TF| Variance explained by PCA", parameter.list$tf.pca.cum.sum, df.log, "tf.pca.cum.sum")
df.log <- addLogEntry("TF| KNN", parameter.list$tf.umap.knn, df.log, "tf.umap.knn")
df.log <- addLogEntry("TF| Target modular purity", parameter.list$tf.cluster.purity, df.log, "tf.cluster.purity")
df.log <- addLogEntry("TF| Scale-free topology enforced", parameter.list$tf.scale.free.topology, df.log, "tf.scale.free.topology")

df.log <- addLogEntry("General| scale expression", parameter.list$general.do.scale, df.log, "general.do.scale")
df.log <- addLogEntry("General| center expression", parameter.list$general.do.center, df.log, "general.do.center")
df.log <- addLogEntry("General| robust PCA", parameter.list$general.robust.pca, df.log, "general.robust.pca")
df.log <- addLogEntry("General| weigh PCA by variance", parameter.list$general.weight.by.var, df.log, "general.weight.by.var")
df.log <- addLogEntry("General| Variance explained by PCA", parameter.list$general.pca.cum.sum, df.log, "general.pca.cum.sum")
df.log <- addLogEntry("General| KNN", parameter.list$general.umap.knn, df.log, "general.umap.knn")
df.log <- addLogEntry("General| Target modular purity", parameter.list$general.cluster.purity, df.log, "general.cluster.purity")
df.log <- addLogEntry("General| Scale-free topology enforced", parameter.list$general.scale.free.topology, df.log, "general.scale.free.topology")

```

```{r get past module logs, include = FALSE}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r recode barcodes, warning = FALSE}


if (exists("barcode.list") && (length(barcode.list) > 0)){

df.meta <- so.query@meta.data

# relabel barcodes
bc.list <-barcode.list

df.meta$bc <- NA
for (i in 1:length(bc.list)){
  
  pattern <- bc.list[[i]]
  pattern.replace <- names(bc.list)[i]
  df.meta$bc[grepl(pattern, df.meta$Barcode)] <- pattern.replace
}

so.query@meta.data <- df.meta
  
} else {
  
  
  u.bc <- unique(so.query@meta.data[["Barcode"]])
  bc.list <- list()
  for (i in 1:length(u.bc)){
    bc.list[[i]] <- u.bc[i]
  }
  names(bc.list) <- u.bc
so.query@meta.data[["bc"]] <- so.query@meta.data[["Barcode"]]
}

```


```{r Network analysis - 1 - prep data, warning = FALSE}

miko_message("Identifying expressed and variable genes for network analysis...")
  # get minimally expressed genes ################################################
  min.pct <-  parameter.list$min.pct # default 0.2
  split.var <- "seurat_clusters" 
  
  
  if (parameter.list$variable.only){
    which.rep.genes2 <- unique(VariableFeatures(so.query))    
  } else {
    which.rep.genes <- getExpressedGenes(object = so.query, min.pct = min.pct, group = split.var, group.boolean = "OR")
    which.rep.genes2 <- unique(c(VariableFeatures(so.query), which.rep.genes))    
  }


    if (parameter.list$species == "Hs"){
    tf.trust <- colnames(geneSets[["TRRUSTv2_Hs"]])
    tf.animal <- (geneSets[["AnimalTFDB"]])$Hs      
    } else if (parameter.list$species == "Mm"){
    tf.trust <- colnames(geneSets[["TRRUSTv2_Mm"]])
    tf.animal <- (geneSets[["AnimalTFDB"]])$Mm        
    }

    
    
    which.TF <- unique(c(tf.trust, tf.animal))
    which.TF <- which.TF[which.TF %in% which.rep.genes2]

  which.rep.common <- which.rep.genes2

```

```{r optimize power}


# ensure node-linkage follows power distribution
if ((parameter.list$tf.scale.free.topology) |  (parameter.list$general.scale.free.topology)){

scaleFreeNet <- function(object, graph.name = "RNA_snn", n.dim, n.workers = 4){
  
  suppressMessages({
    suppressWarnings({

  
  power.all <- c(seq(0.5, 5, by = 0.5), seq(6, 10))
  # n.work <-   parallel::detectCores()
  # if (length(power.all) < n.work) n.work <- length(power.all)
  miko_message("Identifying optimal power...")
  st.res <- getSoftThreshold2(
    s.mat = as.matrix(object@graphs[[graph.name]]),
    power = power.all,
    network.type = "unsigned",
    nBreaks = 20,
    removeFirst = T,
    rescale.adjacency = F,
    n.cores = n.workers,
    r2.target = 0.9
  )
  
  
  new.graph <- paste0(graph.name, "_power")
  object@graphs[[new.graph]] <- object@graphs[[graph.name]]
  object@graphs[[new.graph]]@x <- object@graphs[[graph.name]]@x ^ st.res$powerEstimate
  miko_message(paste0("\tOptimal Power: ",  st.res$powerEstimate))
  
  if (st.res$powerEstimate > 1){
    object <- tryCatch({
      object <- RunUMAP(object,  graph = new.graph, umap.method = "umap-learn") #, umap.method = "umap-learn"
      object <- FindClusters(object, resolution = 1, verbose = F,  graph.name = new.graph)
    }, error = function(e){
      object <- RunUMAP(object, dims = 1:n.dim, n.neighbors = parameter.list$general.umap.knn, reduction  = "pca")
      object <- FindClusters(object, resolution = 1, verbose = F)
      return(object)
    })    
  } else {
    object <- RunUMAP(object, dims = 1:n.dim, n.neighbors = parameter.list$general.umap.knn, reduction  = "pca")
    object <- FindClusters(object, resolution = 1, verbose = F)    
  }
  

  snn.all <-  object@graphs[[new.graph]]@x
  snn.all[snn.all == 1] <- NA
  nn.threshold <- quantile(snn.all, 0.9, na.rm = T)
  
  new.nn <- paste0(new.graph, "_binary")
  object@graphs[[new.nn]] <- object@graphs[[new.graph]]
  object@graphs[[new.nn]]@x <- 0
  object@graphs[[new.nn]]@x[object@graphs[[graph.name]]@x > nn.threshold] <- 1
  
        
    })
  })

  return(
    list(
      object = object,
      st.res = st.res
    )
  )
  
}
  
}
    
```


```{r Network analysis - 2 - generate network, warning = FALSE}

# which reduction to use

which.red <- "pca"
which.data <- "scale" # data, scale

if (parameter.list$tf.robust.pca){
  tfPCA <- runRPCA
} else {
  tfPCA <- RunPCA
}

if (parameter.list$general.robust.pca){
  generalPCA <- runRPCA
} else {
  generalPCA <- RunPCA
}


# prep expression matrices
miko_message("Preparing expression matrix...")
if (which.data == "data"){
  expr.mat <- so.query@assays[[DefaultAssay(so.query)]]@data
} else if (which.data == "scale"){
  
  all.required.genes <- unique(c(which.TF, which.rep.common))
  
  # get SCTransform-scaled expression values
  
  suppressMessages({
    suppressWarnings({
      
      so.query <-tryCatch({
        so.query <- GetResidual(object = so.query, features = all.required.genes, assay = "SCT", verbose = F,
                                clip.range = c(-sqrt(x = ncol(x = so.query)/30), sqrt(x = ncol(x = so.query)/30)), replace.value = T)
      }, error = function(e){
        
        pmt.present <- "percent.mt" %in% colnames(so.query@meta.data)
        if (pmt.present){
          var2reg <- "percent.mt"
        } else {
          var2reg <- NULL
        }
        
        all.assays <- names(so.query@assays)
        if ("RNA" %in% all.assays){
          assay.use <- "RNA"
        } else {
          assay.use <- DefaultAssay(so.query)
        }
        
        so.query <- SCTransform(object = so.query, method = "glmGamPoi", verbose = F, 
                                vars.to.regress = var2reg, assay = assay.use)
        so.query <- GetResidual(object = so.query, assay = "SCT", features =all.required.genes, verbose = F,
                                clip.range = c(-sqrt(x = ncol(x = so.query)/30), sqrt(x = ncol(x = so.query)/30)), replace.value = T)
        DefaultAssay(so.query) <- "SCT"
        
        return(so.query)
      })
      
    })
  })
  
  expr.mat <- so.query@assays[[DefaultAssay(so.query)]]@scale.data
  parameter.list$general.do.scale <- parameter.list$general.do.center <-  parameter.list$tf.do.scale <- parameter.list$tf.do.center <- F
}



e.mat.success <- F
try({
  expr.mat.tf <- t(expr.mat[rownames(expr.mat) %in% which.TF, ])
  expr.mat <- t(expr.mat[rownames(expr.mat) %in% which.rep.common, ])
  e.mat.success <- T
}, silent = T)

if (!e.mat.success){
  expr.mat.tf <- t(as.matrix(expr.mat[rownames(expr.mat) %in% which.TF, ]))
  expr.mat <- t(as.matrix(expr.mat[rownames(expr.mat) %in% which.rep.common, ]))
}

# general network
miko_message(paste0("Generating general network using ", ncol(expr.mat), " genes..."))
suppressMessages(suppressWarnings({
  so.gene <- CreateSeuratObject(expr.mat)
  so.gene <- so.gene[ ,colnames(so.gene) %in% which.rep.common]
  so.gene <- ScaleData(so.gene, do.scale = parameter.list$general.do.scale, do.center = parameter.list$general.do.center, verbose = F)
  if (parameter.list$general.robust.pca){
    so.gene <- runRPCA(so.gene, features = rownames(so.gene), verbose = F, reduction.key = "PC_", reduction.name = "pca")
  } else {
    so.gene <- RunPCA(so.gene, weight.by.var = parameter.list$general.weight.by.var, features = rownames(so.gene), verbose = F)
  }
  
  df.prop <- propVarPCA(so.gene)
  n.dim <- min(which(df.prop$pc.cum_sum > parameter.list$general.pca.cum.sum))
  so.gene <- FindNeighbors(so.gene, dims = 1:n.dim, reduction = which.red, verbose = F)
  
  if (parameter.list$general.scale.free.topology){
    sfn.res <- scaleFreeNet(object = so.gene, graph.name = "RNA_snn", n.dim = n.dim)
    so.gene <- sfn.res$object
    sfn.res$object <- NULL
    plt.sft <- cowplot::plot_grid(sfn.res$st.res$optimization.plot,
                                  sfn.res$st.res$distribution.plot[[as.character(sfn.res$st.res$powerEstimate)]])
    
  } else {
    so.gene <- RunUMAP(so.gene, dims = 1:n.dim, n.neighbors = parameter.list$general.umap.knn, reduction  = "pca")
    so.gene <- FindClusters(so.gene, resolution = 1, verbose = F) 
    
    plt.sft <- NULL
  }
  
  
}))

if (parameter.list$print.inline) cluster.UMAP(so.gene)

# TF-network only
miko_message(paste0("Generating transcription factor network using ", ncol(expr.mat.tf), " genes..."))
suppressMessages(suppressWarnings({
  so.tf <- CreateSeuratObject(expr.mat.tf)
  so.tf <- so.tf[ ,colnames(so.tf) %in% which.TF]
  so.tf <- ScaleData(so.tf, do.scale = parameter.list$tf.do.scale, do.center = parameter.list$tf.do.center, verbose = F)
  if (parameter.list$tf.robust.pca){
    so.tf <- runRPCA(so.tf, features = rownames(so.tf), verbose = F, reduction.key = "PC_", reduction.name = "pca")
  } else {
    so.tf <- RunPCA(so.tf, weight.by.var = parameter.list$tf.weight.by.var, features = rownames(so.tf), verbose = F)
  }
  so.tf <- RunPCA(so.tf, weight.by.var = parameter.list$tf.weight.by.var, features = rownames(so.tf), verbose = F)
  df.prop <- propVarPCA(so.tf)
  n.dim <- min(which(df.prop$pc.cum_sum > parameter.list$tf.pca.cum.sum))
  so.tf <- FindNeighbors(so.tf, dims = 1:n.dim, reduction = which.red, verbose = F)
  
  if (parameter.list$tf.scale.free.topology){
    sfn.res.tf <- scaleFreeNet(object = so.tf, graph.name = "RNA_snn", n.dim = n.dim)
    so.tf <- sfn.res.tf$object
    sfn.res.tf$object <- NULL
    
    plt.sft.tf <- cowplot::plot_grid(sfn.res.tf$st.res$optimization.plot,
                                     sfn.res.tf$st.res$distribution.plot[[as.character(sfn.res.tf$st.res$powerEstimate)]])
  } else {
    so.tf <- RunUMAP(so.tf, dims = 1:n.dim, n.neighbors = parameter.list$tf.umap.knn, reduction  = "pca")
    so.tf <- FindClusters(so.tf, resolution = 1, verbose = F) 
    
    plt.sft.tf <- NULL
  }
  
}))

if (parameter.list$print.inline) cluster.UMAP(so.tf)


```


```{r ICA - helper function, warning = FALSE}

getICAGenes <- function(feature.loading, fdr.cutoff = 0.0001, local.fdr = T, assert.positive.skew = T, only.pos = T){
  
  ica.kme <- feature.loading
  ica.kme <- apply(ica.kme, 2, function(x) (x)/sd(x, na.rm = T))

  if (assert.positive.skew){
    median.loading <- abs(apply(ica.kme, 2, min))
    mean.loading <- abs(apply(ica.kme, 2, max))
    
    pos.skew <- mean.loading > median.loading
    
    reflection.vector <- pos.skew*1
    reflection.vector[reflection.vector == 0] <- -1
    
    for (i in 1:length(reflection.vector)){
      ica.kme[,i] <- ica.kme[,i]*reflection.vector[i]
    } 
  }
  
  # compute FDR
  if (local.fdr){
    ica.p <- apply(ica.kme, 2, 
                   function(x) fdrtool::fdrtool(x, statistic=c("normal"),
                                                plot=T, color.figure=F, verbose=F, 
                                                cutoff.method=c("fndr"),
                                                pct0=0.75)$lfdr )
    
  } else {
    ica.p <- apply(ica.kme, 2, 
                   function(x) fdrtool::fdrtool(x, statistic=c("normal"),
                                                plot=T, color.figure=F, verbose=F, 
                                                cutoff.method=c("fndr"),
                                                pct0=0.75)$qval  )    
  }
  
  rownames(ica.p) <- rownames(ica.kme)
  
  # count number of sig module genes
  if (only.pos){
    ica.p[ica.kme < 0] <- fdr.cutoff+1
  }

  # get module genes
  module.genes <- apply(ica.p, 2, function(x) rownames(ica.p)[x < fdr.cutoff])
  module.size <- unlist(lapply(module.genes, length))
  ica.module.genes <- module.genes[module.size > 0]
  
  return(ica.module.genes)
}



```


```{r run ICA, warning = FALSE}
if (parameter.list$tf.ica){

miko_message("Running ICA on transcription-factor expression matrix...")
if (ncol(so.query) > 20000){
  set.seed(1023)
  so.ica <- RunICA(so.query[ ,sample(colnames(so.query), 20000)], features = colnames(so.tf), verbose = F)
} else {
  so.ica <- RunICA(so.query, features = colnames(so.tf), verbose = F)
}
ica.res.tf <- so.ica@reductions[["ica"]]

}


if (parameter.list$general.ica){
miko_message("Running ICA on general expression matrix...")
so.ica <- RunICA(so.ica, features = colnames(so.gene), verbose = F) 
ica.res.gene <- so.ica@reductions[["ica"]]

}

invisible({gc()})

```





```{r Network analysis - 3 - find optimal cluster resolution, include =  FALSE, warning = FALSE}

optimalResolution <- function(object, graph, target.purity = 0.7, start.res = 0.5, step.size = 0.05, target.level = "global", max.iter = 100, verbose = F){
  
  is.optimal <- F
  best.purity <- NA
  best.res <- NA
  
  i <- 0
  while(is.optimal == F){
    i <- i + 1
    initial.res <- start.res
    if (verbose)  miko_message(paste0("Current resolution: ", start.res))
    suppressWarnings({
      suppressMessages({
        object <- FindClusters(object, graph.name = graph, algorithm = 1, resolution = start.res, verbose = FALSE)
        object <- neighborPurity(object , graph = graph)
      })    
    })
    
    if (target.level == "global"){
      m.purity <- signif(median(object$purity), 3)
    } else if (target.level == "cluster"){
      df.cluster.purity <- data.frame(cluster = object$seurat_clusters, purity = object$purity)
      df.cluster.purity.sum <- df.cluster.purity %>%
        dplyr::group_by(cluster) %>% dplyr::summarize(m.purity = median(purity, na.rm = T), .groups = "drop")
      m.purity <- signif(min(df.cluster.purity.sum$m.purity), 3)
    }
    
    
    if (m.purity > target.purity){
      if (verbose) miko_message(paste0("\tPurity: ", m.purity)) 
      best.purity <- m.purity
      best.res <- start.res
      start.res <- start.res + step.size
    } else if (m.purity == target.purity){
      best.purity <- m.purity
      best.res <- start.res
      is.optimal <- T
     if (verbose)  miko_message(paste0("Optimal Resolution: ", best.res , " (", scMiko::ulength(object$seurat_clusters), " clusters)")  )
    } else {
      if (verbose) miko_message("\tPurity: ", m.purity) 
      
      if (is.na(best.purity)){
        start.res <-  0
      } else {
        if (verbose) message(paste0("\tToo low! Using resolution from prior iteration.") )
        is.optimal <- T
        if (verbose) message(paste0("Optimal Resolution: ", best.res , " (", scMiko::ulength(object$seurat_clusters), " clusters)") )     
      }
      
    }
    
    
    if (i == max.iter){
      message("Failed to identify optimal resolution after ", max.iter, " iterations") 
      is.optimal = T
    }
    
  }
  
  return(best.res)
  
}

group2list <- function(object, group = "seurat_clusters", is.num = F, prefix = ""){
  
  df.meta <- object@meta.data
  
  u.clust <- unique(object$seurat_clusters)
  if (is.num){
    u.clust <- as.numeric(as.character(u.clust))
    u.clust <- u.clust[order(u.clust)]
  }
  
  group.list <- list()
  for (i in 1:length(u.clust)){
    group.list[[paste0(prefix, u.clust[i])]] <- rownames(df.meta)[df.meta[, group] %in% u.clust[i]]
  }
  
  return(group.list)
}

suppressMessages({
  suppressWarnings({
    
    # general network ################
    
  
    if (!is.null(so.gene@commands[["RunUMAP.RNA.pca"]]@params[["graph"]]) && 
            so.gene@commands[["RunUMAP.RNA.pca"]]@params[["graph"]] == "RNA_snn_power"){
      # gn <- "RNA_snn_power_binary"
      gn <- "RNA_snn_power"
    } else {
      gn <- "RNA_nn" 
    }
    best.res <- optimalResolution(object = so.gene, graph = gn,
                                  target.purity = parameter.list$general.cluster.purity, start.res = 1, verbose = F,
                                  step.size = parameter.list$purity.optimization.step.size, target.level = "global", max.iter = 100)
    best.reg.general <- best.res
    if (!is.null(so.gene@commands[["RunUMAP.RNA.pca"]]@params[["graph"]]) && 
            so.gene@commands[["RunUMAP.RNA.pca"]]@params[["graph"]] == "RNA_snn_power"){
      so.gene <- FindClusters(so.gene, graph.name = gn, resolution = best.res, modularity.fxn = 1, algorithm =1)
    } else {
      so.gene <- FindClusters(so.gene,resolution = best.res, modularity.fxn = 1, algorithm =1)  
    }
    
    mod.list <- group2list(so.gene, is.num = T, prefix = "m")
    mod.hg <- runHG(mod.list, gene.universe = rownames(so.query), species = parameter.list$species, pathway.db = parameter.list$pathway.db )
    mod.sum <- summarizeHG(mod.hg, show.n = 10)
    
    # mod.sum$plots
    
    # TF network ##########################
    if (!is.null(so.tf@commands[["RunUMAP.RNA.pca"]]@params[["graph"]]) && 
            so.tf@commands[["RunUMAP.RNA.pca"]]@params[["graph"]] == "RNA_snn_power"){
      # gn <- "RNA_snn_power_binary"
      gn <- "RNA_snn_power"
    } else {
      gn <- "RNA_nn" 
    }
    best.res.tf <- optimalResolution(object = so.tf, graph = gn,
                                     target.purity = parameter.list$tf.cluster.purity, start.res = 1, verbose = F,
                                     step.size = parameter.list$purity.optimization.step.size, target.level = "global", max.iter = 100)
    best.reg.tf <- best.res
    if (!is.null(so.tf@commands[["RunUMAP.RNA.pca"]]@params[["graph"]]) && 
            so.tf@commands[["RunUMAP.RNA.pca"]]@params[["graph"]] == "RNA_snn_power"){
      so.tf <- FindClusters(so.tf, graph.name = gn, resolution = best.res, modularity.fxn = 1, algorithm =1)
    } else {
      so.tf <- FindClusters(so.tf,resolution = best.res, modularity.fxn = 1, algorithm =1)  
    }
    mod.list.tf <- group2list(so.tf, is.num = T, prefix = "m")
    mod.hg.tf <- runHG(mod.list.tf, gene.universe = rownames(so.query), species = parameter.list$species, pathway.db = parameter.list$pathway.db)
    mod.sum.tf <- summarizeHG(mod.hg.tf, show.n = 10)
    
    
  })
})

```



```{r Network analysis - 4 - color palettes, warning = FALSE}

# general network #######################
wnnUMAP.list.meso <- getUMAP(so.gene, umap.key = "umap", size = 0.05)
df.wnn.umap.meso <- wnnUMAP.list.meso$df.umap

df.wnn.umap.meso.sum  <- df.wnn.umap.meso %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::summarize(x.mean = median(x), y.mean = median(y), .groups = 'drop')
plt.wnn.umap.meso <- wnnUMAP.list.meso$plt.umap +
  xlab("geneUMAP 1") + ylab("geneUMAP 2") +
  geom_text(data = df.wnn.umap.meso.sum, aes(x = x.mean, y = y.mean, label = seurat_clusters), inherit.aes = F) + 
  labs(title = "general Transcriptional Network", subtitle = paste0(ncol(so.gene), " genes"))

# get color palettes for each gene module
u.mod.p13 <- unique(as.numeric(as.character(so.gene@meta.data$seurat_clusters)))
u.mod.p13 <- u.mod.p13[order(u.mod.p13)]
p13.col <- categoricalColPal(labels = u.mod.p13)
plt.wnn.umap.meso <- plt.wnn.umap.meso + scale_color_manual(values = p13.col) + labs(color = "Module")  + guides(color = guide_legend(override.aes = list(size = 5)))


# TF network ################################
wnnUMAP.list.tf <- getUMAP(so.tf, umap.key = "umap", size = 0.05)
df.wnn.umap.tf <- wnnUMAP.list.tf$df.umap

df.wnn.umap.tf.sum  <- df.wnn.umap.tf %>%
  dplyr::group_by(seurat_clusters) %>%
  dplyr::summarize(x.mean = median(x), y.mean = median(y), .groups = 'drop')
plt.wnn.umap.tf <- wnnUMAP.list.tf$plt.umap +
  xlab("geneUMAP 1") + ylab("geneUMAP 2") +
  geom_text(data = df.wnn.umap.tf.sum, aes(x = x.mean, y = y.mean, label = seurat_clusters), inherit.aes = F) + 
  labs(title = "TF Transcriptional Network", subtitle = paste0(ncol(so.tf), " genes"))

# get color palettes for each gene module
u.mod.tf <- unique(as.numeric(as.character(so.tf@meta.data$seurat_clusters)))
u.mod.tf <- u.mod.tf[order(u.mod.tf)]
tf.col <- categoricalColPal(labels = u.mod.tf)

plt.wnn.umap.tf <- plt.wnn.umap.tf + scale_color_manual(values = tf.col) + guides(color = guide_legend(override.aes = list(size = 5))) + labs(color = "Module")


if (parameter.list$print.inline) plt.wnn.umap.meso
if (parameter.list$print.inline) plt.wnn.umap.tf

```



```{r Network analysis - 5 - network expression plots, fig.width=10, fig.height=4, warning = FALSE}

networkExpression <- function(cell.object, gene.object){
  
  plt.dot <- DotPlot(cell.object, features = colnames(gene.object))
  df.dot <- plt.dot[["data"]]
  
  u.clust <- as.numeric(as.character(unique(df.dot$id)))
  u.clust <- as.character(u.clust[order(u.clust)])
  
  df.dot$gene <- df.dot$features.plot
  
  df.wnn.umap.cur <- getUMAP(gene.object)[["df.umap"]]
  df.wnn.umap.cur$gene <- df.wnn.umap.cur$var
  
  
  df.umap.sub <- getUMAP(cell.object)[["df.umap"]]
  
  if (nrow(df.umap.sub) > 20000){
    df.umap.sub <- df.umap.sub[sample(seq(1, nrow(df.umap.sub)), 20000), ]
  }
  
  plt.clut.net.highlight.list <- list()
  for (i in 1:length(u.clust)){
    
    df.dot.cur <- df.dot %>% dplyr::filter(id == u.clust[i])
    df.wnn.umap.cur.cur <- df.wnn.umap.cur
    
    df.umap.sub.cur <- df.umap.sub
    df.umap.sub.cur$is.clust <- df.umap.sub.cur$seurat_clusters %in% u.clust[i]
    df.wnn.umap.cur.cur <- merge(df.wnn.umap.cur.cur, df.dot.cur, by = "gene")
    
    plt.clust.highlight <- df.umap.sub.cur %>%
      ggplot(aes(x = x, y = y, color = is.clust)) + 
      geom_point(size = 0.5) + 
      scale_color_manual(values= c("TRUE" = "tomato", "FALSE" = "grey")) + 
      theme_miko()+ theme_void() + theme(legend.position = "none") + 
      labs(x = "UMAP 1", y = "UMAP 2", title = paste0("C", u.clust[i],  " Cell Expression"), subtitle = " ")
    
    plt.clut.net <- df.wnn.umap.cur.cur %>% 
      ggplot(aes(x = x, y = y, color = avg.exp.scaled, size = pct.exp)) + 
      scale_color_gradient2(low = scales::muted("blue"), high = scales::muted("red")) + 
      geom_point() + theme_miko(legend = T) + theme_void()+ 
      scale_size(range = c(0, 5)) + 
      labs(x = "UMAP 1", y = "UMAP 2", title = paste0("C", u.clust[i],  " Network Expression"), subtitle = "Transcriptomic Network", color = "expr")

    plt.clut.net.highlight <- cowplot::plot_grid(plt.clust.highlight, plt.clut.net)
    plt.clut.net.highlight.list[[paste0("c", u.clust[i])]] <- plt.clut.net.highlight
  }
  
  return(plt.clut.net.highlight.list)
}

# get network expression plots
plt.net.expr.tf <- networkExpression(so.query, so.tf)
plt.net.expr.general <- networkExpression(so.query, so.gene)

```

```{r Network analysis - 6 - combine network expression plots, fig.width= 35, fig.height=30, warning = FALSE}

plt.clut.net.tf.highlight <- cowplot::plot_grid(plotlist = plt.net.expr.tf, ncol = 3)
if (parameter.list$print.inline) plt.clut.net.tf.highlight

plt.clut.net.general.highlight <- cowplot::plot_grid(plotlist = plt.net.expr.general, ncol = 3)
if (parameter.list$print.inline) plt.clut.net.general.highlight

# plt.clut.net.general.highlight
# savePDF("networkExpression_TF_230421.pdf", plt.clut.net.tf.highlight, fig.width= 35, fig.height=30)
# savePDF("networkExpression_generalWide_230421.pdf", plt.clut.net.meso.highlight, fig.width= 35, fig.height=30)
```






```{r Network analysis - 7 - meta module activity, warning = FALSE}

moduleActivity <- function(object, df.wnn.umap, species = "Mm", pathway.db = "Bader"){
  
  u.clust.all <- unique(df.wnn.umap$seurat_clusters)
  u.clust.all <- as.numeric(as.character(u.clust.all))
  u.clust.all <- u.clust.all[order(u.clust.all)]
  gene.cluster.list <- list()
  
  # df.metamodule <- NULL
  for (j in 1:length(u.clust.all)){
    gene.cluster.list[[paste0("c", u.clust.all[j])]] <- df.wnn.umap$var[df.wnn.umap$seurat_clusters %in% u.clust.all[j]]
    
  }
  
  df.mod <- NULL
  for (i in 1:length(gene.cluster.list)){
    df.mod <- bind_rows(df.mod, data.frame(genes = gene.cluster.list[[i]], module = names(gene.cluster.list)[i]))
  }
  df.mod <- df.mod[order(df.mod$genes), ]
  
  gene.net.auc <-  runMS(
    object = object,
    genelist = gene.cluster.list,
    assay = DefaultAssay(object),
    size = autoPointSize(ncol(object)),
    winsorize.quantiles = c(0.01, 0.99)
  )
  
  
  return(
    list(
      gene.net.auc = gene.net.auc,
      gene.cluster.list = gene.cluster.list,
      df.mod = df.mod
      
    )
  )
  
}




# compute network module activity scores
mod.res.tf <- moduleActivity(object = so.query, df.wnn.umap = df.wnn.umap.tf, 
                             species = parameter.list$species, pathway.db = parameter.list$pathway.db)
mod.res.meso <- moduleActivity(object = so.query, df.wnn.umap = df.wnn.umap.meso, 
                             species = parameter.list$species, pathway.db = parameter.list$pathway.db)
invisible({gc()})

# combine plots
# plt.meso.module.umap.plots <- cowplot::plot_grid(plotlist =mod.res.meso$gene.net.auc$plot.list, ncol = 4)
# plt.tf.module.umap.plots <- cowplot::plot_grid(plotlist =mod.res.tf$gene.net.auc$plot.list, ncol = 4)

# plt.tf.module.umap.plots

# mod.res.meso$gene.net.auc$plot.list
 # savePDF("cellActivity_byNetworkModule_generalWide_260421.pdf",plt.meso.module.umap.plots, fig.width=20, fig.height=20)
 # savePDF("cellActivity_byNetworkModule_TF_230421.pdf",plt.tf.module.umap.plots, fig.width=20, fig.height=10)
# plt.meso.module.umap.plots
```




```{r Network analysis - 8 - modular scores as heatmap, warning = FALSE}


maHM <- function(cell.object, df.wnn.umap, mod.res, k.row = 2, k.col = 2){
  
  
  u.mod <- as.numeric(as.character(unique(df.wnn.umap$seurat_clusters)))
  df.auc <- mod.res$gene.net.auc$data
  
  df.meta <- cell.object@meta.data
  
  df.auc.cur.sum.all <- NULL
  for (i in 1:length(u.mod)){
    
    mod.name <- paste0("c", u.mod[i])
    
    df.auc.cur <- df.auc[ ,c("cells", "x", "y", mod.name)]
    df.auc.cur$cluster <- df.meta$seurat_clusters
    
    colnames(df.auc.cur) <- c("cells", "x", "y", "z", "cluster")
    
    df.auc.cur.sum <- df.auc.cur %>%
      dplyr::group_by(cluster) %>%
      dplyr::summarize(z.mean = mean(z), .groups = 'drop')
    
    df.auc.cur.sum$module <- mod.name
    
    df.auc.cur.sum.all <- bind_rows(df.auc.cur.sum.all, df.auc.cur.sum)
  }
  
  
  df.auc.cur.sum.all.wide <- pivot_wider(df.auc.cur.sum.all, names_from = "module", values_from = "z.mean")
  df.auc.cur.sum.all.wide$cluster <- as.character(df.auc.cur.sum.all.wide$cluster)
  r.name <- df.auc.cur.sum.all.wide$cluster
  df.auc.cur.sum.all.wide <- col2rowname(df.auc.cur.sum.all.wide, "cluster")
  
  
  df.auc.cur.sum.all.wide <- as.data.frame(apply(df.auc.cur.sum.all.wide, 2, function(x) scale(x)))
  rownames(df.auc.cur.sum.all.wide) <- r.name
  
  w.thresh <- 5
  df.auc.cur.sum.all.wide[df.auc.cur.sum.all.wide > w.thresh] <- w.thresh
  df.auc.cur.sum.all.wide[df.auc.cur.sum.all.wide < -w.thresh] <- -w.thresh
  
  colnames(df.auc.cur.sum.all.wide) <- gsub("c", "m", colnames(df.auc.cur.sum.all.wide))
  rownames(df.auc.cur.sum.all.wide) <-paste0("c", rownames(df.auc.cur.sum.all.wide))
  
  # scale.lim <- max(abs(df.auc.cur.sum.all.wide))
  # my.
  plt.hm <- ggplotify::as.ggplot(pheatmap::pheatmap(df.auc.cur.sum.all.wide, cutree_rows = k.row, cutree_cols = k.col,silent = T,
                                                    scale = "column",
                                                    color = colorRampPalette(rev(brewer.pal(n = 7, name = "RdBu")))(100)))
  
  
  plt.hm <- plt.hm + labs(title = "Cluster-level Modular Activity", subtitle = "x: gene module, y: cell cluster, z: scaled expr." ) +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(plot.subtitle = element_text(hjust = 0.5))
  
  return(plt.hm)
  
}

# # generate modular activity HM (stratified by cell cluster)
plt.hm.tf <- maHM(cell.object = so.query, df.wnn.umap = df.wnn.umap.tf, mod.res = mod.res.tf, k.row = NA, k.col = NA)
plt.hm.meso <- maHM(cell.object = so.query, df.wnn.umap = df.wnn.umap.meso, mod.res = mod.res.meso, k.row = NA, k.col = NA)

if (parameter.list$print.inline) plt.hm.tf
if (parameter.list$print.inline) plt.hm.meso

# savePDF("modularActivity_heatmap_generalWideNetwork_230421.pdf", plt.hm.meso, fig.width = 7, fig.height = 6)
# savePDF("modularActivity_heatmap_TFNetwork_230421.pdf", plt.hm.tf, fig.width = 7, fig.height = 6)

```


```{r Network analysis - 9 - network connectivity prep}

prepConnectivityObjects <- function(gene.object){
  
  # get connectivity ########################################
  # snn.graph <- as.matrix(gene.object@graphs[["RNA_snn"]])
  
    
  if ("RNA_snn_power" %in% names(gene.object@graphs)){
    graph <- "RNA_snn_power"
  } else {
     graph <- "RNA_snn"
  }
  snn.graph <- as.matrix(gene.object@graphs[[graph]])
  
  df.connectivity <- getConnectivity(snn.graph, rownames(snn.graph))
  
  graph.threshold <- quantile(snn.graph[snn.graph > 0], 0.85)
  df.graph.edges <- NULL

    knn.weights <- apply(snn.graph, 2, function(x) x[x>=graph.threshold])
  df.kw <- bind_rows(knn.weights)
  df.kw <- as.data.frame(df.kw)
  rownames(df.kw) <- names(knn.weights)
  df.kw.col <- colnames(df.kw)
  df.kw$start <- names(knn.weights)
  df.graph.edges <- pivot_longer(df.kw, cols = df.kw.col)
  df.graph.edges <- df.graph.edges[complete.cases(df.graph.edges), ]
  colnames(df.graph.edges) <- c("end", "start", "weights")
  
  snnUMAP.list <- getUMAP(gene.object, umap.key = "umap", node.type = "text")
  
  # snnUMAP.list <- getUMAP(so.gene.meso, umap.key = "wnn.umap", node.type = "text")
  df.snn.umap <- snnUMAP.list$df.umap
  df.snn.umap.x <- df.snn.umap
  colnames(df.snn.umap.x) <- c("x.start", "y.start", "start", "cluster")
  df.snn.umap.y <- df.snn.umap
  colnames(df.snn.umap.y) <- c("x.end", "y.end", "end", "cluster")
  df.ux <- merge(df.graph.edges, df.snn.umap.x, by = "start")
  df.uy <- merge(df.graph.edges, df.snn.umap.y, by = "end")
  df.umap.merge <- merge(df.ux, df.uy, by = c("start", "end"))
  
  df.snn.umap$genes <- df.snn.umap$var
  
  df.snn.umap <- merge(df.snn.umap, df.connectivity, by = "genes")
  
  return(
    list(
      df.snn.umap = df.snn.umap,
      df.umap.merge = df.umap.merge
    )
  )
}

message("Preparing connectivity objects...")
tf.connectivity.list <- prepConnectivityObjects(so.tf)
meso.connectivity.list <- prepConnectivityObjects(so.gene)

# generate connectivity plots
plt.tf.connectivitiy <- ggplot() + 
  ggrastr::rasterise(geom_segment(data = tf.connectivity.list$df.umap.merge, aes(x = x.start, y = y.start,
                                                                                 xend = x.end, yend= y.end,
  ), color = "black", alpha = 0.015), dpi = 700)  +
  theme_miko(legend = T) +
  theme(
    panel.border = element_blank(),
    axis.text = element_blank(),
    panel.grid = element_blank(),
    axis.ticks = element_blank()
  ) + xlab("") + ylab("") 

plt.general.connectivitiy <- ggplot() + 
  ggrastr::rasterise(geom_segment(data = meso.connectivity.list$df.umap.merge, aes(x = x.start, y = y.start,
                                                                                   xend = x.end, yend= y.end,
  ), color = "black", alpha = 0.015), dpi = 700)  +
  theme_miko(legend = T) +
  theme(
    panel.border = element_blank(),
    axis.text = element_blank(),
    panel.grid = element_blank(),
    axis.ticks = element_blank()
  ) + xlab("") + ylab("") 


# plt.tf.connectivitiy
# plt.general.connectivitiy

```



```{r ICA - get modules and pool similar sets, fig.width=15, fig.height=5, include = FALSE, warning = FALSE}

icaSubnet <- function(cell.object, gene.object, ica.object, cell.emb.ica, feat.emb.ica, connectivity.plot){
  

# cell to cluster mapping
cellClusterMap <- data.frame(cell = colnames(ica.object), cluster = ica.object@meta.data$seurat_clusters)

# cluster-level ICA activity
u.cluster <- as.numeric(as.character(unique(cellClusterMap$cluster)))
u.cluster <- u.cluster[order(u.cluster)]
ica.cluster.activity <- matrix(nrow = length(u.cluster), ncol = dim(cell.emb.ica)[2])
for (i in 1:(length(u.cluster))){
  which.cell <- cellClusterMap$cell[cellClusterMap$cluster == u.cluster[i]]
  for (j in 1:(dim(cell.emb.ica)[2])){
    ica.cluster.activity[i,j] <- mean(cell.emb.ica[ rownames(cell.emb.ica) %in% which.cell,j])
  }
}
rownames(ica.cluster.activity) <- u.cluster
colnames(ica.cluster.activity) <- colnames(cell.emb.ica)

 plt.ica.expr <- ggplotify::as.ggplot(pheatmap::pheatmap(ica.cluster.activity, 
                                                         silent = T,
                                                         color = colorRampPalette(rev(brewer.pal(n = 7, name =   "RdBu")))(100),
                                                         main = "ICA Pathway Activities\nx=ICA; y=cluster; z=activity", scale  = "column")) 
# get ICA cluster activity dendrograms

# pool similar modules
ica.fuz.df <- data.frame(feat.emb.ica)
# u.ica.modules <- unique(module.ica.colours)
# 
# get ica genes
ica.module.genes <- getICAGenes(feat.emb.ica)

ica.module.merge.genes <- ica.module.genes
names(ica.module.merge.genes) <- paste0("ICM", seq(1:length(ica.module.merge.genes)))
ica.hg.res <- runHG(ica.module.merge.genes, gene.universe = rownames(so.query), species = parameter.list$species, pathway.db = parameter.list$pathway.db)
ica.hg.sum <- summarizeHG(ica.hg.res, show.n = 10)
# ica.hg.sum$plots

icm.col.pal <- categoricalColPal(names(ica.module.merge.genes))

df.umap.icm <- getUMAP(gene.object)[["df.umap"]]
df.umap.cell.ic <- getUMAP(ica.object)[["df.umap"]]
df.umap.icm$gene <- df.umap.icm$var
plt.ica.list <- list()
for (i in 1:length(ica.module.merge.genes)){
  
  
  df.umap.cell.ic$cell.loading <- cell.emb.ica[ ,i]
  
  if (median(df.umap.cell.ic$cell.loading) > mean(df.umap.cell.ic$cell.loading)){
    df.umap.cell.ic$cell.loading <- df.umap.cell.ic$cell.loading*(-1)
  }
  
  plt.icm.cell <- df.umap.cell.ic %>%
    ggplot(aes(x = x, y = y, color = cell.loading)) + 
    geom_point(size = autoPointSize(nrow(df.umap.cell.ic))) + 
    theme_miko() + theme_void() + labs(title = "Cellular UMAP", subtitle = paste0(names(ica.module.merge.genes)[i], " cell loading")) + 
    scale_color_gradient2(low = scales::muted("blue"), high = scales::muted("red"))
  
  df.umap.icm.cur <- df.umap.icm
  df.umap.icm.cur$is.mod <- df.umap.icm.cur$var %in% ica.module.merge.genes[[i]]
  n.mod.gene <- sum(df.umap.icm.cur$is.mod)
  top.n <- 30
  if (top.n > n.mod.gene) top.n <- n.mod.gene
  ica.fuz.df.cur <- data.frame(gene = rownames(ica.fuz.df), loading = ica.fuz.df[,i])
  df.umap.icm.cur <- merge(df.umap.icm.cur, ica.fuz.df.cur, by = "gene", all.x = T)
  min.size <- 0.1 * min(abs(df.umap.icm.cur$loading[df.umap.icm.cur$is.mod]), na.rm = T)
  df.umap.icm.cur$loading[!df.umap.icm.cur$is.mod] <- min.size
  
  
  df.umap.icm.cur$loading <- abs(df.umap.icm.cur$loading)
  df.umap.icm.top <- df.umap.icm.cur %>% dplyr::top_n(top.n, loading)
  df.umap.icm.top <- df.umap.icm.top %>% dplyr::filter(loading != min.size)
 if (nrow(df.umap.icm.top) > top.n) df.umap.icm.top <- df.umap.icm.top[1:top.n, ]

 # plt.icm <-  df.umap.icm.cur %>%
 #   dplyr::arrange(is.mod) %>%
 #    ggplot(aes(x = x, y = y, fill = is.mod, color = is.mod, size = loading)) + 
 #    geom_point(pch = 21) + theme_miko() + 
 #   theme_void() + theme(legend.position = "none") + 
 #    labs(x = "geneUMAP 1", y = "geneUMAP 2", title = "Transcription factor network", subtitle = names(ica.module.merge.genes)[i] ) + 
 #    scale_fill_manual(values = c("TRUE" = as.vector(icm.col.pal[names(ica.module.merge.genes)[i]]), "FALSE" = "grey98")) + 
 #   scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "grey80")) + 
 #   scale_size(range = c(0.5,5)) + 
 #   ggrepel::geom_text_repel(data = df.umap.icm.top, aes(x = x,  y =y, label = gene), inherit.aes = F)
 
  df.umap.icm.cur <- df.umap.icm.cur %>% dplyr::filter(is.mod)
  plt.icm <-  connectivity.plot + 
    geom_point(data = df.umap.icm.cur, pch = 21, aes(x = x, y = y, fill = is.mod, color = is.mod, size = loading)) + theme_miko() + 
   theme_void() + theme(legend.position = "none") + 
    labs(x = "geneUMAP 1", y = "geneUMAP 2", title = "Transcription factor network", subtitle = names(ica.module.merge.genes)[i] ) + 
    scale_fill_manual(values = c("TRUE" = as.vector(icm.col.pal[names(ica.module.merge.genes)[i]]), "FALSE" = "grey98")) + 
   scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "grey80")) + 
   scale_size(range = c(0.5,5)) + 
   ggrepel::geom_text_repel(data = df.umap.icm.top, aes(x = x,  y =y, label = gene), inherit.aes = F, max.overlaps = Inf)
    
    
   #  df.umap.icm.cur %>%
   # dplyr::arrange(is.mod) %>%
   #  ggplot(aes(x = x, y = y, fill = is.mod, color = is.mod, size = loading)) + 
   #  geom_point(pch = 21) + theme_miko() + 
   # theme_void() + theme(legend.position = "none") + 
   #  labs(x = "geneUMAP 1", y = "geneUMAP 2", title = "Transcription factor network", subtitle = names(ica.module.merge.genes)[i] ) + 
   #  scale_fill_manual(values = c("TRUE" = as.vector(icm.col.pal[names(ica.module.merge.genes)[i]]), "FALSE" = "grey98")) + 
   # scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "grey80")) + 
   # scale_size(range = c(0.5,5)) + 
   # ggrepel::geom_text_repel(data = df.umap.icm.top, aes(x = x,  y =y, label = gene), inherit.aes = F)
 
 plt.icm.hg <- ica.hg.sum$plots[[names(ica.module.merge.genes)[i]]]
 plt.icm.sum <- cowplot::plot_grid(plt.icm.cell, plt.icm, plt.icm.hg, ncol = 3)
 plt.ica.list[[names(ica.module.merge.genes)[i]]] <-plt.icm.sum

}

return(
  list(
    plt.ica.list = plt.ica.list,
    plt.ica.expr = plt.ica.expr,
    ica.fuz.df = ica.fuz.df,
    ica.module.genes = ica.module.merge.genes
  )
)
}

if (parameter.list$tf.ica){
  plt.ica.tf.all <- icaSubnet(cell.object = so.query, gene.object = so.tf, 
                              ica.object = so.ica, cell.emb.ica =  ica.res.tf@cell.embeddings, feat.emb.ica = ica.res.tf@feature.loadings, 
                              connectivity.plot = plt.tf.connectivitiy)
  
  plt.ica.tf <- plt.ica.tf.all$plt.ica.list
  plt.ica.tf.hm.expr <- plt.ica.tf.all$plt.ica.expr
  df.ica.loading.tf <- as.data.frame(apply(plt.ica.tf.all$ica.fuz.df, 2, signif, 5))
}

if (parameter.list$general.ica){
  plt.ica.gene.all <- icaSubnet(cell.object = so.query, gene.object = so.gene, 
                                ica.object = so.ica, cell.emb.ica =  ica.res.gene@cell.embeddings, feat.emb.ica = ica.res.gene@feature.loadings, 
                                connectivity.plot = plt.general.connectivitiy)
  
  plt.ica.gene <- plt.ica.gene.all$plt.ica.list
  plt.ica.gene.hm.expr <- plt.ica.gene.all$plt.ica.expr
  df.ica.loading.gene <- as.data.frame(apply(plt.ica.gene.all$ica.fuz.df, 2, signif, 5))
}

try({
  if (parameter.list$print.inline) plt.ica.tf
  if (parameter.list$print.inline) plt.ica.tf.hm.expr
  if (parameter.list$print.inline) plt.ica.gene
  if (parameter.list$print.inline) plt.ica.gene.hm.expr
}, silent = T)


```

```{r fig.width=15, fig.height=5}


modSubNet <- function(gene.object, cell.object, ma.list, gene.list, hg.list, df.snn.umap, connectivity.plot, plt.name, col.pal){
  
names(ma.list) <- gsub("c", "m", names(ma.list))
df.umap.gene <- getUMAP(gene.object)[["df.umap"]]
df.umap.gene$gene <- df.umap.gene$var
df.snn.umap$gene <- df.snn.umap$genes

plt.list <- list()
for (i in 1:length(gene.list)){
  
  mod.name <- names(gene.list)[i]
  
  plt.mod.cell <- ma.list[[mod.name]] + theme_void() + labs(title = "Cellular UMAP", subtitle = paste0(mod.name, " Modular Activity"))
    
  df.umap.gene.cur <- df.umap.gene
  df.umap.gene.cur$is.mod <- df.umap.gene.cur$var %in% gene.list[[i]]
  
    n.mod.gene <- sum(df.umap.gene.cur$is.mod)
  top.n <- 30
  if (top.n > n.mod.gene) top.n <- n.mod.gene
  
  df.umap.gene.cur <- merge(df.umap.gene.cur, df.snn.umap, by = c("gene", "x", "y", "var", "seurat_clusters"))

  min.size <- 0.1 * min(abs(df.umap.gene.cur$wi[df.umap.gene.cur$is.mod]), na.rm = T)
  df.umap.gene.cur$wi[!df.umap.gene.cur$is.mod] <- min.size
  df.umap.gene.top <- df.umap.gene.cur %>% dplyr::top_n(top.n, wi)
  if (nrow(df.umap.gene.top) > top.n) df.umap.gene.top <- df.umap.gene.top[1:top.n, ]

 # plt.mod.umap <-  df.umap.gene.cur %>%
 #   dplyr::arrange(is.mod) %>%
 #    ggplot(aes(x = x, y = y, fill = is.mod, color = is.mod, size = wi)) + 
 #    geom_point(pch = 21) + theme_miko() + 
 #   theme_void() + theme(legend.position = "none") + 
 #    labs(x = "geneUMAP 1", y = "geneUMAP 2", title = plt.name, subtitle = mod.name) + 
 #    scale_fill_manual(values = c("TRUE" = as.vector(col.pal[gsub("m", "", mod.name)]), "FALSE" = "grey98")) + 
 #   scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "grey80")) + 
 #   scale_size(range = c(0.5,5)) + 
 #   ggrepel::geom_text_repel(data = df.umap.gene.top, aes(x = x,  y =y, label = gene), inherit.aes = F)
 
 df.umap.gene.cur <- df.umap.gene.cur %>% dplyr::filter(is.mod)
 plt.mod.umap <-  connectivity.plot + 
   geom_point(data = df.umap.gene.cur, pch = 21, aes(x = x, y = y, fill = is.mod, color = is.mod, size = wi)) + theme_miko() + 
   theme_void() + theme(legend.position = "none") + 
   labs(x = "geneUMAP 1", y = "geneUMAP 2", title = plt.name, subtitle = mod.name) + 
   scale_fill_manual(values = c("TRUE" = as.vector(col.pal[gsub("m", "", mod.name)]), "FALSE" = "grey98")) + 
   scale_color_manual(values = c("TRUE" = "grey", "FALSE" = "grey80")) + 
   scale_size(range = c(0.5,5)) + 
   ggrepel::geom_text_repel(data = df.umap.gene.top, aes(x = x,  y =y, label = gene), inherit.aes = F, segment.alpha = 0.15, size = 3, max.overlaps = Inf)
 
 
 plt.mod.hg <- hg.list[[mod.name]]
 
 plt.mod..sum <- cowplot::plot_grid(plt.mod.cell, plt.mod.umap, plt.mod.hg, ncol = 3)
 
 plt.list[[mod.name]] <- plt.mod..sum

}

return(plt.list)
  
}


mod.subnet.tf <- modSubNet(gene.object = so.tf, cell.object = so.query, ma.list = mod.res.tf$gene.net.auc$plot.list, gene.list = mod.list.tf, hg.list = mod.sum.tf$plots, df.snn.umap = tf.connectivity.list$df.snn.umap, connectivity.plot = plt.tf.connectivitiy, plt.name = "Transcription Factor Network", col.pal = tf.col)

mod.subnet.gene <- modSubNet(gene.object = so.gene, cell.object = so.query, ma.list = mod.res.meso$gene.net.auc$plot.list, gene.list = mod.list, hg.list = mod.sum$plots, df.snn.umap = meso.connectivity.list$df.snn.umap, connectivity.plot = plt.general.connectivitiy, plt.name = "General Network", col.pal = p13.col)


# mod.subnet.gene$m1
# mod.subnet.gene$m1

    # mod.subnet.tf
    
```



```{r Network analysis - 11 - generate network connectivity map , fig.width = 8, fig.height = 6}

connectivityUMAP <- function(object, connectivity.plot, col.pal,umap.key = "umap", show.top.n = 5, goi = NA, segment.alpha = 0.015, label.size = 1.5, rasterise = T, ...){
  
  # get connectivity #############################################################
   # graph = "RNA_snn", 
  
  message("Getting network linkages...")
  if ("RNA_snn_power" %in% names(object@graphs)){
    graph <- "RNA_snn_power"
  } else {
     graph <- "RNA_snn"
  }
  snn.graph <- as.matrix(object@graphs[[graph]])
  df.connectivity <- getConnectivity(snn.graph, rownames(snn.graph))
  
  graph.threshold <- quantile(snn.graph[snn.graph > 0], 0.85)
  # df.graph.edges2 <- NULL
  
  knn.weights <- apply(snn.graph, 2, function(x) x[x>=graph.threshold])
  df.kw <- bind_rows(knn.weights)
  df.kw <- as.data.frame(df.kw)
  rownames(df.kw) <- names(knn.weights)
  df.kw.col <- colnames(df.kw)
  df.kw$start <- names(knn.weights)
  df.graph.edges <- pivot_longer(df.kw, cols = df.kw.col)
  df.graph.edges <- df.graph.edges[complete.cases(df.graph.edges), ]
  colnames(df.graph.edges) <- c("end", "start", "weights")
  
  # df.graph.edges <- df.graph.edges %>% dplyr::arrange(weights)
  # 
  # 
  # for (i in 1:ncol(snn.graph)){
  #   cur.graph <- snn.graph[ ,i]
  #   cur.graph <- cur.graph[cur.graph>=graph.threshold ]
  # 
  #   if (length(cur.graph) == 0) next
  # 
  #   df.graph.edges2 <- bind_rows(df.graph.edges2, data.frame(
  #     start = colnames(snn.graph)[i],
  #     end = names(cur.graph),
  #     weights = cur.graph
  #   ))
  # 
  # }
  # 
  # df.graph.edges2 <- df.graph.edges2 %>% dplyr::arrange(weights)
  message("Constructing network graph...")
  # remove duplicates
  df.graph.edges$order <- df.graph.edges$start > df.graph.edges$end
  df.graph.edges$start.holder <- df.graph.edges$start
  df.graph.edges$end.holder <- df.graph.edges$end
  df.graph.edges$start[df.graph.edges$order] <- df.graph.edges$end.holder[df.graph.edges$order]
  df.graph.edges$end[df.graph.edges$order] <- df.graph.edges$start.holder[df.graph.edges$order]
  df.graph.edges <- df.graph.edges %>% dplyr::select(c("start", "end", "weights"))
  rownames(df.graph.edges) <- NULL
  df.graph.edges <- df.graph.edges[df.graph.edges$start != df.graph.edges$end, ]
  df.graph.edges <- df.graph.edges[!duplicated(df.graph.edges), ]

  # generate connectivity plot
  wnnUMAP.list <- getUMAP(object, umap.key = umap.key, node.type = "text")
  df.wnn.umap <- wnnUMAP.list$df.umap
  df.wnn.umap.x <- df.wnn.umap
  colnames(df.wnn.umap.x) <- c("x.start", "y.start", "start", "cluster")
  df.wnn.umap.y <- df.wnn.umap
  colnames(df.wnn.umap.y) <- c("x.end", "y.end", "end", "cluster")
  df.ux <- merge(df.graph.edges, df.wnn.umap.x, by = "start")
  df.uy <- merge(df.graph.edges, df.wnn.umap.y, by = "end")
  df.umap.merge <- merge(df.ux, df.uy, by = c("start", "end"))
  
  df.connectivity$var <- df.connectivity$genes
  df.wnn.umap <- merge(df.wnn.umap, df.connectivity, by = "var")
  
  df.wnn.umap.sum2 <- df.wnn.umap %>%
    dplyr::group_by(seurat_clusters) %>%
    dplyr::top_n(show.top.n, wi)
  
  
  if (!is.na(goi)){
    df.wnn.umap.sum3 <- df.wnn.umap %>% dplyr::filter(var %in% goi)
    if (nrow(df.wnn.umap.sum3) > 0){
      df.wnn.umap.sum2 <- unique(bind_rows(df.wnn.umap.sum2, df.wnn.umap.sum3))
    }
  }
  
  
  df.wnn.umap.sum <- df.wnn.umap %>% 
    dplyr::group_by(seurat_clusters) %>%
    dplyr::summarize(x.mean = median(x), y.mean = median(y), .groups = 'drop') 
  
  if (!rasterise){
    plt.wnn.umap.connectivity.net.all <- df.wnn.umap %>%
      ggplot(aes(x = x, y = y)) + 
      geom_segment(data = df.umap.merge, aes(x = x.start, y = y.start,
                                             xend = x.end, yend= y.end,
      ), color = "black", alpha = segment.alpha) +   #alpha = weights.x , alpha = 0.8
      geom_point(aes(fill = seurat_clusters), shape = 21, color = "grey", ...) + theme_miko(legend = T) +  #, size = wi
      scale_size_continuous(range = c(1, 5)) +
      theme(
        panel.border = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        axis.ticks = element_blank()
      ) + xlab("") + ylab("") + 
      # ggrepel::geom_text_repel(data = df.wnn.umap.sum2, aes(x = x, y = y, label = var), size = label.size) + 
      geom_text(data = df.wnn.umap.sum, aes(x = x.mean, y = y.mean, label = seurat_clusters), inherit.aes = F, size = 5) + 
      labs(size = "Degree", alpha = "Weight", fill = "Module") + 
      scale_fill_manual(values = col.pal)   
  } else {
    plt.wnn.umap.connectivity.net.all <- df.wnn.umap %>%
      ggplot(aes(x = x, y = y)) + 
      ggrastr::rasterise(geom_segment(data = df.umap.merge, aes(x = x.start, y = y.start,
                                                                xend = x.end, yend= y.end,
      ), color = "black", alpha = segment.alpha)) +   #alpha = weights.x , alpha = 0.8
      geom_point(aes(fill = seurat_clusters), shape = 21, color = "grey", ...) + theme_miko(legend = T) +  #, size = wi
      scale_size_continuous(range = c(1, 5)) +
      theme(
        panel.border = element_blank(),
        axis.text = element_blank(),
        panel.grid = element_blank(),
        axis.ticks = element_blank()
      ) + xlab("") + ylab("") + 
      # ggrepel::geom_text_repel(data = df.wnn.umap.sum2, aes(x = x, y = y, label = var), size = label.size) + 
      geom_text(data = df.wnn.umap.sum, aes(x = x.mean, y = y.mean, label = seurat_clusters), inherit.aes = F, size = 5) + 
      labs(size = "Degree", alpha = "Weight", fill = "Module") + 
      scale_fill_manual(values = col.pal)   
  }

  

  
  return(
    list(
      plt.umap = plt.wnn.umap.connectivity.net.all,
      df.connectivity = df.connectivity,
      df.wnn.umap = df.wnn.umap,
      df.umap.merge = df.umap.merge
    )
  )
  
}


connect.umap.meso.res <- connectivityUMAP(object = so.gene, col.pal = p13.col, size = 0.9,segment.alpha = 0.05,  alpha = 0.8)

connect.umap.tf.res <- connectivityUMAP(object = so.tf, col.pal = tf.col, size = 1.5, alpha = 0.7, segment.alpha = 0.075, label.size = 3)


# connect.umap.meso.res$plt.umap

# savePDF(file.name = "TF_Network_230421.pdf", plot.handle = connect.umap.tf.res$plt.umap, fig.width = 8, fig.height = 6)
# savePDF(file.name = "generalWide_Network_230421.pdf", plot.handle = connect.umap.meso.res$plt.umap, fig.width = 8, fig.height = 6)


# save network related spreadsheet
# df.gene.meso.net <- getUMAP(so.gene)[["df.umap"]]
# colnames(df.gene.meso.net) <- c("umap.x", "umap.y", "gene", "cluster")
# df.gene.tf.net <- getUMAP(so.tf)[["df.umap"]]
# colnames(df.gene.tf.net) <- c("umap.x", "umap.y", "gene", "cluster")
# flex.asDT(df.gene.tf.net)
# flex.asDT(df.gene.meso.net)

# connect.umap.meso.res$plt.umap

```

```{r prep final tables, fig.width=10, fig.height=7}

# General network 
df.general.net <- meso.connectivity.list$df.snn.umap
df.general.net <- df.general.net[ ,c("genes", "x", "y", "seurat_clusters", "wi")]
colnames(df.general.net) <- c("gene", "umap.x", "umap.y",  "module", "degree")

if (parameter.list$general.ica){
df.general.ica.gene.list <- namedList2wideDF(plt.ica.gene.all[["ica.module.genes"]])
}

# TF network
df.tf.net <- tf.connectivity.list$df.snn.umap
df.tf.net <- df.tf.net[ ,c("genes", "x", "y", "seurat_clusters", "wi")]
colnames(df.tf.net) <- c("gene", "umap.x", "umap.y",  "module", "degree")


if (parameter.list$tf.ica){
df.general.ica.tf.list <- namedList2wideDF(plt.ica.tf.all[["ica.module.genes"]])
}

```

```{r jaccard similarity , fig.width=20, fig.height=7}

# jaccard similarity between genesets

if (parameter.list$tf.ica){
j.mat.tf <- jaccardSimilarityMatrix(c(plt.ica.tf.all[["ica.module.genes"]], mod.list.tf))
plt.j.tf <- ggplotify::as.ggplot(pheatmap::pheatmap(j.mat.tf[grepl("m", rownames(j.mat.tf)), grepl("ICM", colnames(j.mat.tf))], silent = T,
                   color = CustomPalette(low = "white", high = "tomato", mid = NULL, k = 50)))

plt.j.tf <- plt.j.tf + labs(title = "TF Network | Jaccard similarity of module- and. ICA-derived genesets", 
                            subtitle = "x: IC geneset; y: modular geneset; z: jaccard similarity") +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(plot.subtitle = element_text(hjust = 0.5))
}

if (parameter.list$general.ica){
j.mat.gene <- jaccardSimilarityMatrix(c(plt.ica.gene.all[["ica.module.genes"]], mod.list))
plt.j.gene <- ggplotify::as.ggplot(pheatmap::pheatmap(j.mat.gene[grepl("m", rownames(j.mat.gene)), grepl("ICM", colnames(j.mat.gene))], silent = T,
                   color = CustomPalette(low = "white", high = "tomato", mid = NULL, k = 50))) 

plt.j.gene <- plt.j.gene + labs(title = "General Network | Jaccard similarity of module- and. ICA-derived genesets", 
                            subtitle = "x: IC geneset; y: modular geneset; z: jaccard similarity") +
      theme(plot.title = element_text(hjust = 0.5)) +
      theme(plot.subtitle = element_text(hjust = 0.5))
}

if (parameter.list$general.ica & parameter.list$tf.ica){
  plt.j.summary <- cowplot::plot_grid(plt.j.gene, plt.j.tf)
} else if (parameter.list$general.ica & !parameter.list$tf.ica){
  plt.j.summary <- plt.j.gene
} else if (!parameter.list$general.ica & parameter.list$tf.ica){
  plt.j.summary <- plt.j.tf
} else {
  plt.j.summary <- NULL
}


if (parameter.list$print.inline) print(plt.j.summary)
```

```{r STRING PPI analysis, include = FALSE}

# library(STRINGdb)
ppi.success <- F
try({
  
  ppiEnrich <- function(gene.list, species, verbose = T){
    
    # load library
    require(STRINGdb, quietly = T)
    
    miko_message("Initializing STRING database...", verbose = verbose)
    # initialize constructor
    suppressWarnings({
      suppressMessages({
        if (species == "Hs"){
          string_db <- STRINGdb$new( version="11", species=9606, score_threshold=400, input_directory="")
        } else if (species == "Mm"){
          string_db <- STRINGdb$new( version="11", species=10090, score_threshold=400, input_directory="")
        }
      })
    })
    
    miko_message("Retrieving gene mappings...", verbose = verbose)
    # get symbol to id mapping
    invisible({
      suppressWarnings({
        suppressMessages({
          all.genes <- unique(unlist(gene.list))
          string_map <- string_db$map( data.frame(gene = all.genes), "gene", removeUnmappedRows = TRUE ) 
        })
      })      
    })
    
    
    miko_message("Calculating PPI enrichments...", verbose = verbose)
    # calculate enrichments for each gene module
    df.ppi.enrichment <- NULL
    for (i in 1:length(gene.list)){
      
      module.name <- names(gene.list)[i]
      gene.input <- (string_map %>% dplyr::filter(toupper(gene) %in% toupper(gene.list[[module.name]])))$STRING_id
      
      if (length(gene.input) == 0) next
      
      p.ppi <- string_db$get_ppi_enrichment(gene.input)
      
      if (is.null(p.ppi[["enrichment"]])) next
      
      df.ppi.enrichment <- bind_rows(
        df.ppi.enrichment, 
        data.frame(
          module = module.name,
          p = p.ppi$enrichment,
          observed = p.ppi$edges,
          expected = p.ppi$lambda
        )
      )
    }
    
    
    # which entries missing:
    which.missing <- c()
    which.missing <- names(gene.list)[!(names(gene.list) %in% df.ppi.enrichment$module)]
    if (length(which.missing) > 0){
      for (i in 1:length(which.missing)){
        df.ppi.enrichment <- bind_rows(df.ppi.enrichment,
                                       data.frame(
                                         module = which.missing[i],
                                         p = 1,
                                         observed = 0,
                                         expected = 0
                                       ))
      }
      
    }
    
    # calculate ratio and fdr
    df.ppi.enrichment$ratio <-(df.ppi.enrichment$observed + 1) /   (df.ppi.enrichment$expected + 1)
    df.ppi.enrichment$fdr <- p.adjust(df.ppi.enrichment$p)
    df.ppi.enrichment$fdr[is.na(df.ppi.enrichment$fdr)] <- 1
    
    miko_message("Generating summary plot...", verbose = verbose)
    # generate erichment plot
    plt.ppi.enrich <- df.ppi.enrichment %>%
      ggplot(aes(x = (ratio), y = reorder(module, ratio), color = fdr < 0.05)) + #observed
      geom_vline(xintercept = 1, linetype = "dashed") +
      geom_point(size = 5) + 
      geom_segment(aes(x = 1, xend = ratio, y = reorder(module, ratio), yend = reorder(module, ratio))) + 
      labs(x=  "PPI Enrichment (observed/exected)", y  = "Network Module",
           title = "PPI Enrichment", subtitle = "STRING v11.0 database") + 
      scale_color_manual(values = c("TRUE" = "tomato", "FALSE" = "grey")) + 
      theme_miko(legend = T, grid = T) 
    
    
    miko_message("PPI enrichment complete!", verbose = verbose)
    # return results
    return(list(
      df.result = df.ppi.enrichment,
      plot.enrichment = plt.ppi.enrich
    ))
  }
  
  
  general.ppi.enrich <- ppiEnrich(gene.list = mod.list, species = parameter.list$species, verbose = T)
  tf.ppi.enrich <- ppiEnrich(gene.list = mod.list.tf, species = parameter.list$species, verbose = T)
  
  # tf.ppi.enrich$plot.enrichment
  ppi.success <- T
}, silent = T)



if (ppi.success){
  plt.general.net.graph <- cowplot::plot_grid(connect.umap.meso.res$plt.umap, 
                                              general.ppi.enrich$plot.enrichment + theme(legend.position = "bottom"), rel_widths = c(1,0.5), nrow = 1)
  plt.tf.net.graph <- cowplot::plot_grid(connect.umap.tf.res$plt.umap, 
                                         tf.ppi.enrich$plot.enrichment + theme(legend.position = "bottom"), rel_widths = c(1,0.5),nrow = 1)
  # plt.general.net.graph
  # plt.tf.net.graph
} else {
  plt.general.net.graph <- connect.umap.meso.res$plt.umap
  plt.tf.net.graph <- connect.umap.tf.res$plt.umap
}

```

```{r fig.width=5, fig.height=7}

# print(plt.ppi.enrich)
# savePDF("ppi_enrichment_div7_180821.pdf", plt.ppi.enrich, fig.width=5, fig.height=7)
```


```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
if (parameter.list$update.log){
  try({
    run.id <-  updateCentralLog(Module = "M37", input.data = input.file, input.subset = NA, pdf.flag = parameter.list$save.pdf)
    clog.update.success <-  T
  }, silent = F) 
}

if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M37_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (parameter.list$save.pdf) dir.create(paste0(output.path, "PDF/"))

```

```{r flex plot helper function}

flexPlotOutput <- function(header.name, fig.width, fig.height, chunk.name, plot.name){
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", header.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf(paste0("\n```{r %s, message=FALSE, warning=FALSE, fig.width = ",fig.width, ", fig.height= ", fig.height, "}"),  
                                          chunk.name))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", paste0("print(", plot.name, ")"))) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  out <- paste(a1, a2, a3, a4, collapse = '\n') 
  
  return(out)
}

```


Sample Overview
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Uniform manifold approximation and projection** (UMAP) used to dimensionally reduce and visualize data while maintaining global transcriptomic structure. Clusters were determined using unsupervised Louvain community detection.

**Sample Overview**\
Cells, n: `r ncol(so.query)`\
Genes, n: `r nrow(so.query)`\
Variable genes, n: `r try({length(VariableFeatures(so.query))}, silent = T)`\

UMI/cell, median: `r try({round(median(so.query@meta.data[["nCount_RNA"]]))}, silent = T)`\
genes/cell, median: `r try({round(median(so.query@meta.data[["nFeature_RNA"]]))}, silent = T)`\

Clusters, n: `r ulength(so.query$seurat_clusters)`\
Resolution: `r parameter.list$cluster.resolution`\
Species: `r try({parameter.list$species}, silent = T)`

Row 
-------------------------------------

### UMAP

```{r plt.umap_by_c, fig.width=7, fig.height=6}

plt.umap.final <- cluster.UMAP(so.query) + theme_miko(legend = T) + labs(title = "UMAP", subtitle = paste0(ncol(so.query), " cells | ", ulength(so.query$seurat_clusters), " clusters"))
print(plt.umap.final)
savePDF(file.name = paste0(output.path, "PDF/", "M37_umap_cluster.pdf"), plot.handle = plt.umap.final,
        fig.width = 7, fig.height = 6, save.flag = parameter.list$save.pdf)
```

General Network 
===================================== 

Sidebar {.sidebar}
-------------------------------------

**General Transcription Network**

**Description**: General transcriptional network with connectivity and functional annotations. 

**Method**: Network was constructed by embedding genes in UMAP representation using principal components. In network graph, each node represents individual gene, and linkages represent shared nearest neighbor similarity, computed as jaccard similarity of KNN graph. Network modules and IC-derived gene-sets were functionally annotated using hypergeometric over-representation analysis. Modular activities were computed using `Seurat::AddModuleScore()` and average cluster-level expression was visualized on heatmap, or cell-level activities were projected onto cellular UMAP. 

**Definitions**:\
"m": network gene modules\
"ICM": independent-component-derived gene module\
"c": cell cluster


Row {.tabset data-height=600}
-------------------------------------

### Network Graph

```{r general network graph, fig.width=9, fig.height=6}

if (!ppi.success){
 print(plt.general.net.graph)

savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_graph.pdf"), plot.handle = plt.general.net.graph,
        fig.width=9, fig.height=6, save.flag = parameter.list$save.pdf)
}

```

```{r general network graph2, fig.width=12, fig.height=6}

if (ppi.success){
 print(plt.general.net.graph)

savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_graph.pdf"), plot.handle = plt.general.net.graph,
        fig.width=12, fig.height=6, save.flag = parameter.list$save.pdf)
}

```

```{r general network annotations - modules}

out <- lapply(seq_along(mod.subnet.gene), function(i) {
  
  s1 <- names(mod.subnet.gene)[i]
  s2 <- paste0("mod.subnet.gene[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("gwnet_enrich_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

for (i in 1:length(mod.subnet.gene)){
  plot.name <- paste0("general_moduleAnnotation_", names(mod.subnet.gene)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  mod.subnet.gene[[i]], 
            fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r general network annotations - ICA}

if (parameter.list$general.ica){
out <- lapply(seq_along(plt.ica.gene), function(i) {
  
  s1 <- names(plt.ica.gene)[i]
  s2 <- paste0("plt.ica.gene[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("gwnet_enrich2_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})


for (i in 1:length(plt.ica.gene)){
  plot.name <- paste0("general_icaAnnotation_", names(plt.ica.gene)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.ica.gene[[i]], 
            fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}
} 

```

`r if (parameter.list$general.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`


Row {.tabset data-height=400}
-------------------------------------

### Network Expression 

```{r general network module heatmap, fig.width=10, fig.height=8}

print(plt.hm.meso)

savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_module_activity.pdf"), plot.handle = plt.hm.meso,
        fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)

```



```{r general network ICA heatmap, fig.width=10, fig.height=8}

if (parameter.list$general.ica){
out <- flexPlotOutput(header.name = "IC Activity", fig.width = 10, fig.height = 8, chunk.name = "ica.gene.hm.expr", plot.name = "plt.ica.gene.hm.expr")

  savePDF(file.name = paste0(output.path, "PDF/", "M37_general_network_ic_activity.pdf"), plot.handle = plt.ica.gene.hm.expr,
        fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)
}


```

`r if (parameter.list$general.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`

```{r general network expression}

out <- lapply(seq_along(plt.net.expr.general), function(i) {
  
  s1 <- names(plt.net.expr.general)[i]
  s2 <- paste0("plt.net.expr.general[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 10, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("gene_net_expr_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

for (i in 1:length(plt.net.expr.general)){
  plot.name <- paste0("general_clusterExpr_", names(plt.net.expr.general)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.net.expr.general[[i]], 
            fig.width = 10, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

TF Network 
===================================== 

Sidebar {.sidebar}
-------------------------------------

**Transcription Factor (TF) Network**

**Description**: Transcription-factor subset of general transcriptional network with connectivity and functional annotations. 

**Method**: Network was constructed by embedding TF genes in UMAP representation using principal components. In network graph, each node represents individual gene, and linkages represent shared nearest neighbor similarity, computed as jaccard similarity of KNN graph. Network modules and IC-derived gene-sets were functionally annotated using hypergeometric over-representation analysis. Modular activities were computed using `Seurat::AddModuleScore()` and average cluster-level expression was visualized on heatmap, or cell-level activities were projected onto cellular UMAP. 

**Definitions**:\
"m": network modules\
"ICM": independent-component-derived module\
"c": cell cluster

Row {.tabset data-height=600}
-------------------------------------

### Network Graph

```{r TF network graph, fig.width=9, fig.height=6}

if (!ppi.success){
  print(plt.tf.net.graph)

savePDF(file.name = paste0(output.path, "PDF/", "M37_tf_network_graph.pdf"), plot.handle = plt.tf.net.graph,
        fig.width=9, fig.height=6, save.flag = parameter.list$save.pdf) 
}


```
```{r TF network graph2, fig.width=12, fig.height=6}

if (ppi.success){
  print(plt.tf.net.graph)

savePDF(file.name = paste0(output.path, "PDF/", "M37_tf_network_graph.pdf"), plot.handle = plt.tf.net.graph,
        fig.width=12, fig.height=6, save.flag = parameter.list$save.pdf) 
}


```

```{r TF network annotation - modules}

out <- lapply(seq_along(mod.subnet.tf), function(i) {
  
  s1 <- names(mod.subnet.tf)[i]
  s2 <- paste0("mod.subnet.tf[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("tfnet_enrich_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

# mod.subnet.tf$m0

for (i in 1:length(mod.subnet.tf)){
  plot.name <- paste0("tf_moduleAnnotation_", names(mod.subnet.tf)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  mod.subnet.tf[[i]], 
            fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r TF network annotation - ICA}

if (parameter.list$tf.ica){

out <- lapply(seq_along(plt.ica.tf), function(i) {
  
  s1 <- names(plt.ica.tf)[i]
  s2 <- paste0("plt.ica.tf[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 15, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("tfnet_enrich2_", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

for (i in 1:length(plt.ica.tf)){
  plot.name <- paste0("tf_icaAnnotation_", names(plt.ica.tf)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.ica.tf[[i]], 
            fig.width = 15, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}

}

```

`r if (parameter.list$tf.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`


Row {.tabset data-height=400}
-------------------------------------


### Network Expression

```{r tf module activity heatmap, fig.width=10, fig.height=8}

print(plt.hm.tf)

savePDF(file.name = paste0(output.path, "PDF/", "M37_tf_network_module_activity.pdf"), plot.handle = plt.hm.tf,
        fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)

```


```{r ica TF heatmap expression, fig.width=10, fig.height=8}

if (parameter.list$tf.ica){
out <- flexPlotOutput(header.name = "IC Activity", fig.width = 10, fig.height = 8, chunk.name = "ica.tf.hm.expr", plot.name = "plt.ica.tf.hm.expr")

savePDF(file.name = paste0(output.path, "PDF/", "M37_tf_network_ic_activity.pdf"), plot.handle = plt.ica.tf.hm.expr,
        fig.width=10, fig.height=8, save.flag = parameter.list$save.pdf)
}


```

`r if (parameter.list$tf.ica){paste(knitr::knit(text = paste(out, collapse = '\n')))}`

```{r clust expr plots}

out <- lapply(seq_along(plt.net.expr.tf), function(i) {
  
  s1 <- names(plt.net.expr.tf)[i]
  s2 <- paste0("plt.net.expr.tf[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 10, fig.height=5}",  #fig.width = 8, fig.height=8, 
                                          paste("tf_net_expr", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

for (i in 1:length(plt.net.expr.tf)){
  plot.name <- paste0("tf_clusterExpr_", names(plt.net.expr.tf)[i], ".pdf")
  try({
      savePDF(file.name = paste0(output.path, "PDF/", plot.name), plot.handle =  plt.net.expr.tf[[i]], 
            fig.width = 10, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
}


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`



Genesets
===================================== 

Row {.tabset}
-------------------------------------



```{r jaccard similarity, fig.width=20, fig.height=7}

out <- flexPlotOutput(header.name = "Geneset Similarity", fig.width = 20, fig.height = 7, chunk.name = "jaccard similarity output", plot.name = "plt.j.summary")

if (!is.null(plt.j.summary)){
savePDF(file.name = paste0(output.path, "PDF/", "M37_geneset_jaccard_similarity.pdf"), plot.handle = plt.j.summary,
        fig.width=20, fig.height=7, save.flag = parameter.list$save.pdf)
}

```

`r if (!is.null(plt.j.summary)){paste(knitr::knit(text = paste(out, collapse = '\n')))}`

### General | network modules

General network table. 

```{r general net umap table, fig.width=20, fig.height=7}

flex.asDT(df.general.net)

```

### TF | network modules

TF network table. 

```{r tf net umap table, fig.width=20, fig.height=7}

flex.asDT(df.tf.net)

```

### General | ICA gene loading

General network ICA gene loading

```{r general ica loading table, fig.width=20, fig.height=7}

try({
  flex.asDT(df.ica.loading.gene)
}, silent = T)


```

### TF | ICA gene loading

TF network ICA gene loading

```{r tf ica loading table, fig.width=20, fig.height=7}

try({
flex.asDT(df.ica.loading.tf)
}, silent = T)

```

### General | ICA geneset

General network ICA genesets

```{r general ica set table, fig.width=20, fig.height=7}

try({
flex.asDT(df.general.ica.gene.list)
}, silent = T)

```

### TF | ICA geneset

TF network ICA genesets

```{r tf ica set table, fig.width=20, fig.height=7}

try({
flex.asDT(df.general.ica.tf.list)
}, silent = T)

```




```{r}

  a1 <- knitr::knit_expand(text = sprintf("\n%s", "Scale-Free Topology"))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  out1 <- paste(a1, a2, collapse = '\n')

```

`r if ((parameter.list$tf.scale.free.topology | parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(out1, collapse = '\n'))) }`


```{r}

#   a1 <- knitr::knit_expand(text = sprintf("\n%s", "TF Network"))
# a2 <- knitr::knit_expand(text = sprintf("\n%s\n", "====================================="))
a3 <- knitr::knit_expand(text = sprintf("\n%s", "Sidebar {.sidebar}"))
a4 <- knitr::knit_expand(text = sprintf("\n%s\n", "-------------------------------------"))
a5 <- knitr::knit_expand(text = "\n**Scale-Free Topology**\n\n**Description**: A network is scale-free if connectivity densities approximate a power-law distribution. In such a case, the majority of genes have few connections, and relatively few 'hub' genes are highly-interconnected. To enforce a scale-free network topology, a range of soft thresholding powers are evaluated, and the optimal soft-thresholding power is used for network construction.\n\n**Methods**: Adopting the framework from weighted correlation analysis (WGCNA), an adjacency matrix is constructed from the shared nearest neighor (snn) graph. Specifically, the adjaceny matrix is defined as the snn graph raised to the soft-thresholding power. To identify the optimal soft-thresholding power, the scale free topology fit index is calculated as the correlation (R^2) between log transformed N linkages and N nodes for a range of powers. The optimal power is taken as the lowest power for which the scale free topology fit (R^2) exceeds 0.9. The adjacency matrix obtained for ths power is used to construct the network UMAP and identify network gene modules. \n\n**Citation**: Zhang, B., & Horvath, S. (2005). A general framework for weighted gene co-expression network analysis. Statistical applications in genetics and molecular biology, 4(1).")

out2 <- paste(a3, a4,a5, collapse = '\n')

```

`r if ((parameter.list$tf.scale.free.topology | parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(out2, collapse = '\n'))) }`

```{r scale free}

r1 <- knitr::knit_expand(text = sprintf("\n%s", "Row {.tabset}"))
r2 <- knitr::knit_expand(text = sprintf("\n%s\n", "-------------------------------------"))

row.chunk <- paste(r1, r2,collapse = '\n')

a1 <- knitr::knit_expand(text = sprintf("### %s\n", "General Network"))  # tab header
a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 10, fig.height=5}",  #fig.width = 8, fig.height=8,
                                        paste("gene_scale_free", 1, sep = "")))
a3 <- knitr::knit_expand(text = sprintf("\n %s", "print(plt.sft)"))
a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

a1.chunk <- paste(a1, a2, a3, a4, collapse = '\n') 

a1 <- knitr::knit_expand(text = sprintf("### %s\n", "TF Network"))  # tab header
a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE, fig.width = 10, fig.height=5}",  #fig.width = 8, fig.height=8,
                                        paste("tf_scale_free", 1, sep = "")))
a3 <- knitr::knit_expand(text = sprintf("\n %s", "print(plt.sft.tf)"))
a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

a2.chunk <- paste(a1, a2, a3, a4, collapse = '\n') 

try({
      savePDF(file.name = paste0(output.path, "PDF/", "general_scaleFree_parameterOptimization.pdf"), plot.handle =  plt.sft, 
            fig.width = 10, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)
try({
      savePDF(file.name = paste0(output.path, "PDF/", "tf_scaleFree_parameterOptimization.pdf"), plot.handle =  plt.sft.tf, 
            fig.width = 10, fig.height = 5, save.flag = parameter.list$save.pdf)
}, silent = T)

```

`r if ((parameter.list$tf.scale.free.topology | parameter.list$general.scale.free.topology)){ paste(knitr::knit(text = paste(row.chunk, collapse = '\n'))) }`

`r if ((parameter.list$general.scale.free.topology)){paste(knitr::knit(text = paste(a1.chunk, collapse = '\n')))}`

`r if ((parameter.list$tf.scale.free.topology)){paste(knitr::knit(text = paste(a2.chunk, collapse = '\n')))}`





```{r finalize log}

# Update analysis log
n.cells.analyzed <- nrow(so.gene)
n.genes.general <- ncol(so.gene)
n.genes.tf <- ncol(so.tf)
df.log <- addLogEntry("Number of cells analyzed", n.cells.analyzed, df.log, "n.cells.analyzed")
df.log <- addLogEntry("Number of cells in general network", n.genes.general, df.log, "n.genes.general")
df.log <- addLogEntry("Number of cells in TF network", n.genes.tf, df.log, "n.genes.tf")
df.log <- addLogEntry("Seurat Assay", DefaultAssay(so.query), df.log, "DefaultAssay(so.query)")

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_37 <- df.log

```



```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 37)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_37)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_37, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```

System Info
=====================================

```{r}

pander::pander(sessionInfo())

```
