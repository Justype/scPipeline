---
title: "scRNAseq: QC and Data Preparation"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# list of packages to load
packages2load <- c('viridis', 'scMiko', 'ggpubr', 'dplyr', 'WGCNA', 'cowplot', 'schex', 'Seurat', 'sctransform', 'plyr', 'tidyr', 'reshape2', 'Matrix', 'RColorBrewer', 'ggplot2', 'gridExtra', 'DT', 'flexdashboard', 'future', 'gplots')

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))


```


```{r c2 - parameter_specification}

# specify parameters
analysis.parameters <- analysisParameters(
  which.data = c("pilot9.Mm"),
  which.strata = c("CT2A"),
  organism.filter.flag = F,                             
  organism.include = c("Mm"),
  save.flag = F,                                                              # OPTIONAL; logical (default = T)  # save results
  save.filename = "Module1_integration_Test.Rdata",
  save.directory = "Preprocessed_Datasets/",
  cluster.resolution = 1,
  gene.upperlimit = 9000,
  gene.lowerlimit = 200,
  mt.upperlimit = 60,
  vars2regress = c("percent.mt", "dataset"),
  do.additional.reduction = F
)


n.workers <- list(
  normScale = 2
)
max.memory <- 200 # numeric, in terms of Gb (set to 100 for cluster)

```

```{r get input data paths}

# get input data files paths
inputDataSpecification <- function(inputs = "M01_inputs.csv", subsets = "M01_subsets.csv"){
  
  input.data <- read.csv(inputs)
  colnames(input.data) <- rmvCSVprefix(colnames(input.data))
  input.data <- apply(input.data, 2, function(x) gsub("Ã‚", "", x))
  
  # get subsets
  input.subset <- read.csv(subsets)
  
  # wrangle into list
  u.samples <- unique(input.subset$sample)
  input.barcode.strata <- list()
  for (i in 1:length(u.samples)){
    
    subset.strata <- input.subset[input.subset$sample %in% u.samples[i], ]
    current.strata <- list()
    
    for (j in 1:nrow(subset.strata)){
      
      current.barcodes <- subset.strata$barcodes[j]
      current.barcodes <- strsplit(current.barcodes, ", ")[[1]]
      current.strata[[subset.strata$set[j]]] <- current.barcodes
    }
    
    input.barcode.strata[[u.samples[i]]] <- current.strata
    
  }
  
  return(list(
    input.data = input.data,
    input.barcode.strata = input.barcode.strata
  ))
}

input.list <- inputDataSpecification()
input.data <- input.list$input.data
input.barcode.strata <- input.list$input.barcode.strata

```

```{r c3 - additional specifications and assertions}

# Specify input data files
which.data <- analysis.parameters$which.data  # REQUIRED 
which.strata <- analysis.parameters$which.strata # NA if no stratification

# specify input 
stopifnot(all(which.data %in% as.vector(input.data$names)))
specified.input <- input.data[as.vector(input.data$names) %in% which.data, ]


# get input data specifications
input_data <- as.vector(specified.input$files)
input_pcr_barcodes <- as.vector(specified.input$pcr.barcodes)
input_rt_barcodes <- as.vector(specified.input$rt.barcodes)
input_set <- c(input_data, input_pcr_barcodes, input_rt_barcodes)
input.type <- as.vector(specified.input$input.type)
all_input_organisms <- as.vector(specified.input$species)
dir <- as.vector(specified.input$directory) 


# get stratification details
if (!is.na(which.strata)){
  which.strata.specified <- which.strata
  which.strata <- c()
  for (i in 1:length(which.strata.specified)){
   which.strata <- c(which.strata, input.barcode.strata[[which.data[i]]][[which.strata.specified[i]]])
  }
} 

# ensure correct directory is specified
stopifnot(exists("input.type")) 

# ensure input data are specified
stopifnot(exists("input_set")) 

try({
  stopifnot(exists("analysis.parameters$organism.include")) 
  if (length(analysis.parameters$organism.include) ==  1) analysis.parameters$organism.include <- rep(analysis.parameters$organism.include, length(input_data))
}, silent = T)

# if set_names are not specified, set_names <-  ""
if (exists("analysis.parameters$set_names")){
  stopifnot(is.character(analysis.parameters$set_names))
} else {analysis.parameters$set_names <- ""}

# if pilot input are not specified, pilot_input <-  ""
if (exists("pilot_input")){
  stopifnot(length(pilot_input) == 1)
} else {pilot_input <- ""}

total_sets <- input_set

```


```{r c4 - analysis log}

df.log <- initiateLog("1, Preprocessing & QC")

if (input.type == 1){
  df.log <- addLogEntry("Input Data (.Rdata)", input_data, df.log, "input_data")
  df.log <- addLogEntry("Input RT Barcode (.txt)", input_rt_barcodes, df.log, "input_rt_barcodes")
  df.log <- addLogEntry("Input PCR Barcode (.txt)", input_pcr_barcodes, df.log, "input_pcr_barcodes")
} else if (input.type == 2){
  df.log <- addLogEntry("Input Cell Ranger", input_data, df.log, "input_data")
} else if (input.type == 3){
  df.log <- addLogEntry("Input TPM Matrix", input_data, df.log, "input_data")
}

df.log <- addLogEntry("Output Results (.Rdata)", analysis.parameters$save.filename, df.log, "analysis.parameters$save.filename")
df.log <- addLogEntry("Output Directory", analysis.parameters$save.directory, df.log, "analysis.parameters$save.directory")

df.log <- addLogEntry("gene/cell Upper Limit (N/cell)", analysis.parameters$gene.upperlimit, df.log, "analysis.parameters$gene.upperlimit")
df.log <- addLogEntry("gene/cell Lower Limit (N/cell)", analysis.parameters$gene.lowerlimit, df.log, "analysis.parameters$gene.lowerlimit")

df.log <- addLogEntry("Filtered by unmatched reads", 
                      analysis.parameters$unmatched.rate.filter.flag, df.log, "analysis.parameters$unmatched.rate.filter.flag")

df.log <- addLogEntry("Mitochondrial Content Upper Limit (%/cell)", analysis.parameters$mt.upperlimit, df.log, "analysis.parameters$mt.upperlimit")

if (analysis.parameters$subsample_factor == 1){subsampled <- FALSE} else {subsampled <- TRUE}
df.log <- addLogEntry("Data Subsampled", subsampled, df.log, "subsampled")

df.log <- addLogEntry("Cluster Resolution", analysis.parameters$cluster.resolution, df.log, "analysis.parameters$cluster.resolution")
df.log <- addLogEntry("Filtered by organism", analysis.parameters$organism.filter.flag, df.log, "analysis.parameters$organism.filter.flag")

if (analysis.parameters$organism.filter.flag) {
  df.log <- addLogEntry("Species Included", analysis.parameters$organism.include, df.log, "analysis.parameters$organism.include")
}

df.log <- addLogEntry("Number of Workers", n.workers$normScale, df.log, "n.workers$normScale")
df.log <- addLogEntry("Max Memory (Gb)", max.memory, df.log, "max.memory")

if (!is.na(which.strata)) {
  df.log[nrow(df.log)+1, 1] <- as.character("Barcode(s) Included")
  df.log[nrow(df.log), 2] <- as.character("which.strata")
  if (length(which.strata) > 1){
    df.log[nrow(df.log), 3] <- paste(which.strata, collapse=", ")
  } else {
    df.log[nrow(df.log), 3] <- as.character(which.strata)
  }
}

df.log <- addLogEntry("Variables regressed out", analysis.parameters$vars2regress, df.log, "analysis.parameters$vars2regress")
df.log <- addLogEntry("Experiment Identifier", pilot_input, df.log, "pilot_input")
df.log <- addLogEntry("Input Species", all_input_organisms, df.log, "all_input_organisms")

```

```{r c5}

loadMatdev <- function(import_set, input_organisms, dir) {
  
  import_set_path <- paste(dir, import_set, sep ="")
  
  # import expression matrix data
  
  is.kumal <- F # specificy fixes made to accomodate Kumal 2018 EMT6 data
  if (is.kumal){
    expression_matrix<-read.csv(import_set_path[1],header=F)
    expression_matrix <- as.data.frame(t(expression_matrix))
  } else {
    expression_matrix<-read.table(import_set_path[1],header=TRUE)
  }
  
  
  # sum(is.na(expression_matrix))
  expression_matrix[is.na(expression_matrix)] <- 0
  
  # get gene and ensembl names
  if (is.kumal){
    features.df<-read.csv(import_set_path[3],header=T)
    cell.df <-read.csv(import_set_path[2],header=T)
    colnames(expression_matrix) <- cell.df$NM_ID
    expression_matrix$GENE <- as.character(features.df$GeneSymbol)
  } 
  
  feature.names <- as.vector(expression_matrix$GENE)
  
  
  # average duplicate rows (i.e., duplicate genes)
  if (length(unique(feature.names)) < length(feature.names)){
    
    success.attempt <- F
    try({
      
      expression_matrix.col <- expression_matrix
      expression_matrix.col <- dplyr::select(expression_matrix.col, -c("GENE"))
      expression_matrix.col$rowID <- seq(1, nrow(expression_matrix.col))
      expression_matrix.col.noDup <-  WGCNA::collapseRows(expression_matrix.col, rowGroup = expression_matrix$GENE, rowID = expression_matrix.col$rowID, method = "Average")
      new.mat <- as.data.frame(expression_matrix.col.noDup[["datETcollapsed"]])
      new.mat <- dplyr::select(new.mat, -c("rowID"))
      new.mat$GENE <- rownames(new.mat)
      expression_matrix2 <- new.mat
      rm("new.mat")
      success.attempt <- T
      
    }, silent = T)
    
    if (!success.attempt){
      which.duplicate <- duplicated(feature.names)
      expression_matrix2 <- expression_matrix[!(which.duplicate), ]
    }
  } else {
    # assign to secondary matrix
    expression_matrix2 <- expression_matrix
  }
  
  
  feature.names <- as.vector(expression_matrix2$GENE)
  
  expression_matrix2 <- dplyr::select(expression_matrix2, -c("GENE"))
  rownames(expression_matrix2) <- feature.names
  stopifnot(length(input_organisms) == 1)
  g2eNames <- sym2ens(my.symbols =  feature.names, my.species = input_organisms)
  gNames <- g2eNames$SYMBOL
  names(gNames) <- g2eNames$ENSEMBL
  gNames <- gNames[!is.na(gNames)]
  names(gNames) <-gsub("\\..*","",as.vector( names(gNames)))
  
  # assign organism
  orgs <- rep(input_organisms,ncol(expression_matrix2));
  names(orgs) <- colnames(expression_matrix2);
  
  
  # create seurat object
  so = CreateSeuratObject(counts = expression_matrix2,project=import_set[1],min.cells=0,min.features=0)

  # add gene symbols as meta data in seurat object
  mat_ens <- rownames(so@assays[["RNA"]])
  match.id <- match(mat_ens, gNames)
  gNames_filtered <- names(gNames)[match.id]
  
  # Add gene symbols as meta data that we can use later
  so[["RNA"]] <- AddMetaData( object=so[["RNA"]],metadata=gNames_filtered,col.name="ENSEMBL");
  so[["RNA"]] <- AddMetaData( object=so[["RNA"]],metadata=as.vector((gNames)[match.id]),col.name="SYMBOL");
  
  # Additional metadata
  if (is.kumal){
    kumal.id <- match( colnames(so), cell.df$NM_ID) 
    so@meta.data[["Sample_ID"]] <- cell.df$Sample_ID[kumal.id]
    so@meta.data[["Model"]] <- cell.df$Model[kumal.id]
    so@meta.data[["Protocol"]] <- cell.df$Protocol[kumal.id]
    so@meta.data[["Experiment"]] <- cell.df$Experiment[kumal.id]
    
    
    which.emt6 <- grepl("B16F10",  so@meta.data[["Model"]])
    
    so <- so[ ,which.emt6]
  }
  
  # Add in inferred organism
  so$Organism <- orgs;
  
  # Specify barcodes
  so$Barcode <- "unspecified";
  
  output <- list(so, gNames)
  
  return(output)
}

```

```{r c6 - load_data}

# Run import function
so.list <- list()
gNames.list.list <- list()

# sequence indices
idx.seq <- c(1, 1+length(input_data), 1+(2*length(input_data)))

# assertions
stopifnot(length(dir) == length(input_data))
stopifnot(length(all_input_organisms) == length(input_data))

for (i in 1:length(input_data)){
  
  
  cur.total_sets <- total_sets[idx.seq + (i-1)]

  if (input.type[i] == 1) {
    output.list <- loadMoffat(import_set = cur.total_sets, 
                                     analysis.parameters$subsample_factor, 
                                     input_organisms = trimws(unlist(strsplit(all_input_organisms[i], ","))) , 
                                     analysis.parameters$organism.include[i], 
                                     dir[i])
  } else if (input.type[i] == 2){
    output.list <- loadCellRanger(import_set = cur.total_sets, 
                                  trimws(unlist(strsplit(all_input_organisms[i], ","))), 
                                  dir[i])
  } else if (input.type[i] == 3){
    # output.list <- loadMat(import_set = cur.total_sets, subsample_factor, all_input_organisms, dir[i])
    output.list <- loadMat.dev(import_set = cur.total_sets, 
                               trimws(unlist(strsplit(all_input_organisms[i], ","))), 
                               dir[i])
    
  }
  
  # unlist outputs
  so.list[[i]] <- output.list[[1]]
  gNames.list.list[[i]] <- output.list[[2]]
  
  if ((unique(so.list[[i]]@meta.data[["Barcode"]]) == "unspecified") ){
    so.list[[i]]@meta.data[["Barcode"]] <- paste("T", i, sep = "")
  } else if (is.na(unique(so.list[[i]]@meta.data[["Barcode"]]))){
    stop("Barcodes incorrectly specified") #140620
  }
  
}

# assign set labels and merge seurat objects if multiple present
for (i in 1:length(so.list)){
  if (length(which.data) == length(which.strata)){
    set.label <- paste0(which.data[i],"_", which.strata[i])
  } else {
    set.label <- which.data[i]
  }
  so.list[[i]][["dataset"]] <- set.label
}

so <- mergeSeuratList(so.list)
rm(so.list)

# Assumed that all gene lists are identical
gNames.list <- gNames.list.list[[1]]


```

```{r c7, include = FALSE}
gc()
```


```{r c8 - filter_data_by_subset}

# define subset parameters
subset.df <- data.frame(field = "Organism", subgroups = analysis.parameters$organism.include)

# subset data
so <- subsetSeurat(so, subset.df)

```


```{r c9 - subset barcodes}

so <- barcodeLabels(so, which.strata)

```


```{r c10 - get_mt_content}

# MITOCHONDRIAL CONTENT
so <- getMitoContent(so, gNames.list)

```


```{r c11 - barcode rankings, fig.width= 15, fig.height=5}

# get metadata
df.meta.qc <- so@meta.data

# rank QC metrics
df.meta.qc$rank.umi <- rank(-df.meta.qc$nCount_RNA)
df.meta.qc$rank.gene <- rank(-df.meta.qc$nFeature_RNA)
df.meta.qc$rank.mt <- rank(-df.meta.qc$percent.mt)

df.meta.qc$mitoOmit <- df.meta.qc$percent.mt > analysis.parameters$mt.upperlimit
df.meta.qc$mitoColor <- "black"
df.meta.qc$mitoColor[df.meta.qc$mitoOmit] <- "tomato"

plt.gene.umi.mito <- df.meta.qc %>%
  ggplot(aes(x = nCount_RNA, y = (nFeature_RNA))) + 
  geom_point(color = df.meta.qc$mitoColor) + 
  scale_y_continuous(trans='log10') + 
  scale_x_continuous(trans='log10') + 
  geom_hline(yintercept = analysis.parameters$gene.upperlimit , color = "red", linetype = "dashed") + 
  geom_hline(yintercept = analysis.parameters$gene.lowerlimit, color = "red", linetype = "dashed") + 
  xlab("UMI counts (/cell)") + ylab("Gene counts (/cell)") + 
  theme_classic() + ggtitle("UMI vs Gene Counts\nred: high mT content")

# generate ranking plots
plt.umi.rank.mito <- df.meta.qc %>%
  ggplot(aes(x = rank.umi, y = (nCount_RNA))) + 
  geom_point(color = df.meta.qc$mitoColor) + 
  scale_y_continuous(trans='log10') + 
  xlab("Barcodes") + ylab("UMI counts (/cell)") + 
  theme_classic() + ggtitle("UMI ranking\nred: high mT content")

plt.gene.rank.mito <- df.meta.qc %>%
  ggplot(aes(x = rank.gene, y = (nFeature_RNA))) + 
  geom_point(color = df.meta.qc$mitoColor) + scale_y_continuous(trans='log10') + 
  geom_hline(yintercept = analysis.parameters$gene.upperlimit , color = "red", linetype = "dashed") + 
  geom_hline(yintercept = analysis.parameters$gene.lowerlimit, color = "red", linetype = "dashed") + 
  xlab("Barcodes") + ylab("Gene counts (/cell)") + 
  theme_classic() + ggtitle("Gene ranking\nred: high mT content")

plt.mt.rank.mito <- df.meta.qc %>%
  ggplot(aes(x = rank.mt, y = (percent.mt))) + 
  geom_point(color = df.meta.qc$mitoColor) + scale_y_continuous(trans='log10') + 
  geom_hline(yintercept = analysis.parameters$mt.upperlimit, color = "red", linetype = "dashed")  + 
  xlab("Barcodes") + ylab("Mitochondrial Content (/cell)") + 
  theme_classic() + ggtitle("Mt ranking\nred: high mT content")


if (input.type == 1){
  
  unmatch.median <- median(df.meta.qc$unmatched.rate)
  unmatch.mad <- mad(df.meta.qc$unmatched.rate, unmatch.median)
  
  if (analysis.parameters$unmatched.rate.filter.flag){
    unmatch.high <- unmatch.median + (1.96*unmatch.mad)
    unmatch.low <- unmatch.median - (1.96*unmatch.mad)
  } else {
    unmatch.high <- 1
    unmatch.low <- 0
  }

  df.meta.qc$matchOmit <- (df.meta.qc$unmatched.rate > unmatch.high) | (df.meta.qc$unmatched.rate < unmatch.low)
  df.meta.qc$matchColor <- "black"
  df.meta.qc$matchColor[df.meta.qc$matchOmit] <- "skyblue"
  
  plt.unmatch.umi <- df.meta.qc %>%
    ggplot(aes(x = nCount_RNA, y = (unmatched.rate))) + 
    geom_point(color = df.meta.qc$matchColor)  + 
    xlab("genes") + ylab("unmatched rate") + 
    geom_hline(yintercept = unmatch.high, color = "red", linetype = "dashed")  + 
    geom_hline(yintercept = unmatch.low, color = "red", linetype = "dashed")  + 
    theme_classic() + ggtitle("Mt ranking\nblue: unmatched rate outliers")
  
  df.meta.qc$unmatch.rank <- rank(-df.meta.qc$unmatched.rate)
  plt.umatch.rank <- df.meta.qc %>%
    ggplot(aes(x = unmatch.rank, y = (unmatched.rate))) + 
    geom_point(color = df.meta.qc$matchColor) + 
    scale_y_continuous(trans='log10') + 
    geom_hline(yintercept = unmatch.high, color = "red", linetype = "dashed")  + 
    geom_hline(yintercept = unmatch.low, color = "red", linetype = "dashed")  + 
    xlab("Barcodes") + ylab("Unmatched Rate") + 
    theme_classic() + ggtitle("Unmatched rate ranking\nblue: unmatched rate outliers")
  
  
  plt.gene.umi.match <- df.meta.qc %>%
    ggplot(aes(x = nCount_RNA, y = (nFeature_RNA))) + 
    geom_point(color = df.meta.qc$matchColor) + 
    scale_y_continuous(trans='log10') + 
    scale_x_continuous(trans='log10') + 
    geom_hline(yintercept = analysis.parameters$gene.upperlimit , color = "red", linetype = "dashed") + 
    geom_hline(yintercept = analysis.parameters$gene.lowerlimit, color = "red", linetype = "dashed") + 
    xlab("UMI counts (/cell)") + ylab("Gene counts (/cell)") + 
    theme_classic() + ggtitle("UMI vs Gene Counts\nblue: unmatched rate outliers")
  
  # generate ranking plots
  plt.umi.rank.match <- df.meta.qc %>%
    ggplot(aes(x = rank.umi, y = (nCount_RNA))) + 
    geom_point(color = df.meta.qc$matchColor) + 
    scale_y_continuous(trans='log10') + 
    xlab("Barcodes") + ylab("UMI counts (/cell)") + 
    theme_classic() + ggtitle("UMI ranking\nblue: unmatched rate outliers")
  
  plt.gene.rank.match <- df.meta.qc %>%
    ggplot(aes(x = rank.gene, y = (nFeature_RNA))) + 
    geom_point(color = df.meta.qc$matchColor) + scale_y_continuous(trans='log10') + 
    geom_hline(yintercept = analysis.parameters$gene.upperlimit , color = "red", linetype = "dashed") + 
    geom_hline(yintercept = analysis.parameters$gene.lowerlimit, color = "red", linetype = "dashed") + 
    xlab("Barcodes") + ylab("Gene counts (/cell)") + 
    theme_classic() + ggtitle("Gene ranking\nblue: unmatched rate outliers")
  
  plt.mt.rank.match <- df.meta.qc %>%
    ggplot(aes(x = rank.mt, y = (percent.mt))) + 
    geom_point(color = df.meta.qc$matchColor) + scale_y_continuous(trans='log10') + 
    geom_hline(yintercept = analysis.parameters$mt.upperlimit, color = "red", linetype = "dashed")  + 
    xlab("Barcodes") + ylab("Mitochondrial Content (/cell)") + 
    theme_classic() + ggtitle("Mt ranking\nblue: unmatched rate outliers")
  
} else {
  plt.umatch.rank <- NULL
  plt.unmatch.umi <- NULL
  unmatch.high <- 1
  unmatch.low <- 0
}

if (analysis.parameters$print.inline) {
  ggpubr::ggarrange(plt.gene.umi.mito, plt.umi.rank.mito, plt.gene.rank.mito, plt.mt.rank.mito, ncol = 4) 
  
  if (input.type == 1){
    ggpubr::ggarrange(plt.umi.rank.match, plt.gene.rank.match, plt.mt.rank.match,
                      plt.unmatch.umi, plt.gene.umi.match, plt.umatch.rank,ncol = 3, nrow = 2) 
  }
}



```


```{r c12 - Density plot of % mitochondrial genes, warning = FALSE}

# MITOCHONDRIAL CONTENT DISTRIBUTIONS

calc_mito_content_by_bc <- function(so, set_name, bc_info_flag, input.type = 1){
  
  
  if (bc_info_flag == TRUE & input.type != 2){   
    # Compute mitochrondrial content for each cell type
    
    # get unique cell types
    barcodes <-unique(so@meta.data[["Barcode"]])
    
    # create dataframe to store mitochondrial content, stratified by cell type
    df_by_bc <- data.frame()
    
    # for each cell type
    for (i in 1:length(barcodes)) {
      percent.mt_by_bc <- as.vector(so$percent.mt[so$Barcode == barcodes[i]])
      count.feature_by_bc <- as.vector(so$nFeature_RNA[so$Barcode == barcodes[i]])
      count.rna_by_bc <- as.vector(so$nCount_RNA[so$Barcode == barcodes[i]])
      n_cells <- length(percent.mt_by_bc)
      cur_length <- dim(df_by_bc)[1]
      # get QC parameters for each cell sample
      for (j in 1:n_cells) {
        df_by_bc[cur_length + j, "barcode"] <- barcodes[i]
        df_by_bc[cur_length + j, "percent.mt"] <- percent.mt_by_bc[j]
        df_by_bc[cur_length + j, "count.feature"] <- count.feature_by_bc[j]
        df_by_bc[cur_length + j, "count.rna"] <- count.rna_by_bc[j]
      }
    }
  } else { # if no cell type information provided, pool everything together
    df_by_bc <- data.frame()
    percent.mt_by_bc <- as.vector(so$percent.mt)
    count.feature_by_bc <- as.vector(so$nFeature_RNA)
    count.rna_by_bc <- as.vector(so$nCount_RNA)
    df_by_bc <- data.frame(percent.mt_by_bc, count.feature_by_bc, count.rna_by_bc)
    colnames(df_by_bc) <- c("percent.mt", "count.feature", "count.rna")
    df_by_bc["barcode"] <-"unspecified"
    barcodes <- "unspecified"
    so@meta.data[["Barcode"]] <-  "unspecified"
  }
  
  # Create summary graphs 
  # plot density plot
  plt.handle <- ggplot(df_by_bc, aes(percent.mt, color=barcode)) + 
    geom_density(size = 1) + 
    ggtitle(paste(set_name)) + 
    xlab("Mitochrondrial Content (%)")
  
  output <- list(so, plt.handle)
  return(output)
}

# calculate mitochondrial content, stratified by barcode (if available)
output_by_bc <- calc_mito_content_by_bc(so, analysis.parameters$set_names, (length(total_sets)>1), input.type)

# retrive results
so <- output_by_bc[[1]]
plt.mito_by_bc <- output_by_bc[[2]] 

if (analysis.parameters$print.inline){
  print(plt.mito_by_bc)
}



```


```{r c13 - qc_violin_plots, fig.height= 5, fig.width = 12}

if (length(unique(so@meta.data[["subset_group"]]))> 1){
  df.qc <- data.frame(so@meta.data[["subset_group"]],  
                      so@meta.data[["nFeature_RNA"]], 
                      so@meta.data[["nCount_RNA"]], 
                      so@meta.data[["percent.mt"]]) 
  colnames(df.qc) <- c("group", "nFeature_RNA", "nCount_RNA", "percent.mt")
  
  df.qc_sum <- df.qc %>%
    group_by(group) %>%
    summarize(nFeature_mean = round(mean(nFeature_RNA),2),
              nCount_mean = round(mean(nCount_RNA),2),
              percent.mt_mean = round(mean(percent.mt),2), 
              nFeature_median = round(median(nFeature_RNA),2),
              nCount_median = round(median(nCount_RNA),2),
              percent.mt_median = round(median(percent.mt),2))
  
  nFeat_aov <- summary(aov(nFeature_RNA ~ group, data = df.qc))
  nCount_aov <- summary(aov(nCount_RNA ~ group, data = df.qc))
  mT_aov <- summary(aov(percent.mt ~ group, data = df.qc))
} else {
  df.qc <- data.frame()
  df.qc_sum <- data.frame()
  nFeat_aov <- c()
  nCount_aov <- c()
  mT_aov <- c()
}

violin.list <- QC.violinPlot(so, analysis.parameters$plt.log.flag )
plt.QC_violin <- violin.list[[1]]
plt.violin_by_subgroup <- violin.list[[2]]

if (analysis.parameters$print.inline){
  print(plt.QC_violin)
  print(plt.violin_by_subgroup)
}


```


```{r c14 - QC scatterplots, fig.height= 5, fig.width = 12}

# Generate QC scatterplots
plt.QC_scatter <- QC.scatterPlot(so)
if (analysis.parameters$print.inline)  print(plt.QC_scatter)

```


```{r c15 - filter_QC, fig.width = 5, fig.height = 5}

if (length(analysis.parameters$set_names) == 2) {
  set.n <- NULL
} else {
  set.n <- analysis.parameters$set_names
}
filter_output_list <- filterSeurat(so = so, 
                                   RNA.upperlimit = analysis.parameters$gene.upperlimit, 
                                   RNA.lowerlimit = analysis.parameters$gene.lowerlimit, 
                                   mt.upperlimit = analysis.parameters$mt.upperlimit, 
                                   unmatch.low = unmatch.low, 
                                   unmatch.high = unmatch.high,
                                   set_names = set.n)
so <- filter_output_list[["seurat"]]
plt.filter_pre_post <- filter_output_list[["plot"]]
filter.breakdown.list <- filter_output_list[["filter.breakdown"]]


plt.filter.venn <- NULL
try({
  plt.filter.venn <- gplots::venn(filter.breakdown.list, show.plot = F, col = gplots::rich.colors(palette="temperature", 3))
}, silent = T)


if (analysis.parameters$print.inline){
  plot(plt.filter.venn)
  print(plt.filter_pre_post)
}


```


```{r c16 - normalize_data, warning = FALSE}

# Run data normalization
# normalization_method_ps <- "SCT" # "NFS" or "SCT"
normalization_method_ps <- "SCT"

enable.parallelization <- T
if (n.workers$normScale == 1) enable.parallelization <- F

so<- scNormScale(so, gNames.list, normalization_method_ps, vars2regress = analysis.parameters$vars2regress,
                 n.workers = n.workers$normScale,  max.memory = (max.memory*20480/20 * 1024^2), enable.parallelization = enable.parallelization)

# plot variable genes
plt.variable_genes <- variableGenes.Plot(so, gNames.list, analysis.parameters$set_names)
if (analysis.parameters$print.inline) print(plt.variable_genes)

```


```{r c17 - per cell statistics}

# ptm <- proc.time()
df_nCount <- data.frame(so@meta.data[["nCount_RNA"]], so@meta.data[["nCount_SCT"]])
colnames(df_nCount) <- c("UMI/cell (raw)",  "UMI/cell (normalized)")
df_nCount_m <- melt(df_nCount)

df_nFeat <- data.frame(so@meta.data[["nFeature_RNA"]], so@meta.data[["nFeature_SCT"]])
colnames(df_nFeat) <- c("genes/cell (raw)","genes/cell (normalized)")
df_nFeat_m <- melt(df_nFeat)

plt.UMI_per_cell <- ggplot(df_nCount_m, aes(x = value, fill = variable)) + 
  geom_density(alpha = 0.3) + scale_x_log10()+  xlab("UMI/cell")
plt.genes_per_cell <- ggplot(df_nFeat_m, aes(x = value, fill = variable)) + 
  geom_density(alpha = 0.3) + scale_x_log10()+   xlab("genes/cell")

plt.pre_post_1 <- FeatureScatter(so, feature1 = "nCount_RNA", feature2 = "nCount_SCT") + 
  xlab("UMI/cell (raw)") + ylab("UMI/cell (normalized)")
plt.pre_post_2 <- FeatureScatter(so, feature1 = "nFeature_RNA", feature2 = "nFeature_SCT") + 
  xlab("Genes/cell (raw)") + ylab("Genes/cell (normalized)")

plt.pre_post_norm <- CombinePlots(plots = list(plt.pre_post_1, plt.pre_post_2), ncol = 2, legend = 'none')
# print(paste("Post-normalization statistics (sec): " , round((proc.time() - ptm)[[3]],2)))


if (analysis.parameters$print.inline){
  print(plt.UMI_per_cell)
  print(plt.genes_per_cell)
  print(plt.pre_post_norm)
}

```


```{r c18 - preliminary umap}


nDim <- 30
cluster_resolution <- analysis.parameters$cluster.resolution

# ptm <- proc.time()
so <- RunPCA(so, verbose = FALSE)
so <- FindNeighbors(object = so, reduction = "pca", dims = 1:nDim)
so <- FindClusters(object = so, resolution = cluster_resolution, verbose = 0, algorithm = 1, modularity.fxn = 1)
so <- RunUMAP(so, dims = 1:nDim)

plt.umap_by_cluster <- DimPlot(so, reduction = "umap", label = TRUE)  + ggtitle(label = "UMAP") +
  xlab("UMAP 1") + ylab("UMAP 2")

plt.umap <- DimPlot(so, reduction = "umap",group.by = "Barcode")  + ggtitle(label = "UMAP") +
  xlab("UMAP 1") + ylab("UMAP 2")

# combine plots
plt.umap.combo <- cowplot::plot_grid(plt.umap_by_cluster, plt.umap, ncol = 2)


so <- schex::make_hexbin(so, nbins = 80, dimension_reduction = "UMAP")
plt.umap_umi <- schex::plot_hexbin_meta(so, col="nCount_RNA", 
                           action="mean", xlab="UMAP1", ylab="UMAP2") + 
  labs(title = "UMI/Cell", subtitle = "Post-Filtering")
plt.umap_features <- schex::plot_hexbin_meta(so, col="nFeature_RNA", 
                           action="mean", xlab="UMAP1", ylab="UMAP2") + 
  labs(title = "Genes/Cell", subtitle = "Post-Filtering")
plt.umap_mito <- schex::plot_hexbin_meta(so, col="percent.mt", 
                           action="mean", xlab="UMAP1", ylab="UMAP2") + 
  labs(title = "Mitochondrial Content (%)", subtitle = "Post-Filtering")


if ("unmatched.rate" %in% names(so@meta.data)){
plt.umap_umr <- schex::plot_hexbin_meta(so, col="unmatched.rate", 
                           action="mean", xlab="UMAP1", ylab="UMAP2") + 
  labs(title ="Unmatched Rate", subtitle = "Post-Filtering")  
} else {
 plt.umap_umr <- NULL 
}

if (is.null(plt.umap_umr)){
  plt.umap.qc <- cowplot::plot_grid((plt.umap_by_cluster + theme_miko()), 
                                    plt.umap_umi, plt.umap_features, plt.umap_mito, ncol = 2, align = "hv")
} else {
  plt.umap.qc.right <- cowplot::plot_grid(plt.umap_umi, plt.umap_features, plt.umap_mito, plt.umap_umr, ncol = 2)
  plt.umap.qc <- cowplot::plot_grid((plt.umap_by_cluster + theme_miko()), 
                                    plt.umap.qc.right, 
                                    ncol = 2, rel_widths = c(1,2))
}

if (analysis.parameters$print.inline){
  print(plt.umap_by_cluster)
  print(plt.umap)
  print(plt.umap_umi)
  print(plt.umap_features)
  print(plt.umap_mito)
}


```

```{r c19 - PCA}

pc.elbow_min_difference_ps <- 0.001
pc.cum_var_explained_threshold_ps <- 0.8
PC_number_method_ps <- 2

# calculate proportion of variance explained by each PC ---------------------
pc.std <- so@reductions[["pca"]]@stdev
pc.var <- pc.std^2
pc.prop_var <- pc.var/sum(pc.var)
pc.cum_sum <- cumsum(pc.prop_var)
pc.id <- c(1:50)
scree.var <- data.frame(pc.id, pc.prop_var, pc.cum_sum)

# determine number of PCs included ------------------------------------------
pc.nPC_method_1 <- sum(abs(diff(pc.prop_var))>pc.elbow_min_difference_ps) +1 
pc.nPC_method_2 <- sum(pc.cum_sum<pc.cum_var_explained_threshold_ps) + 1

if (PC_number_method_ps == 1){
  pc.n_relevant_components <- pc.nPC_method_1
} else if (PC_number_method_ps == 2){
  pc.n_relevant_components <- pc.nPC_method_2
}

# generate Scree Plot -------------------------------------------------------
plt.scree1 <- ggplot(scree.var, aes(x = pc.id, y = pc.prop_var)) + 
  geom_point() +  
  theme(legend.position="right") +
  geom_vline(xintercept = pc.n_relevant_components+0.5, color = 'red') + 
  ggtitle("Scree Plot") + xlab("Principal Components") + ylab("Variance Explained (proportion)")  + theme_miko()

plt.scree2 <- ggplot(scree.var, aes(x = pc.id, y = pc.cum_sum)) + 
  geom_point() +  
  theme(legend.position="right") +
  geom_vline(xintercept = pc.n_relevant_components+0.5, color = 'red') + 
  ylim(0, 1) + 
  ggtitle(paste0(pc.n_relevant_components, " PCs (", round(100*pc.cum_sum[pc.n_relevant_components],2), "%) of variance")) + xlab("Principal     Components") + ylab("Cumulative Variance Explained (proportion)") + theme_miko()


if (analysis.parameters$print.inline){
  print(plt.scree1)
  print(plt.scree2)
}

```


```{r c20 - cell cycle scoring, fig.width=14, fig.height = 4}

# get cell cycle genes
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

if (length(unique(analysis.parameters$organism.include)) > 1){
  s.genes <-  toupper(s.genes)
  g2m.genes <-  toupper(g2m.genes)
} else if (unique(analysis.parameters$organism.include) == "Mm"){
  s.genes <-  firstup(s.genes)
  g2m.genes <-  firstup(g2m.genes)
} else if (unique(analysis.parameters$organism.include) == "Hs"){
  s.genes <-  toupper(s.genes)
  g2m.genes <-  toupper(g2m.genes)
}

so <- ens2sym.so(so, gNames.list)

# cell cycle scoring and umap
plt.cc.umap <- tryCatch({
  
  so <- CellCycleScoring(so, s.features = s.genes, g2m.features = g2m.genes, set.ident = F)
  
  plt.cc.umap <- cluster.UMAP(
    so,
    group.by = "Phase",
    x.label = "UMAP 1",
    y.label = "UMAP 2",
    plot.name = "Cell Cycle Classifications",
    include.labels = F)
  
}, error = function(e){
  plt.cc.umap <- NULL
  return(plt.cc.umap)
})

# cluster-level composition
plt.cc <- NULL
if ("Phase" %in% names(so@meta.data)){
  df.cc <- data.frame(clusters =  so@meta.data[["seurat_clusters"]], phase =  so@meta.data[["Phase"]])
  
  df.cc.tally <- df.cc %>%
    group_by(clusters, phase) %>%
    tally()
  
  plt.cc.compo <- df.cc.tally %>%
    ggplot(aes(x = clusters, y = n, fill = phase)) + 
    geom_bar(position="fill", stat="identity") + 
    theme_miko(legend = T) + 
    labs(title = "Cluster Composition by Cell Cycle") + 
    xlab("Cluster ID") + ylab("Relative Frequency")
  
  plt.cc <- cowplot::plot_grid(plt.umap_by_cluster, plt.cc.umap, plt.cc.compo, ncol = 3)
} 


if (analysis.parameters$print.inline) {
  print(plt.cc)
}

```
```{r c21 - variable gene list}

if (normalization_method_ps == "SCT"){
  df.var.meta <- so@assays[["SCT"]]@meta.features
  df.var.meta <- df.var.meta[df.var.meta$sct.variable == T, ]
  df.var.meta <- bind_cols(data.frame(genes = rownames(df.var.meta)), df.var.meta)
  df.var.meta <- df.var.meta %>% dplyr::arrange(-sct.residual_variance)
  
  which.round <- colnames(df.var.meta)[ !(colnames(df.var.meta) %in% c("genes", "sct.variable"))]
  try({df.var.meta[which.round] <- signif(df.var.meta[which.round], 3)}, silent = T)
} else {
  df.var.meta <- NULL
}

```

```{r c22 - run additional dimensional reductions}



if (analysis.parameters$do.additional.reduction){
  
  # tsne #####################
  
  plt.tsne.combo <- tryCatch({
    so <-RunTSNE(so, dims = 1:nDim)
    
    # generate plots
    plt.tsne_by_cluster <- DimPlot(so, reduction = "tsne", label = TRUE)  + ggtitle(label = "TSNE") +
      xlab("TSNE 1") + ylab("TSNE 2")
    
    plt.tsne <- DimPlot(so, reduction = "tsne",group.by = "Barcode")  + ggtitle(label = "TSNE") +
      xlab("TSNE 1") + ylab("TSNE 2")
    
    # combine plots
    plt.tsne.combo <- cowplot::plot_grid(plt.tsne_by_cluster, plt.tsne, ncol = 2)
  }, error = function(e){
    plt.tsne.combo <- NULL
    return(plt.tsne.combo)
  })
  
  
  # PCA ########################
  
  # generate plots
  plt.pca_by_cluster <- DimPlot(so, reduction = "pca", label = TRUE)  + ggtitle(label = "PCA") +
    xlab("PCA 1") + ylab("PCA 2")
  
  plt.pca <- DimPlot(so, reduction = "pca",group.by = "Barcode")  + ggtitle(label = "PCA") +
    xlab("PCA 1") + ylab("PCA 2")
  
  # combine plots
  plt.pca.combo <- cowplot::plot_grid(plt.pca_by_cluster, plt.pca, ncol = 2)
  
  # ICA ########################
  so <- RunICA(so, verbose = F)
  
  # generate plots
  plt.ica_by_cluster <- DimPlot(so, reduction = "ica", label = TRUE)  + ggtitle(label = "ICA") +
    xlab("ICA 1") + ylab("ICA 2")
  
  plt.ica <- DimPlot(so, reduction = "ica",group.by = "Barcode")  + ggtitle(label = "ICA") +
    xlab("ICA 1") + ylab("ICA 2")
  
  # combine plots
  plt.ica.combo <- cowplot::plot_grid(plt.ica_by_cluster, plt.ica, ncol = 2)
  
} else {
  plt.tsne.combo <- NULL
  plt.ica.combo <- NULL
  plt.pca.combo <- NULL
}


if (analysis.parameters$print.inline){
  print(plt.tsne.combo)
  print(plt.pca.combo)
  print(plt.ica.combo)
}
```


```{r c23 - summary statistics }

meta.data <- names(so@meta.data)

# get subgroup names
quantifier.stem <- c("Count", "Feature", "percent.mt")
which.quant <- grepl(paste(quantifier.stem, collapse = "|"), meta.data)
quant.names <- meta.data[which.quant]
meta.names <- meta.data[!which.quant]

df.meta <- so@meta.data

summary.list <- list()

for (i in 1:length(meta.names)){
  
  current.meta.name <- meta.names[i]
  if (current.meta.name %in% c("unmatched.rate", "S.Score", "G2M.Score")) next
  
  df.meta.summary <- NULL
  
  df.meta.summary <- df.meta %>%
    group_by(get(meta.names[i])) %>%
    dplyr::summarise(n.nuclei =n(),
              UMI.mean = round(mean(nCount_RNA)),
              UMI.median =  round(median(nCount_RNA)),
              UMI.min = min(nCount_RNA),
              UMI.max = max(nCount_RNA),
              genes.mean =  round(mean(nFeature_RNA)),
              genes.median =  round(median(nFeature_RNA)),
              genes.min = min(nFeature_RNA),
              genes.max = max(nFeature_RNA),
              mito.mean =  signif(mean(percent.mt),3) ,
              mito.median =  signif(median(percent.mt),3) ,
              mito.min =  signif(min(percent.mt),3) ,
              mito.max =  signif(max(percent.mt),3))
  
  colnames(df.meta.summary)[1] <- meta.names[i]
  
  if (dim(df.meta.summary)[1] == 1){
    df.meta.summary <- data.frame(t(df.meta.summary)[2:dim(df.meta.summary)[2], ])
    colnames(df.meta.summary)[1] <- meta.names[i]
  } else {
    df.meta.summary <- as.data.frame(t(df.meta.summary))
    new.col.name <- as.matrix(df.meta.summary[1,])
    df.meta.summary <- as.data.frame(df.meta.summary[2:nrow(df.meta.summary),])
    colnames(df.meta.summary) <- new.col.name
  }
  
  try({
    summary.list[[meta.names[i]]] <- df.meta.summary
  }, silent = T)
  
}

```



```{r analysis log and save results}

# Normalization Method #
if (normalization_method_ps == "NFS"){
  norm_method <- "normalize, find features, scale"
} else if (normalization_method_ps == "SCT"){
  norm_method <- "SCT"
}

df.log <- addLogEntry("Normalization Method", norm_method, df.log, "norm_method")
df.log <- addLogEntry("Principal Components Included", nDim, df.log, "nDim")
df.log <- addLogEntry("Unmatched rate upper limit", unmatch.high, df.log, "unmatch.high")
df.log <- addLogEntry("Unmatched rate lower limit", unmatch.low, df.log, "unmatch.low")

end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log_Module_1 <- df.log

save.filename <- paste(analysis.parameters$save.directory , analysis.parameters$save.filename, sep = "")

if ((analysis.parameters$save.flag == TRUE) ){
  save(so, gNames.list, df.log_Module_1, file = save.filename)
}

```


QC Overview
===================================== 

Row 
-----------------------------------------------------------------------

### QC Measures: Distributions (pre-filtering)

```{r plt.QC_violin, fig.height= 5, fig.width = 10}
print(plt.QC_violin)
```

### QC Measures: Pairwise Scatterplots (pre-filtering)

```{r plt.QC_scatter, fig.height= 5, fig.width = 12}
print(plt.QC_scatter)
```

### Mitochondrial %: Distribution (pre-filtering)

```{r mt.mito_by_bc}
print(plt.mito_by_bc + theme_miko(legend = T))
```

### Cells Recovered: Pre- and Post-Filtering

```{r plt.filter_pre_post}
print(plt.filter_pre_post + theme_miko(legend = T))
```

Row 
-----------------------------------------------------------------------

### Pre- vs Post-Normalization Statistics

```{r plt.pre_post_norm}
print(plt.pre_post_norm)
```

### UMI per cell

```{r plt.UMI_per_cell}
print(plt.UMI_per_cell + theme_miko(legend = T))
```

### Genes per cell

```{r plt.genes_per_cell}
print(plt.genes_per_cell + theme_miko(legend = T))
```


### Normalized Gene Expression

```{r plt.variable_genes}
print(plt.variable_genes)
```

Row 
-----------------------------------------------------------------------

### Cells Recovered
```{r valuebox1}
valueBox(ncol(so))
```

### Genes per Cell (Median)
```{r valuebox2}
valueBox(median(so$nFeature_RNA))
```

### UMI per Cell (Median)
```{r valuebox3}
valueBox(median(so$nCount_RNA))
```

QC ranks
===================================== 

Row {.tabset}
-------------------------------------

### QC (mT)

```{r plt QC ranks mT, fig.width = 15, fig.height = 5}
ggpubr::ggarrange(plt.gene.umi.mito, plt.umi.rank.mito, plt.gene.rank.mito, plt.mt.rank.mito, ncol = 4) 
```

### QC (unmatched rate)

```{r plt QC ranks uR, fig.width=17, fig.height = 10}

try({
  ggpubr::ggarrange(plt.umi.rank.match, plt.gene.rank.match, plt.mt.rank.match,
                    plt.unmatch.umi, plt.gene.umi.match, plt.umatch.rank,ncol = 3, nrow = 2) 
}, silent = T)

```

### Filter Venn Diagram

```{r QC venn, fig.width=5, fig.height = 5}
try({
 plot(plt.filter.venn) 
}, silent = T)
```


Population Maps
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

### UMAP

```{r, fig.width=12, fig.height=5}
print(plt.umap.combo)
```

### TSNE

```{r, fig.width=12, fig.height=5}
print(plt.tsne.combo)
```

### PCA

```{r, fig.width=12, fig.height=5}
print(plt.pca.combo)
```

### ICA

```{r, fig.width=12, fig.height=5}
print(plt.ica.combo)
```

PCA 
===================================== 

Row
-----------------------------------------------------------------------

### PCA

```{r plt.PCA}
grid.arrange(plt.scree1, plt.scree2, ncol=2)
```

QC UMAPs
===================================== 

```{r UMAP QC plots, fig.width=12, fig.height=6}
plt.umap.qc
```

QC by subgroups (pre-filtering)
===================================== 

Row {data-height=700}
-----------------------------------------------------------------------

```{r plt.violin_by_subgroup, fig.height= 5, fig.width = 12}
print(plt.violin_by_subgroup)
```

Row {.tabset}
-----------------------------------------------------------------------

### QC summary

```{r df.qc_sum}
knitr::kable(df.qc_sum)
```

### nFeature_RNA ANOVA

```{r nFeat_aov}
knitr::kable(nFeat_aov[[1]])
```

### nCount_RNA ANOVA

```{r nCount_aov}
knitr::kable(nCount_aov[[1]])
```

### percent.mt ANOVA

```{r mT_aov}
knitr::kable(mT_aov[[1]])
```

Cell Cycle
===================================== 

```{r plot cc plot, fig.width=14, fig.height=4}

try({
  print(plt.cc)
}, silent = T)

```


Summary Statistics
===================================== 

Row {.tabset}
-------------------------------------


```{r summary statistis,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out <- flex.multiTabTables(summary.list, "summary.list")

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


Variable Genes
===================================== 
```{r var table list}

if (!is.null(df.var.meta)){
  flex.asDT(df.var.meta)
}
```


Log
===================================== 

```{r}
knitr::kable(df.log_Module_1)

```



