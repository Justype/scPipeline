---
title: "Ligand-Receptor Interactions"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---

```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", 
                   "plyr", "dplyr", "tidyr", "reshape2", "arrangements", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", "cowplot", "iTALK")

# load packages
lapply(packages2load, library, character.only = TRUE)
```


```{r specify parameters}

# TODO
# mean for ligand, median for receptor (rationale is that ligands do not depend on cell type, receptors do)

# query input
input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module1_pilot4_GL261_CT2A.Rdata"
# input.file <- "Module1_Suva2019.Rdata"

which.species <- "Mm"
cluster.resolution = 0.15

print.inline <- F

which.data <- "data" # options: data, scale

data.type  <- "mean count" # options: mean count, DEG

top.N.genes <- 50 # Nth percentile expression

# compare cell types
# pairwise.comparison.flag <- F
# cell_type_a <- "c12"
# cell_type_b <- "c4"

# downsampling
subsample_factor <- 1

# subset
subset.df <- "no.subset"

# top n genes for LR network
 top.N.genes <- 500


# communication type
communication.type <- c("growth factor", "other", 'cytokine','checkpoint')
# communication.type <-  "checkpoint" # options: cytokine, checkpoint, growth factor, other

aggregation.method <- "mean" # options: mean, median
n.LRpairs <- 20

save.pdf <- T
```



```{r analysis log}

# Module
df.log <- initiateLog("12, Ligand-Receptor Interactions")



df.log <- addLogEntry("Input File (.Rdata)", input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Species", which.species, df.log, "which.species")
df.log <- addLogEntry("Data Type", data.type, df.log, "data.type")
df.log <- addLogEntry("Data Slot", which.data, df.log, "which.data")
df.log <- addLogEntry("Communication Type", communication.type, df.log, "communication.type")
df.log <- addLogEntry("Top N pairs shown", n.LRpairs, df.log, "n.LRpairs")
if (is.character(subset.df))  df.log <- addLogEntry("Subset", subset.df, df.log, "subset.df")
df.log <- addLogEntry("Downsample Factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Aggregation Method", aggregation.method, df.log, "aggregation.method")


```




```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"
dir.reference <- "Reference_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}
if (!exists("input.file")) stop("input.file is not specified")

# load query dataset
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

if (!exists("gNames.list")) gNames.list <- prepGeneList(so.query, objects())

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "corr", "gsva", "deg", "counts"))


# unpack results
rm(so)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

```


```{r get prior module logs}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r  function to specify signature gene sets}
# convert human symbols to mouse symbols

gene2species <- function(x, expected_species){
  if (expected_species == "Hs"){
    x <- toupper(x)
  } else if (expected_species == "Mm"){
    x <- tolower(x)
    substr(x, 1, 1) <- toupper(substr(x, 1, 1))

  }
  return(x)
}
```



```{r define prep data function}


prep.data <- function(so, cluster.field, gNames.list, data.slot){
  
  current.assay <- DefaultAssay(so)

  # get unique clusters
  u.clusters <- as.numeric(as.character(unique(so@meta.data[[cluster.field]])))
  u.clusters <- u.clusters[order(u.clusters)]
  
  # get normalizated expression matrix
  if (data.slot == "data"){
    exp.mat <- as.matrix(so@assays[[current.assay]]@data)
  } else if (data.slot == "scale"){
    exp.mat <- so@assays[[current.assay]]@scale.data 
  }
  
  exp.df_t <- as.data.frame(t(exp.mat))
  
  # prepare data
  cur.genes <- colnames(exp.df_t)
  
  # exp.df_t <- as.data.frame(t(exp.mat))
  rownames(exp.mat) <- gene2species(rownames(exp.mat) , expected_species = "Hs")
  colnames(exp.df_t) <- gene2species(cur.genes, expected_species = "Hs")
  exp.df_t$cell_type <- paste("c", as.vector(so@meta.data[[cluster.field]]), sep = "")
  
  output <- list(u.clusters, exp.mat, exp.df_t)
  return(output)
  
}
  cluster.field <- "seurat_clusters"
  prep.output <- prep.data(so.query, cluster.field, gNames.list, which.data)
  
```


```{r analysis function}

analyze_LG.pairs <- function(u.clusters, exp.df_t, communication.type, high.exp_genes = NULL, aggregation.method = "mean", top.N.genes = 50, n.LRpairs = 20){

  
  # get top nth percentile 
  if (is.null(high.exp_genes)){
    high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  }
  
  res_cat<-FindLR(high.exp_genes, datatype='mean count', comm_type=communication.type)
  
  # sort by product of ligand*receptor expression
  res_cat<-res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs,decreasing=T),]
  
  
  # output <- list(high.exp_genes, res_cat)
  return(res_cat)
}

```



```{r ligand-receptor pairs from highly expressed genes, fig.height= 10, fig.width= 10}

# initiate lists
res.LR.list <- list()
res.LR.list2 <- list()

  # initiate lists
  res.comm.list <- list()
  res.comm.list2 <- list()
  
  # get data
  exp.df_t <-  prep.output[[3]]
  u.clusters <- prep.output[[1]]
  
  # get highly expressed genes
 
  high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  
  # inititate data.frames
  res.by_comm <- NULL
  res.by_comm2 <- NULL
  for (j in 1:length(communication.type)){
    comm.type <- communication.type[j]
    
    # run ligand receptor interaction analysis 
    res.comm.list[[comm.type]] <- analyze_LG.pairs(u.clusters = u.clusters, 
                                                   exp.df_t = exp.df_t, 
                                                   communication.type = comm.type,
                                                   high.exp_genes = high.exp_genes, 
                                                   aggregation.method = aggregation.method, 
                                                   top.N.genes = top.N.genes, 
                                                   n.LRpairs = n.LRpairs)
    
    
    res.comm.list[[comm.type]]$cell_from_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_from_mean_exprs, 3)
    res.comm.list[[comm.type]]$cell_to_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_to_mean_exprs, 3)
    
    # a <- res.comm.list[[comm.type]]
    res.by_comm<-rbind(res.by_comm,res.comm.list[[comm.type]])
    
    # subset data to include top n.LRpairs
      top.data <- res.comm.list[[comm.type]][1:n.LRpairs,]
      top.data <- top.data[complete.cases(top.data), ]
      res.comm.list2[[comm.type]] <- top.data
      res.by_comm2 <- rbind(res.by_comm2, res.comm.list2[[comm.type]] ) # for output plots
    
    if (print.inline){
      # specify cell colors
      my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(u.clusters))
      cell_col<-structure(my.cols,names=unique(exp.df_t$cell_type ))
      
      # LR interaction plot
      LRPlot( top.data,
              datatype='mean count',
              cell_col=cell_col,
              link.arr.lwd= top.data$cell_from_mean_exprs,
              link.arr.width= top.data$cell_to_mean_exprs)
      title(comm.type)
      
    }
  }
  
  # store results
  res.comm.list[["pooled"]] <- res.by_comm
  res.comm.list2[["pooled"]] <- res.by_comm2


```
```{r Interaction SUMMARIES, warning = FALSE, message = FALSE}

u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)


# options: #cytokine, checkpoint, growth factor, pooled, other

dot.res.list <- list()
which.communication <- c("cytokine", "checkpoint", "growth factor", "other", "pooled")

for (k in 1:length(which.communication)){

which.threshold <- 0

df.comm <- res.comm.list[[which.communication[k]]]
df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs

df.rollingThreshAll <- NULL
df.rollingThreshAll.IS <- NULL


for (i in 1:length(u.clust)){

  cluster.name <- paste0("c", u.clust[i])
  df.comm.sub <- df.comm[df.comm$cell_from %in% cluster.name, ]
  
  # expression threshold
  int.min <- 0
  int.max <- max(df.comm$interaction.score)
  int.by <- (int.max - int.min)/50
  exp.thresh <- seq(int.min,int.max, int.by)
  
  df.rollingThresh <- NULL
  df.rollingThreshIntScore <- NULL
  for (j in 1:length(exp.thresh)){
    df.tally <- NULL
    filter1 <- df.comm.sub$interaction.score > exp.thresh[j]
    # filter2 <- df.comm.sub$cell_to_mean_exprs > exp.thresh[j]
    df.comm.sub2 <- df.comm.sub[filter1, ]
    
    
    df.tally <- data.frame(table(df.comm.sub2$cell_to))
    df.intscore <- df.comm.sub2 %>% group_by(cell_to) %>% summarize(int.score = mean(interaction.score))
    colnames(df.intscore) <- c("Var1", "int.score")
    
    if (nrow(df.tally) == 0){
      df.tally <- data.frame(Var1 = paste0("c", u.clust), Freq = 0)
       df.intscore <- data.frame(Var1 = paste0("c", u.clust), int.score = 0)
    } else if (nrow(df.tally) < length(u.clust)) {
      which.missing <- u.clust[!(paste0("c", u.clust) %in% df.tally$Var1)]
      df.tally <- bind_rows(df.tally, data.frame(Var1 =  paste0("c", which.missing), Freq = 0))
      df.intscore <- bind_rows(df.intscore, data.frame(Var1 =  paste0("c", which.missing), int.score = 0))
    }
    
    df.tally$threshold <- exp.thresh[j]
    df.intscore$threshold <- exp.thresh[j]
    
    df.rollingThresh <- bind_rows(df.rollingThresh,df.tally)
    df.rollingThreshIntScore <- bind_rows(df.rollingThreshIntScore,df.intscore)
  
  }
  
  df.rollingThresh$Source = paste0("c", u.clust[i])
  df.rollingThreshIntScore$Source = paste0("c", u.clust[i])
  
  df.rollingThreshAll <- bind_rows(df.rollingThreshAll, df.rollingThresh)
  df.rollingThreshAll.IS <- bind_rows(df.rollingThreshAll.IS, df.rollingThreshIntScore)
  
  # df.rollingThresh <- df.rollingThresh %>% group_by(Var1) %>% arrange(threshold)
  
 # plt.rollingThresh <- df.rollingThresh %>%
 #    ggplot(aes(x= threshold, y = log1p(Freq), color = (Var1))) + 
 #    geom_point() + 
 #    geom_path(aes(group = Var1)) +
 #    theme_miko(legend = T) + 
 #   labs(title = paste0("Source Cluster: ", u.clust[i]), subtitle = which.communication)+
 #   scale_color_discrete("Destination\nCluster") + 
 #   xlab("Interaction Score") + ylab("N Interactions (log2)")
 
 # if(print.inline) print(plt.rollingThresh)
  
}


# VERSION 1: NUMBER OF INTERACTIONS
df.rollingThreshAllSum <- df.rollingThreshAll %>% group_by(Var1, Source) %>% summarize(Freq.sum = log1p(sum(Freq)))

df.rta.wide <- pivot_wider(df.rollingThreshAllSum, names_from = "Source", values_from = "Freq.sum")
rownames(df.rta.wide) <- df.rta.wide$Var1
df.rta.wide <- df.rta.wide %>% ungroup() %>% dplyr::select(-c("Var1"))

mat.rta.wide <- data.matrix(df.rta.wide)
# pheatmap::pheatmap(mat.rta.wide, cluster_rows = T, cluster_cols = T, main = paste0(which.communication[k], " N interactions\nx=Source, y=Destination"), color = viridis::viridis(20))

# VERSION 2: INERACTION SCORES
df.rollingThreshAllISscore <- df.rollingThreshAll.IS %>% group_by(Var1, Source) %>% summarize(IS.sum = log1p(sum(int.score)))

df.rta.is.wide <- pivot_wider(df.rollingThreshAllISscore, names_from = "Source", values_from = "IS.sum")
rownames(df.rta.is.wide) <- df.rta.is.wide$Var1
df.rta.is.wide <- df.rta.is.wide %>% ungroup() %>% dplyr::select(-c("Var1"))

mat.rta.is.wide <- data.matrix(df.rta.is.wide)
# pheatmap::pheatmap(mat.rta.is.wide, cluster_rows = T, cluster_cols = T, main = paste0(which.communication[k], " Interaction Score\nx=Source, y=Destination"), color = viridis::viridis(20))

# store results

dot.res.list[[which.communication[k]]] <- list(
  freq = df.rollingThreshAll,
  interaction = df.rollingThreshAll.IS
)
  
}

```

```{r LR dotplot, fig.width=8, fig.height=8, warning = FALSE, message = FALSE}


plt.agg.LR.list <- list()

for (i in 1:length(dot.res.list)){
  
communication.name <- names(dot.res.list)[i]
df.rollMerge <- merge(dot.res.list[[communication.name]][["freq"]], dot.res.list[[communication.name]][["interaction"]])

df.rollMerge$int.score <- log1p(df.rollMerge$int.score)

df.rollMerge.sum <- df.rollMerge %>%
  group_by(Var1, Source) %>%
  summarize(freq.mean = mean(Freq),
            is.mean = mean(int.score))

df.rollMerge.sum$Var1 <- factor(df.rollMerge.sum$Var1, levels = paste0("c", u.clusters))
df.rollMerge.sum$Source <- factor(df.rollMerge.sum$Source, levels = paste0("c", u.clusters))

p <- df.rollMerge.sum %>%
  ggplot(aes(x = Var1, y = Source, size = freq.mean, fill = is.mean )) +
  geom_point(pch=21, color = "black")  +
  xlab("Recipient") + ylab("Source") + theme(legend.position="bottom") + 
  viridis::scale_fill_viridis("Interaction (log)") + coord_flip()

p.legend <- cowplot::get_legend(p)

p <- p+ theme(legend.position="none")

p1 <- df.rollMerge.sum %>%
  group_by(Var1) %>%
  summarize(is.sum = mean(is.mean, na.rm = T),
            is.se = sd(is.mean, na.rm = T)/ sqrt(length(is.mean))) %>%
  ggplot(aes(x = Var1, y = is.sum)) +
  geom_bar(stat = "identity") + xlab("") + ylab("Score") +
  geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                 position=position_dodge(.9)) + 
  coord_flip() + 
  geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")

p2 <- df.rollMerge.sum %>%
  group_by(Source) %>%
  summarize(is.sum = mean(is.mean, na.rm = T),
            is.se = sd(is.mean, na.rm = T) / sqrt(length(is.mean))) %>%
  ggplot(aes(x = Source, y = is.sum)) +
  geom_bar(stat = "identity") + 
    geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                 position=position_dodge(.9)) + 
  xlab("") + ylab("Score") + 
  geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")

p.merge <- cowplot::plot_grid(p2, NULL, p, p1 ,rel_widths = c(3,1), rel_heights = c(1,3), align = c("hv"))

p.title <- ggplot() + labs(title = communication.name, subtitle = "marginal plots show mean interaction +/- se")
p.merge.final <- cowplot::plot_grid(p.title, p.merge, p.legend, ncol = 1, rel_heights = c(0.5,5,1))


if (print.inline) print(p.merge.final)

plt.agg.LR.list[[communication.name]] <- p.merge.final

}

```


```{r cluster differentials, warning = FALSE, message = FALSE}

# get expression  matrix
ef.mat <- as.matrix(so.query@assays[[DefaultAssay(so.query)]]@data)
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# initiate empty matrices
f.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust))

# get cluster-level aggregate scores
for (i in 1:length(u.clust)){
  which.cells <- sc.meta %in% u.clust[i]
  
  # expressing fraction
  f1 <- rowMeans(ef.mat[, which.cells] > 0)
  f.mat[ ,i] <- f1
}

# assign col and row names
colnames(f.mat) <-   u.clust
rownames(f.mat) <-   rownames(ef.mat)

# cast to data.frame
df.f.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(f.mat)); colnames(df.f.wide) <- c("gene", u.clust)

# wide to long
df.f.long <- pivot_longer(df.f.wide, colnames(df.f.wide)[2:ncol(df.f.wide)])

# assign col names to long dataframe
colnames(df.f.long) <- c("gene", "cluster", "value")

# ensure clusters are ordered factors
df.f.long$cluster <- factor(df.f.long$cluster, levels = u.clust)

# clear baggage
rm(ef.mat); invisible({gc()})

```

```{r, fig.width = 15, fig.height=5, warning = FALSE, message = FALSE, include = FALSE}

plt.umap <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() +   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))


f.threshold <- 0.1

plt.granular.list <- list()
plt.top.int <- list()

for (k in 1:length(which.communication)){
  
  # get LR interaction
  df.comm <- res.comm.list[[which.communication[k]]]
  df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs
  
  # LR name
  df.comm$LR <- paste0(df.comm$ligand, " -> ", df.comm$receptor)
  
  # cast clusters as factors
  df.comm$cell_to <- gsub("c", "", df.comm$cell_to)
  df.comm$cell_to <- factor(df.comm$cell_to, levels = paste0(u.clust))
  df.comm$cell_from <- gsub("c", "", df.comm$cell_from)
  df.comm$cell_from <- factor(df.comm$cell_from, levels = paste0(u.clust))
  
  # clone
  df.comm.all <- df.comm
  
  # expression fraction merge
  df.f.ligand <- df.f.long
  df.f.ligand$cluster <- paste0(df.f.ligand$cluster)
  df.f.ligand$gene <- toupper(df.f.ligand$gene)
  colnames(df.f.ligand) <- c("ligand", "cell_from", "source.fraction")
  df.comm <- merge(df.comm, df.f.ligand)
  
  df.f.receptor <- df.f.ligand
  colnames(df.f.receptor) <- c("receptor", "cell_to", "target.fraction")
  df.comm <- merge(df.comm, df.f.receptor)
  
  # filter top interactions
  filter1 <- df.comm$interaction.score > 0
  # filter2 <- df.comm$source.fraction > f.threshold
  # filter3 <- df.comm$target.fraction > f.threshold
  # df.comm <- df.comm[filter1 & filter2 & filter3, ]
  df.comm <- df.comm[filter1, ]
  
  df.comm <- df.comm %>% dplyr::arrange(-interaction.score)
  
  u.lr.cur <- 0
  iter.n <- 0
  u.lr.top <- NULL
  n.top.int <- 20
  while((u.lr.cur < 20) & ((iter.n + n.top.int) < nrow(df.comm))){
    df.comm.top <- df.comm %>% dplyr::top_n(n.top.int+iter.n, interaction.score)
    u.lr.top <- unique(df.comm.top$LR)
    u.lr.cur <- length(u.lr.top)
    if (u.lr.cur >= n.top.int){
      break
    } else {
      iter.n <- iter.n + 1
    }
  }
  
  df.comm <- df.comm.top; rm(df.comm.top)
  
  if (nrow(df.comm) == 0) {
    plt.granular.list[[which.communication[k]]] <- NULL
    next
  }
  
  u.lr.all <- unique(df.comm.all$LR)
  u.lr.filt <- unique(df.comm$LR)
  
  which.keep <- (df.comm.all$LR) %in% u.lr.filt
  df.comm.sub <- df.comm.all[which.keep, ]
  
  plt.gran.ind.list <- list()
  
  for (i in 1:u.lr.cur){
    # for (i in 1:length(u.lr.filt)){
    
    ligand.name <- sub(" .*", "", u.lr.filt[i])
    receptor.name <- stringr::str_replace(u.lr.filt[i], "[A-Za-z0-9]*\ ->\ ", "")
    
    if (which.species == "Mm"){
      ligand.name <- firstup(ligand.name)
      receptor.name <- firstup(receptor.name)
    } else if (which.species == "Hs"){
      ligand.name <- toupper(ligand.name)
      receptor.name <- toupper(receptor.name)      
    }
    
    # LR-level dot plot
    plt.grain.dot <- df.comm.sub %>%
      dplyr::filter(LR %in% u.lr.filt[i]) %>%
      dplyr::group_by(LR) %>%
      ggplot(aes(x = cell_from, y = cell_to, fill = interaction.score, size = interaction.score)) + 
      geom_point() +
      geom_point(pch=21, color = "black")  +
      xlab("Source Cluster") + ylab("Recipient Cluster") + 
      viridis::scale_fill_viridis("Interaction.Score") + 
      facet_wrap(~LR) + 
      theme(plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # LIGAND UMAP
    plt.lig <- scExpression.UMAP(
      so.query,
      ligand.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = ligand.name, subtitle = "Ligand (Source)") + 
        theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # RECEPTOR UMAP
    plt.rec <- scExpression.UMAP(
      so.query,
      receptor.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = receptor.name, subtitle = "Receptor (Recipient)")  + 
      # theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
      theme(axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # EXPRESSION DOTPLOT
    lr.feature <- c(ligand.name,receptor.name )
    names(lr.feature) <- c("L", "R")
    plt.dot.exp <- DotPlot(
      so.query,
      assay = NULL,
      features = lr.feature,
      cols = c("lightgrey", "tomato"),
      col.min = -2.5,
      col.max = 2.5,
      dot.min = 0,
      dot.scale = 6,
      scale = T,
      scale.by = "radius") + 
      xlab("Genes") + ylab("Cluster") + 
        theme(axis.title.x=element_blank(),
              legend.title = element_text(size = 5),
              legend.text = element_text(size = 5),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # COMBINE LIGAND-RECEPTOR UMAPS
    plt.umap.exp <- cowplot::plot_grid(plt.lig, plt.rec, ncol = 1, align = "hv")
    
    # COMBINE REMAINDING PLOTS
    plt.gran <- cowplot::plot_grid(plt.umap, plt.umap.exp, plt.dot.exp, 
                                   plt.grain.dot, ncol = 4, align = "hv", rel_widths = c(1,0.7,0.7, 1.5), labels = "AUTO")
    
    if (print.inline) {
      print(plt.gran)
    }
    
    plt.gran.ind.list[[u.lr.filt[i]]] <- plt.gran
  }
  
  plt.granular.list[[which.communication[k]]] <- plt.gran.ind.list

  # top interactions
  df.comm.u <- unique(df.comm[ ,c("LR", "cell_from")])
  df.lig <- data.frame(table(df.comm.u$LR))
  
  plt.lig.profile <- df.lig %>%
    top_n(20, Freq) %>%
    ggplot(aes(x = reorder(Var1, Freq), y = Freq)) + 
    geom_bar(stat = "identity") + 
    coord_flip() + 
    ylab("N sources with paired target") + 
    xlab("Ligand") + 
    labs(title = "LR Pair Activity", subtitle = which.communication[k]) + 
    theme_miko()
  
  plt.top.int[[which.communication[k]]] <- plt.lig.profile
  
  if (print.inline) print(plt.lig.profile)
}


```



```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M12", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M12_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


UMAP
===================================== 

```{r ph1,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

plt.umap.final <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() 

print(plt.umap.final)

savePDF(file.name = paste0(output.path, "PDF/", "M12_UMAP.pdf"), plot.handle = plt.umap.final, 
        fig.width = 5, fig.height = 5, save.flag = save.pdf)

```

LR Descriptives
===================================== 

Row {.tabset}
-------------------------------------

```{r lr desc,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.agg.LR.list), function(i) {
  
  s1 <- names(plt.agg.LR.list)[i]
  s2 <- paste0("plt.agg.LR.list[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=8, fig.height=8, message=FALSE, warning=FALSE}", paste("lr_sum", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`


```{r lr desc save,include = FALSE}

for (i in 1:length(plt.agg.LR.list)){
  plot.name <- paste0("M12_LR_summary_", names(plt.agg.LR.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.agg.LR.list[[i]], 
          fig.width = 8, fig.height = 8, save.flag = save.pdf)
}

```

Top LR Pairs
===================================== 

Row {.tabset}
-------------------------------------

```{r top lr,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.top.int), function(i) {
  
  s1 <- names(plt.top.int)[i]
  s2 <- paste0("plt.top.int[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=8, fig.height=8, message=FALSE, warning=FALSE}", paste("lr_top", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`

```{r top lr save,include = FALSE}

for (i in 1:length(plt.top.int)){
  plot.name <- paste0("M12_top_LR_pairs_", names(plt.top.int)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.top.int[[i]], 
          fig.width = 5, fig.height = 7, save.flag = save.pdf)
}

```

LR Interactions
===================================== 

Row {.tabset}
-------------------------------------

```{r ph4,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

  out2 <- lapply(seq_along(res.comm.list2), function(j) {

    clust_a <- as.vector(res.comm.list2[[j]][["cell_from"]])
    clust_b <- as.vector(res.comm.list2[[j]][["cell_to"]])
    clust_all <- as.vector(unique(c(clust_a, clust_b)))
    
    # specify cell colors
    comm.type <- names(res.comm.list2)[j]
    my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(clust_all))
    cell_col <-my.cols

    # LR plot
    s1 <- sprintf("LRPlot( res.comm.list2[[%d]], 
    datatype='mean count', 
    link.arr.lwd= res.comm.list2[[%d]]$cell_from_mean_exprs, 
    link.arr.width= res.comm.list2[[%d]]$cell_to_mean_exprs)",j, j, j)

    s2 <- comm.type

    b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", comm.type)) # tab header
    b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=10, fig.height=10, message=FALSE, warning=FALSE}", 
                                            paste("chunk", j, sep = ""))) 
    b3 <- knitr::knit_expand(text = sprintf("\n %s",s1)) 
    b5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    out2 <- paste(b1, b2, b3, b5, collapse = '\n')
    return(out2) 
    
  })

```

`r paste(knitr::knit(text = paste(out2, collapse = '\n')))`

```{r ph4 save,include = FALSE}

try({
  for (i in 1:length(res.comm.list2)){
    plot.name <- paste0("M12_LR_interaction_circle_", names(res.comm.list2)[i] ,".pdf")
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle =  LRPlot( res.comm.list2[[i]], 
                                   datatype='mean count', 
                                   link.arr.lwd= res.comm.list2[[i]]$cell_from_mean_exprs, 
                                   link.arr.width= res.comm.list2[[i]]$cell_to_mean_exprs), 
            fig.width = 10, fig.height = 10, save.flag = save.pdf)
  } 
}, silent = T)


```


1| Cytokines
===================================== 

Row {.tabset}
-------------------------------------

```{r pp1}

 plt.cur <-  plt.granular.list[["cytokine"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
  out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 15, fig.height=5, message=FALSE, warning=FALSE}", paste("p1", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp1 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_cytokines_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 15, fig.height=5, save.flag = save.pdf)
  } 
}, silent = T)


```

2| Checkpoint
===================================== 

Row {.tabset}
-------------------------------------

```{r pp2}

 plt.cur <-  plt.granular.list[["checkpoint"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 15, fig.height=5, message=FALSE, warning=FALSE}", paste("p2", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp2 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_checkpoint_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 15, fig.height=5, save.flag = save.pdf)
  } 
}, silent = T)


```


3| Growth Factors
===================================== 

Row {.tabset}
-------------------------------------

```{r pp3}

 plt.cur <-  plt.granular.list[["growth factor"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 15, fig.height=5, message=FALSE, warning=FALSE}", paste("p3", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp3 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_growthfactor_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 15, fig.height=5, save.flag = save.pdf)
  } 
}, silent = T)


```

4| Other
===================================== 

Row {.tabset}
-------------------------------------

```{r pp4}

 plt.cur <-  plt.granular.list[["other"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 15, fig.height=5, message=FALSE, warning=FALSE}", paste("p4", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp4 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_other_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 15, fig.height=5, save.flag = save.pdf)
  } 
}, silent = T)


```

5| Pooled
===================================== 

Row {.tabset}
-------------------------------------

```{r pp5}

 plt.cur <-  plt.granular.list[["pooled"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 15, fig.height=5, message=FALSE, warning=FALSE}", paste("p5", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp5 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_pooled_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 15, fig.height=5, save.flag = save.pdf)
  } 
}, silent = T)


```

LR Table
===================================== 

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

df.comm.output <- res.comm.list[["pooled"]]
df.comm.output$interaction.score <- signif(df.comm.output$cell_from_mean_exprs * df.comm.output$cell_to_mean_exprs, 3)
df.comm.output <- df.comm.output %>% dplyr::filter(interaction.score > 0.1)

datatable(df.comm.output, 
          filter = 'top',
          extensions = 'Buttons',
          options = list(pageLength = 50,
                         dom = 'Bfrtip', 
                         buttons = c('copy', 'csv', 'pdf')))

write.csv(df.comm.output, file = paste0(output.path, "Tables/", "LR_table.csv"), 
          row.names = F) 

```

```{r analysis log final}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)

df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")
df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_12 <- df.log

```


```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 12)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_12)

```


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_12, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    pdf.list <- pdf.list[validUTF8(pdf.list)]
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}

```