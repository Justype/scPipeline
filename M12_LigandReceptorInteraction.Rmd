---
title: "Ligand-Receptor Interactions"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---

```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", 
                   "plyr", "dplyr", "tidyr", "reshape2", "arrangements", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", "cowplot", "iTALK")

# load packages
lapply(packages2load, library, character.only = TRUE)
```


```{r specify parameters}

# query input
# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module2_integrated_p4789_allGBM_210720.Rdata"
# input.file <- "Module1_Suva2019.Rdata"
 input.file <- "R6_M02_BC2_allGBM_271020.Rdata"

which.species <- "Mm"
cluster.resolution = 1

print.inline <- F

which.data <- "data" # options: data, scale

data.type  <- "mean count" # options: mean count, DEG

# downsampling
subsample_factor <- 1

# subset
which.subset <- "no.subset"

# top n genes for LR network
 top.N.genes <- 500


# communication type
communication.type <- c("growth factor", "other", 'cytokine','checkpoint')
# communication.type <-  "checkpoint" # options: cytokine, checkpoint, growth factor, other

aggregation.method <- "mean" # options: mean, median
n.LRpairs <- 20

save.pdf <- T
```



```{r analysis log}

# Module
df.log <- initiateLog("12, Ligand-Receptor Interactions")
df.log <- addLogEntry("Input File (.Rdata)", input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Species", which.species, df.log, "which.species")
df.log <- addLogEntry("Data Type", data.type, df.log, "data.type")
df.log <- addLogEntry("Data Slot", which.data, df.log, "which.data")
df.log <- addLogEntry("Communication Type", communication.type, df.log, "communication.type")
df.log <- addLogEntry("Top N pairs shown", n.LRpairs, df.log, "n.LRpairs")
if (is.character(which.subset))  df.log <- addLogEntry("Subset", which.subset, df.log, "which.subset")
df.log <- addLogEntry("Downsample Factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Aggregation Method", aggregation.method, df.log, "aggregation.method")


```




```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}
if (!exists("input.file")) stop("input.file is not specified")

# load query dataset
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())
if (!(exists("which.subset"))) which.subset <- "no.subset"

# which terms2drop
t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "scale")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset.data = which.subset, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = T)


# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

```


```{r get prior module logs}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r  function to specify signature gene sets}

# helper function to convert human symbols to mouse symbols
gene2species <- function(x, expected_species){
  if (expected_species == "Hs"){
    x <- toupper(x)
  } else if (expected_species == "Mm"){
    x <- tolower(x)
    substr(x, 1, 1) <- toupper(substr(x, 1, 1))

  }
  return(x)
}
```


```{r define prep data function}

# helper function to prep data
prep.data <- function(so, cluster.field, gNames.list, data.slot){
  
  # get current assay
  current.assay <- DefaultAssay(so)

  # get unique clusters
  u.clusters <- as.numeric(as.character(unique(so@meta.data[[cluster.field]])))
  u.clusters <- u.clusters[order(u.clusters)]
  
  # get normalizated expression matrix
  if (data.slot == "data"){
    exp.mat <- (so@assays[[current.assay]]@data)
  } else if (data.slot == "scale"){
    exp.mat <- so@assays[[current.assay]]@scale.data 
  }
  
  # cast matrix to data.frame
  exp.df_t <- sparse2df(exp.mat, transpose =  T)
  colnames(exp.df_t) <- rownames(exp.mat)
  rownames(exp.df_t) <- colnames(exp.mat)
  rm(exp.mat); invisible({gc()})
  
  # prepare data
  cur.genes <- colnames(exp.df_t)
  colnames(exp.df_t) <- gene2species(cur.genes, expected_species = "Hs")
  exp.df_t$cell_type <- paste("c", as.vector(so@meta.data[[cluster.field]]), sep = "")

  # return output
  output <- list(u.clusters, NULL, exp.df_t)
  return(output)
  
}

# specify where cluster ids are stored
cluster.field <- "seurat_clusters"

# prep data
prep.output <- prep.data(so.query, cluster.field, gNames.list, which.data)

```


```{r analysis function}

# helper function for analyzing LR pairs
analyze_LG.pairs <- function(u.clusters, exp.df_t, communication.type, high.exp_genes = NULL, aggregation.method = "mean", top.N.genes = 50, n.LRpairs = 20){
  
  # get top nth percentile 
  if (is.null(high.exp_genes)){
    high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  }
  
  res_cat<-FindLR(high.exp_genes, datatype='mean count', comm_type=communication.type)
  
  # sort by product of ligand*receptor expression
  res_cat<-res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs,decreasing=T),]
  
  return(res_cat)
}

```



```{r ligand-receptor pairs from highly expressed genes, fig.height= 10, fig.width= 10}

# Identify LR pairs ############################################################

# initiate lists
res.LR.list <- list()
res.LR.list2 <- list()

  # initiate lists
  res.comm.list <- list()
  res.comm.list2 <- list()
  
  # get data
  exp.df_t <-  prep.output[[3]]
  u.clusters <- prep.output[[1]]
  rm(prep.output)
  invisible({gc()})
  
  # get highly expressed genes
  high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  
  # inititate data.frames
  res.by_comm <- NULL
  res.by_comm2 <- NULL
  for (j in 1:length(communication.type)){
    comm.type <- communication.type[j]
    
    # run ligand receptor interaction analysis 
    res.comm.list[[comm.type]] <- analyze_LG.pairs(u.clusters = u.clusters, 
                                                   exp.df_t = exp.df_t, 
                                                   communication.type = comm.type,
                                                   high.exp_genes = high.exp_genes, 
                                                   aggregation.method = aggregation.method, 
                                                   top.N.genes = top.N.genes, 
                                                   n.LRpairs = n.LRpairs)
    
    # round values to nearest sig.fig.
    res.comm.list[[comm.type]]$cell_from_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_from_mean_exprs, 3)
    res.comm.list[[comm.type]]$cell_to_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_to_mean_exprs, 3)
    res.by_comm<-rbind(res.by_comm,res.comm.list[[comm.type]])
    
    # subset data to include top n.LRpairs
      top.data <- res.comm.list[[comm.type]][1:n.LRpairs,]
      top.data <- top.data[complete.cases(top.data), ]
      res.comm.list2[[comm.type]] <- top.data
      res.by_comm2 <- rbind(res.by_comm2, res.comm.list2[[comm.type]] ) # for output plots
    
    if (print.inline){
      # specify cell colors
      my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(u.clusters))
      cell_col<-structure(my.cols,names=unique(exp.df_t$cell_type ))
      
      # LR interaction plot
      LRPlot( top.data,
              datatype='mean count',
              cell_col=cell_col,
              link.arr.lwd= top.data$cell_from_mean_exprs,
              link.arr.width= top.data$cell_to_mean_exprs)
      title(comm.type)
      
    }
  }
  
  # store results
  res.comm.list[["pooled"]] <- res.by_comm
  res.comm.list2[["pooled"]] <- res.by_comm2


```



```{r NEW single cell signal R, fig.width = 8, fig.height = 4}

do.scsr <- F

if (do.scsr){
  


library(SingleCellSignalR)

# get seurat clusters
so.cluster <- as.character(so.query@meta.data[["seurat_clusters"]])
so.cluster <- as.integer(so.cluster) + 1

# cast as matrix and get genes
so.data <- as.matrix(so.query@assays[[DefaultAssay(so.query)]]@data)
so.genes <- rownames(so.data)

# score LR interactions (scsr method)
sr.signal <- cell_signaling(data = so.data, genes = so.genes, cluster = so.cluster,species = "mus musculus")

# some data wranlging...
df.scsr <- NULL
for (i in 1:length(sr.signal)){
  scsr.results <- sr.signal[[i]]
  origin.cluster <- colnames(scsr.results)[1]
  destination.cluster <- colnames(scsr.results)[2]
  df.scsr <- bind_rows(df.scsr, data.frame(ligand = scsr.results[ ,1],
                                           receptor =  scsr.results[ ,2],
                                           origin.cluster = origin.cluster,
                                           destination.cluster = destination.cluster,
                                           interaction.type = scsr.results$`interaction type`,
                                           LR.score = scsr.results$LRscore))
}

# prep scsr data
colnames(df.scsr) <- c("ligand", "receptor", "origin_cluster", "destination_cluster", "comm_type", "scrs.score")
df.scsr <- df.scsr %>% dplyr::arrange(-scrs.score)
df.scsr$origin_cluster <- paste0("c", as.numeric(gsub("cluster ", "", df.scsr$origin_cluster))-1)
df.scsr$destination_cluster <- paste0("c", as.numeric(gsub("cluster ", "", df.scsr$destination_cluster))-1)
df.scsr$ligand <- toupper(df.scsr$ligand)
df.scsr$receptor <- toupper(df.scsr$receptor)

# prep italk data
df.italk <- res.by_comm
colnames(df.italk) <- c("ligand", "receptor", "origin_exp", "origin_cluster", "destination_exp", "destination_cluster", "comm_type")
df.italk$italk.score <- df.italk$origin_exp * df.italk$destination_exp
df.italk <- df.italk %>% dplyr::arrange(-italk.score)
df.italk$ligand <- toupper(df.italk$ligand)
df.italk$receptor <- toupper(df.italk$receptor)

# merge datasets
df.merge.scores <- merge(df.scsr, df.italk, by = c("ligand", "receptor", "origin_cluster", "destination_cluster"))

# rank LR-pairs
df.merge.scores$scrs.rank <- rank(df.merge.scores$scrs.score)
df.merge.scores$italk.rank <- rank(df.merge.scores$italk.score)

# generate plots
plt.score <- df.merge.scores %>%
  ggplot(aes(x = italk.score, y = scrs.score)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = F) + 
  scMiko::theme_miko() + 
  labs(title = "LR Interaction Scores", subtitle = "Score comparison between methods") + 
  ylab("SCRS Score") + xlab("iTalk Score")

plt.rank <- df.merge.scores %>%
  ggplot(aes(x = italk.rank, y = scrs.rank)) + 
  geom_point() + 
  geom_smooth(method = "lm", se = F) + 
  scMiko::theme_miko() + 
  labs(title = "LR Interaction Scores", subtitle = "Rank comparison between methods") + 
  ylab("SCRS Rank") + xlab("iTalk Rank")
  
# combine plots
plt.method.comparisons <- cowplot::plot_grid(plt.score, plt.rank)

# visualize
print(plt.method.comparisons)

}



# flex.asDT(df.merge.scores)

```




```{r GSVA, warning = FALSE}

if (do.scsr){
  
  # get cluster averages (expression matrix) #####################################
  av.mat <- avgGroupExpression(
    so.query,
    which.data = "data",
    which.assay = DefaultAssay(so.query))
  rownames(av.mat) <- av.mat$genes
  av.mat <- av.mat %>% dplyr::select(-c("genes"))
  av.mat <- as.matrix(av.mat)
  
  # get gene list ################################################################
  LR.genes <- unique(c(df.merge.scores$ligand, df.merge.scores$receptor))
  
  if (which.species == "Mm"){
    LR.genes <- firstup(LR.genes)
  } else if (which.species == "Hs") {
    LR.genes <- toupper(LR.genes)
  }
  
  # get list of relevant pathways ################################################
  all.genes <- rownames(av.mat)
  
  # get symbol to entrez mapping
  my.symbol <- as.vector(all.genes)
  my.entrez <- sym2entrez(my.symbol, my.species = which.species )
  my.entrez <- my.entrez[complete.cases(my.entrez), ]
  
  match.ind.LR <- match(LR.genes, my.entrez$SYMBOL)
  LR.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind.LR]) 
  
  match.ind.all <- match(all.genes, my.entrez$SYMBOL)
  all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind.all]) 
  
  # get pathways
  pathways.LR <- getAnnotationPathways(LR.genes.entrez, db = "Bader", species = which.species)
  pathways.all <- getAnnotationPathways(all.genes.entrez, db = "Bader", species = which.species)
  pathway.subset <- pathways.all[names(pathways.all) %in% names(pathways.LR)]
  
  # get entrez to symbol mappings
  e2s <-  my.entrez$SYMBOL
  names(e2s) <-  my.entrez$ENTREZID
  
  # convert entrez to symbols
  for (j in 1:length(pathway.subset)){
    pathway.subset[[j]] <- e2s[pathway.subset[[j]]]
    pathway.subset[[j]] <- pathway.subset[[j]][!is.na(pathway.subset[[j]])]
  }
  
  # GSVA enrichment ##############################################################
  gsva.all <- GSVA::gsva(av.mat, pathway.subset)
  
  col.num <- as.numeric(gsub("c", "", colnames(gsva.all)))
  gsva.all <- gsva.all[, order(col.num)]
  
  # Harmonize GSVA and LR interactions ###########################################
  
  # TODO
  
  df.italk$LR.pair <- paste0(df.italk$ligand, "-", df.italk$receptor)
  u.sources <- unique(df.italk$origin_cluster)
  u.destinations <- unique(df.italk$destination_cluster)
  u.LR <- unique(df.italk$LR.pair)
  
  
  df.gsva.lr <- NULL
  for (i in 1:length(u.LR)){
    
    # get data for current LR pair
    current.df <- df.italk[df.italk$LR.pair %in% u.LR[i], ]
    
    # estimate receptor activity (integrate across all ligand inputs)
    current.df.sum <- current.df %>%
      group_by(destination_cluster) %>%
      summarize(r.activity = sum(italk.score))
    
    if (sum(current.df.sum$r.activity) == 0) next
    
    # reorder dataframe rows
    row.num <- as.numeric(gsub("c", "", current.df.sum$destination_cluster))
    current.df.sum <- current.df.sum[order(row.num), ]
    
    # filter for relevant pathways
    rel.genes <- strsplit(u.LR[i], "-")
    rel.genes2 <- c(rel.genes[[1]][1], rel.genes[[1]][2])
    
    if (which.species == "Mm"){
      rel.genes2 <- firstup(rel.genes2)
    } else if (which.species == "Hs") {
      rel.genes2 <- toupper(rel.genes2)
    }
    
    match.ind.rel <- match(rel.genes2, my.entrez$SYMBOL)
    rel.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind.rel]) 
    pathways.rel <- getAnnotationPathways(rel.genes.entrez, db = "Bader", species = which.species)
    gsva.rel <- gsva.all[rownames(gsva.all) %in% names(pathways.rel), ]
    
    # find correlation ebtween receptor activity and pathways
    gsva.cor <- cor(t(gsva.rel), current.df.sum$r.activity)
    
    # filter top paths
    # all.values <- gsva.cor[,1]
    # av.sd <- sd(all.values)
    # av.z <- all.values/av.sd
    which.sig <- gsva.cor[,1] > 0.8
    if (sum(which.sig) == 0) next
    which.paths <- rownames(gsva.cor)[which.sig]
    
    df.gsva.lr <- bind_rows(df.gsva.lr, data.frame(
      LR.pair = u.LR[i],
      ligand = rel.genes2[1],
      receptor = rel.genes2[2],
      pathways = which.paths,
      r = gsva.cor[which.sig, ]
    ))
    
  }
  
}

```



```{r Interaction SUMMARIES, warning = FALSE, message = FALSE}

# consolidate interaction scores ###############################################

# get cluster ids (ordered)
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# specify which communication types to consolidate
which.communication <- c("cytokine", "checkpoint", "growth factor", "other")

dot.res.list <- list()
for (k in 1:length(which.communication)){ # for each communication type...

# get LR interactions for current communcation type...
df.comm <- res.comm.list[[which.communication[k]]]

# compute interaction score
df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs

# initiate data frame (results will be stored here)
df.rollingThreshAll <- NULL
df.rollingThreshAll.IS <- NULL


for (i in 1:length(u.clust)){ # for each cluster...

  # get cluster names
  cluster.name <- paste0("c", u.clust[i])
  
  # filter LR interactions for current cluster
  df.comm.sub <- df.comm[df.comm$cell_from %in% cluster.name, ]
  
  # set expression thresholds
  int.min <- 0
  int.max <- max(df.comm$interaction.score)
  int.by <- (int.max - int.min)/30
  exp.thresh <- seq(int.min,int.max, int.by)
  
  # initiate data.frame objects to store results
  df.rollingThresh <- NULL
  df.rollingThreshIntScore <- NULL
  for (j in 1:length(exp.thresh)){
    df.tally <- NULL
    
    # specicy interaction-score filter
    filter1 <- df.comm.sub$interaction.score > exp.thresh[j]
    
    # filter data by interaction score
    df.comm.sub2 <- df.comm.sub[filter1, ]
    
    # tally number of recipient clusters
    df.tally <- data.frame(table(df.comm.sub2$cell_to))
    
    # get average interactio score for recipient clusters
    df.intscore <- df.comm.sub2 %>% dplyr::group_by(cell_to) %>% dplyr::summarize(int.score = mean(interaction.score))
    colnames(df.intscore) <- c("Var1", "int.score")
    
    # store results 
    if (nrow(df.tally) == 0){
      df.tally <- data.frame(Var1 = paste0("c", u.clust), Freq = 0)
       df.intscore <- data.frame(Var1 = paste0("c", u.clust), int.score = 0)
    } else if (nrow(df.tally) < length(u.clust)) {
      which.missing <- u.clust[!(paste0("c", u.clust) %in% df.tally$Var1)]
      df.tally <- bind_rows(df.tally, data.frame(Var1 =  paste0("c", which.missing), Freq = 0))
      df.intscore <- bind_rows(df.intscore, data.frame(Var1 =  paste0("c", which.missing), int.score = 0))
    }
    
    df.tally$threshold <- exp.thresh[j]
    df.intscore$threshold <- exp.thresh[j]
    
    df.rollingThresh <- bind_rows(df.rollingThresh,df.tally)
    df.rollingThreshIntScore <- bind_rows(df.rollingThreshIntScore,df.intscore)
  
  }
  
  df.rollingThresh$Source = paste0("c", u.clust[i])
  df.rollingThreshIntScore$Source = paste0("c", u.clust[i])
  
  df.rollingThreshAll <- bind_rows(df.rollingThreshAll, df.rollingThresh)
  df.rollingThreshAll.IS <- bind_rows(df.rollingThreshAll.IS, df.rollingThreshIntScore)
}


# VERSION 1: NUMBER OF INTERACTIONS
df.rollingThreshAllSum <- df.rollingThreshAll %>% 
  group_by(Var1, Source) %>% 
  summarize(Freq.sum = log1p(sum(Freq)))
df.rta.wide <- pivot_wider(df.rollingThreshAllSum, names_from = "Source", values_from = "Freq.sum")
rownames(df.rta.wide) <- df.rta.wide$Var1
df.rta.wide <- df.rta.wide %>% ungroup() %>% dplyr::select(-c("Var1"))
mat.rta.wide <- data.matrix(df.rta.wide)


# VERSION 2: INERACTION SCORES
df.rollingThreshAllISscore <- df.rollingThreshAll.IS %>% 
  group_by(Var1, Source) %>% 
  summarize(IS.sum = log1p(sum(int.score)))
df.rta.is.wide <- pivot_wider(df.rollingThreshAllISscore, names_from = "Source", values_from = "IS.sum")
rownames(df.rta.is.wide) <- df.rta.is.wide$Var1
df.rta.is.wide <- df.rta.is.wide %>% ungroup() %>% dplyr::select(-c("Var1"))
mat.rta.is.wide <- data.matrix(df.rta.is.wide)

# store results
dot.res.list[[which.communication[k]]] <- list(
  freq = df.rollingThreshAll,
  interaction = df.rollingThreshAll.IS
)
  
}

```

```{r LR dotplot, fig.width=8, fig.height=8, warning = FALSE, message = FALSE}

# Aggregate LR interaction ######################################################
# here we generate plots that summarize the LR interaction volumne between pairwise clusters. 

plt.agg.LR.list <- list()


for (i in 1:length(dot.res.list)){ # for each interaction type...
  
  # get communication name
  communication.name <- names(dot.res.list)[i]
  
  # merge datasets
  df.rollMerge <- merge(dot.res.list[[communication.name]][["freq"]], dot.res.list[[communication.name]][["interaction"]])
  
  # log transform interaction scores
  df.rollMerge$int.score <- log1p(df.rollMerge$int.score)
  
  # get frequency and interaction score summaries
  df.rollMerge.sum <- df.rollMerge %>%
    group_by(Var1, Source) %>%
    summarize(freq.mean = mean(Freq),
              is.mean = mean(int.score))
  
  # cast cluster membership as factors
  df.rollMerge.sum$Var1 <- factor(df.rollMerge.sum$Var1, levels = paste0("c", u.clusters))
  df.rollMerge.sum$Source <- factor(df.rollMerge.sum$Source, levels = paste0("c", u.clusters))
  
  # generate dot plot for LR interactions
  p <- df.rollMerge.sum %>%
    ggplot(aes(x = Var1, y = Source, size = freq.mean, fill = is.mean )) +
    geom_point(pch=21, color = "black")  +
    xlab("Recipient") + ylab("Source") + theme(legend.position="bottom") + 
    viridis::scale_fill_viridis("Interaction (log)") + coord_flip()
  
  # get legend object
  p.legend <- cowplot::get_legend(p)
  
  # clear legend from plot
  p <- p+ theme(legend.position="none")
  
  # generate marginal barplots (average LR interactions)
  p1 <- df.rollMerge.sum %>%
    group_by(Var1) %>%
    summarize(is.sum = mean(is.mean, na.rm = T),
              is.se = sd(is.mean, na.rm = T)/ sqrt(length(is.mean))) %>%
    ggplot(aes(x = Var1, y = is.sum)) +
    geom_bar(stat = "identity") + xlab("") + ylab("Score") +
    geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                  position=position_dodge(.9)) + 
    coord_flip() + 
    geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")
  
  p2 <- df.rollMerge.sum %>%
    group_by(Source) %>%
    summarize(is.sum = mean(is.mean, na.rm = T),
              is.se = sd(is.mean, na.rm = T) / sqrt(length(is.mean))) %>%
    ggplot(aes(x = Source, y = is.sum)) +
    geom_bar(stat = "identity") + 
    geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                  position=position_dodge(.9)) + 
    xlab("") + ylab("Score") + 
    geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")
  
  # combine plots 
  p.merge <- cowplot::plot_grid(p2, NULL, p, p1 ,rel_widths = c(3,1), rel_heights = c(1,3), align = c("hv"))
  
  # add titles to plots
  p.title <- ggplot() + labs(title = communication.name, subtitle = "marginal plots show mean interaction +/- se")
  p.merge.final <- cowplot::plot_grid(p.title, p.merge, p.legend, ncol = 1, rel_heights = c(0.5,5,1))
  
  # print plot (if print.inline TRUE)
  if (print.inline) print(p.merge.final)
  
  # store plot
  plt.agg.LR.list[[communication.name]] <- p.merge.final
  
}

```


```{r cluster differentials, warning = FALSE, message = FALSE}

# get expression  matrix
ef.mat <- (so.query@assays[[DefaultAssay(so.query)]]@data)
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# initiate empty matrices
f.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust))

# get cluster-level aggregate scores
for (i in 1:length(u.clust)){
  which.cells <- sc.meta %in% u.clust[i]
  
  n.cells.current <- sum(which.cells)
  
  gene.detected <- as.matrix(ef.mat[, which.cells] > 0)
  # expressing fraction
  if (n.cells.current == 1){
    f1 <- 1*(gene.detected)
  } else {
    f1 <- rowMeans(gene.detected)
  }
  
  f.mat[ ,i] <- f1
}

rm(f1); invisible({gc()})

# assign col and row names
colnames(f.mat) <-   u.clust
rownames(f.mat) <-   rownames(ef.mat)

# cast to data.frame
df.f.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(f.mat)); colnames(df.f.wide) <- c("gene", u.clust)

# wide to long
df.f.long <- pivot_longer(df.f.wide, colnames(df.f.wide)[2:ncol(df.f.wide)])

# assign col names to long dataframe
colnames(df.f.long) <- c("gene", "cluster", "value")

# ensure clusters are ordered factors
df.f.long$cluster <- factor(df.f.long$cluster, levels = u.clust)

# clear baggage
rm(ef.mat); invisible({gc()})

```

```{r, fig.width = 15, fig.height=5, warning = FALSE, message = FALSE, include = FALSE}

# get cluster-labeled UMAP plot
plt.umap <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() +   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))

plt.granular.list <- list()
plt.top.int <- list()

for (k in 1:length(which.communication)){
  
  # get LR interaction
  df.comm <- res.comm.list[[which.communication[k]]]
  df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs
  
  # LR name
  df.comm$LR <- paste0(df.comm$ligand, " -> ", df.comm$receptor)
  
  # cast clusters as factors
  df.comm$cell_to <- gsub("c", "", df.comm$cell_to)
  df.comm$cell_to <- factor(df.comm$cell_to, levels = paste0(u.clust))
  df.comm$cell_from <- gsub("c", "", df.comm$cell_from)
  df.comm$cell_from <- factor(df.comm$cell_from, levels = paste0(u.clust))
  
  # clone
  df.comm.all <- df.comm
  
  # expression fraction merge
  df.f.ligand <- df.f.long
  df.f.ligand$cluster <- paste0(df.f.ligand$cluster)
  df.f.ligand$gene <- toupper(df.f.ligand$gene)
  colnames(df.f.ligand) <- c("ligand", "cell_from", "source.fraction")
  df.comm <- merge(df.comm, df.f.ligand)
  
  df.f.receptor <- df.f.ligand
  colnames(df.f.receptor) <- c("receptor", "cell_to", "target.fraction")
  df.comm <- merge(df.comm, df.f.receptor)
  
  # filter top interactions
  filter1 <- df.comm$interaction.score > 0
  df.comm <- df.comm[filter1, ]
  if (nrow(df.comm) == 0) next
  
  df.comm <- df.comm %>% dplyr::arrange(-interaction.score)
  
  u.lr.cur <- 0
  iter.n <- 0
  u.lr.top <- NULL; df.comm.top <- NULL
  n.top.int <- 20
  while((u.lr.cur < 20) & ((iter.n + n.top.int) < nrow(df.comm))){
    df.comm.top <- df.comm %>% dplyr::top_n(n.top.int+iter.n, interaction.score)
    u.lr.top <- unique(df.comm.top$LR)
    u.lr.cur <- length(u.lr.top)
    if (u.lr.cur >= n.top.int){
      break
    } else {
      iter.n <- iter.n + 1
    }
  }
  
  if (is.null(df.comm.top) || (nrow(df.comm.top) == 0)) next
  df.comm <- df.comm.top; rm(df.comm.top)
  
  if (nrow(df.comm) == 0) {
    plt.granular.list[[which.communication[k]]] <- NULL
    next
  }
  
  u.lr.all <- unique(df.comm.all$LR)
  u.lr.filt <- unique(df.comm$LR)
  
  which.keep <- (df.comm.all$LR) %in% u.lr.filt
  df.comm.sub <- df.comm.all[which.keep, ]
  
  plt.gran.ind.list <- list()
  
  for (i in 1:u.lr.cur){

    ligand.name <- sub(" .*", "", u.lr.filt[i])
    receptor.name <- stringr::str_replace(u.lr.filt[i], "[A-Za-z0-9]*\ ->\ ", "")
    
    if (which.species == "Mm"){
      ligand.name <- firstup(ligand.name)
      receptor.name <- firstup(receptor.name)
    } else if (which.species == "Hs"){
      ligand.name <- toupper(ligand.name)
      receptor.name <- toupper(receptor.name)      
    }
    
    # LR-level dot plot
    plt.grain.dot <- df.comm.sub %>%
      dplyr::filter(LR %in% u.lr.filt[i]) %>%
      dplyr::group_by(LR) %>%
      ggplot(aes(x = cell_from, y = cell_to, fill = interaction.score, size = interaction.score)) + 
      geom_point() +
      geom_point(pch=21, color = "black")  +
      xlab("Source Cluster") + ylab("Recipient Cluster") + 
      viridis::scale_fill_viridis("Interaction.Score") + 
      facet_wrap(~LR) + 
      theme(plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # LIGAND UMAP
    plt.lig <- scExpression.UMAP(
      so.query,
      ligand.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = ligand.name, subtitle = "Ligand (Source)") + 
        theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # RECEPTOR UMAP
    plt.rec <- scExpression.UMAP(
      so.query,
      receptor.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = receptor.name, subtitle = "Receptor (Recipient)")  + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
      theme(axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank(),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # EXPRESSION DOTPLOT
    lr.feature <- c(ligand.name,receptor.name )
    names(lr.feature) <- c("L", "R")
    plt.dot.exp <- DotPlot(
      so.query,
      assay = NULL,
      features = lr.feature,
      cols = c("lightgrey", "tomato"),
      col.min = -2.5,
      col.max = 2.5,
      dot.min = 0,
      dot.scale = 6,
      scale = T,
      scale.by = "radius") + 
      xlab("Genes") + ylab("Cluster") + 
        theme(axis.title.x=element_blank(),
              legend.title = element_text(size = 5),
              legend.text = element_text(size = 5),
            plot.title = element_text(hjust = 0.5),
            plot.subtitle = element_text(hjust = 0.5))
    
    # COMBINE LIGAND-RECEPTOR UMAPS
    plt.umap.exp <- cowplot::plot_grid(plt.lig, plt.rec, ncol = 1, align = "hv")
    
    # COMBINE REMAINDING PLOTS
    plt.gran <- cowplot::plot_grid(plt.umap, plt.umap.exp, plt.dot.exp, 
                                   plt.grain.dot, ncol = 4, align = "hv", rel_widths = c(1,0.7,0.7, 1.5), labels = "AUTO")
    
    if (print.inline) {
      print(plt.gran)
    }
    
    plt.gran.ind.list[[u.lr.filt[i]]] <- plt.gran
  }
  
  plt.granular.list[[which.communication[k]]] <- plt.gran.ind.list

  # top interactions
  df.comm.u <- unique(df.comm[ ,c("LR", "cell_from")])
  df.lig <- data.frame(table(df.comm.u$LR))
  
  plt.lig.profile <- df.lig %>%
    top_n(20, Freq) %>%
    ggplot(aes(x = reorder(Var1, Freq), y = Freq)) + 
    geom_bar(stat = "identity") + 
    coord_flip() + 
    ylab("N sources with paired target") + 
    xlab("Ligand") + 
    labs(title = "LR Pair Activity", subtitle = which.communication[k]) + 
    theme_miko()
  
  plt.top.int[[which.communication[k]]] <- plt.lig.profile
  
  if (print.inline) print(plt.lig.profile)
}

plt.gran

```



```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M12", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M12_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```

```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


UMAP
===================================== 

```{r ph1,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

plt.umap.final <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() 

print(plt.umap.final)

savePDF(file.name = paste0(output.path, "PDF/", "M12_UMAP.pdf"), plot.handle = plt.umap.final, 
        fig.width = 5, fig.height = 5, save.flag = save.pdf)

```

LR Descriptives
===================================== 

Row {.tabset}
-------------------------------------

```{r lr desc,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.agg.LR.list), function(i) {
  
  s1 <- names(plt.agg.LR.list)[i]
  s2 <- paste0("plt.agg.LR.list[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=10, fig.height=10, message=FALSE, warning=FALSE}", paste("lr_sum", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`


```{r lr desc save,include = FALSE}

for (i in 1:length(plt.agg.LR.list)){
  plot.name <- paste0("M12_LR_summary_", names(plt.agg.LR.list)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.agg.LR.list[[i]], 
          fig.width = 10, fig.height = 10, save.flag = save.pdf)
}

```

Top LR Pairs
===================================== 

Row {.tabset}
-------------------------------------

```{r top lr,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.top.int), function(i) {
  
  s1 <- names(plt.top.int)[i]
  s2 <- paste0("plt.top.int[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=8, fig.height=8, message=FALSE, warning=FALSE}", paste("lr_top", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`

```{r top lr save,include = FALSE}

for (i in 1:length(plt.top.int)){
  plot.name <- paste0("M12_top_LR_pairs_", names(plt.top.int)[i] ,".pdf")
  savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
          plot.handle =  plt.top.int[[i]], 
          fig.width = 5, fig.height = 7, save.flag = save.pdf)
}

```

LR Interactions
===================================== 

Row {.tabset}
-------------------------------------

```{r ph4,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out2 <- tryCatch({
    out2 <- lapply(seq_along(res.comm.list2), function(j) {

    clust_a <- as.vector(res.comm.list2[[j]][["cell_from"]])
    clust_b <- as.vector(res.comm.list2[[j]][["cell_to"]])
    clust_all <- as.vector(unique(c(clust_a, clust_b)))
    
    # specify cell colors
    comm.type <- names(res.comm.list2)[j]
    my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(clust_all))
    cell_col <-my.cols

    # LR plot
    s1 <- sprintf("LRPlot( res.comm.list2[[%d]], 
    datatype='mean count', 
    link.arr.lwd= res.comm.list2[[%d]]$cell_from_mean_exprs, 
    link.arr.width= res.comm.list2[[%d]]$cell_to_mean_exprs)",j, j, j)

    s2 <- comm.type

    b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", comm.type)) # tab header
    b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=10, fig.height=10, message=FALSE, warning=FALSE}", 
                                            paste("chunk", j, sep = ""))) 
    b3 <- knitr::knit_expand(text = sprintf("\n %s",s1)) 
    b5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    out2 <- paste(b1, b2, b3, b5, collapse = '\n')
    return(out2) 
    
  })
}, error= function(e){
  print(e)
  out2 <- NULL
  return(out2)
})



```

`r try({paste(knitr::knit(text = paste(out2, collapse = '\n')))}, silent = T)`

```{r ph4 save,include = FALSE}

try({
  for (i in 1:length(res.comm.list2)){
    plot.name <- paste0("M12_LR_interaction_circle_", names(res.comm.list2)[i] ,".pdf")
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle =  LRPlot( res.comm.list2[[i]], 
                                   datatype='mean count', 
                                   link.arr.lwd= res.comm.list2[[i]]$cell_from_mean_exprs, 
                                   link.arr.width= res.comm.list2[[i]]$cell_to_mean_exprs), 
            fig.width = 10, fig.height = 10, save.flag = save.pdf)
  } 
}, silent = T)


```


1| Cytokines
===================================== 

Row {.tabset}
-------------------------------------

```{r pp1}

 plt.cur <-  plt.granular.list[["cytokine"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
  out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 18, fig.height=7, message=FALSE, warning=FALSE}", paste("p1", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp1 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_cytokines_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 18, fig.height=7, save.flag = save.pdf)
  } 
}, silent = T)


```

2| Checkpoint
===================================== 

Row {.tabset}
-------------------------------------

```{r pp2}

 plt.cur <-  plt.granular.list[["checkpoint"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 18, fig.height=7, message=FALSE, warning=FALSE}", paste("p2", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp2 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_checkpoint_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 18, fig.height=7, save.flag = save.pdf)
  } 
}, silent = T)


```


3| Growth Factors
===================================== 

Row {.tabset}
-------------------------------------

```{r pp3}

 plt.cur <-  plt.granular.list[["growth factor"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 18, fig.height=7, message=FALSE, warning=FALSE}", paste("p3", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp3 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_growthfactor_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 18, fig.height=7, save.flag = save.pdf)
  } 
}, silent = T)


```

4| Other
===================================== 

Row {.tabset}
-------------------------------------

```{r pp4}

 plt.cur <-  plt.granular.list[["other"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 18, fig.height=7, message=FALSE, warning=FALSE}", paste("p4", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r pp4 save,include = FALSE}

try({
  for (i in 1:length(plt.cur)){
    plot.name <- paste0("M12_LR_dotplot_other_", names(plt.cur)[i] ,".pdf")
    plot.name <- gsub(" -> ", "-", plot.name)
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.cur[[i]], 
            fig.width = 18, fig.height=7, save.flag = save.pdf)
  } 
}, silent = T)


```


LR Table
===================================== 

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

try({
  df.comm.output <- res.comm.list[["pooled"]]
  df.comm.output$interaction.score <- signif(df.comm.output$cell_from_mean_exprs * df.comm.output$cell_to_mean_exprs, 3)
  df.comm.output <- df.comm.output %>% dplyr::filter(interaction.score > 0.1)
  
  datatable(df.comm.output, 
            filter = 'top',
            extensions = 'Buttons',
            options = list(pageLength = 50,
                           dom = 'Bfrtip', 
                           buttons = c('copy', 'csv', 'pdf')))
  
  write.csv(df.comm.output, file = paste0(output.path, "Tables/", "LR_table.csv"), 
            row.names = F) 
}, silent = T)


```

```{r analysis log final}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)

df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")
df.log <- addLogEntry("Run Identifier", run.id, df.log, "run.id")
df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")

df.log_Module_12 <- df.log

```


```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 12)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_12)

```


```{r save analysis log as csv}

try({
  write.csv(df.log_Module_12, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```

```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    pdf.list <- pdf.list[validUTF8(pdf.list)]
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}

```