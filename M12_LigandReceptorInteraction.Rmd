---
title: "Module12_ligand_receptor_interactions"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", 
                   "plyr", "dplyr", "tidyr", "reshape2", "arrangements", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", "cowplot", "iTALK")

# load packages
lapply(packages2load, library, character.only = TRUE)
```


```{r specify parameters}

# TODO
# mean for ligand, median for receptor (rationale is that ligands do not depend on cell type, receptors do)

# query input
input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module1_pilot4_GL261_CT2A.Rdata"
# input.file <- "Module1_Suva2019.Rdata"

which.species <- "Mm"
cluster.resolution = 0.15

print.inline <- F

which.data <- "data" # options: data, scale

data.type  <- "mean count" # options: mean count, DEG

top.N.genes <- 50 # Nth percentile expression

# compare cell types
pairwise.comparison.flag <- F
cell_type_a <- "c12"
cell_type_b <- "c4"

# downsampling
subsample_factor <- 1

# subset
subset.df <- "no.subset"

# top n genes for LR network
 top.N.genes <- 500

# subset data
cell_barcode.filter.flag <- F
# cell_barcode.filter.list <- list(adult = c("MGH1","MGH66"),
                                 # pediatric = c("BT", "MGH85"))# subset according to cell names 
#Suva2019: 
# adult GBM: MGH1* & MGH66
# pedaetric GBM: BT & MGH85

group_barcode.filter.flag <- F
# group_barcode.filter.list <- list(GL261 = c("GL261"),
                                  # CT2A = c("CT2A"))

# communication type
communication.type <- c("growth factor", "other", 'cytokine','checkpoint')
# communication.type <-  "checkpoint" # options: cytokine, checkpoint, growth factor, other

aggregation.method <- "mean" # options: mean, median
n.LRpairs <- 20
```


```{r}
if (pairwise.comparison.flag){
  stopifnot(exists("cell_type_a") & exists("cell_type_b"))
}
```



```{r analysis log}

# Module
df.log <- initiateLog("12, Ligand-Receptor Interactions")



df.log <- addLogEntry("Input File (.Rdata)", input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster Resolution", cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Species", which.species, df.log, "which.species")
df.log <- addLogEntry("Data Type", data.type, df.log, "data.type")
df.log <- addLogEntry("Data Slot", which.data, df.log, "which.data")
df.log <- addLogEntry("Communication Type", communication.type, df.log, "communication.type")
df.log <- addLogEntry("Top N pairs shown", n.LRpairs, df.log, "n.LRpairs")
if (is.character(subset.df))  df.log <- addLogEntry("Subset", subset.df, df.log, "subset.df")
df.log <- addLogEntry("Downsample Factor", subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("Aggregation Method", aggregation.method, df.log, "aggregation.method")
df.log <- addLogEntry("cell-cell comparison flag", pairwise.comparison.flag, df.log, "pairwise.comparison.flag")

if (pairwise.comparison.flag){
df.log <- addLogEntry("Cell Type A", cell_type_a, df.log, "cell_type_a")
df.log <- addLogEntry("Cell Type B", cell_type_b, df.log, "cell_type_b")
}

```




```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"
dir.reference <- "Reference_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}
if (!exists("input.file")) stop("input.file is not specified")

# load query dataset
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

if (!exists("gNames.list")) gNames.list <- prepGeneList(so.query, objects())

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset.data = subset.df, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "corr", "gsva", "deg", "counts"))


# unpack results
rm(so)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})

```


```{r get prior module logs}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r subset data}
# get Seurat subset for cells of interest
so.list_1 <- list()
if (cell_barcode.filter.flag == TRUE){
  for (i  in 1:length(cell_barcode.filter.list)){
    grp.name <- names(cell_barcode.filter.list)[i]
    pattern <- paste(cell_barcode.filter.list[[i]], collapse="|")
    so.list_1[[grp.name]] <- SubsetData(object = so.query, cells = (grepl(pattern, colnames(so.query@assays[[current.assay]]@scale.data)))) 
  }
} else {so.list_1 <- NULL}


# get Seurat subset for groups of interest
so.list_2 <- list()
if (group_barcode.filter.flag == TRUE){
  for (i  in 1:length(group_barcode.filter.list)){
    grp.name_2 <- names(group_barcode.filter.list)[i]
    if (!is.null(so.list_1)){
      for (j in 1:length(so.list_1)){
        grp.name_1 <- names(so.list_1)[j]
        grp.name <- paste(grp.name_1, "_", grp.name_2, sep = "")
        pattern <- paste(group_barcode.filter.list[[i]], collapse="|")
        so.list_2[[grp.name]] <- SubsetData(object = so.list_1[[j]], 
                                            cells = (grepl(pattern, so.list_1[[j]]@meta.data[["Barcode"]])))  
      }
    } else {
      grp.name <- grp.name_2
        pattern <- paste(group_barcode.filter.list[[i]], collapse="|")
      so.list_2[[grp.name]] <- SubsetData(object = so.query, cells = (grepl(pattern, so.query@meta.data[["Barcode"]])))  
    }
  }
} else {so.list_2 <- NULL}

# assign so subsets to correct list
if (is.null(so.list_1) & is.null(so.list_2)){
  so.list <- list(so.query)
  names(so.list) <- input.file
} else if (is.null(so.list_1) & !is.null(so.list_2)){
  so.list <- so.list_2
} else if (!is.null(so.list_1) & is.null(so.list_2)){
  so.list <- so.list_1
} else if (!is.null(so.list_1) & !is.null(so.list_2)){
  so.list <- so.list_2
}

```


```{r uMAP}

plt.umap.list <- list()

for (i in 1:length(so.list)){
  grp.name <- names(so.list)[i]
  # cluster.field <- paste(DefaultAssay(so.list[[grp.name]]), "_snn_res.", cluster.resolution, sep = "")
  cluster.field <- "seurat_clusters"
  
  plt.umap.list[[grp.name]] <- DimPlot(so.list[[grp.name]], reduction = "umap", 
                                       label = T, 
                                       group.by = cluster.field)  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    ggtitle(grp.name)
  if (print.inline){print(plt.umap.list[[grp.name]])}
}


```


```{r  function to specify signature gene sets}
# convert human symbols to mouse symbols

gene2species <- function(x, expected_species){
  if (expected_species == "Hs"){
    x <- toupper(x)
  } else if (expected_species == "Mm"){
    x <- tolower(x)
    substr(x, 1, 1) <- toupper(substr(x, 1, 1))

  }
  return(x)
}
```



```{r define prep data function}


prep.data <- function(so, cluster.field, gNames.list, data.slot){
  
  current.assay <- DefaultAssay(so)
  # initiate dataframe
  # df.mean_exp <- data.frame()
  
  # get unique clusters
  u.clusters <- as.numeric(as.character(unique(so@meta.data[[cluster.field]])))
  u.clusters <- u.clusters[order(u.clusters)]
  
  # get normalizated expression matrix
  if (data.slot == "data"){
    exp.mat <- as.matrix(so@assays[[current.assay]]@data)
  } else if (data.slot == "scale"){
    exp.mat <- so@assays[[current.assay]]@scale.data 
  }
  
  exp.df_t <- as.data.frame(t(exp.mat))
  
  # prepare data
  cur.genes <- colnames(exp.df_t)
  # gene.rep <- checkGeneRep(cur_gene.list = gNames.list, cur_rep = cur.genes)
  # if (gene.rep == "ensembl"){
  #   cur.genes <-  as.vector(gNames.list[cur.genes])
  # }
  # stopifnot(checkGeneRep(cur_gene.list = gNames.list, cur_rep = cur.genes) == "symbol")
  
  # exp.df_t <- as.data.frame(t(exp.mat))
  rownames(exp.mat) <- gene2species(rownames(exp.mat) , expected_species = "Hs")
  colnames(exp.df_t) <- gene2species(cur.genes, expected_species = "Hs")
  exp.df_t$cell_type <- paste("c", as.vector(so@meta.data[[cluster.field]]), sep = "")
  
  
  
  output <- list(u.clusters, exp.mat, exp.df_t)
  return(output)
  
}

# initiate lists
u.clusters.list <- list()
exp.mat.list <- list()
exp.df_t.list <- list()

for (i in 1:length(so.list)){
  grp.name <- names(so.list)[i]
  
  # cluster.field <- paste(DefaultAssay(so.list[[grp.name]]), "_snn_res.", cluster.resolution, sep = "")
  cluster.field <- "seurat_clusters"
  prep.output <- prep.data(so.list[[grp.name]], cluster.field, gNames.list, which.data)
  
  u.clusters.list[[grp.name]] <- prep.output[[1]]
  exp.mat.list[[grp.name]] <- prep.output[[2]]
  exp.df_t.list[[grp.name]] <- prep.output[[3]]
}


```


```{r analysis function}

analyze_LG.pairs <- function(u.clusters, exp.df_t, communication.type, high.exp_genes = NULL, aggregation.method = "mean", top.N.genes = 50, n.LRpairs = 20){

  
  # get top nth percentile 
  if (is.null(high.exp_genes)){
    high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  }
  
  res_cat<-FindLR(high.exp_genes, datatype='mean count', comm_type=communication.type)
  
  # sort by product of ligand*receptor expression
  res_cat<-res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs,decreasing=T),]
  
  
  # output <- list(high.exp_genes, res_cat)
  return(res_cat)
}

```



```{r ligand-receptor pairs from highly expressed genes, fig.height= 10, fig.width= 10}

# initiate lists
res.LR.list <- list()
res.LR.list2 <- list()


for (i in 1:length(so.list)){
  
  # initiate lists
  res.comm.list <- list()
  res.comm.list2 <- list()
  
  # get data name
  grp.name <- names(so.list)[i]
  
  # get data
  so <- so.list[[grp.name]]
  exp.df_t <- exp.df_t.list[[grp.name]]
  u.clusters <- u.clusters.list[[grp.name]]
  
  # get highly expressed genes
 
  high.exp_genes <-rawParse(exp.df_t,top_genes=top.N.genes,stats=aggregation.method)
  
  # inititate data.frames
  res.by_comm <- NULL
  res.by_comm2 <- NULL
  for (j in 1:length(communication.type)){
    comm.type <- communication.type[j]
    
    # run ligand receptor interaction analysis 
    res.comm.list[[comm.type]] <- analyze_LG.pairs(u.clusters = u.clusters, 
                                                   exp.df_t = exp.df_t, 
                                                   communication.type = comm.type,
                                                   high.exp_genes = high.exp_genes, 
                                                   aggregation.method = aggregation.method, 
                                                   top.N.genes = top.N.genes, 
                                                   n.LRpairs = n.LRpairs)
    
    
    res.comm.list[[comm.type]]$cell_from_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_from_mean_exprs, 3)
    res.comm.list[[comm.type]]$cell_to_mean_exprs <- signif(res.comm.list[[comm.type]]$cell_to_mean_exprs, 3)
    
    # a <- res.comm.list[[comm.type]]
    res.by_comm<-rbind(res.by_comm,res.comm.list[[comm.type]])
    
    # subset data to include top n.LRpairs
      top.data <- res.comm.list[[comm.type]][1:n.LRpairs,]
      top.data <- top.data[complete.cases(top.data), ]
      res.comm.list2[[comm.type]] <- top.data
      res.by_comm2 <- rbind(res.by_comm2, res.comm.list2[[comm.type]] ) # for output plots
    
    if (print.inline){
      # specify cell colors
      my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(u.clusters))
      cell_col<-structure(my.cols,names=unique(exp.df_t$cell_type ))
      
      # LR interaction plot
      LRPlot( top.data,
              datatype='mean count',
              cell_col=cell_col,
              link.arr.lwd= top.data$cell_from_mean_exprs,
              link.arr.width= top.data$cell_to_mean_exprs)
      title(paste(grp.name, ": ", comm.type, sep = ""))
      
      # NetView(res.comm.list[[comm.type]][1:n.LRpairs,],col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
    }
  }
  
  # store results
  res.comm.list[["pooled"]] <- res.by_comm
  res.comm.list2[["pooled"]] <- res.by_comm2
  
  res.LR.list[[grp.name]] <- res.comm.list
  res.LR.list2[[grp.name]] <- res.comm.list2
}


# # show top N LR pairs (overall; for each communication type)
# resA.overall<-resA.by_comm[order(resA.by_comm$cell_from_mean_exprs*resA.by_comm$cell_to_mean_exprs,decreasing=T),][1:n.LRpairs,]
# 
# if (print.inline){
#   # network plot
#   a <- NetView(resA.overall,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
# 
#   # LR pairs
#   b <- LRPlot(resA.overall[1:n.LRpairs,],
#          datatype='mean count',
#          cell_col=cell_col,
#          link.arr.lwd=resA.overall$cell_from_mean_exprs[1:n.LRpairs],
#          link.arr.width=resA.overall$cell_to_mean_exprs[1:n.LRpairs])
#   title("Top Interactions")
# }

```
```{r Interaction SUMMARIES, warning = FALSE, message = FALSE}

u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)


# options: #cytokine, checkpoint, growth factor, pooled, other

dot.res.list <- list()
which.communication <- c("cytokine", "checkpoint", "growth factor", "other", "pooled")

for (k in 1:length(which.communication)){

which.threshold <- 0

df.comm <- res.comm.list[[which.communication[k]]]
df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs

df.rollingThreshAll <- NULL
df.rollingThreshAll.IS <- NULL


for (i in 1:length(u.clust)){

  cluster.name <- paste0("c", u.clust[i])
  df.comm.sub <- df.comm[df.comm$cell_from %in% cluster.name, ]
  
  # expression threshold
  int.min <- 0
  int.max <- max(df.comm$interaction.score)
  int.by <- (int.max - int.min)/50
  exp.thresh <- seq(int.min,int.max, int.by)
  
  df.rollingThresh <- NULL
  df.rollingThreshIntScore <- NULL
  for (j in 1:length(exp.thresh)){
    df.tally <- NULL
    filter1 <- df.comm.sub$interaction.score > exp.thresh[j]
    # filter2 <- df.comm.sub$cell_to_mean_exprs > exp.thresh[j]
    df.comm.sub2 <- df.comm.sub[filter1, ]
    
    
    df.tally <- data.frame(table(df.comm.sub2$cell_to))
    df.intscore <- df.comm.sub2 %>% group_by(cell_to) %>% summarize(int.score = mean(interaction.score))
    colnames(df.intscore) <- c("Var1", "int.score")
    
    if (nrow(df.tally) == 0){
      df.tally <- data.frame(Var1 = paste0("c", u.clust), Freq = 0)
       df.intscore <- data.frame(Var1 = paste0("c", u.clust), int.score = 0)
    } else if (nrow(df.tally) < length(u.clust)) {
      which.missing <- u.clust[!(paste0("c", u.clust) %in% df.tally$Var1)]
      df.tally <- bind_rows(df.tally, data.frame(Var1 =  paste0("c", which.missing), Freq = 0))
      df.intscore <- bind_rows(df.intscore, data.frame(Var1 =  paste0("c", which.missing), int.score = 0))
    }
    
    df.tally$threshold <- exp.thresh[j]
    df.intscore$threshold <- exp.thresh[j]
    
    df.rollingThresh <- bind_rows(df.rollingThresh,df.tally)
    df.rollingThreshIntScore <- bind_rows(df.rollingThreshIntScore,df.intscore)
  
  }
  
  df.rollingThresh$Source = paste0("c", u.clust[i])
  df.rollingThreshIntScore$Source = paste0("c", u.clust[i])
  
  df.rollingThreshAll <- bind_rows(df.rollingThreshAll, df.rollingThresh)
  df.rollingThreshAll.IS <- bind_rows(df.rollingThreshAll.IS, df.rollingThreshIntScore)
  
  # df.rollingThresh <- df.rollingThresh %>% group_by(Var1) %>% arrange(threshold)
  
 # plt.rollingThresh <- df.rollingThresh %>%
 #    ggplot(aes(x= threshold, y = log1p(Freq), color = (Var1))) + 
 #    geom_point() + 
 #    geom_path(aes(group = Var1)) +
 #    theme_miko(legend = T) + 
 #   labs(title = paste0("Source Cluster: ", u.clust[i]), subtitle = which.communication)+
 #   scale_color_discrete("Destination\nCluster") + 
 #   xlab("Interaction Score") + ylab("N Interactions (log2)")
 
 # if(print.inline) print(plt.rollingThresh)
  
}


# VERSION 1: NUMBER OF INTERACTIONS
df.rollingThreshAllSum <- df.rollingThreshAll %>% group_by(Var1, Source) %>% summarize(Freq.sum = log1p(sum(Freq)))

df.rta.wide <- pivot_wider(df.rollingThreshAllSum, names_from = "Source", values_from = "Freq.sum")
rownames(df.rta.wide) <- df.rta.wide$Var1
df.rta.wide <- df.rta.wide %>% ungroup() %>% dplyr::select(-c("Var1"))

mat.rta.wide <- data.matrix(df.rta.wide)
# pheatmap::pheatmap(mat.rta.wide, cluster_rows = T, cluster_cols = T, main = paste0(which.communication[k], " N interactions\nx=Source, y=Destination"), color = viridis::viridis(20))

# VERSION 2: INERACTION SCORES
df.rollingThreshAllISscore <- df.rollingThreshAll.IS %>% group_by(Var1, Source) %>% summarize(IS.sum = log1p(sum(int.score)))

df.rta.is.wide <- pivot_wider(df.rollingThreshAllISscore, names_from = "Source", values_from = "IS.sum")
rownames(df.rta.is.wide) <- df.rta.is.wide$Var1
df.rta.is.wide <- df.rta.is.wide %>% ungroup() %>% dplyr::select(-c("Var1"))

mat.rta.is.wide <- data.matrix(df.rta.is.wide)
# pheatmap::pheatmap(mat.rta.is.wide, cluster_rows = T, cluster_cols = T, main = paste0(which.communication[k], " Interaction Score\nx=Source, y=Destination"), color = viridis::viridis(20))

# store results

dot.res.list[[which.communication[k]]] <- list(
  freq = df.rollingThreshAll,
  interaction = df.rollingThreshAll.IS
)
  
}

```

```{r LR dotplot, fig.width=8, fig.height=8, warning = FALSE, message = FALSE}


plt.agg.LR.list <- list()

for (i in 1:length(dot.res.list)){
  
communication.name <- names(dot.res.list)[i]
df.rollMerge <- merge(dot.res.list[[communication.name]][["freq"]], dot.res.list[[communication.name]][["interaction"]])

df.rollMerge$int.score <- log1p(df.rollMerge$int.score)

df.rollMerge.sum <- df.rollMerge %>%
  group_by(Var1, Source) %>%
  summarize(freq.mean = mean(Freq),
            is.mean = mean(int.score))

df.rollMerge.sum$Var1 <- factor(df.rollMerge.sum$Var1, levels = paste0("c", u.clusters))
df.rollMerge.sum$Source <- factor(df.rollMerge.sum$Source, levels = paste0("c", u.clusters))

p <- df.rollMerge.sum %>%
  ggplot(aes(x = Var1, y = Source, size = freq.mean, fill = is.mean )) +
  geom_point(pch=21, color = "black")  +
  xlab("Recipient") + ylab("Source") + theme(legend.position="bottom") + 
  viridis::scale_fill_viridis("Interaction (log)") + coord_flip()

p.legend <- cowplot::get_legend(p)

p <- p+ theme(legend.position="none")

p1 <- df.rollMerge.sum %>%
  group_by(Var1) %>%
  summarize(is.sum = mean(is.mean, na.rm = T),
            is.se = sd(is.mean, na.rm = T)/ sqrt(length(is.mean))) %>%
  ggplot(aes(x = Var1, y = is.sum)) +
  geom_bar(stat = "identity") + xlab("") + ylab("Score") +
  geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                 position=position_dodge(.9)) + 
  coord_flip() + 
  geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")

p2 <- df.rollMerge.sum %>%
  group_by(Source) %>%
  summarize(is.sum = mean(is.mean, na.rm = T),
            is.se = sd(is.mean, na.rm = T) / sqrt(length(is.mean))) %>%
  ggplot(aes(x = Source, y = is.sum)) +
  geom_bar(stat = "identity") + 
    geom_errorbar(aes(ymin=is.sum-is.se, ymax=is.sum+is.se), width=.2,
                 position=position_dodge(.9)) + 
  xlab("") + ylab("Score") + 
  geom_hline(aes(yintercept = mean(is.sum)), linetype = "dashed")

p.merge <- cowplot::plot_grid(p2, NULL, p, p1 ,rel_widths = c(3,1), rel_heights = c(1,3), align = c("hv"))

p.title <- ggplot() + labs(title = communication.name, subtitle = "marginal plots show mean interaction +/- se")
p.merge.final <- cowplot::plot_grid(p.title, p.merge, p.legend, ncol = 1, rel_heights = c(0.5,5,1))


if (print.inline) print(p.merge.final)

plt.agg.LR.list[[communication.name]] <- p.merge.final

}

```


```{r cluster differentials}

# get expression  matrix
ef.mat <- as.matrix(so.query@assays[[DefaultAssay(so.query)]]@data)
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# initiate empty matrices
f.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust))

# get cluster-level aggregate scores
for (i in 1:length(u.clust)){
  which.cells <- sc.meta %in% u.clust[i]
  
  # expressing fraction
  f1 <- rowMeans(ef.mat[, which.cells] > 0)
  f.mat[ ,i] <- f1
}

# assign col and row names
colnames(f.mat) <-   u.clust
rownames(f.mat) <-   rownames(ef.mat)

# cast to data.frame
df.f.wide <- data.frame(gene = rownames(ef.mat), as.data.frame(f.mat)); colnames(df.f.wide) <- c("gene", u.clust)

# wide to long
df.f.long <- pivot_longer(df.f.wide, colnames(df.f.wide)[2:ncol(df.f.wide)])

# assign col names to long dataframe
colnames(df.f.long) <- c("gene", "cluster", "value")

# ensure clusters are ordered factors
df.f.long$cluster <- factor(df.f.long$cluster, levels = u.clust)

# clear baggage
rm(ef.mat); invisible({gc()})

```

```{r, fig.width = 12, fig.height=4, warning = FALSE}

plt.umap <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() +   theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())


f.threshold <- 0.2

plt.granular.list <- list()
plt.top.int <- list()

for (k in 1:length(which.communication)){
  
  # get LR interaction
  df.comm <- res.comm.list[[which.communication[k]]]
  df.comm$interaction.score <- df.comm$cell_from_mean_exprs * df.comm$cell_to_mean_exprs
  
  # LR name
  df.comm$LR <- paste0(df.comm$ligand, " -> ", df.comm$receptor)
  
  # cast clusters as factors
  df.comm$cell_to <- gsub("c", "", df.comm$cell_to)
  df.comm$cell_to <- factor(df.comm$cell_to, levels = paste0(u.clust))
  df.comm$cell_from <- gsub("c", "", df.comm$cell_from)
  df.comm$cell_from <- factor(df.comm$cell_from, levels = paste0(u.clust))
  
  # clone
  df.comm.all <- df.comm
  
  # expression fraction merge
  df.f.ligand <- df.f.long
  df.f.ligand$cluster <- paste0(df.f.ligand$cluster)
  df.f.ligand$gene <- toupper(df.f.ligand$gene)
  colnames(df.f.ligand) <- c("ligand", "cell_from", "source.fraction")
  df.comm <- merge(df.comm, df.f.ligand)
  
  df.f.receptor <- df.f.ligand
  colnames(df.f.receptor) <- c("receptor", "cell_to", "target.fraction")
  df.comm <- merge(df.comm, df.f.receptor)
  
  # filter top interactions
  filter1 <- df.comm$interaction.score > 0
  filter2 <- df.comm$source.fraction > f.threshold
  filter3 <- df.comm$target.fraction > f.threshold
  df.comm <- df.comm[filter1 & filter2 & filter3, ]
  
  df.comm <- df.comm %>% dplyr::arrange(-interaction.score)
  
  u.lr.cur <- 0
  iter.n <- 0
  u.lr.top <- NULL
  n.top.int <- 20
  while((u.lr.cur < 20) & ((iter.n + n.top.int) < nrow(df.comm))){
    df.comm <- df.comm %>% dplyr::top_n(n.top.int+iter.n)
    u.lr.top <- unique(df.comm$LR)
    u.lr.cur <- length(u.lr.top)
    if (u.lr.cur >= n.top.int){
      break
    } else {
      iter.n <- iter.n + 1
    }
  }
  
  if (nrow(df.comm) == 0) {
    plt.granular.list[[which.communication[k]]] <- NULL
    next
  }
  
  
  
  u.lr.all <- unique(df.comm.all$LR)
  u.lr.filt <- unique(df.comm$LR)
  
  which.keep <- (df.comm.all$LR) %in% u.lr.filt
  df.comm.sub <- df.comm.all[which.keep, ]
  
  plt.gran.ind.list <- list()
  
  for (i in 1:u.lr.cur){
    # for (i in 1:length(u.lr.filt)){
    
    ligand.name <- stringr::str_extract(u.lr.filt[i], "[A-Za-z0-9]*")
    receptor.name <- stringr::str_replace(u.lr.filt[i], "[A-Za-z0-9]*\ ->\ ", "")
    
    if (which.species == "Mm"){
      ligand.name <- firstup(ligand.name)
      receptor.name <- firstup(receptor.name)
    } else if (which.species == "Hs"){
      ligand.name <- toupper(ligand.name)
      receptor.name <- toupper(receptor.name)      
    }
    
    # LR-level dot plot
    plt.grain.dot <- df.comm.sub %>%
      dplyr::filter(LR %in% u.lr.filt[i]) %>%
      dplyr::group_by(LR) %>%
      dplyr::mutate(interaction.score = interaction.score / max(interaction.score)) %>%
      ggplot(aes(x = cell_from, y = cell_to, fill = interaction.score, size = interaction.score)) + 
      geom_point() +
      geom_point(pch=21, color = "black")  +
      xlab("Source Cluster") + ylab("Recipient Cluster") + 
      viridis::scale_fill_viridis("Interaction (log)") + 
      facet_wrap(~LR)
    
    # print(plt.grain.dot)
    
    plt.lig <- scExpression.UMAP(
      so.query,
      ligand.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = ligand.name, subtitle = "Ligand (Source)") + 
        theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
    
    plt.rec <- scExpression.UMAP(
      so.query,
      receptor.name,
      x.label = "UMAP 1",
      y.label = "UMAP 2",
      plot.name = NULL,
      adjust.pt.size = F) +
      theme_miko(legend = T) +
      viridis::scale_color_viridis(option = "A") + 
      labs(title = receptor.name, subtitle = "Receptor (Recipient)")  + 
      # theme_minimal() +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank()) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
    
    plt.umap.exp <- cowplot::plot_grid(plt.lig, plt.rec, ncol = 1, align = "hv")
    
    plt.gran <- cowplot::plot_grid(plt.umap, plt.umap.exp, plt.grain.dot, ncol = 3, align = "hv", rel_widths = c(0.7,0.5,1))
    
    if (print.inline) print(plt.gran)
    
    plt.gran.ind.list[[u.lr.filt[i]]] <- plt.gran
  }
  
  plt.granular.list[[which.communication[k]]] <- plt.gran.ind.list
  
  # , axis = "lrbt"

  
  # top interactions
  df.comm.u <- unique(df.comm[ ,c("LR", "cell_from")])
  df.lig <- data.frame(table(df.comm.u$LR))
  
  plt.lig.profile <- df.lig %>%
    top_n(20, Freq) %>%
    ggplot(aes(x = reorder(Var1, Freq), y = Freq)) + 
    geom_bar(stat = "identity") + 
    coord_flip() + 
    ylab("N sources with paired target") + 
    xlab("Ligand") + 
    labs(title = "Ligand Profile", subtitle = which.communication[k]) + 
    theme_miko()
  
  plt.top.int[[which.communication[k]]] <- plt.lig.profile
  
  if (print.inline) print(plt.lig.profile)
}


```



```{r}


# work.in.progress <- F
# 
# if (work.in.progress){
#   
# 
# # find and filter queries
# query.interaction <- "tnf"
# query.match <- grepl(toupper(query.interaction), res.by_comm$ligand) |  grepl(toupper(query.interaction), res.by_comm$receptor)
# res.query <- res.by_comm[query.match, ]
# 
# res.query <- res.by_comm
# 
# # res.query <- res.query[res.query$cell_from_mean_exprs > 0 | res.query$cell_to_mean_exprs > 0, ]
# 
# res.query$pair <- paste(res.query$ligand, "-", res.query$receptor, sep = "")
# 
# # res.query.tally <- res.query %>%
# #   dplyr::group_by(comm_type, pair) %>%
# #   tally()
# # 
# # 
# # res.query.ligand <- res.query %>%
# #   dplyr::group_by(comm_type, ligand) %>%
# #   tally()
# # 
# # res.query.receptor <- res.query %>%
# #   dplyr::group_by(comm_type, receptor) %>%
# #   tally()
# 
# 
# res.query.ligand <- res.query %>%
#   dplyr::group_by(ligand) %>%
#   tally()
# 
# df.exp <- high.exp_genes
# 
# 
# all.cluster.id <- paste("c", as.character(so@active.ident), sep = "")
# df.c <- data.frame(cell_type = all.cluster.id) %>%
#   dplyr::group_by(cell_type) %>%
#   tally()
# 
# df.exp.merge <- merge(df.exp, df.c, by = "cell_type")
# df.exp.merge$cluster.gene <- paste(df.exp.merge$cell_type, "-", df.exp.merge$gene, sep = "")
# 
# df.interaction <- res.by_comm
# df.interaction$cluster.gene<- paste(df.interaction$cell_from, "-", df.interaction$ligand, sep = "")
# df.interaction <- df.interaction[ , c("cell_from_mean_exprs", "cluster.gene", "comm_type")]
# 
# df.exp.merge.int <- merge(df.exp.merge, df.interaction, by = "cluster.gene")
# 
# df.exp.merge.int.u <- unique(df.exp.merge.int)
# 
# df.exp.merge.int.u$ligand.sum <- df.exp.merge.int.u$n * df.exp.merge.int.u$cell_from_mean_exprs
# 
# df.ligand.pool <- df.exp.merge.int.u %>%
#   dplyr::group_by(gene) %>%
#   dplyr::summarize(ligand.pool = sum(ligand.sum),
#             comm = list(comm.type))
# 
# 
# hist(df.ligand.pool$ligand.pool)
# # hist(res.query$cell_from_mean_exprs)
# # res.query <- res.query[res.query$receptor %in% query.receptor, ]
# 
# }

```


```{r significant ligand-receptor pairs between compare groups}

# exp.df_t$cell_type 

# 
# valid_column_names <- make.names(names=names(exp.df_t), unique=TRUE, allow_ = TRUE)
# names(exp.df_t) <- valid_column_names
# 
# exp.df_t.pooled <- NULL
# for (i in 1:length(exp.df_t.list)){
#   grp.name <- names(so.list)[i]
#   exp.df_t <- exp.df_t.list[[grp.name]]
#   exp.df_t$cell_type = i # last change
#   exp.df_t.pooled <- rbind(exp.df_t.pooled, exp.df_t)
# }
# 
# 
# 
# u.groups <- as.vector(unique(exp.df_t.pooled$compare_group))
# deg.pooled.list <- list()
# 
# 
# for (i in u.groups){
#   exp.df_t.pooled_comp<- exp.df_t.pooled %>% mutate(compare_group =  sample(2,nrow(exp.df_t.pooled),replace=TRUE))
#   deg.pooled.list[[i]] <- DEG(exp.df_t.pooled_comp %>% dplyr::filter(cell_type==i), method='Wilcox')
#   
# }






# deg.pooled <- DEG(exp.df_t.pooled, 
#              method='Wilcox')
# 
# # randomly assign the compare group to each sample
# # compare_grps <- sample(2,nrow(exp.df_t),replace=TRUE)
# exp.df_t_comp<- exp.df_t %>% mutate(compare_group =  sample(2,nrow(exp.df_t),replace=TRUE))
# exp.df_t_comp <- exp.df_t_comp[complete.cases(exp.df_t_comp), ]
# 
# 
# # find DEGenes of regulatory T cells and NK cells between these 2 groups
# sub_a <- exp.df_t_comp %>% dplyr::filter(cell_type==cell_type_a)
# compare_grps <- sample(2,nrow(sub_a),replace=TRUE)
# sub_a<- sub_a %>% mutate(compare_group = compare_grps)
# sub_a <- sub_a[complete.cases(sub_a), ]
# deg_a <- DEG(sub_a, 
#              method='Wilcox',
#              contrast=c(2,1))
# 
# 
# sub_b <- exp.df_t_comp %>% dplyr::filter(cell_type==cell_type_b)
# compare_grps <- sample(2,nrow(sub_b),replace=TRUE)
# sub_b<- sub_b %>% mutate(compare_group = compare_grps)
# sub_b <- sub_b[complete.cases(sub_b), ]
# deg_b <- DEG(sub_b,
#              method='Wilcox',
#              contrast=c(2,1))

# find significant ligand-receptor pairs and do the plotting
# resB.by_comm<-NULL
# 
# for(comm_type in communication.type){
#   res_cat<-FindLR(deg_a,deg_b,datatype='DEG',comm_type=comm_type)
#   res_cat<-res_cat[order(res_cat$cell_from_logFC*res_cat$cell_to_logFC,decreasing=T),]
#   
#   #plot by ligand category
#   if(nrow(res_cat)==0){
#     next
#   }else if(nrow(res_cat>=n.LRpairs)){
#     LRPlot(res_cat[1:n.LRpairs,],
#            datatype='DEG',cell_col=cell_col,
#            link.arr.lwd=res_cat$cell_from_logFC[1:n.LRpairs],
#            link.arr.width=res_cat$cell_to_logFC[1:n.LRpairs])
#   }else{
#     LRPlot(res_cat,datatype='DEG',
#            cell_col=cell_col,
#            link.arr.lwd=res_cat$cell_from_logFC,
#            link.arr.width=res_cat$cell_to_logFC)
#   }
#   
#   # network plot
#   NetView(res_cat,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   title(comm_type)
#   
#   # store results
#   resB.by_comm<-rbind(resB.by_comm,res_cat)
# }
# 
# # pool results for all communication types
# if(is.null(resB.by_comm)){
#   print('No significant pairs found')
#   
# } else if(nrow(resB.by_comm)>=n.LRpairs){
#   # pool results
#   resB.overall <- resB.by_comm[order(resB.by_comm$cell_from_logFC*resB.by_comm$cell_to_logFC,decreasing=T),][1:n.LRpairs,]
#   
#   # network plot
#   NetView(resB.overall,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   
#   # LR plot
#   LRPlot(resB.overall[1:n.LRpairs,],
#          datatype='DEG',
#          cell_col=cell_col,
#          link.arr.lwd=resB.overall$cell_from_logFC[1:n.LRpairs],
#          link.arr.width=resB.overall$cell_to_logFC[1:n.LRpairs])
#   
# } else{
#   
#   # network plot
#   NetView(resB.by_comm,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   
#   # LR plot
#   LRPlot(resB.by_comm,datatype='DEG',
#          cell_col=cell_col,link.arr.lwd=resB.by_comm$cell_from_logFC,
#          link.arr.width=resB.by_comm$cell_to_logFC)
# }

```



```{r, fig.height= 10, fig.width= 10}
# 
# library(iTALK)
# 
# 
# 
# ## highly expressed ligand-receptor pairs
# 
# # find top 50 percent highly expressed genes
# highly_exprs_genes<-rawParse(my_data,top_genes=50,stats='mean')
# # find the ligand-receptor pairs from highly expressed genes
# comm_list<-c('growth factor','other','cytokine','checkpoint')
# cell_col<-structure(c('#4a84ad','#4a1dc6','#e874bf','#b79eed', '#ff636b', '#52c63b','#9ef49a'),names=unique(my_data$cell_type))
# par(mfrow=c(1,2))
# res<-NULL
# for(comm_type in comm_list){
#   res_cat<-FindLR(highly_exprs_genes,datatype='mean count',comm_type=comm_type)
#   res_cat<-res_cat[order(res_cat$cell_from_mean_exprs*res_cat$cell_to_mean_exprs,decreasing=T),]
#   #plot by ligand category
#   #overall network plot
#   NetView(res_cat,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   #top 20 ligand-receptor pairs
#   LRPlot(res_cat[1:20,],datatype='mean count',cell_col=cell_col,link.arr.lwd=res_cat$cell_from_mean_exprs[1:20],link.arr.width=res_cat$cell_to_mean_exprs[1:20])
#   title(comm_type)
#   res<-rbind(res,res_cat)
# }
# res<-res[order(res$cell_from_mean_exprs*res$cell_to_mean_exprs,decreasing=T),][1:20,]
# NetView(res,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
# LRPlot(res[1:20,],datatype='mean count',cell_col=cell_col,link.arr.lwd=res$cell_from_mean_exprs[1:20],link.arr.width=res$cell_to_mean_exprs[1:20])
# 
# ## significant ligand-receptor pairs between compare groups
# 
# # randomly assign the compare group to each sample
# my_data<-my_data %>% mutate(compare_group=sample(2,nrow(my_data),replace=TRUE))
# # find DEGenes of regulatory T cells and NK cells between these 2 groups
# deg_t<-DEG(my_data %>% filter(cell_type=='regulatory_t'),method='Wilcox',contrast=c(2,1))
# deg_nk<-DEG(my_data %>% filter(cell_type=='cd56_nk'),method='Wilcox',contrast=c(2,1))
# # find significant ligand-receptor pairs and do the plotting
# par(mfrow=c(1,2))
# res<-NULL
# for(comm_type in comm_list){
#   res_cat<-FindLR(deg_t,deg_nk,datatype='DEG',comm_type=comm_type)
#   res_cat<-res_cat[order(res_cat$cell_from_logFC*res_cat$cell_to_logFC,decreasing=T),]
#   #plot by ligand category
#   if(nrow(res_cat)==0){
#     next
#   }else if(nrow(res_cat>=20)){
#     LRPlot(res_cat[1:20,],datatype='DEG',cell_col=cell_col,link.arr.lwd=res_cat$cell_from_logFC[1:20],link.arr.width=res_cat$cell_to_logFC[1:20])
#   }else{
#     LRPlot(res_cat,datatype='DEG',cell_col=cell_col,link.arr.lwd=res_cat$cell_from_logFC,link.arr.width=res_cat$cell_to_logFC)
#   }
#   NetView(res_cat,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   title(comm_type)
#   res<-rbind(res,res_cat)
# }
# if(is.null(res)){
#   print('No significant pairs found')
# }else if(nrow(res)>=20){
#   res<-res[order(res$cell_from_logFC*res$cell_to_logFC,decreasing=T),][1:20,]
#   NetView(res,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   LRPlot(res[1:20,],datatype='DEG',cell_col=cell_col,link.arr.lwd=res$cell_from_logFC[1:20],link.arr.width=res$cell_to_logFC[1:20])
# }else{
#   NetView(res,col=cell_col,vertex.label.cex=1,arrow.width=1,edge.max.width=5)
#   LRPlot(res,datatype='DEG',cell_col=cell_col,link.arr.lwd=res$cell_from_logFC,link.arr.width=res$cell_to_logFC)
# }
# I just randomly assigned the compare group to samples which has no biological difference for showing how to use the package.
# So there should be no significant genes to be expected. 

```



UMAP
===================================== 

```{r ph1,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}



plt.umap.final <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() 

print(plt.umap.final)

```

LR Descriptives
===================================== 

Row {.tabset}
-------------------------------------

```{r lr desc,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.agg.LR.list), function(i) {
  
  s1 <- names(plt.agg.LR.list)[i]
  s2 <- paste0("plt.agg.LR.list[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=8, fig.height=8, message=FALSE, warning=FALSE}", paste("lr_sum", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`

Top Interactions
===================================== 

Row {.tabset}
-------------------------------------

```{r top lr,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_lr <- NULL

out_lr <- lapply(seq_along(plt.top.int), function(i) {
  
  s1 <- names(plt.top.int)[i]
  s2 <- paste0("plt.top.int[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width=8, fig.height=8, message=FALSE, warning=FALSE}", paste("lr_top", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_lr, collapse = '\n')))`



```{r ph4,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(res.LR.list2), function(i) {
  
  cur.name <- names(res.LR.list2)[i]
  
  a1 <- knitr::knit_expand(text = sprintf("\nLR interactions | %s", paste(cur.name)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = "\nRow {.tabset}")
  a4 <- knitr::knit_expand(text = "\n-------------------------------------\n")
  
  
  out2 <- lapply(seq_along(res.LR.list2[[i]]), function(j) {
    
    
    n.LRpairs <- 20 # changed 
    
    clust_a <- as.vector(res.LR.list2[[i]][[j]][["cell_from"]])
    clust_b <- as.vector(res.LR.list2[[i]][[j]][["cell_to"]])
    clust_all <- as.vector(unique(c(clust_a, clust_b)))
    
    # specify cell colors
    
    grp.name <- names(res.LR.list2)[i]
    comm.type <- names(res.LR.list2[[i]])[j]
    my.cols <-colorRampPalette(brewer.pal(8, paste("Set", set_color = 2, sep = "")))(length(clust_all))
    cell_col <-my.cols
    # cell_col<-structure(my.cols,names=unique(exp.df_t$cell_type ))
    
    # LR plot
    s1 <- sprintf("LRPlot( res.LR.list2[[%d]][[%d]], 
    datatype='mean count', 
    link.arr.lwd= res.LR.list2[[%d]][[%d]]$cell_from_mean_exprs, 
    link.arr.width= res.LR.list2[[%d]][[%d]]$cell_to_mean_exprs)",i, j, i, j, i, j)
    
    
    # s1 <- sprintf("LRPlot( res.LR.list2[[%d]][[%d]][1:%d,], 
    # datatype='mean count', 
    # link.arr.lwd= res.LR.list2[[%d]][[%d]]$cell_from_mean_exprs[1:%d], 
    # link.arr.width= res.LR.list2[[%d]][[%d]]$cell_to_mean_exprs[1:%d])",i, j,  n.LRpairs, i, j,  n.LRpairs, i, j, n.LRpairs)
    
    s2 <- paste(grp.name, ': ',comm.type, sep = '')
    # s2 <- sprintf("title(paste(%s)", s2)
    
    
    b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", comm.type)) # tab header
    b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=10, fig.height=10, message=FALSE, warning=FALSE}", 
                                            paste("chunk", i, j, sep = ""))) 
    b3 <- knitr::knit_expand(text = sprintf("\n %s",s1)) 
    # b4 <- knitr::knit_expand(text = sprintf("\n title(%s)", s2))
    b5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    out2 <- paste(b1, b2, b3, b5, collapse = '\n')
    return(out2) # collapse together all lines with newline separator
    
  })
  
  a5 <- paste(knitr::knit(text = paste(out2, collapse = '\n')))
  
  out1 <- paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  return(out1)
  
})

```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`


1| Cytokines
===================================== 

```{r pp1}

 plt.cur <-  plt.granular.list[["cytokine"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
  out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width = 12, fig.height=4, message=FALSE, warning=FALSE}", paste("p1", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

2| Checkpoint
===================================== 

```{r pp2}

 plt.cur <-  plt.granular.list[["checkpoint"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width = 12, fig.height=4, message=FALSE, warning=FALSE}", paste("p2", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

3| Growth Factors
===================================== 

```{r pp3}

 plt.cur <-  plt.granular.list[["growth factor"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width = 12, fig.height=4, message=FALSE, warning=FALSE}", paste("p3", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

4| Other
===================================== 

```{r pp4}

 plt.cur <-  plt.granular.list[["other"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width = 12, fig.height=4, message=FALSE, warning=FALSE}", paste("p4", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

5| Pooled
===================================== 

```{r pp5}

 plt.cur <-  plt.granular.list[["pooled"]] 
if (is.null(plt.cur)){
  out <- NULL
} else {
  
    out <- lapply(seq_along(plt.cur), function(i) {
  
  s1 <- names(plt.cur)[i]
  s2 <- paste0("plt.cur[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s,fig.width = 12, fig.height=4, message=FALSE, warning=FALSE}", paste("p5", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})
  
}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`



LR Interaction Tables
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(res.LR.list), function(i) {
  
  # res.LR.list[["GL261"]][["pooled"]]
  
  s1 <- paste("res.LR.list[[", i, "]][['pooled']]", sep = "")
  
  table.name <- names(res.LR.list)[i]
  
  s4 <- paste("datatable(", s1, ", filter = 'top', options = list(pageLength = 50))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`



```{r analysis log final}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_12 <- df.log

```


```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 12)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_12)

```

