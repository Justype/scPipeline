---
title: "Module14_map_embeddings"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r load libraries, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform",
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggExtra", "grid", "ggrepel", "ddpcr")

# load packages
lapply(packages2load, library, character.only = TRUE)

```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
  }

```


```{r parameter specification}

input1 <- data.frame(name = "integrated_T12_4000ds_renca",
                    file = "Module2_Renca_cell_nuc_sci_T12_4000ds_Celsius_integrated_240220.Rdata",
                    cluster.resolution = 0.4,
                    integrated.set = T, 
                    subsample_factor = 0.2, 
                    specific.clusters = NA) # e.g., I(list(c(4,5,6,7,8,14)))

input2 <- data.frame(name = "nuc_t1",
                    file = "Module1_renca_nuc_T1_040320.Rdata",
                    integrated.set = F,
                    subsample_factor = 0.2, 
                    cluster.resolution = 0.4)

# Module1_Neftel_ss2_GBM_160120.Rdata
# Module1_Neftel_10x_160120.Rdata



mapping.orientation <- "horizontal" #horizontal (recommended), vertical

dir.preprocessed <- "Preprocessed Datasets/"

print.inline <- F


```

```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("14, map embedding")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("Sys.getenv('USERDOMAIN')")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("Sys.time()")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# label 1
df.log[nrow(df.log)+1, 1] <- as.character("Input Label 1 (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input1$name")
df.log[nrow(df.log), 3] <- as.character(input1$name)

# file 1
df.log[nrow(df.log)+1, 1] <- as.character("Input File 1 (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input1$file")
df.log[nrow(df.log), 3] <- as.character(input1$file)

# cluster resolution 1
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution 1")
df.log[nrow(df.log), 2] <- as.character("input1$cluster.resolution")
df.log[nrow(df.log), 3] <- as.character(input1$cluster.resolution)

# label 2
df.log[nrow(df.log)+1, 1] <- as.character("Input Label 2 (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input2$name")
df.log[nrow(df.log), 3] <- as.character(input2$name)

# file 2
df.log[nrow(df.log)+1, 1] <- as.character("Input File 2 (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input2$file")
df.log[nrow(df.log), 3] <- as.character(input2$file)

# cluster resolution 2
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution 2")
df.log[nrow(df.log), 2] <- as.character("input2$cluster.resolution")
df.log[nrow(df.log), 3] <- as.character(input2$cluster.resolution)


```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r import seurat objects}

if (!exists("dir.preprocessed")) dir.preprocessed <- ""

# import data1
input.file1 <- paste(dir.preprocessed, input1$file, sep = "")
load(input.file1)

# subsample (for dev purposes)
n.subset <- round(input1$subsample_factor *ncol(so))
cell.ind <- sample(x = seq(1, ncol(so)), size = n.subset, replace = FALSE, prob = NULL)
so <- SubsetData(so , cells = cell.ind)

so1 <- so
rm(so)

# import data2
input.file2 <- paste(dir.preprocessed, input2$file, sep = "")
load(input.file2)

# subsample (for dev purposes)
n.subset <- round(input2$subsample_factor *ncol(so))
cell.ind <- sample(x = seq(1, ncol(so)), size = n.subset, replace = FALSE, prob = NULL)
so <- SubsetData(so , cells = cell.ind)

so2 <- so
rm(so)

```


```{r get cell barcodes and umap embeddings}

# get cluster memberships
current.assay1 <- DefaultAssay(so1)
current.cluster1 <- paste(current.assay1, "_snn_res.", input1$cluster.resolution, sep = "")
if (!(current.cluster1 %in% so1@meta.data)){
  so1 <- FindClusters(object = so1, resolution = input1$cluster.resolution, verbose = 0, algorithm = 1, modularity.fxn = 1)
}

current.assay2 <- DefaultAssay(so2)
current.cluster2 <- paste(current.assay2, "_snn_res.", input2$cluster.resolution, sep = "")
if (!(current.cluster2 %in% so2@meta.data)){
  so2 <- FindClusters(object = so2, resolution = input2$cluster.resolution, verbose = 0, algorithm = 1, modularity.fxn = 1)
}

# get umap embeddings
df.embedding1 <- as.data.frame(so1@reductions[["umap"]]@cell.embeddings)
colnames(df.embedding1) <- c("x1", "y1")
df.embedding1$cell <- rownames(df.embedding1)
df.embedding1$cluster1 <- so1@meta.data[[current.cluster1]]

df.embedding2 <- as.data.frame(so2@reductions[["umap"]]@cell.embeddings)
colnames(df.embedding2) <- c("x2", "y2")
df.embedding2$cell <- rownames(df.embedding2)
df.embedding2$cluster2 <- so2@meta.data[[current.cluster2]]


# match names (partial match, set 1 to 2; revserse not reciprocated)
c1 <- df.embedding1$cell
c2 <- df.embedding2$cell

for (i in 1:length(c1)){
  try({
    c2[which(grepl(c1[i], c2))] <- c1[i]
  }, silent = T)
}
df.embedding2$cell <- c2


```

```{r}
# get umap dimensions
x1.min <- min(df.embedding1$x1)
x1.max <- max(df.embedding1$x1)
y1.min <- min(df.embedding1$y1)
y1.max <- max(df.embedding1$y1)

x2.min <- min(df.embedding2$x2)
x2.max <- max(df.embedding2$x2)
y2.min <- min(df.embedding2$y2)
y2.max <- max(df.embedding2$y2)

x.range <- c(min(c(x1.min, x2.min)), max(c(x1.max, x2.max)))
y.range <- c(min(c(y1.min, y2.min)), max(c(y1.max, y2.max))) 

x.span <- abs((x.range[1] - x.range[2]))
y.span <- abs((y.range[1] - y.range[2]))

if (mapping.orientation == "horizontal"){
  df.embedding2$x2 <- df.embedding2$x2 + x.span
} else if (mapping.orientation == "vertical"){
  df.embedding2$y1 <- df.embedding2$y1 + y.span
}

df.embedding1.v2 <- df.embedding1
df.embedding2.v2 <- df.embedding2
colnames(df.embedding1.v2)[c(1,2, 4)] <- c("x", "y", "cluster")
colnames(df.embedding2.v2)[c(1,2, 4)] <- c("x", "y", "cluster")

df.embedding1.v2$embedding <- input1$name
df.embedding2.v2$embedding <- input2$name

integrated.1 <- input1$integrated.set 
integrated.2 <- input2$integrated.set 


df.embedding.v2 <- bind_rows(df.embedding1.v2, df.embedding2.v2)
df.embedding.v1 <- join(df.embedding1, df.embedding2)


df.embedding.v2$duplicate.set <- df.embedding.v2$cell %in% df.embedding.v1$cell

```

```{r,  fig.width=11, fig.height=5}
# group.by = "seurat_cluster", 

plt.umap_original <-  DimPlot(so1, reduction = "umap", label = TRUE, repel = TRUE)  + 
  ggtitle(label = input1$name) + 
  xlab("UMAP 1") + 
  ylab("UMAP 2") + 
  theme(legend.position = "none")

plt.umap_new <-  DimPlot(so2, reduction = "umap", label = TRUE, repel = TRUE)  + 
  ggtitle(label = input2$name) + 
  xlab("UMAP 1") + 
  ylab("") + 
  theme(legend.position = "none")

plt.umap.list <- list(original = plt.umap_original, new = plt.umap_new)

if (print.inline)   print((CombinePlots(plt.umap.list, ncol = length(plt.umap.list), legend = 'none')))

```


```{r, fig.height= 5, fig.width= 10}

plt.embedding <- ggplot(data = df.embedding.v2, aes(x = x, y = y)) + 
  geom_point(aes(color = duplicate.set), size = 0.5) + 
  geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), alpha = 0.01, data = df.embedding.v1) + 
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) 

if (print.inline) print(plt.embedding)


```


```{r}

u.cluster1 <- as.numeric(as.vector(unique(df.embedding.v1$cluster1)))
u.cluster1 <- u.cluster1[order(u.cluster1)]
u.cluster2 <-  as.numeric(as.vector(unique(df.embedding.v1$cluster2)))
u.cluster2 <- u.cluster2[order(u.cluster2)]


if ("specific.clusters" %in% colnames(input1)){
  if (!is.na(input1$specific.clusters)){
    u.cluster1 <- as.numeric(as.vector(unlist(input1$specific.clusters)))
    u.cluster1 <- u.cluster1[order(u.cluster1)]
  }
}

plt.embedding_by_cluster.list <- list()
df.embedding_by_cluster <- NULL
for (i in 1:length(u.cluster1)){
  
  cur.cluster <- as.character(u.cluster1[i])
  
  df.embedding.v1$highlight.cluster <- df.embedding.v1$cluster1 %in% cur.cluster

  df.embedding.v1$highlight.color <- "black"
  df.embedding.v1$highlight.alpha <- 0.005
  df.embedding.v1$highlight.color[df.embedding.v1$highlight.cluster] <- "red"
  df.embedding.v1$highlight.alpha[df.embedding.v1$highlight.cluster] <- 0.05
  
  df.embedding.v2$highlight.cluster <- df.embedding.v2$cell %in% df.embedding.v1$cell[df.embedding.v1$highlight.cluster]
  df.embedding.v2$highlight.color[df.embedding.v2$embedding == input1$name] <- "grey0"
  df.embedding.v2$highlight.color[df.embedding.v2$embedding == input2$name] <- "grey18"
  df.embedding.v2$highlight.color[df.embedding.v2$highlight.cluster] <- "red"
  
  plt.embedding_by_cluster.list[[cur.cluster]] <- ggplot(data = df.embedding.v2, aes(x = x, y = y)) + 
  geom_point(color = df.embedding.v2$highlight.color, size = 0.5) + 
  geom_segment(aes(x = x1, y = y1, xend = x2, yend = y2), 
               color = df.embedding.v1$highlight.color, alpha = df.embedding.v1$highlight.alpha, data = df.embedding.v1) + 
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) + 
    ggtitle(paste("Cluster ", cur.cluster, sep  =""))

  if (print.inline) print(plt.embedding_by_cluster.list[[cur.cluster]])
  
}

```

```{r table}


df.embedding.v1$cluster1 <- as.numeric(as.vector(df.embedding.v1$cluster1))
df.embedding.v1$cluster2 <- as.numeric(as.vector(df.embedding.v1$cluster2))

df.cluster_tally <- df.embedding.v1 %>%
  group_by(cluster1, cluster2) %>%
  tally(cluster2) %>%
  group_by(cluster1) %>%
  mutate(freq = signif(n/sum(n), 3))

# df.cluster_tally.subset <- df.cluster_tally %>% dplyr::select(c("cluster1", "cluster2", "freq"))
# colnames(df.cluster_tally) <- c("original cluster", "new cluster", "count", "frequency")

df.cluster_tally$cluster1 <- as.character(df.cluster_tally$cluster1) 
df.cluster_tally$cluster2 <- as.character(df.cluster_tally$cluster2) 

colnames(df.cluster_tally) <- c("original cluster", "new cluster", "count", "frequency")

```




Clusters
===================================== 

```{r plt.umap.list, fig.width=11, fig.height=5}
print((CombinePlots(plt.umap.list, ncol = length(plt.umap.list), legend = 'none')))
```


UMAP Remapping
===================================== 

```{r plt.embedding, fig.height= 5, fig.width= 10}
print(plt.embedding)
```



Cluster-Specific Remapping (1)
===================================== 

### Remapping Table
```{r tbl.embedding, fig.height= 5, fig.width= 10}

datatable(df.cluster_tally, rownames = F, filter = 'top', options = list(
 columnDefs = list(list(className = 'dt-center', targets = 0:(ncol(df.cluster_tally)-1)))))


```

Cluster-Specific Remapping (2)
===================================== 


Row {.tabset}
-------------------------------------

```{r res2, echo = FALSE, eval = TRUE}

out <- lapply(seq_along(plt.embedding_by_cluster.list), function(i) {

  a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.embedding_by_cluster.list)[i])) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.height= 5, fig.width= 10}", paste(i, "umap"))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.embedding_by_cluster.list[[%d]])", i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk

  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator

})


```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`




```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 14)
===================================== 

```{r table.log_current}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_14 <- df.log

knitr::kable(df.log_Module_14)

```

