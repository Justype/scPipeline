---
title: "Pairwise Cluster Differentials"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("scMiko", "Seurat", "sctransform", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "MAST", "future", "cluster", "doParallel", "parallel", "foreach", "GSVA")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))


```


```{r parameter specification}



# Query input
# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"
input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R111_M27_NM2_M02_p467891011_tumorImmune_tier1_150920.Rdata"

# Rapid marker finding (logical flag)
quick_markers <- TRUE 

# specify cluster resolution
cluster.resolution <- 0.5

do.schex <- T

# print inline
print.inline <- FALSE

# 
which.species <- "Mm"

which.annotation.db <- "GO"    # Reactome, GO, Bader

# specify whether DEG is performed (optional)
run.deg <- T

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)



# specify number of workers (for parallelization)
n.workers <- list(
  gsea =  14 # GSEA analysis
  )

# which markers to return
only.pos <- F# 

# DEG test
DEG.test <- "MAST" #options: wilcox, bimod, roc, t, poisson, negbinom, LR, MAST, DESeq2

# save PDF
save.pdf <- T


```



```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so.query, objects())

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset = NULL, 
                             subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "corr", "gsva", "deg"), rmv.pattern = "so")

# unpack results
rm(so)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```

```{r analysis log}

# Module
df.log <- initiateLog("29, Pairwise Cluster Differentials")
df.log <- addLogEntry("Query File (.Rdata)", (input.file), df.log, "input.file")
df.log <- addLogEntry("Default Assay", (current.assay), df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", (cluster.resolution), df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", (subsample_factor), df.log, "subsample_factor")
df.log <- addLogEntry("Quick DEG analysis", (quick_markers), df.log, "quick_markers")
df.log <- addLogEntry("schex binning", (do.schex), df.log, "do.schex")
df.log <- addLogEntry("Species", (which.species), df.log, "which.species")
df.log <- addLogEntry("Enrichment DB", (which.annotation.db), df.log, "which.annotation.db")
df.log <- addLogEntry("DEG performed", (run.deg), df.log, "run.deg")
df.log <- addLogEntry("N workers (GSEA)", (n.workers$gsea), df.log, "gsea")
df.log <- addLogEntry("Only positive DEGs", (only.pos), df.log, "only.pos")
df.log <- addLogEntry("DEG test", (DEG.test), df.log, "DEG.test")

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r pairwise differential gene expression}

u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

cluster.membership <- as.numeric(as.character(so.query@meta.data[["seurat_clusters"]]))
cell.names <- colnames(so.query)

# log fold change threshold
lfc.threshold <- 1

# p.value threshold <- p.threshold
p.threshold <- 0.01

clust.deg.list <- list()

# initiate matrix for coutning n degs
n.deg.mat <- matrix(ncol = length(u.clust), nrow = length(u.clust))

deg.res.all <- NULL



if (run.deg){

for (i in 1:length(u.clust)){
  
  clust.i.name <- paste0("c", u.clust[i])
  clust.deg.list[[clust.i.name]] <- list()
  
  for (j in 1:length(u.clust)){
    
    if (i == j)  {
      n.deg.mat[i,j] <- n.deg.mat[j,i] <- 0
      next
    }
    
    clust.j.name <- paste0("c", u.clust[j])
    which.cells.i <- cell.names[cluster.membership %in% u.clust[i]]
    which.cells.j <- cell.names[cluster.membership %in% u.clust[j]]
    
    deg.res <- NULL
    try({

    if (quick_markers == TRUE){
      deg.res <- FindMarkers(object = so.query, 
                             ident.1 = u.clust[i], ident.2 = u.clust[j], 
                             test.use = DEG.test,
                             only.pos = only.pos,
                             max.cells.per.ident = 200,
                             logfc.threshold = lfc.threshold,
                             min.pct = 0.25)
      deg.res$pct.dif <- deg.res$pct.1 - deg.res$pct.2
      deg.res <- deg.res %>% dplyr::filter(p_val_adj < p.threshold)

    } else {
      deg.res <- FindMarkers(object = so.query, 
                             ident.1 = u.clust[i], ident.2 = u.clust[j], 
                             test.use = DEG.test,
                             only.pos = only.pos,
                             logfc.threshold = 0.01,
                             min.pct = 0.01)  
      deg.res$pct.dif <- deg.res$pct.1 - deg.res$pct.2
      deg.res <- deg.res %>% dplyr::filter(p_val_adj < p.threshold)
    }
            
    }, silent = T)
    
    if (is.null(deg.res)) {
      n.deg.mat[i,j] <-  n.deg.mat[j,i] <- 0
      warning(paste0("Issue detected for ",  u.clust[i], "-", u.clust[j], " comparison."))
    } else {
      n.deg.mat[i,j] <-  n.deg.mat[j,i] <- nrow(deg.res)
    }
    
    
    try({
    pair.name <- paste0(clust.i.name, "-", clust.j.name)
    deg.res$pair <-pair.name
    
    deg.res <- bind_cols(data.frame(genes = rownames(deg.res)), deg.res)
    clust.deg.list[[clust.i.name]][[clust.j.name]] <- deg.res
    
    deg.res.all <- bind_rows(deg.res.all, deg.res)      
    }, silent = T)

    
  }
}

which.round <- c("p_val", "avg_logFC","pct.1","pct.2","p_val_adj","pct.dif")
deg.res.all[ , which.round]<- signif(deg.res.all[ , which.round], 3)

}

```

```{r}


plt.umap.final <- DimPlot(so.query, reduction = "umap", 
                                       label = T, 
                                       group.by = "seurat_clusters")  + 
    xlab("UMAP 1") + ylab("UMAP 2") + 
    labs(title = "UMAP", subtitle = "clusters") + theme_miko() 

if (print.inline) print(plt.umap.final)
```

```{r n deg sim matrix, include = FALSE}

if (run.deg){
colnames(n.deg.mat) <- paste0("c", u.clust)
rownames(n.deg.mat) <- paste0("c", u.clust)
plt.n.deg <- ggplotify::as.ggplot(pheatmap::pheatmap(n.deg.mat, 
                                                     main = "DEG Counts\nlow DEG ~ high similarity (yellow); high DEG ~ low similarity (blue)",
                                                     color = rev(viridis::viridis(20)))) 

if (print.inline) print(plt.n.deg)

} else {
  plt.n.deg <- NULL
}

```



```{r cluster differentials NEW}

# get expression  matrix
ef.mat <- so.query@assays[[DefaultAssay(so.query)]]@data
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# initiate empty matrices
logfc.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust)^2)
pct.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust)^2)
e.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust))
f.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust))

# get cluster-level aggregate scores
current.index <- 1
pair.name <- c()
for (i in 1:length(u.clust)){
  which.cells.i <- sc.meta %in% u.clust[i]
  
  f1 <- rowMeans(ef.mat[, which.cells.i] > 0)
  f.mat[ ,i] <- f1
  
  e1 <- log(rowMeans(expm1(x = ef.mat[, which.cells.i])) + 1)
  e.mat[ ,i] <- e1
  
  for (j in 1:length(u.clust)){
    which.cells.j <- sc.meta %in% u.clust[j]
    
    # log data expression
    e2 <- log(rowMeans(expm1(x = ef.mat[, which.cells.j])) + 1)
    logfc.mat[ ,current.index] <- e1 - e2
    
    current.index <- current.index + 1
    pair.name <- c(pair.name, paste0("c", u.clust[i], "-", "c", u.clust[j]))
  }
  
}

colnames(logfc.mat) <- pair.name
colnames(e.mat) <-   colnames(f.mat) <-  paste0("c", u.clust)
rownames(e.mat) <-  rownames(logfc.mat) <-  rownames(f.mat) <- rownames(ef.mat)

```


```{r cluster-specific markers, fig.width=10, fig.height=7}

no.expression.definition <- 0.05
high.exp.definition <- 0.3

sel.mat.1 <- f.mat < no.expression.definition
sel.mat.2 <- f.mat > high.exp.definition

filter.1 <- apply(sel.mat.1, 1, function(x) sum(x) == (ncol(f.mat)-1))
filter.2 <- apply(sel.mat.2, 1, function(x) sum(x) == 1)
filter.3 <- filter.1 & filter.2

selective.markers <- rownames(f.mat)[filter.3]

filter.2.sub <- sel.mat.2[rownames(sel.mat.2) %in% selective.markers, ]

plt.dot <- DotPlot(object = so.query, features = selective.markers, group.by = "seurat_clusters", scale = F) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) + 
  labs(title = "Selectively Expressed Markers", subtitle = paste0("Null expression threshold: ", no.expression.definition, "\nExpression threshold: ", high.exp.definition))


if (print.inline) print(plt.dot)

```

```{r get pathays, warning = FALSE}

# all.genes <-df2enrich$genes
all.genes <- rownames(logfc.mat)

# get symbol to entrez mapping
my.symbol <- as.vector(all.genes)
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

match.ind <- match(all.genes, my.entrez$SYMBOL)
all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind]) 

pathways.subset <- getAnnotationPathways(all.genes.entrez, db = which.annotation.db, ontology = "BP", species = which.species)

```


```{r gsea enrichment, warning = FALSE}

library(fgsea)

# get pathways relevant to current gene set
gse.pathway.combined <- NULL
gse.pathway.list <- list()

# single.path.of.interest <- NULL

plt.enrichment <- list()

# specify analysis parameters
if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db::org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db::org.Mm.eg.db
}



# start cluster
if (n.workers$gsea > ncol(logfc.mat)) n.workers$gsea <- ncol(logfc.mat)
cl <- parallel::makeCluster(n.workers$gsea)
doParallel::registerDoParallel(cl)

score.results <- foreach(i = 1:ncol(logfc.mat), .packages = c("fgsea", "plyr"))  %dopar% {
  
  # for (i in 1:length(enrich.groups)){
  
  # gene.list <- (df2enrich[, enrich.groups[i]])
  gene.list <- logfc.mat[ ,i]
  names(gene.list) <- rownames(logfc.mat)
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  
  suppressMessages({gse.pathway <- fgsea(pathways.subset, gene.list.clean, nperm=1000, maxSize=500) })
  
  if (nrow(gse.pathway) == 0) {
    return(list(out1 = NULL,
                out2 = NULL))
  } else {
    
    gse.pathway$query <- colnames(logfc.mat)[i]
      gse.pathway.filtered <- gse.pathway[((gse.pathway$pval < 0.01) & (abs(gse.pathway$NES) > 1.5)), ]
    
    if (nrow(gse.pathway.filtered) == 0) {
      
          return(list(out1 = NULL,
                out2 = NULL))
      
    } else {
    
    # make human readable (map entrez to symbol)
    gse.pathway.filtered.orig <- gse.pathway.filtered
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$leadingEdge, 
                                       mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
    gse.pathway.filtered$set <- lapply(gse.pathway.filtered$set, paste,collapse = ", ")
    gse.pathway.filtered$query <-colnames(logfc.mat)[i]
    
    
    # sig figs for numerics
    gse.pathway.filtered$ES <- signif(gse.pathway.filtered$ES, 3)
    gse.pathway.filtered$NES <- signif(gse.pathway.filtered$NES, 3)
    gse.pathway.filtered$pval <- signif(gse.pathway.filtered$pval, 3)
    gse.pathway.filtered$padj <- signif(gse.pathway.filtered$padj, 3)
    
    # filter and rearrange columns
    gse.pathway.cur <- gse.pathway.filtered[ ,c("query", "pathway", "size", "ES", "NES", "pval", "padj", "set")]
    
        return(list(out1 = gse.pathway.cur,
                out2 = gse.pathway))
    
    }
  }
  
} 

# stop workers
parallel::stopCluster(cl)

for (i in 1: ncol(logfc.mat)){
  pair.name <- colnames(logfc.mat)[i]
  gse.pathway.list[[pair.name]] <- score.results[[i]]$out1
}

```


```{r plot enrichment patterns, include = FALSE, fig.width=8, fig.height=8}

library(ggnewscale)


# combine enrichments
gsea.path.all <- NULL
for (i in 1:length(gse.pathway.list)){
  gsea.path.all <- bind_rows(gsea.path.all, gse.pathway.list[[i]])
}

# parse out cluster IDs
clust.list <- strsplit(gsea.path.all$query, "-")
clust.1 <- unlist(lapply(clust.list, function(x) x[[1]]))
clust.2 <- unlist(lapply(clust.list, function(x) x[[2]]))
gsea.path.all$cluster.1 <- as.integer(gsub("c", "",clust.1))
gsea.path.all$cluster.2 <- as.integer(gsub("c", "",clust.2))

# tally GSEA counts
gsea.tally <- data.frame(table(gsea.path.all$pathway))
plt.gsea.tally <- gsea.tally %>%
  ggplot(aes(x = Freq)) + 
  geom_histogram() + 
  theme_miko()
if (print.inline) print(plt.gsea.tally) 


# align trajectories with cluster centers
which.center <- "mean"
df.umap <- data.frame(so.query@reductions[["umap"]]@cell.embeddings)
df.umap$cluster <- so.query@meta.data[["seurat_clusters"]]
colnames(df.umap) <- c("x","y", "cluster")
df.umap.centers <- getClusterCenters(df.umap, which.center)

# get entrez to symbol mappings
e2s <-  my.entrez$SYMBOL
names(e2s) <-  my.entrez$ENTREZID


# get top enrichments
gsea.path.all$logp <- -1*log10(gsea.path.all$pval)
gsea.path.all$score <- sqrt((abs(gsea.path.all$NES)^2) + (abs(gsea.path.all$logp)^2))

top.gsea <- gsea.path.all %>%
  group_by(cluster.1, cluster.2) %>%
  top_n(1, score)

gsea.tally.solo <- unique(as.character(gsea.tally$Var1[gsea.tally$Freq < 3]))
top.solo.gsea <- gsea.path.all %>%
  dplyr::filter(pathway %in% gsea.tally.solo) %>%
  group_by(cluster.1, cluster.2) %>%
  top_n(1, score)

top.gsea.all <- bind_rows(top.gsea, top.solo.gsea)

gene.list <- top.gsea.all$set
top.gsea.all <- top.gsea.all[which(unlist(lapply(gene.list, function(x) length(unlist(strsplit(x, ",")))))>5), ]


top.gsea.u <- unique(c(top.gsea$pathway, top.solo.gsea$pathway))

# GSVA enrichment
paths.sig <- pathways.subset[which(names(pathways.subset) %in% top.gsea.u)]
for (j in 1:length(paths.sig)){
  paths.sig[[j]] <- e2s[paths.sig[[j]]]
  paths.sig[[j]] <- paths.sig[[j]][!is.na(paths.sig[[j]])]
}

  # gsva enrichment
  gsva.enrich.all <- gsva(e.mat, paths.sig)
  colnames(gsva.enrich.all) <-  as.character(gsub("c", "",colnames(gsva.enrich.all)))
  
  if (do.schex){
    so.query <- schex::make_hexbin(so.query, nbins = 40, 
                                   dimension_reduction = "UMAP")
    plt.hex <- schex::plot_hexbin_meta(so.query, col = "seurat_clusters", action = "majority", na.rm = T) +
      theme_miko(legend = T)
    plt.hex.v2 <- plt.hex
    plt.hex.v2[["plot_env"]][["drhex"]] <- NULL
    plt.hex.v2 <- plt.hex.v2 + labs(fill = "Cluster")
  }

gsea.cluster.plot.list <- list()
df.pos.all <- NULL
for (j in 1:length(top.gsea.u)){

  # get current pathway
  cur.pathway <- top.gsea.u[j]
  gsea.path.current <- gsea.path.all[gsea.path.all$pathway %in% cur.pathway, ]

  # get gsva enrichment
  gsva.enrich <- t(as.matrix(gsva.enrich.all[rownames(gsva.enrich.all) %in% cur.pathway, ]))
  rownames(gsva.enrich) <- cur.pathway
  colnames(gsva.enrich) <- colnames(gsva.enrich.all)

  # get positions and edges
  df.edges <- NULL
  df.positions <- NULL
  
  show.sig.only <- F
  for (i in 1:nrow(gsea.path.current)){
    
    source.cluster <- which(df.umap.centers$cluster %in% gsea.path.current$cluster.1[i])
    destination.cluster <- which(df.umap.centers$cluster %in% gsea.path.current$cluster.2[i])
    df.edges <- bind_rows(df.edges, 
                          data.frame(x1 = df.umap.centers$x.center[source.cluster],
                                     y1 = df.umap.centers$y.center[source.cluster],
                                     x2 = df.umap.centers$x.center[destination.cluster],
                                     y2 = df.umap.centers$y.center[destination.cluster],
                                     NES = gsea.path.current$NES[i],
                                     p = gsea.path.current$pval[i]))  
    
    if (show.sig.only){
      
      df.positions <- bind_rows(df.positions, 
                                data.frame(x = df.umap.centers$x.center[source.cluster], 
                                           y = df.umap.centers$y.center[source.cluster],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in%
                                                                 df.umap.centers$cluster[source.cluster]]),
                                data.frame(x = df.umap.centers$x.center[destination.cluster], 
                                           y = df.umap.centers$y.center[destination.cluster],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in%
                                                                 df.umap.centers$cluster[destination.cluster]]))
    }
  }
  
  if (!show.sig.only){
    for (i in 1:nrow(df.umap.centers)){
      current.cluster <- df.umap.centers$cluster[i]
      df.positions <- bind_rows(df.positions, 
                                data.frame(cluster = current.cluster,
                                           x = df.umap.centers$x.center[i], 
                                           y = df.umap.centers$y.center[i],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in% current.cluster]))
    }
  }
  
  df.edges$logp <- -1*log10(df.edges$p)
  df.positions <- unique(df.positions)
  
  df.pos.all <- bind_rows(df.pos.all, bind_cols(data.frame(path = cur.pathway), df.positions))
  
  
  if (do.schex){
    
    

    
    gsea.cluster.plot <-  plt.hex.v2 + theme_miko(legend = F)  + 
      new_scale_color() +
      geom_segment(
      data = df.edges,
      aes(x = x1, y = y1, xend = x2, yend = y2,  color = logp),
      size = if (length(unique(df.edges$logp)) == 1) 1 else rescaleValues(df.edges$logp, 0.05, 0.25)*4,
      show.legend = FALSE, inherit.aes = FALSE
      ) + 
      scale_colour_gradient(low = "grey", high = "black") +
       new_scale_fill() +
      geom_point(data = df.positions, aes(x, y, fill = gsva ),size = 6, alpha = 1 , pch=21, inherit.aes = FALSE) +
      labs(x = "UMAP 1", y = "UMAP 2", title = cur.pathway, subtitle = "Segments: NES (significant)\nDot: GSVA scores") + 
      theme_bw() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
      scale_fill_gradient2(low = scales::muted("blue"), mid = "white", high = scales::muted("red"))
    
  } else {

  gsea.cluster.plot <-  ggplot() +   
    geom_point(data = df.umap, 
               aes(x, y, color = cluster),
               size = 1) +
     new_scale_color() +
    geom_segment(
      data = df.edges,
      aes(x = x1, y = y1, xend = x2, yend = y2,  color = logp),
      size = if (length(unique(df.edges$logp)) == 1) 1 else rescaleValues(df.edges$logp, 0.05, 0.25)*4,
      show.legend = FALSE
    ) +
    scale_colour_gradient(low = "grey", high = "black") + 
    geom_point(data = df.positions, aes(x, y, fill = gsva),size = 6, alpha = 1 , pch=21) +
    labs(x = "UMAP 1", y = "UMAP 2", title = cur.pathway, subtitle = "Segments: NES (significant)\nDot: GSVA scores") +
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
      scale_fill_gradient2(low = scales::muted("blue"), mid = "white", high = scales::muted("red")) 
  
  }

  if (print.inline) print(gsea.cluster.plot)
  
  gsea.cluster.plot.list[[cur.pathway]] <- gsea.cluster.plot
  
}

names(gsea.cluster.plot.list) <- make.unique(stringr::str_trunc(names(gsea.cluster.plot.list), 20)) 


# gsea.cluster.plot.list
```

```{r, fig.width = 14, fig.height = 10, include = FALSE}

# wrangle gsva data
df.path <- df.pos.all[ ,c("path", "cluster", "gsva")]
df.path.wide <- as.data.frame(pivot_wider(df.path, values_from = "gsva", names_from = "cluster"))
rownames(df.path.wide) <- df.path.wide$path
df.path.wide <- df.path.wide %>% dplyr::select(-c("path"))
rownames(df.path.wide) <- make.unique(stringr::str_trunc(rownames(df.path.wide), 20)) 

# get pathway profile similarities
path.cor <- cor(t(df.path.wide))
plt.path.sim <- ggplotify::as.ggplot(pheatmap::pheatmap(path.cor, show_colnames = F, 
                                                        main = "Pathway GSVA Similarities"))

if (print.inline) print(plt.path.sim)

# get cluster vs. pathway similarities
plt.path.gsva <- ggplotify::as.ggplot(pheatmap::pheatmap(df.path.wide, show_colnames = T, 
                                                         main = "Cluster x Pathway GSVA Scores"))

if (print.inline) print(plt.path.gsva)


#reorder umap plots
gsea.cluster.plot.list <- gsea.cluster.plot.list[plt.path.sim[["plot_env"]][["plot"]][["tree_row"]][["order"]]]

# gsea.cluster.plot.list
# gsea.cluster.plot.list
```
```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M29", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M29_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```

UMAP
===================================== 

```{r plt.umap_by_c}
print(plt.umap.final)
savePDF(file.name = paste0(output.path, "PDF/", "M29_umap_cluster.pdf"), plot.handle = plt.umap.final,
        fig.width = 5, fig.height = 5, save.flag = save.pdf)
```




```{r plt.dot}

# Dot
# ===================================== 
# print(plt.dot)

```


N DEG
===================================== 

```{r plt.n.deg, fig.height=8, fig.width=10}

if (run.deg) {
  print(plt.n.deg)
  savePDF(file.name = paste0(output.path, "PDF/", "M29_n_deg_heatmap.pdf"), plot.handle = plt.n.deg,
        fig.width = 10, fig.height = 8, save.flag = save.pdf)
}

```

Pathway Clusters
===================================== 

Row {.tabset}
-------------------------------------

### Pathway Similarity

```{r pathway similarity plot, fig.width = 14, fig.height = 10}

print(plt.path.sim)

savePDF(file.name = paste0(output.path, "PDF/", "M29_pathway_similarity_heatmap.pdf"), plot.handle = plt.path.sim,
        fig.width = 14, fig.height = 10, save.flag = save.pdf)

```

### GSVA Scores

```{r pathway gsva plot, fig.width = 14, fig.height = 10}

print(plt.path.gsva)

savePDF(file.name = paste0(output.path, "PDF/", "M29_cluster_x_gsva_heatmap.pdf"), plot.handle = plt.path.gsva,
        fig.width = 14, fig.height = 10, save.flag = save.pdf)

```

### GSEA Tally

```{r pathway gsva tally}

plt.gsea.tally <- plt.gsea.tally + 
  xlab("Pathway Significant N Times")+ 
  ylab("Count") + labs(title = "N Pathway Differentials")

print(plt.gsea.tally)

savePDF(file.name = paste0(output.path, "PDF/", "M29_gsea_tally.pdf"), plot.handle = plt.gsea.tally,
        fig.width = 7, fig.height = 5, save.flag = save.pdf)

```


Pathway Patterns
===================================== 

Row {.tabset}
-------------------------------------

```{r plot pathway patterns}

out <- lapply(seq_along(gsea.cluster.plot.list), function(i) {
  
  s1 <- names(gsea.cluster.plot.list)[i]
  s2 <- paste0("gsea.cluster.plot.list[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 8, fig.height=8, message=FALSE, warning=FALSE}", 
                                          paste("pathpat", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save path patterns,include = FALSE}

try({
  for (i in 1:length(gsea.cluster.plot.list)){
    plot.name <- paste0("M12_UMAP_pathDiff_", names(gsea.cluster.plot.list)[i] ,".pdf")

    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = gsea.cluster.plot.list[[i]], 
            fig.width = 8, fig.height=8, save.flag = save.pdf)
  } 
}, silent = T)


```


DEG table
=====================================

```{r deg.res.all}

if (run.deg) {
  
  rownames(deg.res.all) <- NULL
  datatable(deg.res.all,
            filter = 'top',
            extensions = 'Buttons',
            options = list(pageLength = 50,
                           dom = 'Bfrtip',
                           buttons = c('copy', 'csv', 'pdf')))   
}

```

```{r save DEG table}

try({
  write.csv(deg.res.all, file = paste0(output.path, "Tables/", "pairwise_cluster_DEGs.csv"), 
    row.names = F)  
}, silent = T)

```

GSEA table
===================================== 

Row {.tabset}
-------------------------------------

```{r gsea.res.all}

 out_enrich_table <- flex.multiTabTables(gse.pathway.list, "gse.pathway.list")

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`

```{r finalize log}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)

df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log_Module_29 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}

try({
  out1 <- flex.multiTabLogs(module.logs)
}, silent = T)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 29)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_29)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_29, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```


```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}


```
