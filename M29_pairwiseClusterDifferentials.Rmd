---
title: "Pairwise Cluster Differentials"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("scMiko", "Seurat", "sctransform", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "MAST", "future", "cluster", "doParallel", "parallel", "foreach", "GSVA")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))


```


```{r parameter specification}

# data input ###################################################################

# Query input
# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "R189_M01_NM2_p12_Meso_061020.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "R117_M27_NM2_M02_p467891011_Immune_tier2_160920.Rdata"
# input.file <- "R111_M27_NM2_M02_p467891011_tumorImmune_tier1_150920.Rdata"
# input.file <- "R65_M01_NM2_p11_neural_DIV7_270820.Rdata"
# input.file <- "R71_M01_NM2_p10_CGR8_310820.Rdata"
input.file <- "R73_M02_NM2_M02_neuroDif_p41011_010920.Rdata"

# data prep parameters #########################################################

# specify cluster resolution
cluster.resolution <- 0.5

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)

# specify species
which.species <- "Hs"

# annotation databases #########################################################
which.annotation.db <- "GO"    # Reactome, GO, Bader, msigdb

# msigdb collection specification (see getAnnotationPathways() for options)
# arguments are ignored if which.annotation.db is not msigdb. 
which.msigdb.collection <- "C3"
which.msigdb.subcollection <- "TFT"

# analysis parameters ##########################################################
# DEG ANALYSIS #####################################################

# Rapid marker finding (logical flag)
quick_markers <- F 

# which markers to return
only.pos <- F# 

# DEG test
DEG.test <- "MAST" #options: wilcox, bimod, roc, t, poisson, negbinom, LR, MAST, DESeq2

# vector specifying pairwise comparisons of interest (cluster id); set to NA for all comparisons
# which.clusters <- c(1,5)
which.clusters <- NA


# if which.clusters specified, evaluate all query-clusters pairs (T) or restrict analysis to queries only (F)
all.cluster.query.pairs <- T  # options: T (recommended), F (recommended if specific pair)

# Misc. ############################################################
do.schex <- T

# print inline
print.inline <- FALSE

# max number of paths to visualize (if exceeding, top paths are randomly sampled)
max.paths <- 75 # recommended: 80

# specify number of workers (for parallelization)
n.workers <- list(
  deg = 3,   # DEG analysis
  gsea = 6 # GSEA analysis
)

gsea.p.threshold <- 0.05
gsea.NES.threshold <- 1

# set seed
seed <- 1095

# save PDF
save.pdf <- T


```



```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# set seed (for sampling downstream)
set.seed(seed)

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so.query, objects())

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species = which.species, resolution= cluster.resolution, subset = NULL, 
                         subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = c("ica", "tsne", "nmf", "corr", "gsva", "deg"), rmv.pattern = "so", keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```

```{r analysis log}

# specify whether DEG is performed (optional)
run.deg <- T

# check input
if (!all.cluster.query.pairs) {
  if ((!is.na(which.clusters)) && (length(which.clusters) < 2)) {
    stop("More than one cluster must be specified in 'which.cluster' parameter\n")
  }
}

# Module
df.log <- initiateLog("29, Pairwise Cluster Differentials")
df.log <- addLogEntry("Query File (.Rdata)", (input.file), df.log, "input.file")
df.log <- addLogEntry("Default Assay", (current.assay), df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", (cluster.resolution), df.log, "cluster.resolution")

if (is.na(which.clusters)){
  df.log <- addLogEntry("Pairwise cluster comparisons", ("all"), df.log, "which.clusters")
  df.log <- addLogEntry("All pairwise comparisons", TRUE, df.log, "all.cluster.query.pairs")
} else {
  df.log <- addLogEntry("Pairwise cluster comparisons", (which.clusters), df.log, "which.clusters")
  df.log <- addLogEntry("All pairwise comparisons", all.cluster.query.pairs, df.log, "all.cluster.query.pairs")
}

df.log <- addLogEntry("Subsample Factor", (subsample_factor), df.log, "subsample_factor")
df.log <- addLogEntry("Quick DEG analysis", (quick_markers), df.log, "quick_markers")
df.log <- addLogEntry("schex binning", (do.schex), df.log, "do.schex")
df.log <- addLogEntry("Species", (which.species), df.log, "which.species")
df.log <- addLogEntry("Enrichment DB", (which.annotation.db), df.log, "which.annotation.db")
df.log <- addLogEntry("DEG performed", (run.deg), df.log, "run.deg")
df.log <- addLogEntry("N workers (GSEA)", (n.workers$gsea), df.log, "gsea")
df.log <- addLogEntry("N workers (DEG)", (n.workers$deg), df.log, "deg")
df.log <- addLogEntry("Only positive DEGs", (only.pos), df.log, "only.pos")
df.log <- addLogEntry("DEG test", (DEG.test), df.log, "DEG.test")
df.log <- addLogEntry("Max number of paths to visualize", (max.paths), df.log, "max.paths")
df.log <- addLogEntry("Seed", (seed), df.log, "seed")
df.log <- addLogEntry("gsea.p.threshold", (gsea.p.threshold), df.log, "gsea.p.threshold")
df.log <- addLogEntry("gsea.NES.threshold", (gsea.NES.threshold), df.log, "gsea.NES.threshold")




```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r pairwise differential gene expression}

# get clusters
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)

# filter clusters 
if (!all.cluster.query.pairs){
  if (exists("which.clusters") && !is.na(which.clusters)){
    u.clust <- u.clust[u.clust %in% which.clusters]
  } 
}

# get all unique pairwise cluster combinations
all.pair.combos <- base::expand.grid(u.clust,u.clust)
all.pair.ordered <- NULL
for (i in 1:nrow(all.pair.combos)){
  current.pair <- c(all.pair.combos[i,]$Var1, all.pair.combos[i,]$Var2)
  if (current.pair[1] - current.pair[2] == 0){
    next
  } else if  (current.pair[1] > current.pair[2] ){
    hold.1 <- current.pair[1]
    current.pair[1] <- current.pair[2]
    current.pair[2] <- hold.1
  }
  
  all.pair.ordered <- bind_rows(all.pair.ordered, data.frame(cluster.1 = current.pair[1], cluster.2 = current.pair[2]))
}
all.pair.ordered.u <- unique(all.pair.ordered)

if (all.cluster.query.pairs){
  if (exists("which.clusters") && !is.na(which.clusters)){
    match.1 <- all.pair.ordered.u$cluster.1 %in% which.clusters
    match.2 <- all.pair.ordered.u$cluster.2 %in% which.clusters
    which.match <- which(match.1|match.2)
    all.pair.ordered.u <- all.pair.ordered.u[which.match, ]
  } 
}


cluster.membership <- as.numeric(as.character(so.query@meta.data[["seurat_clusters"]]))
cell.names <- colnames(so.query)

# log fold change threshold
lfc.threshold <- 1

# p.value threshold <- p.threshold
p.threshold <- 0.01

if (run.deg){
  
  # start cluster
  if (n.workers$deg > nrow(all.pair.ordered.u)) n.workers$deg <-nrow(all.pair.ordered.u)
  cl <- parallel::makeCluster(n.workers$deg)
  doParallel::registerDoParallel(cl)
  
  deg.results <- list()
  deg.results <- foreach(j = 1:nrow(all.pair.ordered.u), .packages = c("Seurat", "dplyr"), .errorhandling = 'remove')  %dopar% {
    # for (j in 1:nrow(all.pair.ordered.u)){
    
    # try({
      
    clust.i.name <- paste0("c", all.pair.ordered.u$cluster.1[j])
    clust.j.name <- paste0("c", all.pair.ordered.u$cluster.2[j])
    which.cells.i <- cell.names[cluster.membership %in% all.pair.ordered.u$cluster.1[j]]
    which.cells.j <- cell.names[cluster.membership %in% all.pair.ordered.u$cluster.2[j]]
    
    deg.res <- NULL
    
      
      if (quick_markers == TRUE){
        deg.res <- FindMarkers(object = so.query, 
                               ident.1 = all.pair.ordered.u$cluster.1[j], ident.2 = all.pair.ordered.u$cluster.2[j], 
                               test.use = DEG.test,
                               only.pos = only.pos,
                               max.cells.per.ident = 200,
                               logfc.threshold = lfc.threshold,
                               min.pct = 0.25)
        deg.res$pct.dif <- deg.res$pct.1 - deg.res$pct.2
        deg.res <- deg.res %>% dplyr::filter(p_val_adj < p.threshold)
        
      } else {
        deg.res <- FindMarkers(object = so.query, 
                               ident.1 = all.pair.ordered.u$cluster.1[j], ident.2 = all.pair.ordered.u$cluster.2[j], 
                               test.use = DEG.test,
                               only.pos = only.pos,
                               logfc.threshold = 0.01,
                               min.pct = 0.01)  
        deg.res$pct.dif <- deg.res$pct.1 - deg.res$pct.2
        deg.res <- deg.res %>% dplyr::filter(p_val_adj < p.threshold)
      }
      
    # }, silent = T)
    
    if (!is.null(deg.res)){
      
      # try({
        pair.name <- paste0(clust.i.name, "-", clust.j.name)
        deg.res$pair <-pair.name
        deg.res <- bind_cols(data.frame(genes = rownames(deg.res)), deg.res)
        return(list(deg.res = deg.res, pair.name = pair.name, clust.i.name = clust.i.name, clust.j.name = clust.j.name))
      # }, silent = T)
    } else {
      return(list(deg.res = NULL, pair.name = NULL, clust.i.name = NULL, clust.j.name = NULL))
    }
    
    
  }
  
  # stop workers
  parallel::stopCluster(cl)
  
  deg.res.all <- NULL
  for (i in 1:length(deg.results)){
    deg.res <- deg.results[[i]]$deg.res
    if (is.null(deg.res)) next
    clust.i.name <- deg.results[[i]]$clust.i.name
    clust.j.name <- deg.results[[i]]$clust.j.name
    pair.name <- deg.results[[i]]$pair.name
    deg.res$cluster.1 <- clust.i.name
    deg.res$cluster.2 <- clust.j.name
    deg.res.all <- bind_rows(deg.res.all, deg.res)   
  }
  which.round <- c("p_val", "avg_logFC","pct.1","pct.2","p_val_adj","pct.dif")
  deg.res.all[ , which.round]<- signif(deg.res.all[ , which.round], 3)
  
}

```

```{r}


plt.umap.final <- DimPlot(so.query, reduction = "umap", 
                          label = T, 
                          group.by = "seurat_clusters")  + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
  labs(title = "UMAP", subtitle = "clusters") + theme_miko() 

if (print.inline) print(plt.umap.final)
```

```{r n deg sim matrix, include = FALSE}

if (run.deg){
  
  # count number of differential genes
  n.deg.mat <- matrix(ncol = length(u.clust), nrow = length(u.clust))
  c.1 <- gsub("c", "", deg.res.all$cluster.1)
  c.2 <- gsub("c", "", deg.res.all$cluster.2)
  for (i in 1:length(u.clust)){
    
    # no difference with self
    n.deg.mat[i,i] <- 0
    
    # get current cluster comparisons
    keep.which <- c.1 %in% u.clust[i] |  c.1 %in% u.clust[i]
    current.deg <- deg.res.all[keep.which, ]
    u.p <- unique(current.deg$pair)
    
    for (j in 1:length(u.p)){
      current.deg.2 <- current.deg[current.deg$pair %in% u.p[j], ]
      cj.1 <- gsub("c", "", current.deg.2$cluster.1)
      cj.2 <- gsub("c", "", current.deg.2$cluster.2)
      
      which.i <- which(u.clust %in% unique(cj.1))
      which.j <- which(u.clust %in% unique(cj.2))
      
      n.deg.mat[which.i, which.j] <- nrow(current.deg.2)
      n.deg.mat[which.j, which.i] <- nrow(current.deg.2)
    }
  }
  
  # if na, set to 0 (no differentials found)...conditional on all.cluster.query.pairs
  if (!all.cluster.query.pairs){
    n.deg.mat[is.na(n.deg.mat)] <- 0
  } 
  
  colnames(n.deg.mat) <- paste0("c", u.clust)
  rownames(n.deg.mat) <- paste0("c", u.clust)
  plt.n.deg <- ggplotify::as.ggplot(pheatmap::pheatmap(n.deg.mat, 
                                                       main = "DEG Counts\nlow DEG ~ high similarity (yellow); 
                                                     high DEG ~ low similarity (blue)",
                                                     color = rev(viridis::viridis(20)))) 
  
  if (print.inline) print(plt.n.deg)
  
} else {
  plt.n.deg <- NULL
}

```



```{r cluster differentials NEW}

# get expression  matrix
ef.mat <- so.query@assays[[DefaultAssay(so.query)]]@data
sc.meta <- so.query@meta.data[["seurat_clusters"]]
u.clust <- getOrderedGroups(so.query, which.group = "seurat_clusters", is.number = T)
u.clust.all <- u.clust

# filter clusters 
if (exists("which.clusters") && !is.na(which.clusters)){
  u.clust <- u.clust[u.clust %in% which.clusters]
  if (!all.cluster.query.pairs) u.clust.all <- u.clust.all[u.clust.all %in% which.clusters]
}

# initiate empty matrices
logfc.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust) * length(u.clust.all))
pct.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust) * length(u.clust.all))
e.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust.all))
f.mat <- matrix(nrow = nrow(ef.mat), ncol = length(u.clust.all))

# get cluster-level aggregate scores
current.index <- 1
pair.name <- c()
for (i in 1:length(u.clust.all)){
  which.cells.i <- sc.meta %in% u.clust.all[i]
  
  f1 <- rowMeans(ef.mat[, which.cells.i] > 0)
  f.mat[ ,i] <- f1
  
  e1 <- log(rowMeans(expm1(x = ef.mat[, which.cells.i])) + 1)
  e.mat[ ,i] <- e1
  
  for (j in 1:length(u.clust)){
    which.cells.j <- sc.meta %in% u.clust[j]
    
    # log data expression
    e2 <- log(rowMeans(expm1(x = ef.mat[, which.cells.j])) + 1)
    logfc.mat[ ,current.index] <- e1 - e2
    
    current.index <- current.index + 1
    pair.name <- c(pair.name, paste0("c", u.clust.all[i], "-", "c", u.clust[j]))
  }
  
}

colnames(logfc.mat) <- pair.name
colnames(e.mat) <-   colnames(f.mat) <-  paste0("c", u.clust.all)
rownames(e.mat) <-  rownames(logfc.mat) <-  rownames(f.mat) <- rownames(ef.mat)

# get rid of self-compariosns
which.same <- apply(logfc.mat, 2, function(x) sum(x) == 0)
logfc.mat <- logfc.mat[ ,!which.same]

```


```{r pairwise-DEG heatmaps, include = FALSE, fig.height = 8, fig.width = 8}

all.pairs <- unique(deg.res.all$pair)

so.clust <- as.numeric(as.character(so.query@meta.data[["seurat_clusters"]])) 

n.cells <- 100

plt.deg.map <- list()

for (i in 1:length(all.pairs)){
  
  current.pair <- all.pairs[i]
  current.pair.split <- strsplit(current.pair, "-")
  cluster.1 <- current.pair.split[[1]][1]; cluster.1 <- as.numeric(gsub("c", "", cluster.1))
  cluster.2 <- current.pair.split[[1]][2]; cluster.2 <- as.numeric(gsub("c", "", cluster.2))
  doi <- deg.res.all[deg.res.all$pair %in% current.pair, ]
  doi <- doi %>%
    group_by(sign(avg_logFC)) %>%
    top_n(25, abs(avg_logFC))
  if (nrow(doi) == 0) next
  
  which.1 <- which(so.clust %in% cluster.1);
  if (length(which.1) > n.cells){
    which.1 <- sample(which.1, n.cells, replace = F)
  } else {
    which.1 <- c(which.1, sample(which.1,n.cells - length(which.1), replace = T))
  }
  
  which.2 <- which(so.clust %in% cluster.2);
  if (length(which.2) > n.cells){
    which.2 <- sample(which.2, n.cells, replace = F)
  } else {
    which.2 <- c(which.2, sample(which.2,n.cells - length(which.2) , replace = T))
  }
  
  ef.mat.genesub <- ef.mat[rownames(ef.mat) %in% doi$genes, ]
  if (is.null(dim(ef.mat.genesub))) {
    next
    # ef.mat.genesub <- t(as.matrix(ef.mat.genesub))
    # rownames(ef.mat.genesub) <- doi$genes
  }
  clust.1.emat <- (ef.mat.genesub[ ,which.1]);  colnames(clust.1.emat) <- make.unique(colnames(clust.1.emat))
  clust.2.emat <- ef.mat.genesub[ ,which.2]; colnames(clust.2.emat) <- make.unique(colnames(clust.2.emat))
  emat.current <- cbind(clust.1.emat, clust.2.emat)
  
  df.ann <- bind_rows(data.frame(cluster = rep(paste0("c", cluster.1), dim(clust.1.emat)[2]), row.names = colnames(clust.1.emat)),
                      data.frame(cluster = rep(paste0("c", cluster.2), dim(clust.1.emat)[2]), row.names = colnames(clust.2.emat)))
  
  ann.color = list(cluster =  c("black", "grey"))
  names(ann.color$cluster) <- c(paste0("c", cluster.1), paste0("c", cluster.2))
  
  plt.pairwise.deg.map <- ggplotify::as.ggplot(pheatmap::pheatmap(emat.current, 
                                                                  show_colnames = F, 
                                                                  color = viridis::inferno(20), 
                                                                  annotation_col = df.ann,
                                                                  annotation_colors = ann.color,
                                                                  main = paste0(current.pair)))
  
  if (print.inline) print(plt.pairwise.deg.map)
  
  plt.deg.map[[current.pair]] <- plt.pairwise.deg.map
  
}

```


```{r get pathays, warning = FALSE}


all.genes <- rownames(logfc.mat)

# get symbol to entrez mapping
my.symbol <- as.vector(all.genes)
my.entrez <- sym2entrez(my.symbol, my.species = which.species )
my.entrez <- my.entrez[complete.cases(my.entrez), ]

match.ind <- match(all.genes, my.entrez$SYMBOL)
all.genes.entrez <- as.character(my.entrez$ENTREZID[match.ind]) 

if ((!exists("which.msigdb.collection")) || is.null(which.msigdb.collection)) which.msigdb.collection <- "H"
if (!exists("which.msigdb.subcollection")) which.msigdb.subcollection <- NULL

pathways.subset <- getAnnotationPathways(all.genes.entrez, db = which.annotation.db, 
                                         ontology = "BP", species = which.species, 
                                         msigdb.collection = which.msigdb.collection,
                                         msigdb.subcollection = which.msigdb.subcollection)

```


```{r gsea enrichment, warning = FALSE}

library(fgsea)

# get pathways relevant to current gene set
gse.pathway.combined <- NULL
gse.pathway.list <- list()

plt.enrichment <- list()

# specify analysis parameters
if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db::org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db::org.Mm.eg.db
}

# start cluster
if (n.workers$gsea > ncol(logfc.mat)) n.workers$gsea <- ncol(logfc.mat)
cl <- parallel::makeCluster(n.workers$gsea)
doParallel::registerDoParallel(cl)

score.results <- foreach(i = 1:ncol(logfc.mat), .packages = c("fgsea", "plyr"))  %dopar% {
  
  gene.list <- logfc.mat[ ,i]
  names(gene.list) <- rownames(logfc.mat)
  match.ind <- match(names(gene.list), my.entrez$SYMBOL)
  names(gene.list) <- as.character(my.entrez$ENTREZID[match.ind])
  gene.list = sort(gene.list, decreasing = TRUE)
  
  # clean list
  df.ent <- data.frame(names = names(gene.list), values = as.vector(gene.list))
  df.ent <- df.ent[complete.cases(df.ent), ]
  df.ent <- df.ent[!is.infinite(df.ent$values), ]
  gene.list.clean <- df.ent$values
  names(gene.list.clean) <- df.ent$names
  
  suppressMessages({gse.pathway <- fgsea(pathways.subset, gene.list.clean, nperm=1000, maxSize=500) })
  
  if (nrow(gse.pathway) == 0) {
    return(list(out1 = NULL,
                out2 = NULL))
  } else {
    
    gse.pathway$query <- colnames(logfc.mat)[i]
    gse.pathway.filtered <- gse.pathway[((gse.pathway$pval < gsea.p.threshold) & (abs(gse.pathway$NES) > gsea.NES.threshold)), ]
    
    if (nrow(gse.pathway.filtered) == 0) {
      
      return(list(out1 = NULL,
                  out2 = NULL))
    } else {
      
      # make human readable (map entrez to symbol)
      gse.pathway.filtered.orig <- gse.pathway.filtered
      gse.pathway.filtered$set <- lapply(gse.pathway.filtered$leadingEdge, 
                                         mapvalues,from = my.entrez$ENTREZID, to = my.entrez$SYMBOL)
      gse.pathway.filtered$set <- lapply(gse.pathway.filtered$set, paste,collapse = ", ")
      gse.pathway.filtered$query <-colnames(logfc.mat)[i]
      
      # sig figs for numerics
      gse.pathway.filtered$ES <- signif(gse.pathway.filtered$ES, 3)
      gse.pathway.filtered$NES <- signif(gse.pathway.filtered$NES, 3)
      gse.pathway.filtered$pval <- signif(gse.pathway.filtered$pval, 6)
      gse.pathway.filtered$padj <- signif(gse.pathway.filtered$padj, 6)
      
      # filter and rearrange columns
      gse.pathway.cur <- gse.pathway.filtered[ ,c("query", "pathway", "size", "ES", "NES", "pval", "padj", "set")]
      
      return(list(out1 = gse.pathway.cur,
                  out2 = gse.pathway))
    }
  }
} 

# stop workers
parallel::stopCluster(cl)

for (i in 1: ncol(logfc.mat)){
  pair.name <- colnames(logfc.mat)[i]
  gse.pathway.list[[pair.name]] <- score.results[[i]]$out1
}

```


```{r plot enrichment patterns, include = FALSE, fig.width=8, fig.height=8}

library(ggnewscale)

# combine enrichments
gsea.path.all <- NULL
for (i in 1:length(gse.pathway.list)){
  if (class(gse.pathway.list[[i]]$set) == "list") gse.pathway.list[[i]]$set <- as.character(gse.pathway.list[[i]]$set)
  gsea.path.all <- bind_rows(gsea.path.all, gse.pathway.list[[i]])
}

# parse out cluster IDs
clust.list <- strsplit(gsea.path.all$query, "-")
clust.1 <- unlist(lapply(clust.list, function(x) x[[1]]))
clust.2 <- unlist(lapply(clust.list, function(x) x[[2]]))
gsea.path.all$cluster.1 <- as.integer(gsub("c", "",clust.1))
gsea.path.all$cluster.2 <- as.integer(gsub("c", "",clust.2))

# tally GSEA counts
gsea.tally <- data.frame(table(gsea.path.all$pathway))
plt.gsea.tally <- gsea.tally %>%
  ggplot(aes(x = Freq)) + 
  geom_histogram() + 
  theme_miko()
if (print.inline) print(plt.gsea.tally) 

# align trajectories with cluster centers
which.center <- "mean"
df.umap <- data.frame(so.query@reductions[["umap"]]@cell.embeddings)
df.umap$cluster <- so.query@meta.data[["seurat_clusters"]]
colnames(df.umap) <- c("x","y", "cluster")
df.umap.centers <- getClusterCenters(df.umap, which.center)

# filter clusters 
if (exists("which.clusters") && !is.na(which.clusters)){
  df.umap.centers <- df.umap.centers[df.umap.centers$cluster %in% unique(c(u.clust, u.clust.all)), ]
}


# get entrez to symbol mappings
e2s <-  my.entrez$SYMBOL
names(e2s) <-  my.entrez$ENTREZID

# get top enrichments
gsea.path.all$logp <- -1*log10(gsea.path.all$pval)
gsea.path.all$score <- sqrt((abs(gsea.path.all$NES)^2) + (abs(gsea.path.all$logp)^2))

# pos scores
gsea.path.all <- gsea.path.all %>% dplyr::arrange(-(score))
which.dup <- duplicated(gsea.path.all$pathway)
gsea.path.all.nodup <- gsea.path.all[!(which.dup), ]
gsea.path.all.pos <- gsea.path.all.nodup[gsea.path.all.nodup$NES > 0, ]
gsea.path.all.neg <- gsea.path.all.nodup[gsea.path.all.nodup$NES < 0, ]

gsea.path.all.pos.top <- gsea.path.all.pos[seq(1,(max.paths/2)), ]
gsea.path.all.neg.top <- gsea.path.all.neg[seq(1,(max.paths/2)), ]

top.gsea.all <- bind_rows(gsea.path.all.pos.top, gsea.path.all.neg.top)
top.gsea.u <- unique(top.gsea.all$pathway)

# GSVA enrichment
paths.sig <- pathways.subset[which(names(pathways.subset) %in% top.gsea.u)]
for (j in 1:length(paths.sig)){
  paths.sig[[j]] <- e2s[paths.sig[[j]]]
  paths.sig[[j]] <- paths.sig[[j]][!is.na(paths.sig[[j]])]
}

# gsva enrichment
gsva.enrich.all <- gsva(e.mat, paths.sig)
colnames(gsva.enrich.all) <-  as.character(gsub("c", "",colnames(gsva.enrich.all)))
max.gsva <- max(gsva.enrich.all, na.rm = T); min.gsva <- min(gsva.enrich.all, na.rm = T)
scale.limits <- max(c(abs(max.gsva), abs(min.gsva)))

if (do.schex){
  
  og <- getOrderedGroups(so.query)
  so.query@meta.data[["seurat_clusters"]] <- factor(so.query@meta.data[["seurat_clusters"]], levels = og)
  
  so.query <- schex::make_hexbin(so.query, nbins = 40, 
                                 dimension_reduction = "UMAP")
  plt.hex <- schex::plot_hexbin_meta(so.query, col = "seurat_clusters", action = "majority", na.rm = T) +
    theme_miko(legend = T) 
  plt.hex[["mapping"]][["alpha"]]<- 0.5
  
  plt.hex.v2 <- plt.hex
  plt.hex.v2[["plot_env"]][["drhex"]] <- NULL
  plt.hex.v2 <- plt.hex.v2 + labs(fill = "Cluster")
}

gsea.cluster.plot.list <- list()
df.pos.all <- NULL
for (j in 1:length(top.gsea.u)){
  
  # get current pathway
  cur.pathway <- top.gsea.u[j]
  gsea.path.current <- gsea.path.all[gsea.path.all$pathway %in% cur.pathway, ]
  
  # get gsva enrichment
  gsva.enrich <- t(as.matrix(gsva.enrich.all[rownames(gsva.enrich.all) %in% cur.pathway, ]))
  if (dim(gsva.enrich)[2] == 0) next
  if (dim(gsva.enrich)[1] > 1) gsva.enrich <- t(gsva.enrich[ ,1])
  rownames(gsva.enrich) <- cur.pathway
  colnames(gsva.enrich) <- colnames(gsva.enrich.all)
  
  # get positions and edges
  df.edges <- NULL
  df.positions <- NULL
  
  show.sig.only <- F
  for (i in 1:nrow(gsea.path.current)){
    source.cluster <- which(df.umap.centers$cluster %in% gsea.path.current$cluster.1[i])
    destination.cluster <- which(df.umap.centers$cluster %in% gsea.path.current$cluster.2[i])
    df.edges <- bind_rows(df.edges, 
                          data.frame(x1 = df.umap.centers$x.center[source.cluster],
                                     y1 = df.umap.centers$y.center[source.cluster],
                                     x2 = df.umap.centers$x.center[destination.cluster],
                                     y2 = df.umap.centers$y.center[destination.cluster],
                                     NES = gsea.path.current$NES[i],
                                     p = gsea.path.current$pval[i]))  
    if (show.sig.only){
      
      df.positions <- bind_rows(df.positions, 
                                data.frame(x = df.umap.centers$x.center[source.cluster], 
                                           y = df.umap.centers$y.center[source.cluster],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in%
                                                                 df.umap.centers$cluster[source.cluster]]),
                                data.frame(x = df.umap.centers$x.center[destination.cluster], 
                                           y = df.umap.centers$y.center[destination.cluster],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in%
                                                                 df.umap.centers$cluster[destination.cluster]]))
    }
  }
  if (!show.sig.only){
    for (i in 1:nrow(df.umap.centers)){
      current.cluster <- df.umap.centers$cluster[i]
      df.positions <- bind_rows(df.positions, 
                                data.frame(cluster = current.cluster,
                                           x = df.umap.centers$x.center[i], 
                                           y = df.umap.centers$y.center[i],
                                           gsva = gsva.enrich[ ,colnames(gsva.enrich) %in% current.cluster]))
    }
  }
  df.edges$logp <- -1*log10(df.edges$p)
  df.positions <- unique(df.positions)
  
  df.pos.all <- bind_rows(df.pos.all, bind_cols(data.frame(path = cur.pathway), df.positions))
  
  
  if (do.schex){
    
    gsea.cluster.plot <-  plt.hex.v2 + theme_miko(legend = F)  + 
      new_scale_color() +
      geom_segment(
        data = df.edges,
        aes(x = x1, y = y1, xend = x2, yend = y2,  color = logp),
        size = if (length(unique(df.edges$logp)) == 1) 1 else rescaleValues(df.edges$logp, 0.05, 0.25)*4,
        show.legend = FALSE, inherit.aes = FALSE
      ) + 
      scale_colour_gradient(low = "grey", high = "black") +
      new_scale_fill() +
      geom_point(data = df.positions, aes(x, y, fill = gsva ),size = 6, alpha = 1 , pch=21, inherit.aes = FALSE) +
      labs(x = "UMAP 1", y = "UMAP 2", title = cur.pathway, subtitle = "Segments: NES (significant)\nDot: GSVA scores") + 
      theme_bw() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
      scale_fill_gradient2(low = scales::muted("blue"), mid = "white", high = scales::muted("red"), 
                           limits = c(-1*scale.limits,scale.limits))
    
  } else {
    
    gsea.cluster.plot <-  ggplot() +   
      geom_point(data = df.umap, 
                 aes(x, y, color = cluster),
                 size = 1) +
      new_scale_color() +
      geom_segment(
        data = df.edges,
        aes(x = x1, y = y1, xend = x2, yend = y2,  color = logp),
        size = if (length(unique(df.edges$logp)) == 1) 1 else rescaleValues(df.edges$logp, 0.05, 0.25)*4,
        show.legend = FALSE
      ) +
      scale_colour_gradient(low = "grey", high = "black") + 
      geom_point(data = df.positions, aes(x, y, fill = gsva),size = 6, alpha = 1 , pch=21) +
      labs(x = "UMAP 1", y = "UMAP 2", title = cur.pathway, subtitle = "Segments: NES (significant)\nDot: GSVA scores") +
      theme_bw() +
      theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
      scale_fill_gradient2(low = scales::muted("blue"), mid = "white", high = scales::muted("red"), 
                           limits = c(-1*scale.limits,scale.limits)) 
  }
  
  if (print.inline) print(gsea.cluster.plot)
  gsea.cluster.plot.list[[cur.pathway]] <- gsea.cluster.plot
  
}

# gsea.cluster.plot.list
```

```{r, fig.width = 14, fig.height = 10, include = FALSE}

# wrangle gsva data
df.path <- df.pos.all[ ,c("path", "cluster", "gsva")]
df.path.wide <- as.data.frame(pivot_wider(df.path, values_from = "gsva", names_from = "cluster"))
rownames(df.path.wide) <- df.path.wide$path
df.path.wide <- df.path.wide %>% dplyr::select(-c("path"))

# get pathway profile similarities
path.cor <- cor(t(df.path.wide))
rownames(path.cor) <- make.unique(stringr::str_trunc(rownames(path.cor), 50)) 
plt.path.sim <- ggplotify::as.ggplot(pheatmap::pheatmap(path.cor, show_colnames = F, 
                                                        main = "Pathway GSVA Similarities",
                                                        border_color = NA))

if (print.inline) print(plt.path.sim)

# get cluster vs. pathway similarities
rownames(df.path.wide) <- make.unique(stringr::str_trunc(rownames(df.path.wide), 50)) 
plt.path.gsva <- ggplotify::as.ggplot(pheatmap::pheatmap(df.path.wide, show_colnames = T, 
                                                         main = "Cluster x Pathway GSVA Scores",
                                                         border_color = NA))

if (print.inline) print(plt.path.gsva)


#reorder umap plots
gsea.cluster.plot.list <- gsea.cluster.plot.list[plt.path.sim[["plot_env"]][["plot"]][["tree_row"]][["order"]]]

names(gsea.cluster.plot.list) <- make.unique(stringr::str_trunc(names(gsea.cluster.plot.list), 25)) 

# gsea.cluster.plot.list
```

```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M29", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M29_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```

UMAP
===================================== 

```{r plt.umap_by_c}
print(plt.umap.final)
savePDF(file.name = paste0(output.path, "PDF/", "M29_umap_cluster.pdf"), plot.handle = plt.umap.final,
        fig.width = 5, fig.height = 5, save.flag = save.pdf)
```


N DEG
===================================== 

```{r plt.n.deg, fig.height=8, fig.width=10}

if (run.deg) {
  print(plt.n.deg)
  savePDF(file.name = paste0(output.path, "PDF/", "M29_n_deg_heatmap.pdf"), plot.handle = plt.n.deg,
          fig.width = 10, fig.height = 8, save.flag = save.pdf)
}

```


Pairwise-DEG Heatmaps
===================================== 
Top differentially-expressed genes for each pairwise comparison are visualized. Values are normalized expression data and only a subset of cells are shown.  

Row {.tabset}
-------------------------------------

```{r paired deg maps}

out <- lapply(seq_along(plt.deg.map), function(i) {
  
  s1 <- names(plt.deg.map)[i]
  s2 <- paste0("plt.deg.map[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 8, fig.height=8, message=FALSE, warning=FALSE}", 
                                          paste("degmap", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save paired deg maps,include = FALSE}

try({
  for (i in 1:length(plt.deg.map)){
    plot.name <- paste0("M29_Paired_Deg_Map_", names(plt.deg.map)[i] ,".pdf")
    
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = plt.deg.map[[i]], 
            fig.width = 8, fig.height=8, save.flag = save.pdf)
  } 
}, silent = T)


```

Pathway Clusters
===================================== 

Row {.tabset}
-------------------------------------

### Pathway Similarity {.tabset .tabset-dropdown}

```{r pathway similarity plot, fig.width = 14, fig.height = 10}

print(plt.path.sim)

savePDF(file.name = paste0(output.path, "PDF/", "M29_pathway_similarity_heatmap.pdf"), plot.handle = plt.path.sim,
        fig.width = 14, fig.height = 10, save.flag = save.pdf)

```

### GSVA Scores

```{r pathway gsva plot, fig.width = 14, fig.height = 10}

print(plt.path.gsva)

savePDF(file.name = paste0(output.path, "PDF/", "M29_cluster_x_gsva_heatmap.pdf"), plot.handle = plt.path.gsva,
        fig.width = 14, fig.height = 10, save.flag = save.pdf)

```

### GSEA Tally

```{r pathway gsva tally}

plt.gsea.tally <- plt.gsea.tally + 
  xlab("Pathway Significant N Times")+ 
  ylab("Count") + labs(title = "N Pathway Differentials")

print(plt.gsea.tally)

savePDF(file.name = paste0(output.path, "PDF/", "M29_gsea_tally.pdf"), plot.handle = plt.gsea.tally,
        fig.width = 7, fig.height = 5, save.flag = save.pdf)

```


Pathway Patterns
===================================== 

Row {.tabset .tabset-dropdown}
-------------------------------------

```{r plot pathway patterns}

out <- lapply(seq_along(gsea.cluster.plot.list), function(i) {
  
  s1 <- names(gsea.cluster.plot.list)[i]
  s2 <- paste0("gsea.cluster.plot.list[[", i, "]]")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width = 8, fig.height=8, message=FALSE, warning=FALSE}", 
                                          paste("pathpat", i, sep = "")))
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

```{r save path patterns,include = FALSE}

try({
  for (i in 1:length(gsea.cluster.plot.list)){
    plot.name <- paste0("M29_UMAP_pathDiff_", names(gsea.cluster.plot.list)[i] ,".pdf")
    
    savePDF(file.name = paste0(output.path, "PDF/", plot.name), 
            plot.handle = gsea.cluster.plot.list[[i]], 
            fig.width = 8, fig.height=8, save.flag = save.pdf)
  } 
}, silent = T)


```


DEG table
=====================================

```{r deg.res.all}

if (run.deg) {
  
  rownames(deg.res.all) <- NULL
  datatable(deg.res.all,
            filter = 'top',
            extensions = 'Buttons',
            options = list(pageLength = 50,
                           dom = 'Bfrtip',
                           buttons = c('copy', 'csv', 'pdf')))   
}

```

```{r save DEG table}

try({
  write.csv(deg.res.all, file = paste0(output.path, "Tables/", "pairwise_cluster_DEGs.csv"), 
            row.names = F)  
}, silent = T)

```

GSEA table
===================================== 

Row {.tabset}
-------------------------------------

```{r gsea.res.all}

out_enrich_table <- flex.multiTabTables(gse.pathway.list, "gse.pathway.list")

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`

```{r finalize log}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)

df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log_Module_29 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}

try({
  out1 <- flex.multiTabLogs(module.logs)
}, silent = T)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 29)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_29)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_29, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
            row.names = F)  
}, silent = T)

```


```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}


```
