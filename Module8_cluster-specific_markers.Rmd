---
title: "Module8_cluster-specific_markers"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "ddpcr", "readxl", "MAST", "future")

# load packages
lapply(packages2load, library, character.only = TRUE)


```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
  }

```

```{r parameter specification}

# Specify data directories
dir.preprocessed <- "Preprocessed Datasets/"
dir.markers <- "Marker Datasets/"

# Query input
# input.file <- "Module2_p1345_all_differentiation_070220.Rdata"
# input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"
input.file <- "Module2_p3_p5_renca_tumor_integration_270120.Rdata"
input.file <- "Module1_p4_neural_differentiation_300120.Rdata"

# Rapid marker finding (logical flag)
quick_markers <- TRUE 

# specify cluster resolution
cluster_resolution <- c(0.15)

# print inline
print.inline <- FALSE

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)

# which markers to return
only.pos <- FALSE # FALSE recommended if doing downstream functional enrichment

# DEG test
DEG.test <- "MAST" #options: wilcox, bimod, roc, t, poisson, negbinom, LR, MAST, DESeq2


# Barcode Field
barcode.field = "Barcode" # used to stratify DEG as well (good for comparing experimental conditions)

# specify save flag (saves .RData and .xlsx files)
save.Rdata.flag <- T
Rdata.filename <- "Module8_markers_p3_p5_renca_tumor_integrated_110220"

save.xlsx.flag <- T # DO NOT RUN ON MAC
xlsx.filename <- Rdata.filename

```


```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("11, Cluster Markers")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)

# Rapid Cluster Marker Search
df.log[nrow(df.log)+1, 1] <- as.character("Rapid Marker Find")
df.log[nrow(df.log), 2] <- as.character("quick_markers")
df.log[nrow(df.log), 3] <- as.character(quick_markers)

# Only Positive Markers
df.log[nrow(df.log)+1, 1] <- as.character("Positive Markers Only")
df.log[nrow(df.log), 2] <- as.character("only.pos")
df.log[nrow(df.log), 3] <- as.character(only.pos)

# Differentially expressed genes test
df.log[nrow(df.log)+1, 1] <- as.character("DEG test")
df.log[nrow(df.log), 2] <- as.character("DEG.test")
df.log[nrow(df.log), 3] <- as.character(DEG.test)

# Cluster Resolution
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution")
df.log[nrow(df.log), 2] <- as.character("cluster_resolution")
if (length(cluster_resolution) > 1){
  df.log[nrow(df.log), 3] <- paste(cluster_resolution, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(cluster_resolution)
}

df.log[nrow(df.log)+1, 1] <- as.character("Figures Printed in Notebook")
df.log[nrow(df.log), 2] <- as.character("print.inline")
df.log[nrow(df.log), 3] <- as.character(print.inline)

df.log[nrow(df.log)+1, 1] <- as.character("Save Rdata")
df.log[nrow(df.log), 2] <- as.character("save.Rdata.flag")
df.log[nrow(df.log), 3] <- as.character(save.Rdata.flag)

# Output file
if (save.Rdata.flag){
  df.log[nrow(df.log)+1, 1] <- as.character("Rdata File Output")
  df.log[nrow(df.log), 2] <- as.character("Rdata.filename")
  df.log[nrow(df.log), 3] <- as.character(Rdata.filename)
}

df.log[nrow(df.log)+1, 1] <- as.character("Save xlsx")
df.log[nrow(df.log), 2] <- as.character("save.xlsx.flag")
df.log[nrow(df.log), 3] <- as.character(save.xlsx.flag)

if (save.xlsx.flag){
  df.log[nrow(df.log)+1, 1] <- as.character("xlsx File Output")
  df.log[nrow(df.log), 2] <- as.character("xlsx.filename")
  df.log[nrow(df.log), 3] <- as.character(xlsx.filename)
}

```



```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```

```{r load data}
# load data
load(paste(dir.preprocessed, input.file, sep = ""))

so <- fix.barcode.label(so)
so.query <- so
rm(so)

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r prep gene list}

# TODO drop .N suffix in ensembl IDs

if (exists("gNames.list_master")){
  gNames.list <- NULL
  for (i in 1:length(gNames.list_master)){
    gNames.list <- c(gNames.list, gNames.list_master[[i]] )
  }
  
  # gNames.df <-  data.frame(n = as.vector(names(gNames.list)), g = as.vector(gNames.list))
  gNames.df <-  data.frame(n = gsub("\\..*","",as.vector(names(gNames.list))), g = as.vector(gNames.list))
  gNames.df <- unique(gNames.df)
  gNames.list <- as.vector(gNames.df$g)
  names(gNames.list) <- as.vector(gNames.df$n)
} 

# ensure gene list is available
stopifnot(exists("gNames.list"))
```


```{r cluster data}

# initiate list to store cluster plots
plt.umap_by_cluster <- list()
cluster.name <- c()

# cluster data and generate cluster-stratified UMAPs
plan(strategy = "multisession", workers = parallel::detectCores())
options(future.globals.maxSize = (20480 * 1024^2) )
  
for (i in 1:length(cluster_resolution)) {
  so.query <- FindClusters(object = so.query, resolution = cluster_resolution[i], verbose = 0, algorithm = 1, modularity.fxn = 1)
  
  cluster.name[i] <- paste(DefaultAssay(so.query),"_snn_res.", cluster_resolution[i], sep = "")
  plt.umap_by_cluster[[as.character(cluster_resolution[i])]] <- DimPlot(so.query, reduction = "umap", group.by = cluster.name[i], label = TRUE)  + 
    ggtitle(label = paste("Resolution: ", cluster_resolution[i], sep = "")) + 
    xlab("UMAP 1") + 
    ylab("UMAP 2")
  
  if (print.inline){
    print(plt.umap_by_cluster[[i]])
  }
  # Lung_UMAP_res0_15
  
}

# generate barcode-stratified UMAP
plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = barcode.field)  + ggtitle(label = "UMAP") + xlab("UMAP 1") + ylab("UMAP 2")
plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_barcode

if (print.inline){
  print(plt.umap_by_barcode)
}

cr_names <- c(cluster_resolution, "barcodes")
```


```{r function for long to wide annotation table}

long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster_membership ~ predicted_labels, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster_membership)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster_membership
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```


```{r}

# alternative function to plot cluster composition
plot.cluster_composition_alt <- function(df.cluster_annotations, other_threshold = 0.05, set_color = 2, lab_color = NULL, label_order = NULL){
  levels(df.cluster_annotations$predicted_labels) <- c(levels(df.cluster_annotations$predicted_labels), "other")
  df.cluster_annotations$predicted_labels[df.cluster_annotations$freq < other_threshold] <- as.character("other")
  
  # create graph to visualize representation across clusters
  u_predictions <- unique(df.cluster_annotations$predicted_labels)
  n_subgroups <- length(u_predictions)
  
  if (is.null(lab_color)){
    color_count <- max(n_subgroups)
    my_cols = colorRampPalette(brewer.pal(8, paste("Set", set_color, sep = "")))(color_count)
  } else {
    my_cols <- lab_color
  }
  
  if (is.null(label_order)){
    label_order <- unique(df.cluster_annotations$predicted_labels)
  } 
  
  
  # ensure that clusters are ordered numerically
  reordered_clusters <- order(as.numeric(as.vector(df.cluster_annotations$cluster_membership)))
  df.cluster_annotations <- df.cluster_annotations[reordered_clusters, ]
  df.cluster_annotations$cluster_membership <- as.numeric(as.vector(df.cluster_annotations$cluster_membership))
  cluster_chart_labels <- unique(df.cluster_annotations$cluster_membership)
  
  plt.cluster_composition <- ggplot(df.cluster_annotations, aes(x = cluster_membership, fill = factor(predicted_labels, levels = label_order), y = freq)) +
    geom_bar(position = "fill", stat = "identity") + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    xlab("Cluster ID") + ylab("Cluster Representation") + ggtitle("Cluster Annotations")
  
  return(plt.cluster_composition)
}

```


```{r cluster composition by barcode}



# function to get cluster composition by barcode
cluster_barcode_composition <- function(so.query, cluster_res_label = "", cluster_label = "seurat_clusters"){
  
  # get barcode labels and clusters
  cluster_membership <- as.vector(so.query@meta.data[[cluster_label]])
  barcode_labels <- as.vector(so.query@meta.data[[barcode.field]])
  df.bar_codes <- data.frame(cluster_membership, barcode_labels)
  
  # tally up cluster compositions
  df.all_barcodes <- df.bar_codes %>% group_by(cluster_membership, barcode_labels) %>%
    tally() %>% mutate(freq = n / sum(n)) 
  
  u_barcodes <- unique(df.all_barcodes$barcode_labels)
  
  if (length(u_barcodes) > 1) {
    
    # convert long to wide (cell type table)
    df_for_wide_barcodes <- df.all_barcodes
    colnames(df_for_wide_barcodes)[colnames(df_for_wide_barcodes) == "barcode_labels"] <- "predicted_labels"
    df.all_barcodes_wide <- long2wide(df_for_wide_barcodes)
    
    # plot cluster compositio by barcode
    df.cluster_annotations_barcodes <- df.all_barcodes
    colnames(df.cluster_annotations_barcodes)[colnames(df.cluster_annotations_barcodes) == "barcode_labels"] <- "predicted_labels"
    
    plt.cluster_composition_barcodes <- plot.cluster_composition_alt(df.cluster_annotations_barcodes, 
                                                                     other_threshold = 0)
  } else {
    df_for_wide_barcodes <- data.frame()
    df.all_barcodes_wide <- data.frame()
    df.cluster_annotations_barcodes <- data.frame()
    plt.cluster_composition_barcodes <- c()
  }
  
  output <- list(df_for_wide_barcodes, df.all_barcodes_wide, df.cluster_annotations_barcodes, plt.cluster_composition_barcodes)
  names(output) <- c(paste("df_for_wide_barcodes_res", cluster_res_label, sep = ""),
                     paste("df.all_barcodes_wide_res", cluster_res_label, sep = ""),
                     paste("df.cluster_annotations_barcodes_res", cluster_res_label, sep = ""),
                     paste("plt.cluster_composition_barcodes_res", cluster_res_label, sep = ""))
  return(output)
}


# get cluster composition by barcode
for (i in 1:length(cluster_resolution)){
  output.barcode <- cluster_barcode_composition(so.query, cluster_res_label = cluster_resolution[i], cluster_label = cluster.name[i])
  quiet(list2env(output.barcode, env = environment()), all = TRUE)  
}

```


```{r gene representation}

# check what format genes are represented in (ensembl or symbol)
check.gene_rep <- function(cur_gene.list, cur_rep){
  
  ensembl_rep <- sum(as.vector(names(cur_gene.list)) %in% cur_rep)
  symbol_rep <- sum(toupper(as.vector(cur_gene.list)) %in% toupper(cur_rep))
  
  if (ensembl_rep > symbol_rep){
    gene.rep <- "ensembl"
  } else if (symbol_rep > ensembl_rep){
    gene.rep <- "symbol"
  } else {
    gene.rep <- NA
  }
  
  return(gene.rep)
  
}
```


```{r function to convert ENSEMBLE to SYMBOL}

# for input dataframe, converts ENSEMBLE to SYMBOL (gene symbols)
ens2sym <- function(so, gNames.list){
  
  # var features
  so_ens <- so@assays[["SCT"]]@var.features
  so@assays[["SCT"]]@var.features <- as.vector((gNames.list[so_ens]))
  
  # scale data
  so_sd <- so@assays[["SCT"]]@scale.data
  rownames(so_sd) <-  as.vector((gNames.list[rownames(so_sd)]))
  so@assays[["SCT"]]@scale.data <- so_sd
  
  # data
  so_d <- so@assays[["SCT"]]@data
  rownames(so_d) <-  as.vector((gNames.list[rownames(so_d)]))
  so@assays[["SCT"]]@data <- so_d
  
  # pca feature loading
  so_pc <-  so@reductions[["pca"]]@feature.loadings
  rownames(so_pc) <-  as.vector((gNames.list[rownames(so_pc)]))
  so@reductions[["pca"]]@feature.loadings <- so_pc
  
  
  if (DefaultAssay(so) == "integrated"){
    
    # var features
    so_ens <- so@assays[["integrated"]]@var.features
    so@assays[["integrated"]]@var.features <- as.vector((gNames.list[so_ens]))
    
    # scale data
    so_sd <- so@assays[["integrated"]]@scale.data
    rownames(so_sd) <-  as.vector((gNames.list[rownames(so_sd)]))
    so@assays[["integrated"]]@scale.data <- so_sd
    
    # data
    so_d <- so@assays[["integrated"]]@data
    rownames(so_d) <-  as.vector((gNames.list[rownames(so_d)]))
    so@assays[["integrated"]]@data <- so_d
  }
  return(so)
}





```


```{r check gene rep and convert if necessary}

# check.gene_rep <- function(cur_gene.list, cur_rep)

current.assay <- DefaultAssay(so.query)
gene.rep <- check.gene_rep(gNames.list, as.vector(rownames(so.query@assays[[current.assay]]@scale.data)))
if (gene.rep == "ensembl"){
  so.query <- ens2sym(so.query, gNames.list)
}
  
```


```{r find query markers}

# initiate list to store cluster markers
query_markers.list <- list()

# store current identities
cur_idents <- Idents(so.query)
so.markers <- so.query

# find cluster-specific markers
# plan(strategy = "multisession", workers = parallel::detectCores())
# options(future.globals.maxSize = (20480 * 1024^2) )

for (i in 1:length(cluster_resolution)){
  Idents(so.markers) <- so.markers@meta.data[[cluster.name[i]]]
  
  if (quick_markers == TRUE){
    query_markers.list[[as.character(cluster_resolution[i])]] <- FindAllMarkers(so.markers, 
                                                            assay = DefaultAssay(so.markers),
                                                            slot = "data",
                                                            only.pos = only.pos, 
                                                            min.pct = 0.25,
                                                            test.use = DEG.test,
                                                            logfc.threshold = 0.5, 
                                                            max.cells.per.ident = 200)
  } else if (quick_markers == FALSE){
    query_markers.list[[as.character(cluster_resolution[i])]]  <- FindAllMarkers(so.markers, 
                                                            assay = DefaultAssay(so.markers),
                                                            slot = "data",
                                                             only.pos = only.pos, 
                                                             min.pct = 0.01, 
                                                             test.use = DEG.test,
                                                             logfc.threshold = 0.01)
  }
  
  
  query_markers.list[[as.character(cluster_resolution[i])]]  <- query_markers.list[[as.character(cluster_resolution[i])]] %>%
    group_by(cluster) %>%
    arrange(desc(avg_logFC))
  
  query_markers.list[[as.character(cluster_resolution[i])]]$cluster <- as.character(query_markers.list[[as.character(cluster_resolution[i])]]$cluster)
  
}

# find differentially expressed barcode markers 
Idents(so.markers) <- so.query@meta.data[[barcode.field]]

if (quick_markers == TRUE){
  barcode_markers <- FindAllMarkers(so.markers, 
                                    assay = DefaultAssay(so.markers),
                                    slot = "data",
                                    only.pos = only.pos, 
                                    min.pct = 0.25, 
                                    test.use = DEG.test,
                                    logfc.threshold = 0.5, 
                                    max.cells.per.ident = 200)
} else if (quick_markers == FALSE){
  barcode_markers  <- FindAllMarkers(so.markers, 
                                     assay = DefaultAssay(so.markers),
                                     slot = "data",
                                     only.pos = only.pos, 
                                     min.pct = 0.01, 
                                     test.use = DEG.test,
                                     logfc.threshold = 0.01)
}

```



```{r, make wide, warning = FALSE }


make.wide <- function(u_clusters, top_markers, n_top_markers, rename_clusters = TRUE){
  top_markers_wide <- data.frame()
  
  top_marker_clusters <- as.vector(top_markers$cluster)
  for (i in 1:length(u_clusters)){
    
    top_markers_current <- top_markers$gene[top_marker_clusters == u_clusters[i]]
    n_markers_cur <- length(top_markers_current)
    
    if (!(n_markers_cur >= n_top_markers)){
      top_markers_current <- c(top_markers_current, rep(NA, n_top_markers-n_markers_cur))
    }
    
    top_markers_wide[seq(1, n_top_markers), c(paste("c", u_clusters[i], sep = ""))] <- as.data.frame(top_markers_current)
    if (!rename_clusters){
      colnames(top_markers_wide)[i] <- u_clusters[i]
    }
  }
  
  return(top_markers_wide)
}


```



```{r NEW 1 get top markers function}



# function to get top cluster-specific markers
get.topmarkers <- function(query.markers, n_top_markers = 10, cluster_res_label = "", rename_clusters = TRUE){
  
  # all top markers
  top_markers <- query.markers %>% 
    group_by(cluster) %>% 
    arrange(desc(avg_logFC)) 
  
  top_markers_filter <- top_markers[ , c("cluster", "gene")]
  
  top_marker.tally <- top_markers_filter %>%
    group_by(cluster) %>%
    tally()
  max.n <- max(top_marker.tally$n)
  
  if (is.na(unique(as.numeric(as.character(top_markers_filter$cluster))))){
    top_markers_filter$cluster <- as.character(top_markers_filter$cluster)
  } else {
    top_markers_filter$cluster <- as.numeric(as.character(top_markers_filter$cluster))
  }
  
  
  if (rename_clusters)  top_markers$cluster <- paste("c", as.character(top_markers$cluster), sep = "")
  top_markers$p_val <- signif( top_markers$p_val, 3)
  top_markers$p_val_adj <- signif( top_markers$p_val_adj, 3)
  top_markers$avg_logFC <- signif( top_markers$avg_logFC, 3)
  
  u_clusters <- as.vector(unique(top_markers_filter$cluster))
  u_clusters <- u_clusters[order(u_clusters)]
  
  top_markers_wide <- make.wide(u_clusters, 
                                top_markers = top_markers_filter, 
                                n_top_markers = max.n, 
                                rename_clusters = rename_clusters)
  
  # top 50 
  top_markers_50 <- query.markers %>% 
    group_by(cluster) %>% 
    arrange(desc(avg_logFC)) %>%
    top_n(n = 50, wt = avg_logFC)
  
  top_markers_50_filter <- top_markers_50[ , c("cluster", "gene")]

    if (is.na(unique(as.numeric(as.character(top_markers_50_filter$cluster))))){
    top_markers_50_filter$cluster <- as.character(top_markers_50_filter$cluster)
  } else {
    top_markers_50_filter$cluster <- as.numeric(as.character(top_markers_50_filter$cluster))
  }
  
  if (rename_clusters) top_markers_50$cluster <- paste("c", as.character(top_markers_50$cluster), sep = "")
  top_markers_50$p_val <- signif( top_markers_50$p_val, 3)
  top_markers_50$p_val_adj <- signif( top_markers_50$p_val_adj, 3)
  top_markers_50$avg_logFC <- signif( top_markers_50$avg_logFC, 3)
  
  u_clusters <- as.vector(unique(top_markers_50_filter$cluster))
  u_clusters <- u_clusters[order(u_clusters)]
  
  top_markers_50_wide <- make.wide(u_clusters, top_markers = top_markers_50_filter, n_top_markers = 50, rename_clusters = rename_clusters)
  
  # top 5
  top5_markers <- query.markers %>% 
    group_by(cluster) %>% 
    arrange(desc(avg_logFC)) %>%
    top_n(n = 5, wt = avg_logFC)
  
  
  # assign outputs to list and return
  output <- list(top_markers, top_markers_50, top_markers_wide, top_markers_50_wide, top5_markers)
  names(output) <- c("top_markers_res",
                     "top_markers_50_res",
                     "top_markers_wide_res",
                     "top_markers_50_wide_res",
                     "top5_markers_res")
  return(output)
}

```


```{r NEW 2, get top cluster markers, warning = FALSE }

# get top markers
which.res2rmv <- c()
top_markers_res.list <- list()         
top_markers_50_res.list <- list()      
top_markers_wide_res.list <- list()    
top_markers_50_wide_res.list <- list() 
top5_markers_res.list <- list()  

for (i in 1:length(query_markers.list)){
  if (length( query_markers.list[[i]]) == 0) {
    which.res2rmv <- c(which.res2rmv, cluster_resolution[i])
    next
  }
  output.markers <- get.topmarkers(query.markers = query_markers.list[[i]], cluster_res_label = cluster_resolution[i])
  
  top_markers_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_res"]])     
  top_markers_50_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_res"]])     
  top_markers_wide_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_wide_res"]])   
  top_markers_50_wide_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top_markers_50_wide_res"]])
  top5_markers_res.list[[as.character(cluster_resolution[i])]] <- as.data.frame(output.markers[["top5_markers_res"]])

}

# omit resolution where no DEGs were observed
cluster_resolution <-cluster_resolution[!(cluster_resolution  %in% which.res2rmv)]


if (exists("barcode_markers")){
    output.markers <- get.topmarkers(query.markers = barcode_markers, cluster_res_label = barcode.field, rename_clusters =  F)
  
  top_markers_res.list[["barcode_markers"]] <- as.data.frame(output.markers[["top_markers_res"]])     
  top_markers_50_res.list[["barcode_markers"]] <- as.data.frame(output.markers[["top_markers_50_res"]])     
  top_markers_wide_res.list[["barcode_markers"]] <- as.data.frame(output.markers[["top_markers_wide_res"]])   
  top_markers_50_wide_res.list[["barcode_markers"]] <- as.data.frame(output.markers[["top_markers_50_wide_res"]])
  top5_markers_res.list[["barcode_markers"]] <- as.data.frame(output.markers[["top5_markers_res"]])
  
  
}



```


```{r downsample function}

# downsample data if necessary
downsample_cells <- function(so.query, cluster.name, n.downsample = 500){
  
  cluster_id <- as.vector(so.query@meta.data[[cluster.name]])
  u_clusters <- unique(cluster_id)
  
  n_per_cluster <- round(n.downsample / length(u_clusters))
  
  cells_to_plot <- c()
  for (i in 1:length(u_clusters)){
    
    cell_to_sample <- Cells(so.query)[cluster_id == u_clusters[i]]
    if (length(cell_to_sample) < n_per_cluster){
      cells_to_plot <-  c(cells_to_plot, cell_to_sample)
    } else {
      cells_to_plot <-  c(cells_to_plot, sample(Cells(so.query)[cluster_id == u_clusters[i]], n_per_cluster, replace = FALSE))
    }
  }
  
  so.query_small <- SubsetData(object = so.query, cells = cells_to_plot)
  return(so.query_small)
}

```

```{r heatmap, message=FALSE, warning=FALSE, include=FALSE}




plt.heatmap <- list()

# generate heatmap
for (i in 1:length(cluster_resolution)){
  Idents(so.query) <- so.query@meta.data[[cluster.name[i]]]
  so.query_small <- downsample_cells(so.query = so.query, cluster.name = cluster.name[i])
  
  # group genes by cluster (not by avg logfc)
  cur.markers <- top5_markers_res.list[[as.character(cluster_resolution[i])]]
  
  cur.markers <- cur.markers %>% arrange((cluster))
  cur.features <- cur.markers$gene
  
  plt.heatmap[[as.character(cluster_resolution[i])]] <- DoHeatmap(so.query_small, 
                                                                  size = 5, 
                                                                  features = cur.features,
                                                                  draw.lines = F) + 
    NoLegend() + 
    theme(text = element_text(size = 7)) + 
    scale_fill_gradientn(colors = rev(brewer.pal(11,"RdYlBu")))
  
  
  if (print.inline){
    print(plt.heatmap[[i]])
  }
  
}

# add barcode-level heatmap

try({
  Idents(so.query) <- so.query@meta.data[[barcode.field]]
  so.query_small <- downsample_cells(so.query = so.query, cluster.name = barcode.field)
  plt.heatmap[[barcode.field]] <- DoHeatmap(so.query_small, 
                                                        size = 5, 
                                                        features = unique(top5_markers_res.list[["barcode_markers"]]$gene),
                                                        draw.lines = T) + 
    NoLegend() + 
    theme(text = element_text(size = 7)) + 
    scale_fill_gradientn(colors = rev(brewer.pal(11,"RdYlBu")))
  
  if (print.inline){
    print(plt.heatmap[[((length(plt.heatmap)))]])
  }
  
}, silent = TRUE)

if (length(plt.heatmap) != (length(cluster_resolution) + 1)){
  plt.heatmap[[barcode.field]] <- NULL
}


```

```{r get umap markers}

# function to plot cluster-specific markers on UMAP
plot.cluster_markers_umap <- function(so.query, u_clusters, query.markers, cluster_field,  top_n_genes = 5, gNames.list = gNames.list){
  
  # generate list to store plots
  plt.clustermarkers_by_umap <- list()
  
  
  query.markers$cluster <- as.numeric(query.markers$cluster)

  # Get top differentially expressed genes by cluster 
  top_genes_by_cluster<-(query.markers %>% 
                           arrange(desc(avg_logFC)) %>%
                           group_by(cluster) %>% 
                           top_n(top_n_genes, avg_logFC)) # highest fold-change 
  
  top_genes_by_cluster <- top_genes_by_cluster[c("cluster", "gene")]

  # add order for top 5 genes 
  top_genes_by_cluster <- top_genes_by_cluster %>%
    group_by(cluster) %>%
    mutate(repn = seq(1, length(gene)))
  
  
  top_genes_by_cluster <- spread(top_genes_by_cluster, repn, gene)
  
  these_clusters <- as.numeric(as.character(top_genes_by_cluster$cluster))
  
  these_clusters <- these_clusters[order(these_clusters)]
  
  # plot top differentially expressed genes per cluster and compare to cluster membership
  for (i in 1:length(top_genes_by_cluster$cluster)) {# iterate through each cluster
    
    
    # empty list where plts will be stored
    all_plts <- list()
    
    # plot1: cluster membership (UMAP)
    all_plts[[1]] <- DimPlot(so.query, reduction = "umap", label = F, 
                             cells.highlight = (which(so.query@meta.data[[cluster_field]] == these_clusters[i])), label.size = 4) + 
      xlab("UMAP 1") +  ylab("UMAP 2") + ggtitle(paste("Cluster ", these_clusters[i]))

    # plots 2:n top genes
    for (j in c(1:top_n_genes)) {
      gene_symbol <- pull(top_genes_by_cluster[i,j+1])
      gene_name <-gene_symbol 
      if(!is.na(gene_name)){
        all_plts[[j + 1]] <- myplt(so.query, gene_symbol, gene_name)
      }
    }
    
    plt.clustermarkers_by_umap[[paste("c", these_clusters[i], sep = "")]] <- (CombinePlots(all_plts, ncol = 1 + top_n_genes, legend = 'none'))
  }
  
  names(plt.clustermarkers_by_umap) <- these_clusters
  
  return(plt.clustermarkers_by_umap)
  
}

```

```{r umap plot function}

# define function to plot figures
myplt <- function(so, gene_symbol, gene_name) {
  plt.handle <- FeaturePlot(object = so, features = gene_symbol, cols =rev(brewer.pal(11,"RdYlBu")), 
                            reduction = "umap", label.size = 2, pt.size = TRUE, sort.cell = TRUE) + 
    xlab("UMAP 1") +  ylab("") + ggtitle(gene_name) 
  
  
  return(plt.handle)
}


```


```{r plot_top_dif_genes_compare_marker, fig.width=13, fig.height=4, message=FALSE, warning=FALSE, include=FALSE}

plt.all_umaps <- list()

for (i in 1:length(cluster_resolution)){
  
  cluster.name[i] <- paste(DefaultAssay(so.query), "_snn_res." , cluster_resolution[i], sep = "")
  Idents(so.query) <- so.query@meta.data[[cluster.name[i]]]
  u_clusters <- as.vector(unique(so.query@meta.data[[cluster.name[i]]])[order(unique(so.query@meta.data[[cluster.name[i]]]))])
  plt.all_umaps[[i]] <- plot.cluster_markers_umap(so.query = so.query, 
                                                  u_clusters = u_clusters[order(as.numeric(u_clusters))], 
                                                  query.markers = query_markers.list[[as.character(cluster_resolution[i])]], 
                                                  cluster_field = cluster.name[i],
                                                  top_n_genes = 5, 
                                                  gNames.list = gNames.list)
  
  
  if (print.inline == TRUE){
    print( plt.all_umaps[[i]])
    
  }
}


try({
  Idents(so.query) <- so.query@meta.data[[barcode.field]]
  u_clusters <- as.vector(unique(so.query@meta.data[[barcode.field]]))
  plt.all_umaps[[length(plt.all_umaps)+1]] <- plot.cluster_markers_umap(so.query = so.query, 
                                                                        u_clusters = u_clusters, 
                                                                        query.markers = barcode_markers, 
                                                                        cluster_field = barcode.field,
                                                                        top_n_genes = 5, 
                                                                        gNames.list = gNames.list)
  
  if (print.inline == TRUE){
    print(plt.all_umaps[[length(plt.all_umaps)]])
    
  }
  
}, silent = TRUE)

if (length(plt.all_umaps) != (length(cluster_resolution) + 1)){
  plt.all_umaps[[((length(plt.all_umaps)+1))]] <- NULL
}


```



Barcodes
===================================== 

Row {data-height=700}
-------------------------------------

### Barcode Identities
```{r plt.umap_by_barcode, message=FALSE, warning=FALSE}
print(plt.umap_by_barcode)
```


Row {.tabset}
-------------------------------------

```{r ph1,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out <- lapply(seq_along(cluster_resolution), function(i) {
  
  s1 <- paste("Cluster Composition | res = ", cluster_resolution[i], sep = "")
  s2 <- paste('plt.cluster_composition_barcodes_res', cluster_resolution[i], sep="")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1)) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=4, message=FALSE, warning=FALSE}", paste("plt", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(%s)", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


```{r ph2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out <- lapply(seq_along(cluster_resolution), function(i) {
  
  s1 <- paste("Cluster Composition (Table) | res = ", cluster_resolution[i], sep = "")
  s2 <- paste('df.all_barcodes_wide_res', cluster_resolution[i], sep="")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


Cluster Markers (1)
===================================== 

Row {.tabset}
-------------------------------------

```{r plt.umap_by_all_clusters, message=FALSE, warning=FALSE}

out <- lapply(seq_along(plt.umap_by_cluster), function(i) {
  
  a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res = ",names(plt.umap_by_cluster)[i], sep = ""))) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("clust_umap", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.umap_by_cluster[[%d]])",i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

Row {.tabset}
-------------------------------------

```{r table.topmarkers, message=FALSE, warning=FALSE}

out_tb <- lapply(seq_along(top_markers_wide_res.list), function(i) {
  
  s1 <- paste("top_markers_wide_res.list[[", i, "]]", sep = "")

  # if (exists(s1)){
    
    s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")

    a1 <- knitr::knit_expand(text = sprintf("\n### %s\n", paste("res=", names(top_markers_wide_res.list)[i], sep = ""))) # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("clust_umap_tab", i, sep = ""))) # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  # }
  
})

```

`r paste(knitr::knit(text = paste(out_tb, collapse = '\n')))`

Cluster Markers (2)
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(top_markers_res.list), function(i) {
  
  s1 <- paste("top_markers_res.list[[", i, "]]", sep = "")
  
  table.name <- paste("res=", names(top_markers_res.list)[i], "")
  
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`


Heatmap
===================================== 

Row {.tabset}
-------------------------------------

```{r ph3,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(plt.heatmap), function(i) {
  
  s1 <- paste("Cluster Heatmap | res=", names(plt.heatmap)[i], sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=6, message=FALSE, warning=FALSE}", paste("hm", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\nprint(plt.heatmap[[%d]])", i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`


```{r ph4,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(plt.all_umaps), function(i) {
  
  
  a1 <- knitr::knit_expand(text = sprintf("\nUMAP | res = %s", paste(cr_names[i])))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = "\nRow {data-height=150}")
  a4 <- knitr::knit_expand(text = "\n-------------------------------------")
  a5 <- knitr::knit_expand(text = "\n###   ")
  a6 <- knitr::knit_expand(text =  sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("pl1_", i, sep = ""))) # start r chunk
  a7 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  a8 <- knitr::knit_expand(text = "\nRow {.tabset}")
  a9 <- knitr::knit_expand(text = "\n-------------------------------------\n")
  
  
  out2 <- lapply(seq_along(plt.all_umaps[[i]]), function(j) {
    
    b1 <- knitr::knit_expand(text = sprintf("\n### %s\n", names(plt.all_umaps[[i]])[j])) # tab header
    b2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=13, fig.height=4, message=FALSE, warning=FALSE}", paste("chunk", i, j, sep = ""))) 
    b3 <- knitr::knit_expand(text = sprintf("\nprint(plt.all_umaps[[%d]][[%d]])",i,  j)) 
    b4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    out2 <- paste(b1, b2, b3, b4, collapse = '\n')
    return(out2) # collapse together all lines with newline separator
    
  })
  
  a10 <- paste(knitr::knit(text = paste(out2, collapse = '\n')))
  
  a11 <- knitr::knit_expand(text = "\nRow {data-height=150}")
  a12 <- knitr::knit_expand(text = "\n-------------------------------------")
  a13 <- knitr::knit_expand(text = "\n###   ")
  a14 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("pl2_", i, sep = ""))) # start r chunk
  a15 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  out1 <- paste(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, collapse = '\n') # collapse together all lines with newline separator
  return(out1)
  
})

```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`


```{r export to excel, message=FALSE, warning=FALSE}

# try(
if (save.xlsx.flag == TRUE){
  try({
    
  
  excel_output_filename <- paste(dir.markers, 
                                 xlsx.filename ,
                                 "_RESULTS-", 
                                 gsub(":", "-",
                                      as.character(Sys.time())),  
                                 ".xlsx", 
                                 sep = "") 

  # statistics
  for (i in 1:length(query_markers.list)){
    
    output_data_name <- names(query_markers.list)[i]
    
    sheet_name <- paste("DEG | ", output_data_name, sep = "")
    
    xlsx::write.xlsx(query_markers.list[[i]], 
                     file = excel_output_filename, 
                     sheetName = sheet_name, 
                     col.names = TRUE, row.names = FALSE, append = TRUE)
  }
  
  # summary tables
  for (i in 1:length(cr_names)){
    
    output_data_name <- paste("top_markers_50_wide_res", cr_names[i], sep = "")
    
    if (exists(output_data_name)){
      sheet_name <- paste("Markers | res = ", cr_names[i], sep = "")
      
      xlsx::write.xlsx(eval(as.name(output_data_name)), 
                       file = excel_output_filename, 
                       sheetName = sheet_name, 
                       col.names = TRUE, row.names = FALSE, append = TRUE)
    }
    
  }
  }, silent = T)
}
```

```{r save analysis log and Rdata results, message=FALSE, warning=FALSE}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_8 <- df.log

if (save.Rdata.flag == TRUE){
  # Exported variables
  df.log[nrow(df.log)+1, 1] <- as.character("Exported Variables")
  
  if (exists("barcode_markers")){
    save.var <- c("so", "query_markers.list", "barcode_markers", "gNames.list", "df.log_Module_8", module.logs)
  } else {
    save.var <- c("so", "query_markers.list", "gNames.list", "df.log_Module_8", module.logs)
  }
  
  df.log[nrow(df.log), 2] <- as.character("save.var")
  df.log[nrow(df.log), 3] <- as.character(paste(save.var, collapse = ", "))
  
  so <- so.query
  try({
  save(list = save.var, file = paste(dir.markers, Rdata.filename, ".Rdata", sep = ""))
  }, silent = T)
}

```

```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 8)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_8)

```



