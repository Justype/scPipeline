---
title: "Module19_Modular_Genesets"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform", 
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", 
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "ddpcr", "readxl", "MAST", "future", "cluster", "ReactomePA", "clusterProfiler")

# load packages
# lapply(packages2load, library, character.only = TRUE)


```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
}

```

```{r parameter specification}

# Specify data directories
dir.preprocessed <- "Preprocessed Datasets/"

# Query input
# input.file <- "Module1_p4_neural_differentiation_300120.Rdata"
# input.file <- "Module1_pilot4_GL261_CT2A_scaleAll_080120.Rdata"
# input.file <- "Module2_Renca_Cell_Celsius_integrated_190220.Rdata"
# input.file <- "Module2_Renca_cell_nuc_sci_Celsius_integrated_230220.Rdata"

# input.file <- "Module2_Renca_cell_nuc_sci_T123_1800ds_Celsius_integrated_240220.Rdata"
# input.file <- "Module2_p3_p5_renca_tumor_integration_270120.Rdata"
input.file <- "Module2_Renca_cell_nuc_sci_T12_4000ds_Celsius_integrated_240220.Rdata"
# input.file <- "Module1_UHN_0238_filtered_aggr_labledv2_300120.Rdata"

# Rapid marker finding (logical flag)
quick_markers <- TRUE 

# specify cluster resolution
cluster.resolution <- 0.4
# cluster_resolution <- c(0.1)

# expected input species
which.species <- "Mm"

# max number of meta-modules permitted
max.module.n <- 50

# data slot (seurat object)
which.data <- "scale" # data or scale (recommended)


subset.clusters <- NULL # Null if none, vector of numbers otherwise
# subset.clusters <- c(0, 15, 4, 36, 10, 19, 29, 33, 32) # GBM tumor only - p4
# subset.clusters <- c(0, 6, 3, 5) # Renca Ce;;
# subset.clusters <- c(2, 5, 1, 10, 3, 14, 8, 7)

which.h <- NULL # if null, h selection is based on optimization criteria
# which.h <- 0.70

h.tiebreaker <- "max" # min, max (if multiple heights are identified, which to choose?)

var.threshold <- -100 # if 0, all entries with below average varaince are omitted (i.e., this is standardized gene variance threhold); set to -100 to not omit any

# print inline
print.inline <- F

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)


```


```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("19, Modular Genesets")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)

# subsample factor
df.log[nrow(df.log)+1, 1] <- as.character("Subsample Factor")
df.log[nrow(df.log), 2] <- as.character("subsample_factor")
df.log[nrow(df.log), 3] <- as.character(subsample_factor)

# Species
df.log[nrow(df.log)+1, 1] <- as.character("Species")
df.log[nrow(df.log), 2] <- as.character("which.species")
df.log[nrow(df.log), 3] <- as.character(which.species)

# max module size
df.log[nrow(df.log)+1, 1] <- as.character("max.module.n")
df.log[nrow(df.log), 2] <- as.character("max.module.n")
df.log[nrow(df.log), 3] <- as.character(max.module.n)

# Species
df.log[nrow(df.log)+1, 1] <- as.character("Data Used")
df.log[nrow(df.log), 2] <- as.character("which.data")
df.log[nrow(df.log), 3] <- as.character(which.data)

# Var gene
df.log[nrow(df.log)+1, 1] <- as.character("Variable gene threhsold")
df.log[nrow(df.log), 2] <- as.character("var.threshold")
df.log[nrow(df.log), 3] <- as.character(var.threshold)

# Var gene
df.log[nrow(df.log)+1, 1] <- as.character("Dendrogram height ")
df.log[nrow(df.log), 2] <- as.character("h.tiebreaker")
df.log[nrow(df.log), 3] <- as.character(h.tiebreaker)

# Cluster Resolution
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution")
df.log[nrow(df.log), 2] <- as.character("cluster.resolution")
if (length(cluster.resolution) > 1){
  df.log[nrow(df.log), 3] <- paste(cluster.resolution, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(cluster.resolution)
}


# Cluster Subset
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Subset")
df.log[nrow(df.log), 2] <- as.character("subset.clusters")
if (!is.null(subset.clusters)){
  

if (length(subset.clusters) > 1){
  df.log[nrow(df.log), 3] <- paste(subset.clusters, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(subset.clusters)
}
} else {
  df.log[nrow(df.log), 3] <- NA
}


df.log[nrow(df.log)+1, 1] <- as.character("Figures Printed in Notebook")
df.log[nrow(df.log), 2] <- as.character("print.inline")
df.log[nrow(df.log), 3] <- as.character(print.inline)


```



```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```

```{r load data}
# load data
load(paste(dir.preprocessed, input.file, sep = ""))

so <- fix.barcode.label(so)
so.query <- so
rm(so)

# subsample (for dev purposes)
n.subset <- round(subsample_factor *ncol(so.query))
cell.ind <- sample(x = seq(1, ncol(so.query)), size = n.subset, replace = FALSE, prob = NULL)
so.query <- SubsetData(so.query , cells = cell.ind)



```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r prep gene list}

# TODO drop .N suffix in ensembl IDs

if (exists("gNames.list_master")){
  gNames.list <- NULL
  for (i in 1:length(gNames.list_master)){
    gNames.list <- c(gNames.list, gNames.list_master[[i]] )
  }
  
  # gNames.df <-  data.frame(n = as.vector(names(gNames.list)), g = as.vector(gNames.list))
  gNames.df <-  data.frame(n = gsub("\\..*","",as.vector(names(gNames.list))), g = as.vector(gNames.list))
  gNames.df <- unique(gNames.df)
  gNames.list <- as.vector(gNames.df$g)
  names(gNames.list) <- as.vector(gNames.df$n)
} 

# ensure gene list is available
stopifnot(exists("gNames.list"))
```

```{r gene representation function}

# check what format genes are represented in (ensembl or symbol)
check.gene_rep <- function(cur_gene.list, cur_rep){
  
  ensembl_rep <- sum(as.vector(names(cur_gene.list)) %in% cur_rep)
  symbol_rep <- sum(toupper(as.vector(cur_gene.list)) %in% toupper(cur_rep))
  
  if (ensembl_rep > symbol_rep){
    gene.rep <- "ensembl"
  } else if (symbol_rep > ensembl_rep){
    gene.rep <- "symbol"
  } else {
    gene.rep <- NA
  }
  
  return(gene.rep)
  
}
```

```{r cluster at correct resolution}

# so.query@meta.data[["SCT_snn_res.0.15"]]
query.res <- paste(DefaultAssay(so.query), "_snn_res.", cluster.resolution, sep = "")


if (!(query.res %in% names(so.query@meta.data))) {
  so.query <- FindClusters(object = so.query, 
                           resolution = cluster.resolution, 
                           verbose = 0, 
                           algorithm = 1, 
                           modularity.fxn = 1)
}

# filter clusters 
if (!is.null(subset.clusters)){
  av.clusters <- as.numeric(as.character(so.query@meta.data[[query.res]]))
  cluster.ind <- av.clusters %in% subset.clusters
  
  so.query <- so.query[ ,cluster.ind]
}

# plot umap by cluster
plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = query.res, label = TRUE)  + 
  ggtitle(label = "UMAP") + 
  xlab("UMAP 1") + ylab("UMAP 2")

if (print.inline) plt.umap_by_cluster

```



```{r prep expression matrix}

# get expression data
cluster.membership <- so.query@meta.data[[query.res]]
u.clusters <- unique(as.numeric(as.character((cluster.membership))))
u.clusters <- u.clusters[order(u.clusters)]


if (which.data == "scale"){
  exp.mat.scale <- so.query@assays[[DefaultAssay(so.query)]]@scale.data
} else if (which.data == "data"){
  exp.mat.scale <- as.matrix(so.query@assays[[DefaultAssay(so.query)]]@data)
}

gene.scale.name <- rownames(exp.mat.scale)
cell.scale.name <- colnames(exp.mat.scale)

df.exp.scale <- NULL
for (i in 1:length(u.clusters)){
  exp.mat.scale.sub <- (exp.mat.scale[, (cluster.membership == u.clusters[i])])
  exp.mat.scale.mean <- apply(exp.mat.scale.sub, 1, mean)
  cur.df.scale <- data.frame(exp.mat.scale.mean)
  colnames(cur.df.scale) <- paste("c", u.clusters[i], sep = "")
  df.exp.scale <- bind_cols(df.exp.scale, cur.df.scale)
}

# cast expression data as matrix
exp.mat.scale.processed <- as.matrix(df.exp.scale)




```

```{r convert ensemble to symbol}
# convert genes to symbol if necessary

gene.rep <- check.gene_rep(gNames.list, gene.scale.name)
if (gene.rep == "ensembl"){
  # get available meta-features
  available.meta.features <- so.query@assays[["RNA"]]@meta.features
  if (all(colnames(available.meta.features) %in% c("ENSEMBL", "SYMBOL"))){
    av.ens <- as.character(available.meta.features$ENSEMBL)
    av.sym <- as.character(available.meta.features$SYMBOL)
    gene.rep.ens <- gene.scale.name
    gene.rep.sym <-  av.sym[av.ens %in% gene.rep.ens]
  } else {
    gene.rep.sym <- as.vector(gNames.list)[(as.vector(names(gNames.list))) %in% (gene.scale.name)]
  }
} else if ((gene.rep == "symbol")) {
  gene.rep.sym <- gene.scale.name
}

gene.rep <- check.gene_rep(gNames.list, gene.rep.sym)
rownames(exp.mat.scale.processed) <- gene.rep.sym
rownames(df.exp.scale) <- make.names(gene.rep.sym, unique = T)

```


```{r compute percentiles}

# use only variable features (other wise gene matrix too large for html file)
var.features <- so.query@assays[[DefaultAssay(so.query)]]@var.features
var.feature.representation <- check.gene_rep(gNames.list, var.features)

# potential gene name manipulation here
df.exp.scale.v2 <- as.data.frame(signif(df.exp.scale, 3))
rownames(df.exp.scale.v2) <- make.names(rownames(exp.mat.scale.processed), unique = T)

# get available meta-features
available.meta.features <- so.query@assays[["RNA"]]@meta.features

if (var.feature.representation == "ensembl"){
  if (all(colnames(available.meta.features) %in% c("ENSEMBL", "SYMBOL"))){
    av.ens <- as.character(available.meta.features$ENSEMBL)
    av.sym <- as.character(available.meta.features$SYMBOL)
    var.features.ens <- var.features
    var.features.sym <-  av.sym[av.ens %in% var.features.ens]
  } else {
    var.features.sym <- as.vector(gNames.list)[(as.vector(names(gNames.list))) %in% (var.features)]
  }
} else if ((var.feature.representation == "symbol")) {
  var.features.sym <- var.features
}

# filter data to include variable features only
match.ind <- rownames(exp.mat.scale.processed) %in% var.features.sym
df.exp.scale.v3 <- df.exp.scale.v2[match.ind ,]
rownames(df.exp.scale.v3) <- rownames(df.exp.scale.v2)[match.ind]

# get mean and sd of all expression values
df.exp.scale.v3.long <- pivot_longer(df.exp.scale.v3, colnames(df.exp.scale.v3))
mean.val <- mean(df.exp.scale.v3.long$value, na.rm = T)
std.val <- sd(df.exp.scale.v3.long$value, na.rm = T)

# standardize values
df.exp.scale.v4 <- df.exp.scale.v3 %>%
  mutate_each(funs((.-mean.val)/std.val))
df.exp.scale.v4 <- signif(df.exp.scale.v4, 3) 
rownames(df.exp.scale.v4) <- rownames(df.exp.scale.v3) 

# verify standardization
df.exp.scale.v4.long <- pivot_longer(df.exp.scale.v4, colnames(df.exp.scale.v4))
mean.val <- mean(df.exp.scale.v4.long$value, na.rm = T)
std.val <- sd(df.exp.scale.v4.long$value, na.rm = T)

# gene percentiles
exp.gene.percentile <-  apply(df.exp.scale.v3, 1, dplyr::percent_rank)
rownames(exp.gene.percentile) <- make.names(colnames(df.exp.scale.v3), unique = T)
exp.gene.percentile <- t(exp.gene.percentile)
exp.gene.percentile[is.na(exp.gene.percentile)] <- 0
exp.gene.percentile <- as.data.frame(signif(exp.gene.percentile, 3))

# cluster percentiles

exp.cluster.percentile <-  apply(df.exp.scale.v3, 2, dplyr::percent_rank)
rownames(exp.cluster.percentile) <- make.names(rownames(df.exp.scale.v3), unique = T)
exp.cluster.percentile[is.na(exp.cluster.percentile)] <- 0
exp.cluster.percentile <- as.data.frame(signif(exp.cluster.percentile, 3))


mat.exp.scale.v4 <- as.matrix(df.exp.scale.v4)
cur.cluster.id <- colnames(mat.exp.scale.v4)
# cols <- palette(brewer.pal(length(cur.cluster.id), "Dark2"))[seq(1:length(cur.cluster.id))]

# cluster colors
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
cols <- sample(col_vector, length(cur.cluster.id))

# heatmap colors
hmcol <- colorRampPalette(brewer.pal(9, "RdBu"))(100)

scale.min = -2
scale.max = 2 

# if (print.inline){


```


```{r variable gene filter}
# filter most variable genes

which.genes <- rownames(mat.exp.scale.v4)

exp.mat.scale.processed.fil <- exp.mat.scale.processed[rownames(exp.mat.scale.processed) %in% which.genes, ]

df.exp4var <- as.data.frame(exp.mat.scale.processed.fil)
df.exp4var$var <- apply(df.exp4var, 1, var, na.rm = T)
df.var <- data.frame(SYMBOL = rownames(df.exp4var), var = df.exp4var$var, var.log = log(df.exp4var$var))

df.var$var.norm <- df.var$var / max(df.var$var)
df.var$var.sd <- (df.var$var - mean(df.var$var, na.rm = T) )/ sd(df.var$var, na.rm = T)

df.var$var.norm.log <- df.var$var.log / max(df.var$var.log)
df.var$var.sd.log <- (df.var$var.log - mean(df.var$var.log, na.rm = T) )/ sd(df.var$var.log, na.rm = T)
# 
# df.var %>% 
#   # ggplot(aes(var.norm.log)) + 
#   geom_histogram()

# df.var %>% 
#   ggplot(aes(var.sd.log)) + 
#   geom_histogram()

keep.ind <- df.var$var.sd.log > var.threshold

mat.exp.scale.v4 <- mat.exp.scale.v4[keep.ind, ]

# eval(heat.object$call)
```

```{r, include= F}


get.heat <- function(mat, hmcol, cols, scale.min, scale.max){
  
  #threw this into a function to suppress plot that is automatically generated
  heat.object <- NULL
  try({
    heat.object <- gplots::heatmap.2( mat, labCol= colnames(mat),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     breaks = c(min(mat), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     xlab = "Cluster ID")
    
  }, silent = T)
  
  if (is.null(heat.object)){
        heat.object <- gplots::heatmap.2( mat, labCol= colnames(mat),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     xlab = "Cluster ID")
  }

return(heat.object)
}


heat.object <- get.heat(mat.exp.scale.v4, hmcol, cols, scale.min, scale.max)

# }

  
  

```

```{r}

if (print.inline){
   gplots::heatmap.2( mat.exp.scale.v4, labCol= colnames(mat.exp.scale.v4),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     breaks = c(min(mat.exp.scale.v4), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.v4)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     xlab = "Cluster ID")
}


```

```{r dendrogram}

dd.gene <- as.hclust(heat.object[["rowDendrogram"]])
dd.cluster <- as.hclust(heat.object[["colDendrogram"]])
```

```{r}

if (print.inline){
  plot(dd.cluster)
  rect.hclust(dd.cluster , k = 4, border = 2:6)
  abline(h = 3, col = 'red')
}

```


```{r}

if (print.inline){
plot(dd.gene, labels=FALSE)
rect.hclust(dd.gene , h = 0.85, border = 2:6)
abline(h = 3, col = 'red')
}
```


```{r compute module scores}
# 
# h.list <- seq(0.1, 1, by = 0.05)

h.list <- seq(0.4, 1.2, by = 0.05)

within.tot <- c()
between.tot <- c()
total.tot <- c()

n.leaf <- c()
mod.list <- list()

abs.flag <- F


mat.exp.scale.v5 <- mat.exp.scale.v4[heat.object[["rowInd"]] , heat.object[["colInd"]]]

for (k in 1:length(h.list)){
  
  
  dd.gene.cut <- cutree(dd.gene, h = h.list[k])
  
  dd.gene.cut <-dd.gene.cut[heat.object[["rowInd"]]] 
  
  u.leafs <- rev(unique(dd.gene.cut))
  
  df.exp.scale.module <- NULL
  
  within <- c()
  between <- c()
  total <- c()
  
  for (i in 1:ncol(mat.exp.scale.v5)){
    cur.df.scale <- NULL
    exp.mat.scale.sub <- NULL
    
    cur.cluster <- colnames(mat.exp.scale.v5)[i]
    exp.mat.scale.sub <- (mat.exp.scale.v5[, cur.cluster])
    
    if (abs.flag) exp.mat.scale.sub <- abs(exp.mat.scale.sub)
    
    leaf.mean <- c()
    within.ind <- c()
    for (j in 1:length(u.leafs)){
      which.genes = which(dd.gene.cut == u.leafs[j])
      if (length(exp.mat.scale.sub[which.genes]) > 1){
        leaf.mean[j] <- mean(exp.mat.scale.sub[which.genes])
        within.ind[j] <- sum((leaf.mean[j] - exp.mat.scale.sub[which.genes])^2)
        within.ind[is.na(within.ind)] <- 0
      } else {
        leaf.mean[j] <- 0
      }
    }
    
    within[i] <- sum(within.ind)
    between[i] <- sum((mean(exp.mat.scale.sub) - leaf.mean)^2)
    total[i] <- sum((mean(exp.mat.scale.sub) - exp.mat.scale.sub)^2)
    cur.df.scale <- data.frame(leaf.mean)
    colnames(cur.df.scale) <- cur.cluster
    df.exp.scale.module <- bind_cols(df.exp.scale.module, cur.df.scale)
  }
  
  rownames(df.exp.scale.module) <- paste("m", as.character(u.leafs), sep = "")
  mat.exp.scale.module <- as.matrix(df.exp.scale.module)
  mod.list[[as.character(h.list[k])]] <- mat.exp.scale.module
  
  n.leaf[k] <- length(u.leafs)
  
  
  within.tot[k] <- sum(within)
  between.tot[k] <- sum(between)
  total.tot[k] <- sum(total)
  
}

df.var.summary.v2 <- data.frame(
  h = h.list,
    total = total.tot,
  within = within.tot,
  between = between.tot,
  n.leaf = n.leaf
)

df.var.summary.v2$between <- df.var.summary.v2$total - df.var.summary.v2$within
```



```{r}

# find elbow h


xleaf <-  df.var.summary.v2$n.leaf
xh <-  df.var.summary.v2$h
xw <- df.var.summary.v2$between
xt <- df.var.summary.v2$total

xw.n <- xw/xt

xw.n <- xw.n[order(xh)]
xleaf <- xleaf[order(xh)]
xh <- xh[order(xh)]



get.elbow.points.indices <- function(x, y, threshold) {
  d1 <- diff(y) / diff(x) # first derivative
  d2 <- diff(d1) / diff(x[-1]) # second derivative
  indices <- which(abs(d2) > threshold)  
  return(indices)
}

match.ind  <- get.elbow.points.indices(log(xleaf), xw.n, threshold = 0.2) + 1
# if (length(match.ind) == 0){
#   match.ind  <- get.elbow.points.indices(log(xleaf), xw.n, threshold = 0.15) + 1
# } 
if (length(match.ind) == 0){
  match.ind  <- get.elbow.points.indices(log(xleaf), xw.n, threshold = 0.1) + 1
} 

h.opt <-  xh[match.ind]




# cap n modules at 50
match.ind <- match.ind[which(xleaf[match.ind] < max.module.n)]
match.ind.org <- match.ind


if (!is.null(which.h)){
  match.ind.org <- unique(c(match.ind.org, which(xh == which.h)))
  match.ind <- which(signif(xh,2) == signif(which.h,2))
  h.opt <-  xh[match.ind]
} else {
  h.opt <-  xh[match.ind]
}



# if multiple heights, take maximal.
if (length(h.opt) > 1) {
  if (h.tiebreaker == "max"){
    h.opt <- max(h.opt, na.rm = T)
    match.ind <- max(match.ind)
  } else if (h.tiebreaker == "min"){
    h.opt <- min(h.opt, na.rm = T)
    match.ind <- min(match.ind)
  }
}

  

  

df.var.summary.v2$color = "black"
df.var.summary.v2$color[match.ind.org] = "orange"
df.var.summary.v2$color[match.ind] <- "red"

n.modules <- xleaf[match.ind]
  
  line.size <- 1
  plt.relation <- df.var.summary.v2 %>%
  ggplot(aes(x = (n.leaf))) +
  geom_line(aes(y = total/total,  color = "total"), size = line.size) + 
  geom_line(aes(y = within/total, color = "within"), size = line.size) +
     geom_point(aes(y = within/total), size = 2, color =  df.var.summary.v2$color, alpha = 0.5) + 
  ggtitle(paste("Variance Decomposition (optimal n = ", n.modules, ")", sep = ""))  +
  xlab("Meta Modules, n (log10)") +  
  ylab("Variance Composition (/total variance)") + 
  scale_color_manual(name = 'Component', 
                     values =c("total"='firebrick', "within"='deepskyblue4',"between"= 'forestgreen'), 
                     labels = c('total','within', 'between')) + 
  theme_bw() + scale_x_log10() + ylim(0, 1)
  
    plt.relation.h <- df.var.summary.v2 %>%
  ggplot(aes(x = (h))) +
  geom_line(aes(y = total/total,  color = "total"), size = line.size) + 
  geom_line(aes(y = within/total, color = "within"), size = line.size) +
     geom_point(aes(y = within/total), size = 2, color =  df.var.summary.v2$color, alpha = 0.5) + 
  ggtitle(paste("Variance Decomposition (optimal n = ", n.modules, ")", sep = ""))  +
  xlab("Dendrogram Cut Height") +  
  ylab("Variance Composition (/total variance)") + 
  scale_color_manual(name = 'Component', 
                     values =c("total"='firebrick', "within"='deepskyblue4',"between"= 'forestgreen'), 
                     labels = c('total','within', 'between')) + 
  theme_bw() + scale_x_log10() + ylim(0, 1)


  
  if (print.inline) {
    print(plt.relation)
    print(plt.relation.h)
  }
    
    
    
```


```{r}

# cut dendrogram
 dd.gene.cut <- cutree(dd.gene, h = h.opt)

# get gene orders
row.ind.orig <- heat.object[["rowInd"]]

# identify most variable genes
df.exp4var <- as.data.frame(exp.mat.scale.processed)
df.exp4var$var <- apply(df.exp4var, 1, var, na.rm = T)
df.var <- data.frame(SYMBOL = rownames(df.exp4var), var = df.exp4var$var)

df.gene.modules <- data.frame(
  SYMBOL = dd.gene[["labels"]],
  module.cluster = dd.gene.cut
)


# reorder genes
df.gene.modules <- df.gene.modules[row.ind.orig, ]

# merge with variance data frame
df.gene.modules.mer <- merge(df.gene.modules,df.var, by = "SYMBOL")

df.gene.modules.tally <- df.gene.modules %>%
  group_by(module.cluster) %>%
  tally()

cur.mat <-mod.list[[as.character(h.opt)]]
cur.mat[is.na(cur.mat)] <- mean(cur.mat)
cur.mat[is.nan(cur.mat)] <- mean(cur.mat)
cur.mat[is.infinite(cur.mat)] <- mean(cur.mat)





# get peak module scores
# RESUME HERE
prototypic.module <- c()
u.modules <- unique(dd.gene.cut)
u.modules <- u.modules[order(as.numeric(as.character(u.modules)))]
for (i in length(u.modules)){
  mod.exp <- mat.exp.scale.v4[rownames(mat.exp.scale.v4) %in% df.gene.modules$SYMBOL[df.gene.modules$module.cluster == u.modules[i]], ]
  mean.mod.exp <- apply(mod.exp, 2, mean)
  which.max <- which(max(mean.mod.exp)== mean.mod.exp)
}

```

```{r fig.height=10, fig.width=8}



if (n.modules < 15){
  mod.label.size <- 1.5
} else if (n.modules < 25){
   mod.label.size <- 1.2 
} else if (n.modules < 35){
    mod.label.size <- 1
} else if (n.modules < 45){
    mod.label.size <- 0.9
} else if (n.modules < 55){
    mod.label.size <- 0.8
} else {
  mod.label.size <- 0.7
}


if (print.inline){
  gplots::heatmap.2(  cur.mat, labCol= colnames(cur.mat),
                      trace="none", 
                      col= rev(hmcol),
                      ColSideColors= cols, 
                      distfun = function(x) as.dist(1-cor(t(x))),
                      hclustfun = function(x) hclust(x, method="average"),
                      main = "Gene Exp Matrix",
                      xlab = "Cluster ID",
                      Rowv=F,
                      Colv = FALSE,
                      cexRow=mod.label.size)
}




```
```{r fig.height=10, fig.width=8}

if (print.inline){
  gplots::heatmap.2( mat.exp.scale.v4, labCol= colnames(mat.exp.scale.v4),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     breaks = c(min(mat.exp.scale.v4), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.v4)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     cexRow=mod.label.size,
                     xlab = "Cluster ID")
}

```


```{r}

if (print.inline){
  plot(dd.gene, labels=FALSE)
rect.hclust(dd.gene , h = h.opt, border = 2:6)
abline(h = 3, col = 'red')
}


```



```{r}

sym2entrez <- function(my.symbols, my.species){
  
my.symbols <- as.vector(my.symbols)
if (my.species == "Hs"){
  db <- org.Hs.eg.db
} else if (my.species == "Mm"){
db <- org.Mm.eg.db
}

my.entrez <- select(db, 
       keys = my.symbols,
       columns = c("ENTREZID", "SYMBOL"),
       keytype = "SYMBOL")

return(my.entrez)
}

my.entrez <- sym2entrez(as.vector(df.gene.modules$SYMBOL), my.species = which.species )

df.gene.entrez <- merge(df.gene.modules, my.entrez, by = "SYMBOL")

df.gene.entrez <- df.gene.entrez[complete.cases(df.gene.entrez), ]

```


```{r raw Module Scores functional enrichment v1}

# get unique modules
u.mod.cluster <- as.numeric(as.character(unique(df.gene.entrez$module.cluster)))
u.mod.cluster <- u.mod.cluster[order(u.mod.cluster)]

# specify gene universe
gene.universe <- as.vector(df.gene.entrez$ENTREZID)

# intitiate results lists
enrich.list <- list()
enrichResult.list <- list()

if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

# perform functional enrichment on each modular cluster
enrich.df <- NULL
for (i in 1:length(u.mod.cluster)){
  
  gse.mod <- NULL
  
  try({
    
  
  # prep gene list
  df.gene.modules.cur <- df.gene.modules.mer[as.numeric(df.gene.modules.mer$module.cluster) == (u.mod.cluster[i]), ]
  
  # log transform and standardize scores
  df.gene.modules.cur$var <- log10(df.gene.modules.cur$var)
  df.gene.modules.cur$var <- (df.gene.modules.cur$var - mean(df.gene.modules.cur$var, na.rm = T))/sd(df.gene.modules.cur$var, na.rm = T)

  gene.list.mod <- df.gene.modules.cur$var
  names(gene.list.mod) <- df.gene.modules.cur$SYMBOL
  match.ind <- match(names(gene.list.mod), df.gene.entrez$SYMBOL)
  names(gene.list.mod) <- as.character(df.gene.entrez$ENTREZID[match.ind])
  gene.list.mod = sort(gene.list.mod, decreasing = TRUE)
  
  # pathway gsea enrichment
  gse.mod.pathway <- gsePathway(geneList=gene.list.mod, organism=org, verbose=T, pAdjustMethod = "BH")
  gse.mod.pathway <- setReadable(gse.mod.pathway, OrgDb = db)
  
  # GO gsea enrichment
  gse.mod.go <- gseGO(geneList=gene.list.mod, OrgDb=db, verbose=T, pAdjustMethod = "BH")
  gse.mod.go <- setReadable(gse.mod.go, OrgDb = db)
  
  # specify which annotations were used
  if (nrow( gse.mod.pathway@result) > 0)   gse.mod.pathway@result$annotation <- "Reactome"
  if (nrow( gse.mod.go@result) > 0)     gse.mod.go@result$annotation <- "GO"
  
  # merge results
  if ((nrow( gse.mod.pathway@result) > 0) &  (nrow( gse.mod.go@result) > 0)){
    gse.mod <- bind_rows(gse.mod.pathway@result, gse.mod.go@result)
  }  else if ((nrow( gse.mod.pathway@result) > 0) &  (nrow( gse.mod.go@result) == 0)){
    gse.mod <- gse.mod.pathway@result
  } else if ((nrow( gse.mod.pathway@result) == 0) &  (nrow( gse.mod.go@result) > 0)){
    gse.mod <- gse.mod.go@result
  } else {
    next
  }
  
  }, silent = T)
  
  if (is.null(gse.mod)) next
  
  enrichResult.list[[i]] <- gse.mod
  enrich.list[[i]] <- as.data.frame(gse.mod)
  
  if (nrow(enrich.list[[i]]) > 0){
    enrich.list[[i]]$mod.cluster <- paste("m", i, sep = "")
    
    enrich.df <- bind_rows(enrich.df,enrich.list[[i]] )

  }
}

# sig figs for numerics
enrich.df$pvalue <- signif(enrich.df$pvalue, 3)
enrich.df$p.adjust <- signif(enrich.df$p.adjust, 3)
enrich.df$qvalues <- signif(enrich.df$qvalues, 3)
enrich.df$enrichmentScore <- signif(enrich.df$enrichmentScore, 3)
enrich.df$NES <- signif(enrich.df$NES, 3)

# reorder columns
enrich.df <- enrich.df[ ,c("mod.cluster", "annotation",  "Description", "setSize", "enrichmentScore", "NES", "pvalue", "qvalues", "p.adjust","rank", "core_enrichment",  "ID", "leading_edge")]

# print data table
if (print.inline){
  datatable(enrich.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}

```



```{r pca and function enrichment v2, fig.height= 5,  fig.height= 7}


# df.exp <- as.data.frame(mat.exp.scale.v4)

#   cumsum.threshold <- 0.5 # e.g., 0.1 indicates top 10% of genes are taken
#     which.component <- 1 # e.g., 1 = pc1
# 
# # intitiate results lists
# enrich.list.topPC <- list()
# enrichResult.list.topPC <- list()
# enrich.pc.df <- NULL
# 
# 
# enriched.gene.list <- c()
# plt.cumsum.list <- list()
# 
# for (i in 1:length(u.mod.cluster)){
#   
#   # name of current module
#   which.module <- paste("Meta-Module ", u.mod.cluster[i], sep = "")
#   
#   # get module gene set
#   gene.set <- as.vector(df.gene.entrez$SYMBOL[df.gene.entrez$module.cluster == u.mod.cluster[i]])
#   
#   # get expression matrix for current gene set
#   gene.set.exp <- df.exp[rownames(df.exp) %in% gene.set, ]
#   
#   # run PCA and get component loading
#   pc.name <- paste("pc", which.component, sep = "")
#   pca.input <- t(as.matrix(gene.set.exp))
#   pca = prcomp(pca.input,scale = F)
#   df.loading <- data.frame(gene = rownames(pca[["rotation"]]),  pc =  pca[["rotation"]][,which.component])
#   loading.direction <- sign(df.loading$pc[which(abs(df.loading$pc) == max(abs(df.loading$pc)))])
#   
#   # normalize loading
#   df.loading$pc <- loading.direction * df.loading$pc
#   df.loading$pc.scale <- loading.direction*(df.loading$pc - (min(df.loading$pc))) / max(df.loading$pc - (min(df.loading$pc)))
#   df.loading$pc <- loading.direction * df.loading$pc 
# 
#   # cumulative sum and noramlization
#   df.cumsum <- df.loading %>% 
#     arrange(desc(loading.direction*pc.scale))  %>%
#     mutate(cumsum = cumsum(loading.direction*pc.scale),
#            ind = seq(1, nrow(df.loading)))
#   
#   df.cumsum$cumsum.norm <- df.cumsum$cumsum/max(df.cumsum$cumsum)
#   
#   
# 
#   plt.cumsum.list[[i]] <- df.cumsum %>% 
#     ggplot(aes(x = ind, y = cumsum.norm)) + 
#     geom_point() + 
#     geom_hline(yintercept = cumsum.threshold, color = "red", linetype = "dashed") + ggtitle(which.module)
#   
#   # get top loaded genes
#   top.n.hits <- sum(df.cumsum$cumsum.norm <= cumsum.threshold)
#   top.hits <- df.loading %>% 
#     arrange((loading.direction*pc.scale)) %>%
#     top_n(wt = loading.direction*pc.scale, top.n.hits)
#   
#   # visualize top loaded genes
#   gene.set.exp.sub <- as.matrix(gene.set.exp[rownames(gene.set.exp) %in% top.hits$gene, ])
#   gene.mat.scaled <- (gene.set.exp.sub) * df.loading$pc.scale[df.loading$gene %in% top.hits$gene]
#   
#   
#   # biplot(pca,  main = which.module, pc.biplot = T)
#   
#   
#   pca.var.exp <- as.data.frame(summary(pca)[["importance"]])
#   which.module <- paste(which.module, "\nVariance Explained (", paste("PC", which.component, sep = ""), "): ", 100*signif(pca.var.exp["Proportion of Variance", paste("PC", which.component, sep = "")], 3) , "%, Top ", top.n.hits , " Genes", sep = "")
#   
#   enrich.list.PC <- list()
#   enrichResult.list.PC <- list()
#   
#   
#   enriched.gene.list <- c(enriched.gene.list, top.hits$gene)
#   
#   enrich.x.pc <- enrichPathway(gene=df.gene.entrez$ENTREZ[df.gene.entrez$SYMBOL %in% top.hits$gene],
#                                pvalueCutoff=0.05, 
#                                readable=T, 
#                                organism = "mouse")
#   
#   
#   enrichResult.list.PC[[i]] <- enrich.x.pc
#   enrich.list.PC[[i]] <- as.data.frame(enrich.x.pc)
#   
#   if (nrow(enrich.list.PC[[i]]) > 0){
#     enrich.list.PC[[i]]$mod.cluster <- paste("m", u.mod.cluster[i], sep = "")
#     
#     enrich.pc.df <- bind_rows(enrich.pc.df,enrich.list.PC[[i]] )
#     
#     # barplot(enrich.x, showCategory=8)
#   }
#   
# 
# }
# 
# # sig figs for numerics
# enrich.pc.df$pvalue <- signif(enrich.pc.df$pvalue, 3)
# enrich.pc.df$p.adjust <- signif(enrich.pc.df$p.adjust, 3)
# enrich.pc.df$qvalue <- signif(enrich.pc.df$qvalue, 3)
# 
# # reorder columns
# enrich.pc.df <- enrich.pc.df[ ,c("mod.cluster",  "Description","GeneRatio" ,  "BgRatio" ,    "pvalue"  ,    "p.adjust" ,   "qvalue"    ,  "geneID" ,     "Count", "ID") ]
# if (print.inline){
#   datatable(enrich.pc.df, 
#     filter = 'top',
#     extensions = 'Buttons',
#     options = list(pageLength = 50,
#     dom = 'Bfrtip', 
#     buttons = c('copy', 'csv', 'pdf')))
# }
# 
# 
# if (print.inline){
#   mat.exp.scale.enriched <- mat.exp.scale.v4[rownames(mat.exp.scale.v4) %in% enriched.gene.list, ]
#   
#   gplots::heatmap.2( mat.exp.scale.enriched, labCol= colnames(mat.exp.scale.enriched),
#                      trace="none", 
#                      col= rev(hmcol),
#                      ColSideColors= cols, 
#                      breaks = c(min(mat.exp.scale.enriched), 
#                                 seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.enriched)),
#                      distfun = function(x) as.dist(1-cor(t(x))),
#                      hclustfun = function(x) hclust(x, method="average"),
#                      main = "Gene Exp Matrix",
#                      cexRow=mod.label.size,
#                      xlab = "Cluster ID")
# }

```


```{r SVD scree}

# expression data
df.exp <- as.data.frame(mat.exp.scale.v4)

# SVD
svd.res <- svd(mat.exp.scale.v4)

# decomposition matrices
d.mat <- diag(svd.res$d)
u.mat <- svd.res$u
v.mat <- svd.res$v

# var explained
var_explained <-  signif(svd.res$d^2/sum(svd.res$d^2), 3)
df.svd <- data.frame(sv = seq(1, length(var_explained)),
                     var.exp = var_explained,
                     cum.var.exp = cumsum(var_explained))

plt.scree <- df.svd %>%
  ggplot(aes(x = sv, y = var.exp)) + 
  geom_bar(stat = "identity") + 
  theme_classic() + 
  xlab("Singular Vector") +
  ylab("Variance Explained") + 
  ggtitle("Scree Plot")


if (print.inline){
  print(plt.scree)
}


```





```{r svd and gene id, message=F, warning=F}


gene.activity.list <- list()
cluster.activity.list <- list()
reconstruct.mat.list <- list()
plt.top.gene.list <- list()
plt.svd.activity.list <- list()
df.gene.svd.list <- list()

  

for (i in 1: length(var_explained)){
  # for (i in 1:2){
  
# sv of interest
which.sv <- i

# update eigenvalue diagonal matrix
d.mat.filter <- d.mat*0
d.mat.filter[i,i] <- d.mat[i,i]



# reconstruct svd matrices
mat.reconstruct <- u.mat %*%d.mat.filter %*% t(v.mat)
rownames(mat.reconstruct) <- rownames(mat.exp.scale.v4)
colnames(mat.reconstruct) <- colnames(mat.exp.scale.v4)

# reorder according to original clustering
mat.reconstruct <- mat.reconstruct[heat.object[["rowInd"]], heat.object[["colInd"]]]

# create data frame from reconstructed matrix
gene.order <- rownames(mat.reconstruct)
df.recon <- as.data.frame(mat.reconstruct)
df.recon$genes <- factor(rownames(df.recon), levels = gene.order)
df.recon.melt <- melt(df.recon)
df.recon.melt$variable <- factor(df.recon.melt$variable, levels = colnames(mat.reconstruct))

# define limits
df.recon.melt$value[df.recon.melt$value > scale.max] <- scale.max
df.recon.melt$value[df.recon.melt$value < scale.min] <- scale.min

df.recon.gene <-as.data.frame(mat.reconstruct)
gene.activity <- apply(df.recon.gene, 1, var, na.rm = T)
df.gene.activity <- data.frame(   activity = gene.activity,
                                  genes = factor(rownames(df.recon.gene), levels = gene.order),
                                  ranks = rank(-gene.activity),
                                  percentile = percent_rank(gene.activity))


# get top 300 active genes in current svd component
df.gene.svd <- df.recon.gene
df.gene.svd.colnames <- colnames(df.gene.svd)
df.gene.svd$activity.variance <- gene.activity
df.gene.svd$genes <- rownames(df.gene.svd)
df.gene.svd <- df.gene.svd %>% top_n(300, wt = activity.variance)
df.gene.svd <- df.gene.svd[ , c("genes", "activity.variance", df.gene.svd.colnames)]
df.gene.svd[,  c( "activity.variance", df.gene.svd.colnames)] <- signif(df.gene.svd[,  c("activity.variance", df.gene.svd.colnames)], 3)


# heatmap (ggplot2-based)
plt.svd.comp <- ggplot(df.recon.melt, aes(variable, genes)) + 
  geom_tile(aes(fill = (value))) +  
  scale_fill_gradientn(colours = rev(brewer.pal(9, "RdBu")), limits = c(scale.min, scale.max)) + 
  theme(axis.text.y = element_blank()) + 
  xlab("Cluster ID") + 
  ggtitle(paste("Gene Exp Matrix, svd = ", which.sv, " (" , 100*var_explained[i], "% var)", sep = ""))

# print(plt.svd.comp)

# gene activity plot
plt.gene_act <-df.gene.activity %>%
  ggplot(aes(x = genes, y = activity)) + 
  geom_bar(stat = "identity")  + 
  coord_flip() + 
  theme_classic() +
  ggpubr::clean_theme() 

# cluster activity plot (derived from cluster-wise variance)
# df.recon.clust <-as.data.frame(mat.reconstruct)
# cluster.activity <- apply(df.recon.clust, 2, var, na.rm = T)
# df.cluster.activity <- data.frame(cluster = colnames(mat.reconstruct), activity = cluster.activity)
# df.cluster.activity$cluster <- factor(df.cluster.activity$cluster, levels = colnames(mat.reconstruct))
# plt.clust_act <- df.cluster.activity %>%
#   ggplot(aes(x = cluster, y = activity)) + 
#   geom_bar(stat = "identity") +
#   theme_classic() +
#   ggpubr::clean_theme() 

# cluster activity (derived from v matrix (y=udv; svd decomposition) )
df.recon.clust <-as.data.frame(mat.reconstruct)
cluster.activity <- t(v.mat)[i, heat.object[["colInd"]]]
df.cluster.activity <- data.frame(cluster = colnames(mat.reconstruct), activity = cluster.activity)
df.cluster.activity$cluster <- factor(df.cluster.activity$cluster, levels = colnames(mat.reconstruct))
plt.clust_act <- df.cluster.activity %>%
  ggplot(aes(x = cluster, y = activity)) + 
  geom_bar(stat = "identity") +
  theme_classic() +
  ggpubr::clean_theme() 

# classify clusters
df.cluster.activity.class <- df.cluster.activity
df.cluster.activity.class$class <- "low"
df.cluster.activity.class$class[df.cluster.activity.class$activity>0] <- "high"

high.clust <- as.character(df.cluster.activity.class$cluster[df.cluster.activity.class$class == "high"])
low.clust <- as.character(df.cluster.activity.class$cluster[df.cluster.activity.class$class == "low"])

if (length(high.clust) == 1){
  df.gene.svd$high <- df.gene.svd[, high.clust]
} else if (length(high.clust) > 1){
  df.gene.svd$high <- apply(df.gene.svd[, high.clust], 1, mean)
} else {
  df.gene.svd$high <- 0
}

if (length(low.clust) == 1){
  df.gene.svd$low <- df.gene.svd[, low.clust]
} else if (length(low.clust) > 1){
  df.gene.svd$low <- apply(df.gene.svd[, low.clust], 1, mean)
} else {
  df.gene.svd$high <- 0
}


# df.gene.svd %>%
#   ggplot(aes(x=low, y = high)) + 
#   geom_point()

# arrange plots
p1 <- cowplot::insert_xaxis_grob(plt.svd.comp, plt.clust_act, grid::unit(.2, "null"), position = "top")
p2<- cowplot::insert_yaxis_grob(p1, plt.gene_act, grid::unit(.2, "null"), position = "right")

# flag top genes
df.gene.activity$label.gene <- F
mean.activity <- mean(df.gene.activity$activity)
sd.activity <- sd(df.gene.activity$activity)
activity.threshold <- mean.activity + (sd.activity * 1.96)
df.gene.activity$label.gene[df.gene.activity$activity > activity.threshold] <- T
df.gene.activity.filt <- df.gene.activity %>% dplyr::filter(percentile > 0.9)
plt.top.genes <- df.gene.activity.filt %>%
  ggplot(aes(x = percentile, y = log(activity))) + 
  geom_point() +  
  xlab("Rank (eigengene variance-based ranking)") + 
  ylab("Eigengene Variance (log)") + 
  ggtitle(paste("Eigengene Ranking, svd = ", which.sv, sep = "")) +
  ggrepel::geom_text_repel(label = ifelse(df.gene.activity.filt$label.gene, as.character(df.gene.activity.filt$genes), ""), box.padding = unit(0, "lines"), hjust = 1)  +
  theme_classic()

# print plots
if (print.inline){
  print(cowplot::ggdraw(p2))
  # print(plt.top.genes)
}

# store results
gene.activity.list[[i]] <- df.gene.activity
cluster.activity.list[[i]] <- df.cluster.activity
reconstruct.mat.list[[i]] <- mat.reconstruct
plt.top.gene.list[[i]] <- plt.top.genes
plt.svd.activity.list[[i]] <- p2

svd.list.name <- paste("SVD", i, sep = "")
df.gene.svd.list[[svd.list.name]] <- df.gene.svd

}

```

```{r GSEA SVD term enrichment}


df.exp <- as.data.frame(mat.exp.scale.v4)

# intitiate results lists
enrich.svd.list <- list()
enrichResult.svd.list <- list()

# perform functional enrichment on each svd component
enrich.svd.df <- NULL

if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

for (i in 1:length(df.gene.svd.list)){
  
  # name of current module
  which.svd <- i
  current.gene.set <- df.gene.svd.list[[i]]
  current.gene.set$genes <- as.character(current.gene.set$genes)
  
  # high activity gene ranks
  gene.set.high <- current.gene.set$high
  names(gene.set.high) <- current.gene.set$genes
  match.ind <- match( names(gene.set.high), df.gene.entrez$SYMBOL)
  names(gene.set.high) <- as.character(df.gene.entrez$ENTREZID[match.ind])
  gene.set.high <- sort(gene.set.high, decreasing = TRUE)
  is.valid.high <- !(all(is.na(current.gene.set$high)))
  
  # low activity gene ranks
  gene.set.low <- current.gene.set$low
  names(gene.set.low) <- current.gene.set$genes
  match.ind <- match( names(gene.set.low), df.gene.entrez$SYMBOL)
  names(gene.set.low) <- as.character(df.gene.entrez$ENTREZID[match.ind])
  gene.set.low = sort(gene.set.low, decreasing = TRUE)
  is.valid.low <- !(all(is.na(current.gene.set$low)))

  # enrich high activity SVD components
  if (is.valid.high){
    # GO enrichment
    gse.gobp.high <- gseGO(geneList=gene.set.high, ont="BP", OrgDb=db, verbose=T, pAdjustMethod = "BH")
    gse.gobp.high <- setReadable(gse.gobp.high, OrgDb=db)
    
    # Pathway enrichment
    gse.pathway.high <- gsePathway(geneList=gene.set.high, organism=org, verbose=T, pAdjustMethod = "BH")
    gse.pathway.high <- setReadable(gse.pathway.high, OrgDb=db)
    
    # specify which annotations were used
    if (nrow( gse.pathway.high@result) > 0)   {
      gse.pathway.high@result$annotation <- "Reactome"
      gse.pathway.high@result$svd.component <- paste("SVD", i,".high", sep = "")
    }
    if (nrow( gse.gobp.high@result) > 0){
      gse.gobp.high@result$annotation <- "GO"
      gse.gobp.high@result$svd.component <- paste("SVD", i,".high", sep = "")
    }
    
    # merge results
    if ((nrow( gse.pathway.high@result) > 0) &  (nrow( gse.gobp.high@result) > 0)){
      gse.mod.high <- bind_rows(gse.pathway.high@result, gse.gobp.high@result)
    }  else if ((nrow( gse.pathway.high@result) > 0) &  (nrow( gse.gobp.high@result) == 0)){
      gse.mod.high <- gse.pathway.high@result
    } else if ((nrow( gse.pathway.high@result) == 0) &  (nrow( gse.gobp.high@result) > 0)){
      gse.mod.high <- gse.gobp.high@result
    } else {
      gse.mod.high <- NULL
    }
  } else {
    gse.mod.high <- NULL
  }
  
  # enrich low activity SVD components
  if (is.valid.low){
    # GO enrichment
    gse.gobp.low <- gseGO(geneList=gene.set.low, ont="BP", OrgDb=db, verbose=T, pAdjustMethod = "BH")
    gse.gobp.low <- setReadable(gse.gobp.low, OrgDb=db)
    
    # Pathway enrichment
    gse.pathway.low <- gsePathway(geneList=gene.set.low, organism=org, verbose=T, pAdjustMethod = "BH")
    gse.pathway.low <- setReadable(gse.pathway.low, OrgDb=db)
    
    # specify which annotations were used
    if (nrow( gse.pathway.low@result) > 0)   {
      gse.pathway.low@result$annotation <- "Reactome"
      gse.pathway.low@result$svd.component <- paste("SVD", i,".low", sep = "")
    }
    if (nrow( gse.gobp.low@result) > 0){
      gse.gobp.low@result$annotation <- "GO"
      gse.gobp.low@result$svd.component <- paste("SVD", i,".low", sep = "")
    }   
    
    # merge results
    if ((nrow( gse.pathway.low@result) > 0) &  (nrow( gse.gobp.low@result) > 0)){
      gse.mod.low <- bind_rows(gse.pathway.low@result, gse.gobp.low@result)
    }  else if ((nrow( gse.pathway.low@result) > 0) &  (nrow( gse.gobp.low@result) == 0)){
      gse.mod.low <- gse.pathway.low@result
    } else if ((nrow( gse.pathway.low@result) == 0) &  (nrow( gse.gobp.low@result) > 0)){
      gse.mod.low <- gse.gobp.low@result
    } else {
      gse.mod.low <- NULL
    }
  } else {
    gse.mod.low <- NULL
  }
  
  # merge high and low
  if ((!is.null(gse.mod.low)) &  (!is.null(gse.mod.high))){
    gse.mod <- bind_rows(gse.mod.high, gse.mod.low)
  }  else if ((is.null(gse.mod.low)) &  (!is.null(gse.mod.high))){
    gse.mod <- gse.mod.high
  } else if ((!is.null(gse.mod.low)) &  (is.null(gse.mod.high))){
    gse.mod <- gse.mod.low
  } else {
    next
  }

  
  # store results
  enrich.svd.list[[i]] <- gse.mod
  enrichResult.svd.list[[i]] <- as.data.frame(gse.mod)
  enrich.svd.df <- bind_rows(enrich.svd.df,enrich.svd.list[[i]] )
  
}

# sig figs for numerics
enrich.svd.df$pvalue <- signif(enrich.svd.df$pvalue, 3)
enrich.svd.df$p.adjust <- signif(enrich.svd.df$p.adjust, 3)
enrich.svd.df$qvalues <- signif(enrich.svd.df$qvalues, 3)
enrich.svd.df$enrichmentScore <- signif(enrich.svd.df$enrichmentScore, 3)
enrich.svd.df$NES <- signif(enrich.svd.df$NES, 3)

# reorder columns
enrich.svd.df <- enrich.svd.df[ ,c("svd.component", "annotation",  "Description", "setSize", "enrichmentScore", "NES", "pvalue", "qvalues", "p.adjust","rank", "core_enrichment",  "ID", "leading_edge")]

if (print.inline){
  datatable(enrich.svd.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}


```

```{r GSEA SVD term enrichment orig}

# 
# df.exp <- as.data.frame(mat.exp.scale.v4)
# 
# # intitiate results lists
# enrich.svd.list <- list()
# enrichResult.svd.list <- list()
# 
# # perform functional enrichment on each svd component
# enrich.svd.df <- NULL
# 
# if (which.species == "Hs") {
#   org <- "human"
#   db <- org.Hs.eg.db
# } else if (which.species == "Mm"){
#   org <- "mouse"
#   db <- org.Mm.eg.db
# }
# 
# for (i in 1:length(gene.activity.list)){
#   
#   # name of current module
#   which.svd <- i
#   current.gene.set <- gene.activity.list[[i]]
#   cur.gene.symbol <- as.character(current.gene.set$genes[current.gene.set$label.gene])
#   current.gene.set$genes <- as.character(current.gene.set$genes)
#   current.gene.set <- dplyr::arrange(current.gene.set, by = ranks) 
#   
#   # log transform and standardize scores
#   current.gene.set$activity <- log10(current.gene.set$activity)
#   current.gene.set$activity <- (current.gene.set$activity - mean(current.gene.set$activity, na.rm = T))/sd(current.gene.set$activity, na.rm = T)
# 
#   match.ind <- match(current.gene.set$genes, df.gene.entrez$SYMBOL)
#   gene.set.ordered.entrez <- (current.gene.set$activity)
#   names(gene.set.ordered.entrez) <- as.character(df.gene.entrez$ENTREZID[match.ind])
#   gene.set.ordered.entrez = sort(gene.set.ordered.entrez, decreasing = TRUE)
#   
#   # GO enrichment
#   gse.gobp <- gseGO(geneList=gene.set.ordered.entrez, ont="BP", OrgDb=db, verbose=T, pAdjustMethod = "BH")
#   gse.gobp <- setReadable(gse.gobp, OrgDb=db)
#   
#   # Pathway enrichment
#   gse.pathway <- gsePathway(geneList=gene.set.ordered.entrez, organism=org, verbose=T, pAdjustMethod = "BH")
#   gse.pathway <- setReadable(gse.pathway, OrgDb=db)
#   
#   # specify which annotations were used
#   if (nrow( gse.pathway@result) > 0)   gse.pathway@result$annotation <- "Reactome"
#   if (nrow( gse.gobp@result) > 0)     gse.gobp@result$annotation <- "GO"
#   
#   # merge results
#   if ((nrow( gse.pathway@result) > 0) &  (nrow( gse.gobp@result) > 0)){
#     gse.mod <- bind_rows(gse.pathway@result, gse.gobp@result)
#   }  else if ((nrow( gse.pathway@result) > 0) &  (nrow( gse.gobp@result) == 0)){
#     gse.mod <- gse.pathway@result
#   } else if ((nrow( gse.pathway@result) == 0) &  (nrow( gse.gobp@result) > 0)){
#     gse.mod <- gse.gobp@result
#   } else {
#     next
#   }
#   
#   # store results
#   enrich.svd.list[[i]] <- gse.mod
#   enrichResult.svd.list[[i]] <- as.data.frame(gse.mod)
# 
#   if (nrow(enrich.svd.list[[i]]) > 0){
#     enrich.svd.list[[i]]$svd.component <- paste("SVD", i, sep = "")
#     enrich.svd.df <- bind_rows(enrich.svd.df,enrich.svd.list[[i]] )
#   }
#   
# }
# 
# # sig figs for numerics
# enrich.svd.df$pvalue <- signif(enrich.svd.df$pvalue, 3)
# enrich.svd.df$p.adjust <- signif(enrich.svd.df$p.adjust, 3)
# enrich.svd.df$qvalues <- signif(enrich.svd.df$qvalues, 3)
# enrich.svd.df$enrichmentScore <- signif(enrich.svd.df$enrichmentScore, 3)
# enrich.svd.df$NES <- signif(enrich.svd.df$NES, 3)
# 
# # reorder columns
# enrich.svd.df <- enrich.svd.df[ ,c("svd.component", "annotation",  "Description", "setSize", "enrichmentScore", "NES", "pvalue", "qvalues", "p.adjust","rank", "core_enrichment",  "ID", "leading_edge")]
# 
# if (print.inline){
#   datatable(enrich.svd.df, 
#     filter = 'top',
#     extensions = 'Buttons',
#     options = list(pageLength = 50,
#     dom = 'Bfrtip', 
#     buttons = c('copy', 'csv', 'pdf')))
# }


```

```{r}

if (print.inline){
  

  gplots::heatmap.2( mat.exp.scale.v4, labCol= colnames(mat.exp.scale.v4),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     breaks = c(min(mat.exp.scale.v4), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.v4)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     cexRow=mod.label.size,
                     xlab = "Cluster ID")
}
```

```{r compute DEGs}
# get DEG
so.markers <- so.query

Idents(so.markers) <- so.markers@meta.data[[query.res]]
deg_markers.list <- FindAllMarkers(so.markers, 
                                   assay = DefaultAssay(so.markers),
                                   slot = "data",
                                   only.pos = F, 
                                   min.pct = 0.25,
                                   test.use = "MAST",
                                   logfc.threshold = 0.5, 
                                   max.cells.per.ident = 200,
                                   return.thresh = 0.01,
                                   verbose = F)

deg_markers.list[ ,c("p_val", "avg_logFC", "p_val_adj")] <- signif(deg_markers.list[ ,c("p_val", "avg_logFC", "p_val_adj")], 3)

```


```{r function enrichment of DEGs}


# df.exp <- as.data.frame(mat.exp.scale.v4)

# intitiate results lists
enrich.deg.list <- list()
enrichResult.deg.list <- list()

# perform functional enrichment on each svd component
enrich.deg.df <- NULL

if (which.species == "Hs") {
  org <- "human"
  db <- org.Hs.eg.db
} else if (which.species == "Mm"){
  org <- "mouse"
  db <- org.Mm.eg.db
}

u.clusters <- as.numeric(as.character(unique(deg_markers.list$cluster)))
u.clusters <- u.clusters[order(u.clusters)]

for (i in 1:length(u.clusters)){
  
  # name of current module
  which.cluster <- paste("c", i, sep = "")
  
    gse.mod <- NULL
  
  try({
    
  # get DEGs
  deg.markers.current <- deg_markers.list[deg_markers.list$cluster == u.clusters[i], ]
  current.gene.set <- deg.markers.current$avg_logFC
  names(current.gene.set) <- deg.markers.current$gene
  
  # match symbol to entrez id
  match.ind <- match(names(current.gene.set), df.gene.entrez$SYMBOL)
  current.gene.set <- current.gene.set[!is.na(match.ind)]
  match.ind <- match.ind[!is.na(match.ind)]
  names(current.gene.set) <- as.character(df.gene.entrez$ENTREZID[match.ind])
  current.gene.set = sort(current.gene.set, decreasing = TRUE)
  
  # GO enrichment
  gse.deg.gobp <- gseGO(geneList=current.gene.set, ont="BP", OrgDb=db, verbose=T, pAdjustMethod = "BH")
  gse.deg.gobp <- setReadable(gse.deg.gobp, OrgDb=db)
  
  # Pathway enrichment
  gse.deg.pathway <- gsePathway(geneList=current.gene.set, organism=org, verbose=T, pAdjustMethod = "BH")
  gse.deg.pathway <- setReadable(gse.deg.pathway, OrgDb=db)
  
  # specify which annotations were used
  if (nrow( gse.deg.pathway@result) > 0)   gse.deg.pathway@result$annotation <- "Reactome"
  if (nrow( gse.deg.gobp@result) > 0)     gse.deg.gobp@result$annotation <- "GO"
  
  # merge results
  if ((nrow( gse.deg.pathway@result) > 0) &  (nrow( gse.deg.gobp@result) > 0)){
    gse.mod <- bind_rows(gse.deg.pathway@result, gse.deg.gobp@result)
  }  else if ((nrow( gse.deg.pathway@result) > 0) &  (nrow( gse.deg.gobp@result) == 0)){
    gse.mod <- gse.deg.pathway@result
  } else if ((nrow( gse.deg.pathway@result) == 0) &  (nrow( gse.deg.gobp@result) > 0)){
    gse.mod <- gse.deg.gobp@result
  } else {
    next
  }
  
  }, silent = T)
    
    if (is.null(gse.mod)) next
  
  # store results
  enrich.deg.list[[i]] <- gse.mod
  enrichResult.deg.list[[i]] <- as.data.frame(gse.mod)
  
  if (nrow(enrich.deg.list[[i]]) > 0){
    enrich.deg.list[[i]]$cluster <- paste("c", u.clusters[i], sep = "")
    enrich.deg.df <- bind_rows(enrich.deg.df,enrich.deg.list[[i]] )
  }
  
}

# sig figs for numerics
enrich.deg.df$pvalue <- signif(enrich.deg.df$pvalue, 3)
enrich.deg.df$p.adjust <- signif(enrich.deg.df$p.adjust, 3)
enrich.deg.df$qvalues <- signif(enrich.deg.df$qvalues, 3)
enrich.deg.df$enrichmentScore <- signif(enrich.deg.df$enrichmentScore, 3)
enrich.deg.df$NES <- signif(enrich.deg.df$NES, 3)

# reorder columns
enrich.deg.df <- enrich.deg.df[ ,c("cluster", "annotation",  "Description", "setSize", "enrichmentScore", "NES", "pvalue", "qvalues", "p.adjust","rank", "core_enrichment",  "ID", "leading_edge")]

if (print.inline){
  datatable(enrich.deg.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
}

```



```{r radial coord function}

# function provided by Erwan Le Pennec for the radar coord. 
coord_radar <- function (theta = "x", start = 0, direction = 1) {
  theta <- match.arg(theta, c("x", "y"))
  r <- if (theta == "x") "y" else "x"
  ggproto("CordRadar", CoordPolar, theta = theta, r = r, start = start, 
          direction = sign(direction),
          is_linear = function(coord) TRUE)
}

```


```{r module radial plots, fig.width= 20,  fig.height= 20}


df.mod <- as.data.frame(cur.mat)

cell.clusters <- colnames(df.mod)
df.mod$mod.cluster <- rownames(df.mod)

df.mod.long <- pivot_longer(df.mod,cell.clusters)

df.mod.long$name <- factor(df.mod.long$name, levels = cur.cluster.id)
df.mod.long$mod.cluster <- factor(df.mod.long$mod.cluster, levels = paste("m", seq(1, nrow(df.mod)), sep = ""))

# normalize values

df.mod.long$value.normAll <- df.mod.long$value + abs(min(df.mod.long$value))
df.mod.long$value.normAll  <- df.mod.long$value.normAll / max(df.mod.long$value.normAll )

df.mod.long <- df.mod.long %>%
  group_by(mod.cluster) %>%
  mutate(value.normMod = (value - min(value))/max(value- min(value)))

df.mod.long <- df.mod.long %>%
  group_by(name) %>%
  mutate(value.normCluster = (value - min(value))/max(value- min(value)))

df.mod.long <- df.mod.long %>%
  group_by(name) %>%
  mutate(id =readr::parse_number(as.character(mod.cluster))) %>%
  arrange(id)


# as.numeric(gsub("([0-9]+).*$", "\\1", paste("m", seq(1, nrow(df.mod)), sep = "")))
# df.mod.long$id <- rep(seq(1, length(cur.cluster.id)), each = nrow(df.mod))

plt.radial.normAll <- ggplot(data = df.mod.long, aes(x  = mod.cluster, y = value.normAll) ) +  theme_light() +
  geom_polygon(aes(group = name, color = name),
               fill  = NA, size = 1) +
  facet_wrap(~ name) +
  theme(strip.text.x = element_text(size = rel(0.8)),
        axis.text.x  = element_text(size = rel(0.8)),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank()) +
  guides(color = "none")+
  xlab("") + ylab("") + ggtitle("Relative Activity") +
  coord_radar()

df.mod.long.clust <- df.mod.long %>%
  group_by(mod.cluster) %>%
  mutate(id =readr::parse_number(as.character(name))) %>%
  arrange(id)

plt.radial.normAll_byMod <- ggplot(data = df.mod.long.clust, aes(x  = name, y = value.normAll) ) +  theme_light() +
  geom_polygon(aes(group = mod.cluster, color = mod.cluster),
               fill  = NA, size = 1) +
  facet_wrap(~ mod.cluster) +
  theme(strip.text.x = element_text(size = rel(0.8)),
        axis.text.x  = element_text(size = rel(0.8)),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank()) +
  guides(color = "none")+
  xlab("") + ylab("") + ggtitle("Relative Activity") +
  coord_radar()

# plt.radial.normMod <- ggplot(data = df.mod.long, aes(x  = mod.cluster, y = value.normMod) ) +  theme_light() +
#   geom_polygon(aes(group = name, color = name),
#                fill  = NA, size = 1) +
#   facet_wrap(~ name) +
#   theme(strip.text.x = element_text(size = rel(0.8)),
#         axis.text.x  = element_text(size = rel(0.8)),
#         axis.ticks.y = element_blank(),
#         axis.text.y  = element_blank()) +
#   guides(color = "none")+
#   xlab("") + ylab("") + ggtitle("Relative modular activity across clusters") + 
#   coord_radar()
# 
# plt.radial.normCluster <- ggplot(data = df.mod.long, aes(x  = mod.cluster, y = value.normCluster) ) +  theme_light() +
#   geom_polygon(aes(group = name, color = name),
#                fill  = NA, size = 1) +
#   facet_wrap(~ name) +
#   theme(strip.text.x = element_text(size = rel(0.8)),
#         axis.text.x  = element_text(size = rel(0.8)),
#         axis.ticks.y = element_blank(),
#         axis.text.y  = element_blank()) +
#   guides(color = "none")+
#   xlab("") + ylab("") + ggtitle("Relative modular activity within clusters") + 
#   coord_radar()


if (print.inline){
  print(plt.radial.normAll)
  print(plt.radial.normAll_byMod)
}


```




```{r svd radial plots, fig.width= 20,  fig.height= 20}

# get svd=based component activities
df.cluster.act <- NULL
for (i in 1:length(cluster.activity.list)){
  
  cur.act <- cluster.activity.list[[i]]
  if (is.null(df.cluster.act)){
    df.cluster.act$cluster <- as.data.frame(cur.act$cluster)
    df.cluster.act <- as.data.frame(df.cluster.act)
    colnames(df.cluster.act) <- "cluster"
  }
  df.cluster.act[ ,paste("SVD", i, sep = "")] <- cur.act$activity
  
}

df.cluster.act <- t(df.cluster.act)
colnames(df.cluster.act) <- df.cluster.act[1,]
df.cluster.act <- as.data.frame(df.cluster.act[ 2:ncol(df.cluster.act), ])

cell.clusters <- colnames(df.cluster.act)
df.cluster.act$svd.cluster <- rownames(df.cluster.act)

df.cluster.act.long <- pivot_longer(df.cluster.act,cell.clusters)

df.cluster.act.long$name <- factor(df.cluster.act.long$name, levels = cur.cluster.id)
df.cluster.act.long$svd.cluster <- factor(df.cluster.act.long$svd.cluster, levels = paste("SVD", seq(1, nrow(df.cluster.act)), sep = ""))
df.cluster.act.long$value <- as.numeric(as.character(df.cluster.act.long$value))

# normalize values
df.cluster.act.long$baseline <- 0
df.cluster.act.long$baseline.normAll <- df.cluster.act.long$baseline + abs(min(df.cluster.act.long$value))
df.cluster.act.long$value.normAll <- df.cluster.act.long$value + abs(min(df.cluster.act.long$value))
df.cluster.act.long$baseline.normAll <- df.cluster.act.long$baseline.normAll / max(df.cluster.act.long$value.normAll )
df.cluster.act.long$value.normAll  <- df.cluster.act.long$value.normAll / max(df.cluster.act.long$value.normAll )

# normMod
df.cluster.act.long <- df.cluster.act.long %>%
  group_by(svd.cluster) %>%
  mutate(baseline.normMod = (baseline - min(value))/max(value- min(value)))

df.cluster.act.long <- df.cluster.act.long %>%
  group_by(svd.cluster) %>%
  mutate(value.normMod = (value - min(value))/max(value- min(value)))
  
# normClust
df.cluster.act.long <- df.cluster.act.long %>%
  group_by(name) %>%
  mutate(baseline.normCluster = (baseline - min(value))/max(value- min(value)))

df.cluster.act.long <- df.cluster.act.long %>%
  group_by(name) %>%
  mutate(value.normCluster = (value - min(value))/max(value- min(value)))

df.cluster.act.long <- df.cluster.act.long %>%
  group_by(name) %>%
  mutate(id =readr::parse_number(as.character(svd.cluster))) %>%
  arrange(id)

plt.radial.normAll.svd.base <- ggplot(data = df.cluster.act.long ) +  theme_light() +
    geom_polygon(aes(x = svd.cluster, y = baseline.normAll, group = name),
                fill  = NA, size = 1, color = "grey") +
    geom_polygon(aes(x  = svd.cluster, y = value.normAll, group = name, color = name),
               fill  = NA, size = 1) +
  facet_wrap(~ name) +
  theme(strip.text.x = element_text(size = rel(0.8)),
        axis.text.x  = element_text(size = rel(0.8)),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank()) +
  guides(color = "none")+
  xlab("") + ylab("") + ggtitle("Relative Activity") +
  coord_radar()

df.cluster.act.long.clust <- df.cluster.act.long %>%
  group_by(svd.cluster) %>%
  mutate(id =readr::parse_number(as.character(name))) %>%
  arrange(id)

plt.radial.normAll_byMod.svd.base <- ggplot(data = df.cluster.act.long.clust ) +  theme_light() +
    geom_polygon(aes(x  = name, y = baseline.normAll, group = svd.cluster),
              color = "grey", fill  = NA, size = 1) +
  geom_polygon(aes(x  = name, y = value.normAll, group = svd.cluster, color = svd.cluster),
               fill  = NA, size = 1) +
  facet_wrap(~ svd.cluster) +
  theme(strip.text.x = element_text(size = rel(0.8)),
        axis.text.x  = element_text(size = rel(0.8)),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank()) +
  guides(color = "none")+
  xlab("") + ylab("") + ggtitle("Relative Activity") +
  coord_radar()

if (print.inline){
  print(plt.radial.normAll.svd.base)
  print(plt.radial.normAll_byMod.svd.base)
}


```


cluster UMAP
===================================== 

```{r plt.umap_by_c}
print(plt.umap_by_cluster)
```


M-1| Dendrograms
===================================== 

Row 
-----------------------------------------------------------------------

### Cell Clusters

```{r dendro dd.cluster}

success.run <- 0

try({
  plot(dd.cluster)
  rect.hclust(dd.cluster , k = 4, border = 2:6)
  abline(h = 3, col = 'red')
  success.run <- 1
}, silent = T)

if (success.run == 0){
  plot(dd.cluster)
  # rect.hclust(dd.cluster ,k = 3, border = 2:6)
  # abline(h = 3, col = 'red')
  
}


```


### Gene Clusters
```{r dendro dd.gene}
  plot(dd.gene, labels=FALSE)
rect.hclust(dd.gene , h = h.opt, border = 2:6)
abline(h = 3, col = 'red')

```



M-2| Modular Reduction
===================================== 

Row 
-----------------------------------------------------------------------

### Original

```{r head original, fig.height=10, fig.width=8}


ho <- NULL
try({
  ho <- gplots::heatmap.2( mat.exp.scale.v4, labCol= colnames(mat.exp.scale.v4),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     cexRow=mod.label.size,
                     breaks = c(min(mat.exp.scale.v4), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.v4)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     xlab = "Cluster ID")
}, silent = T)


```

> input expression matrix (gene x cluster)

### Reduced

```{r head reduced, fig.height=10, fig.width=8}


hr <- NULL
try({
  hr <-  gplots::heatmap.2(  cur.mat, labCol= colnames(cur.mat),
                             trace="none", 
                             col= rev(hmcol),
                             ColSideColors= cols, 
                             cexRow=mod.label.size,
                             breaks = c(min(cur.mat), 
                                        seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(cur.mat)),
                             distfun = function(x) as.dist(1-cor(t(x))),
                             hclustfun = function(x) hclust(x, method="average"),
                             main = "Gene Exp Matrix",
                             xlab = "Cluster ID",
                             Rowv=F,
                             Colv = FALSE)
}, silent = T)

```

> Pooled expression matrix, based on optimal clustering. 

M-3| Variance Explained
===================================== 

### Modular number vs variance

```{r var exp}

print(plt.relation)

```

> Relationship between number of meta-modules used to pool expression data (optimal number determined using 2nd-derivative-based elbow identification method) and variance explained by pooling of gene x cluster expression matrix. 


### Dendrogram height vs variance

```{r var h2}

print(plt.relation.h)

```

> Relationship between dendrogram cut height used to pool expression data (optimal number determined using 2nd-derivative-based elbow identification method) and variance explained by pooling of gene x cluster expression matrix. 


M-4| Radial Clusters
===================================== 

Row
-------------------------------------

### Radial Plot

```{r plt.radial.normAll.v1, fig.height= 20}
n.cell.clusters <- length(cell.clusters)
if (n.cell.clusters > 25) print(plt.radial.normAll)
```

```{r plt.radial.normAll.v2, fig.height= 15}
if ((n.cell.clusters > 20) & (n.cell.clusters < 26)) print(plt.radial.normAll)
```

```{r plt.radial.normAll.v3, fig.height= 10}
if ((n.cell.clusters > 15) & (n.cell.clusters < 21)) print(plt.radial.normAll)
```

```{r plt.radial.normAll.v4, fig.width= 7,  fig.height= 7}
if ((n.cell.clusters > 10) & (n.cell.clusters < 16))   print(plt.radial.normAll)
```

```{r plt.radial.normAll.5}
if ((n.cell.clusters < 11))   print(plt.radial.normAll)
```

> Module scores stratified by cluster. 

### Enrichment 

```{r enrihcment table pre cluster }

enrich.df.all <- enrich.df
enrich.df <- dplyr::select(enrich.df, -c("core_enrichment",  "ID", "leading_edge"))

  datatable(enrich.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
```

> Enrichement of top gene-module genesets. Genes ranked according to gene-wise variance. 

M-5| Radial Modules
===================================== 

Row
-------------------------------------

### Radial Plot

```{r plt.radial.normAll.v1.mod, fig.height= 20}
if (n.modules > 25) print(plt.radial.normAll_byMod)
```


```{r plt.radial.normAll.v2.mod, fig.height= 15}
if ((n.modules > 20) & (n.modules < 26)) print(plt.radial.normAll_byMod)
```

```{r plt.radial.normAll.v3.mod, fig.height= 10}
if ((n.modules > 15) & (n.modules < 21))   print(plt.radial.normAll_byMod)
```

```{r plt.radial.normAll.v4.mod, fig.width= 7,  fig.height= 7}
if ((n.modules > 10) & (n.modules < 16))   print(plt.radial.normAll_byMod)
```


```{r plt.radial.normAll.v5.mod}
if ((n.modules < 11))   print(plt.radial.normAll_byMod)
```

> Module scores stratified by cluster. 

### Enrichment 

```{r enrihcment table pre mod }
  datatable(enrich.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
```

> Enrichement of top gene-module genesets. Genes ranked according to gene-wise variance. 


M-6| Gene List
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

### Gene Tally

```{r}
  datatable(df.gene.modules.tally, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))

```

### Gene List

```{r gene list table }

  datatable(df.gene.modules.mer, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))

```


S-1| Scree
===================================== 

```{r s1 scree}
print(plt.scree)
```

> Scree plot: Variance composition of gene x cluster expression matrix following single value decomposition (SVD). 

S-2| SVD
===================================== 


Row {.tabset}
-------------------------------------

### Input

```{r head original v2}

ho <- NULL
try({
  ho <- gplots::heatmap.2( mat.exp.scale.v4, labCol= colnames(mat.exp.scale.v4),
                     trace="none", 
                     col= rev(hmcol),
                     ColSideColors= cols, 
                     cexRow=mod.label.size,
                     breaks = c(min(mat.exp.scale.v4), 
                                seq(scale.min, scale.max, by = ((scale.max-scale.min)/98)), max(mat.exp.scale.v4)),
                     distfun = function(x) as.dist(1-cor(t(x))),
                     hclustfun = function(x) hclust(x, method="average"),
                     main = "Gene Exp Matrix",
                     xlab = "Cluster ID")
}, silent = T)


```


```{r SVD decompMats,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(plt.svd.activity.list), function(i) {
  
  s1 <- paste("SVD",  i, sep = "")
  
  s2 <- paste("print(cowplot::ggdraw(plt.svd.activity.list[[", i, "]]))", sep = "")

  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, message=FALSE, warning=FALSE}", paste("svd mat", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`

> SVD matrices


S-3.1| Radial 
===================================== 

Row
-------------------------------------

### Radial Plot

```{r plt.radial.normAll.svd.base.v1, fig.height= 20}
n.cell.clusters <- length(cell.clusters)
if (n.cell.clusters > 25) print(plt.radial.normAll.svd.base)
```

```{r plt.radial.normAll.svd.base.v2, fig.height= 15}
if ((n.cell.clusters > 20) & (n.cell.clusters < 26)) print(plt.radial.normAll.svd.base)
```

```{r plt.radial.normAll.svd.base.v3, fig.height= 10}
if ((n.cell.clusters > 15) & (n.cell.clusters < 21)) print(plt.radial.normAll.svd.base)
```

```{r plt.radial.normAll.svd.base.v4, fig.width= 7,  fig.height= 7}
if ((n.cell.clusters > 10) & (n.cell.clusters < 16))   print(plt.radial.normAll.svd.base)
```

```{r plt.radial.normAll.svd.base.5}
if ((n.cell.clusters < 11))   print(plt.radial.normAll.svd.base)
```

### Enrichment 

```{r enrich.svd.df s-1}

enrich.svd.df.all <- enrich.svd.df
enrich.svd.df <- dplyr::select(enrich.svd.df, -c("core_enrichment",  "ID", "leading_edge"))

  datatable(enrich.svd.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))

```

> Enrichment of SVD-derived metagenes, ranked according to SVD-component variances. 

S-3.2| Radial 
===================================== 

Row
-------------------------------------

### Radial Plot

```{r plt.radial.normAll_byMod.svd.base.v1.mod, fig.height= 20}

n.svd <- length(var_explained)
if (n.svd > 25) print(plt.radial.normAll_byMod.svd.base)
```


```{r plt.radial.normAll_byMod.svd.base.v2.mod, fig.height= 15}
if ((n.svd > 20) & (n.svd < 26)) print(plt.radial.normAll_byMod.svd.base)
```

```{r plt.radial.normAll_byMod.svd.base.v3.mod, fig.height= 10}
if ((n.svd > 15) & (n.svd < 21))   print(plt.radial.normAll_byMod.svd.base)
```

```{r plt.radial.normAll_byMod.svd.base.v4.mod, fig.width= 7,  fig.height= 7}
if ((n.svd > 10) & (n.svd < 16))   print(plt.radial.normAll_byMod.svd.base)
```


```{r plt.radial.normAll_byMod.svd.base.normAll.v5.mod}
if ((n.svd < 11))   print(plt.radial.normAll_byMod.svd.base)
```

> grey curve: 0 baseline (i.e., value above are positive, below are negative); colored curves: SVD-derived activity. 


### Enrichment 

```{r enrich.svd.df s-2 }

  datatable(enrich.svd.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))


```

> Enrichment of SVD-derived metagenes, ranked according to SVD-component variances. 


S-4| Metagenes
=====================================

Row {.tabset}
-------------------------------------

```{r detailed table output v3,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# create enrihcment list

out_meta_table <- lapply(seq_along(df.gene.svd.list), function(i) {
  
  s1 <- paste("df.gene.svd.list[[", i, "]]", sep = "")
  
  table.name <- names(df.gene.svd.list)[i]
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
      s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v3_metagenes", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_meta_table, collapse = '\n')))`


C-1| UMAP
===================================== 

Row
-------------------------------------

### UMAP
```{r plt.umap_by_c_annotated}
print(plt.umap_by_cluster)
```

> Cluster-annotated UMAP 

### Enrichment 

```{r enrihcment table pre cluster 2 }

enrich.deg.df.all <- enrich.deg.df
enrich.deg.df <- dplyr::select(enrich.deg.df, -c("core_enrichment",  "ID", "leading_edge"))

  datatable(enrich.deg.df, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
```

> Enrichment of cluster-specific differentially-expressed genes (DEGs)

C-2| DEG
===================================== 

### Cluster-specific Differentially-Expressed Genes (DEGs)

```{r DEG table c2 }

  datatable(deg_markers.list, 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))
```



Enrichments (All)
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output v2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

# create enrihcment list

all.enrichments <- list(modular = enrich.df.all,
                        svd = enrich.svd.df.all,
                        deg = enrich.deg.df.all)

out_enrich_table <- lapply(seq_along(all.enrichments), function(i) {
  
  s1 <- paste("all.enrichments[[", i, "]]", sep = "")
  
  table.name <- names(all.enrichments)[i]
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
      s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v2", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_enrich_table, collapse = '\n')))`

```{r save analysis log and Rdata results}


if (is.null(which.h)) which.h <- h.opt

# H selection
df.log[nrow(df.log)+1, 1] <- as.character("Dendrogram cut height")
df.log[nrow(df.log), 2] <- as.character("which.h")
df.log[nrow(df.log), 3] <- as.character(which.h)

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_19 <- df.log


```


```{r ph10,  echo = FALSE, eval = TRUE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 19)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_19)

```


