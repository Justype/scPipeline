---
title: "Module21_Cluster_Composition"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# clear global enviroment
rm(list = ls())

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "sctransform",
                   "plyr", "dplyr", "tidyr", "reshape2", "RColorBrewer", "ggplot2", "gridExtra", 
                   "DT", "flexdashboard", "ggpmisc", "ggpmisc", "ggExtra", "grid", "ddpcr",  "future")


library("viridis")

# load packages
lapply(packages2load, library, character.only = TRUE)


```


```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Preprocessed Datasets/")
}

```


```{r parameter specification}

# Specify data directories
dir.preprocessed <- "Preprocessed Datasets/"

# Query input
# input.file <- "Module2_Renca_cell_nuc_sci_T123_1800ds_Celsius_integrated_240220.Rdata"
# input.file <- "Module2_CCA_GBM_invivo_invitro_GBMonly_010320.Rdata"
input.file <- "Module2_Renca_cell_nuc_sci_T123_1800ds_Celsius_integrated_240220.Rdata"
# input.file <- "Module2_DataIntegration_Celsius_T12_invitro_ds4000_rencaSubset_010320.Rdata"

# specify cluster resolution
cluster_resolution <- c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1)
# cluster_resolution <- c(0.4)

# print inline
print.inline <- FALSE

custom.subanalysis <- 1 # 0: no, 1: stratify Renca Celsius experiment by tumor type

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)

# grouping (list specifying group compositions); supports indirect matching 
group.field <- "batch" # batch used when using intergration dataset
# group.list <- list(in.vivo = "invivo",
#                    in.vitro = "invitro")

group.list <- list(snRNAseq.invivo = "nuc",
                   scRNAseq.invivo = "cell",
                   sciRNAseq3.invivo = "sci")

# group.list <- list(snRNAseq.invivo = "nuc",
#                    scRNAseq.invivo = "cell",
#                    sciRNAseq3.invivo = "sci",
#                    sciRNAseq3.invitro = "invitro")

# group.list <- list(sciRNAseq3 = "sci", 
#                    snRNAseq = "nuc")




```




```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("21, Cluster Composition")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)

# Cluster Resolution
df.log[nrow(df.log)+1, 1] <- as.character("Cluster Resolution")
df.log[nrow(df.log), 2] <- as.character("cluster_resolution")
if (length(cluster_resolution) > 1){
  df.log[nrow(df.log), 3] <- paste(cluster_resolution, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(cluster_resolution)
}

# subsample factor
df.log[nrow(df.log)+1, 1] <- as.character("Subsample Factor")
df.log[nrow(df.log), 2] <- as.character("subsample_factor")
df.log[nrow(df.log), 3] <- as.character(subsample_factor)

# Custom subanalysis
df.log[nrow(df.log)+1, 1] <- as.character("custom subanalysis")
df.log[nrow(df.log), 2] <- as.character("custom.subanalysis")
df.log[nrow(df.log), 3] <- as.character(custom.subanalysis)

# new labels 
df.log[nrow(df.log)+1, 1] <- as.character("New Labels")
df.log[nrow(df.log), 2] <- as.character("names(unlist(group.list))")
df.log[nrow(df.log), 3] <- as.character(paste(names(unlist(group.list)), collapse = ", "))

# old labels
df.log[nrow(df.log)+1, 1] <- as.character("Old Labels")
df.log[nrow(df.log), 2] <- as.character("as.vector(unlist(group.list))")
df.log[nrow(df.log), 3] <- as.character(paste(as.vector(unlist(group.list)), collapse = ", "))


# Grouping Field
df.log[nrow(df.log)+1, 1] <- as.character("Grouping Field")
df.log[nrow(df.log), 2] <- as.character("group.field")
df.log[nrow(df.log), 3] <- as.character(group.field)

df.log[nrow(df.log)+1, 1] <- as.character("Figures Printed in Notebook")
df.log[nrow(df.log), 2] <- as.character("print.inline")
df.log[nrow(df.log), 3] <- as.character(print.inline)


```



```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```

```{r load data}
# load data
load(paste(dir.preprocessed, input.file, sep = ""))

so <- fix.barcode.label(so)
so.query <- so
rm(so)

# subsample (for dev purposes)
n.subset <- round(subsample_factor *ncol(so.query))
cell.ind <- sample(x = seq(1, ncol(so.query)), size = n.subset, replace = FALSE, prob = NULL)
so.query <- SubsetData(so.query , cells = cell.ind)

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```


```{r prep gene list}

# TODO drop .N suffix in ensembl IDs

if (exists("gNames.list_master")){
  gNames.list <- NULL
  for (i in 1:length(gNames.list_master)){
    gNames.list <- c(gNames.list, gNames.list_master[[i]] )
  }
  
  # gNames.df <-  data.frame(n = as.vector(names(gNames.list)), g = as.vector(gNames.list))
  gNames.df <-  data.frame(n = gsub("\\..*","",as.vector(names(gNames.list))), g = as.vector(gNames.list))
  gNames.df <- unique(gNames.df)
  gNames.list <- as.vector(gNames.df$g)
  names(gNames.list) <- as.vector(gNames.df$n)
} 

# ensure gene list is available
stopifnot(exists("gNames.list"))
```


```{r cluster data}

# initiate list to store cluster plots
plt.umap_by_cluster <- list()
cluster.name <- c()

# cluster data and generate cluster-stratified UMAPs
plan(strategy = "multisession", workers = 4)
options(future.globals.maxSize = (10240 * 1024^2) )

for (i in 1:length(cluster_resolution)) {
  so.query <- FindClusters(object = so.query, resolution = cluster_resolution[i], verbose = 0, algorithm = 1, modularity.fxn = 1)
  
  cluster.name[i] <- paste(DefaultAssay(so.query),"_snn_res.", cluster_resolution[i], sep = "")
  # plt.umap_by_cluster[[i]] <- DimPlot(so.query, reduction = "umap", group.by = cluster.name[i], label = TRUE)  + 
  #   ggtitle(label = paste("Resolution: ", cluster_resolution[i], sep = "")) + 
  #   xlab("UMAP 1") + 
  #   ylab("UMAP 2")
  
  if (print.inline){
    # print(plt.umap_by_cluster[[i]])
  }
  # Lung_UMAP_res0_15
  
}

# generate barcode-stratified UMAP
# plt.umap_by_barcode <- DimPlot(so.query, reduction = "umap", group.by = "Barcode")  + ggtitle(label = "UMAP") + xlab("UMAP 1") + ylab("UMAP 2")
# plt.umap_by_cluster[[length(plt.umap_by_cluster)+1]] <- plt.umap_by_barcode
# 
# if (print.inline){
#   print(plt.umap_by_barcode)
# }

cr_names <- c(cluster_resolution, "barcodes")
```


```{r}
# group membership

membership.n <- c()
membership.list <- list()



keep.this <- NULL
for (i in 1:length(group.list)){
  
  cur.group <- names(group.list)[i]
  cur.pattern <- (group.list)[[i]]
  
  u.members <- as.vector(unique(so.query@meta.data[[group.field]][grepl(cur.pattern, so.query@meta.data[[group.field]])]))
  membership.list[[cur.group]] <- u.members
  membership.n[i] <- length(u.members)
  
  if (is.null(keep.this)){
    keep.this <- grepl(cur.pattern, so.query@meta.data[[group.field]])
  } else {
    keep.this <- (keep.this | grepl(cur.pattern, so.query@meta.data[[group.field]]))
  }
  
  so.query@meta.data[["group.query"]][grepl(cur.pattern, so.query@meta.data[[group.field]])] <- cur.group
  
  
}

so.query <-so.query[, keep.this]


names(membership.n) <-  names(group.list)

if (length(group.list) == 2){
  col.end <- 0.6
} else {
  col.end <- 1
}

group.cols <- viridis_pal(option = "D", end = col.end)(length(group.list))
names(group.cols) <- names(group.list)

# group.cols <- c("black", "red")
# names(group.cols) <- names(group.list)


membership.cols <- viridis_pal(option = "D", end = col.end)(length(as.vector(unlist(membership.list))))
names(membership.cols) <- as.vector(unlist(membership.list))




plt.umap_group <- DimPlot(so.query, 
                          reduction = "umap", 
                          group.by = "group.query",
                          cols = group.cols)  + 
  ggtitle(label = "UMAP") + 
  xlab("UMAP 1") + 
  ylab("UMAP 2") 

plt.umap_membership <- DimPlot(so.query, 
                               reduction = "umap", 
                               group.by = group.field,
                               cols = membership.cols,
                               split.by = "group.query")  + 
  ggtitle(label = "UMAP") + 
  xlab("UMAP 1") + 
  ylab("UMAP 2") 

if (print.inline){
  print(plt.umap_group) 
  print(plt.umap_membership)
}



```



```{r function for long to wide annotation table}

long2wide <- function(df){
  
  # create wide version (for output to excel), reorder factors, and get basic descriptive stats
  df.wide <- dcast(df, cluster ~ batch, value.var = "n")
  df.wide[is.na(df.wide)] <- 0
  reordered_factors <- order(as.numeric(as.vector(df.wide$cluster)))
  df.wide <- df.wide[reordered_factors, ]
  rownames(df.wide) <- df.wide$cluster
  df.wide <- as.data.frame(t(df.wide))
  df.wide <- df.wide[2:dim(df.wide)[1], ]
  df_id_rnames <- rownames(df.wide)
  colnames(df.wide) <- paste("cluster", colnames(df.wide), sep = "")
  df.wide <- data.frame(apply(df.wide, 2, function(x) as.numeric(as.character(x))))
  df.wide[dim(df.wide)[1]+1, ] <- apply(df.wide, 2, sum)
  rownames(df.wide) <- c(df_id_rnames, "TOTAL")
  df.wide[, dim(df.wide)[2]+1] <- apply(df.wide, 1, sum)
  colnames(df.wide)[dim(df.wide)[2]] <- "TOTAL"
  
  return(df.wide)
}

```

```{r plot functions}

plot.clusterComp_fStack <- function(df, cluster_chart_labels,  my_cols, cum.freq, bar.alpha = 0.8){
  plt.cluster_composition_fStack <- ggplot(df, 
                                           aes(x = cluster, 
                                               fill = batch, 
                                               y = freq)) +
    geom_bar(position = "fill", stat = "identity", alpha = bar.alpha) + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    xlab("Cluster ID") + ylab("Cluster Representation (rel.freq)") + 
    ggtitle("Cluster Composition (rel.freq)")
  
  if (!is.null(cum.freq)){
    for (i in 1:length(cum.freq)){
      plt.cluster_composition_fStack <- plt.cluster_composition_fStack + geom_hline(yintercept = cum.freq[i])
    }
  }
  
  return(plt.cluster_composition_fStack)
}

plot.clusterComp_fDodge <- function(df, cluster_chart_labels,  my_cols, bar.alpha = 0.8){
  
  plt.cluster_composition_fDodge <- ggplot(df, 
                                           aes(x = cluster, fill = batch, y = freq)) +
    geom_bar(position = "dodge", stat = "identity", alpha = bar.alpha) + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    xlab("Cluster ID") + ylab("Cluster Representation (rel.freq)") + 
    ggtitle("Cluster Composition (rel.freq)")
  
  return(plt.cluster_composition_fDodge)
}

plot.clusterComp_nStack <- function(df, cluster_chart_labels,  my_cols, bar.alpha = 0.8){
  
  plt.cluster_composition_nStack <- ggplot(df.cluster_annotations, 
                                           aes(x = cluster, fill = batch, y = n)) +
    geom_bar( stat = "identity", alpha = bar.alpha) + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    xlab("Cluster ID") + ylab("Cluster Representation (n cells)") + 
    ggtitle("Cluster Composition (n cells)")
  
  return(plt.cluster_composition_nStack)
}

plot.clusterComp_nDodge <- function(df, cluster_chart_labels,  my_cols, bar.alpha = 0.8){
  
  plt.cluster_composition_nDodge <- ggplot(df.cluster_annotations, 
                                           aes(x = cluster, fill = batch, y = n)) +
    geom_bar( stat = "identity", position = "dodge", alpha = bar.alpha) + 
    scale_x_continuous("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    xlab("Cluster ID") + ylab("Cluster Representation (n cells)") + 
    ggtitle("Cluster Composition (n cells)")
  
  return(plt.cluster_composition_nDodge)
}

plot.nFreq_scatter <- function(df, my_cols, expected.freq = NULL, group.cols = NULL, line.alpha = 0.1){
  
  plt.n_vs_freq <- ggplot(df.cluster_annotations, aes(x = n, y = freq, color = batch, fill = batch)) +
    geom_point() + 
    geom_smooth(method = 'lm', alpha = line.alpha) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    scale_color_manual(values = my_cols) + 
    xlab("Cell Count (within cluster)") + ylab("Rel. Frequency (within cluster)") + 
    ggtitle("Cell Count vs. Rel. Frequency\ndashed: expected, solid: fit")
  
  if (!(is.null(expected.freq)) & !(is.null(group.cols))){
    
    for (i in 1:length(expected.freq)){
      cur.freq <- expected.freq[i]
      cur.col <- group.cols[names(expected.freq)[i]]
      plt.n_vs_freq <- plt.n_vs_freq + geom_hline(yintercept = cur.freq, color = cur.col, linetype = "dashed", alpha = 0.5)
    }
  }
  
  return(plt.n_vs_freq)
}


plot.chiSq_results <- function(df.chi, cluster_chart_labels){
  
  plt.chi_res <- df.chi %>%
    group_by(cluster) %>%
    summarize(cluster.id = as.numeric(unique(cluster)),
              log10p = unique(log10.p),
              sig = unique(significant)) %>%
    arrange(cluster.id) %>%
    mutate(cluster.id = factor(cluster.id, levels = cluster_chart_labels),
           significant = ifelse(sig, "TRUE", "FALSE")) %>%
    ggplot(aes(x = cluster.id, y =  log10p, fill = significant)) +
    geom_bar( stat = "identity", alpha = bar.alpha) +
    scale_x_discrete("Cluster", labels = as.character(cluster_chart_labels), breaks = cluster_chart_labels) + 
    theme_classic() +
    xlab("Cluster ID") + ylab("Chi Sq Test (-log10(p))") +
    ggtitle("Observed vs. Expected Cluster Content") +
    scale_fill_manual(values=c("black","tomato"))
  
  
  return(plt.chi_res)
}

plot.obsExp_scatter <- function(df.chi, my_cols){
  
  plt.obs_vs_exp <- ggplot(df.chi, aes(x = observed, y = expected , color = batch, fill = batch)) +
    geom_point() + 
    geom_smooth(method = 'lm', alpha = 0.1) + 
    scale_fill_manual(values = my_cols) + 
    theme_classic() + 
    scale_color_manual(values = my_cols) + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") + 
    xlab("Observed (within cluster)") + ylab("Expected (within cluster)") + 
    ggtitle("Observed vs. Expected Cluster Content\ndashed: expected, solid: fit")
  
  
  return(plt.obs_vs_exp)
}

```


```{r chi sq test function}


# compute chi square statistics for cluster composition
compute.chi.statistics <- function(df.tally, u.clusters, u.batches, n.clusters, expected.freq) {
  
  
  df.chi <- NULL
  which.missing <- NULL
  
  for (i in 1:n.clusters){
    
    
    df.tally.cur <- df.tally %>% dplyr::filter(cluster == u.clusters[i])
    
    
    if (!all(u.batches %in% df.tally.cur$batch)){
      which.missing <- which((!(u.batches %in% df.tally.cur$batch)))
    } else {
      which.missing <- NULL
    }
    which.av <- which(((u.batches %in% df.tally.cur$batch)))
    
    batch.cur <- as.vector(df.tally.cur$batch)
    obs.n <- df.tally.cur$n
    exp.f <- expected.freq[batch.cur]
    
    if (!is.null(which.missing)){
      for (j in 1:length(which.missing)){
        batch.cur <- c(batch.cur, u.batches[which.missing[j]])
        obs.n <- c(obs.n, 0)
        exp.f <- expected.freq[batch.cur]
      }
    }
    
    exp.n <- round(sum(df.tally.cur$n) * exp.f)
    
    chisq.res <- chisq.test(obs.n, p = exp.f)
    
    chi.p <- chisq.res[["p.value"]]
    
    
    df.chi.cur <- data.frame(cluster = u.clusters[i],
                             batch = batch.cur,
                             observed = (obs.n),
                             expected = (exp.n),
                             p = signif(chi.p, 3),
                             otherp = signif(-log10(chi.p)),
                             sig = chi.p < 0.05)
    colnames(df.chi.cur) <- c("cluster","batch",  "observed", "expected", "chi.p", "log10.p", "significant")
    
    df.chi <- bind_rows(df.chi, df.chi.cur)
    
  }
  
  return(df.chi)
  
}

```


```{r compare cluster composition, warning=F, message=F, fig.width=17}

# cluster_resolution

comp.res <-list()

chi.res.list <- list()

for (i  in 1:length(cluster_resolution)){
  
  cur.cluster <- paste(DefaultAssay(so.query), "_snn_res.", cluster_resolution[i], sep = "")
  
  batches <- as.vector(so.query@meta.data[["group.query"]])
  clusters <- as.vector(so.query@meta.data[[cur.cluster]])
  
  u.batches <- unique(batches)
  u.clusters <- unique(clusters)
  
  df.cluster_comp <- data.frame(batch = batches, 
                                cluster = clusters)
  
  df.tally <- df.cluster_comp %>%
    group_by(cluster, batch) %>%
    tally() %>%
    mutate(freq = n/sum(n))
  
  
  df_for_wide <- df.tally
  # df.all_id_wide <- long2wide(df_for_wide)
  
  df.cluster_annotations <- df.tally
  
  u.batches <- unique(batches)
  n.batches <- length(u.batches)
  
  color_count <- max(n.batches)
  my_cols <- group.cols
  
  
  # get expected proportional to delinate on bargraph
  batch.factor <- factor(batches)
  batch.levels <- levels(batch.factor)
  
  n.clusters <- length(u.clusters)
  
  df.tally.all <- df.tally %>%
    group_by(batch) %>%
    summarize(n.all = sum(n))
  df.tally.all$n.all.rel <- df.tally.all$n.all / sum(df.tally.all$n.all)
  
  batch.levels.rev <- rev(batch.levels)
  rownames(df.tally.all) <- df.tally.all$batch
  cum.freq <- cumsum(df.tally.all[batch.levels.rev, "n.all.rel"])$n.all.rel[1:(nrow(df.tally.all) - 1)]
  
  
  # ensure that clusters are ordered numerically
  reordered_clusters <- order(as.numeric(as.vector(df.cluster_annotations$cluster)))
  df.cluster_annotations <- df.cluster_annotations[reordered_clusters, ]
  df.cluster_annotations$cluster <- as.numeric(as.vector(df.cluster_annotations$cluster))
  cluster_chart_labels <- unique(df.cluster_annotations$cluster)
  
  # get expected frequencies
  expected.freq <- df.tally.all$n.all.rel
  names(expected.freq) <- rownames(df.tally.all)
  
  bar.alpha <- 0.8
  
  # FREQUENCY PLOTS #################
  
  plt.fStack.list <- list()
  plt.fDodge.list <- list()
  plt.nStack.list <- list()
  plt.nDodge.list <- list()
  
  plt.cluster_composition_fStack <- plot.clusterComp_fStack(df.cluster_annotations, cluster_chart_labels, my_cols,cum.freq ,  bar.alpha = 0.8)
  plt.cluster_composition_fDodge <- plot.clusterComp_fDodge(df.cluster_annotations, cluster_chart_labels,  my_cols, bar.alpha = 0.8)
  
  plt.cluster_composition_nStack <- plot.clusterComp_nStack(df.cluster_annotations, cluster_chart_labels,  my_cols, bar.alpha = 0.8)
  plt.cluster_composition_nDodge <- plot.clusterComp_nDodge(df.cluster_annotations, cluster_chart_labels,  my_cols, bar.alpha = 0.8)
  
  plt.n_vs_freq <- plot.nFreq_scatter(df.cluster_annotations, my_cols, expected.freq , group.cols , line.alpha = 0.2)
  
  
  df.chi <- compute.chi.statistics(df.tally, u.clusters, u.batches, n.clusters, expected.freq)
  
  chi.res.list[[as.character(cluster_resolution[i])]] <- df.chi
  
  
  plt.obs_vs_exp <- plot.obsExp_scatter(df.chi, my_cols)
  plt.chi_res <- plot.chiSq_results(df.chi, cluster_chart_labels)
  
  
  
  
  plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = cur.cluster, label = TRUE)  + 
    ggtitle(label = paste("Resolution: ", cluster_resolution[i], sep = "")) + 
    xlab("UMAP 1") + 
    ylab("UMAP 2")
  
  if (print.inline){
    print(ggpubr::ggarrange(plt.umap_by_cluster, plt.cluster_composition_fStack, plt.cluster_composition_nStack, 
                            plt.n_vs_freq, plt.obs_vs_exp,plt.chi_res, ncol = 3, nrow = 2))
    
  }
  
  comp.res[[as.character(cluster_resolution[i])]] <- list(plt.umap_by_cluster, plt.cluster_composition_fStack, plt.cluster_composition_nStack,
                                                          plt.n_vs_freq, plt.obs_vs_exp, plt.chi_res)
  
}


```



```{r, warning=F, message=F, fig.width=17}


supp.analysis <-list()

supp.anova.analysis <- list()

supp.comp.table <- list()

if (custom.subanalysis== 1){
  


for (i  in 1:length(cluster_resolution)){
  
  cur.cluster <- paste(DefaultAssay(so.query), "_snn_res.", cluster_resolution[i], sep = "")
  
  orig.groups <- as.vector(so.query@meta.data[[group.field]])
  batches <- as.vector(so.query@meta.data[["group.query"]])
  clusters <- as.vector(so.query@meta.data[[cur.cluster]])
  
  u.groups <- unique(orig.groups)
  u.batches <- unique(batches)
  u.clusters <- unique(clusters)
  u.clusters <- u.clusters[order(as.numeric(u.clusters))]
  
  df.cluster_comp <- data.frame(groups = orig.groups,
                                batch = batches, 
                                cluster = clusters)
  
  df.cluster_comp$cluster <- factor(df.cluster_comp$cluster, levels = u.clusters)
  
  
  df.tally.batch <- df.cluster_comp %>%
    group_by(cluster, batch) %>%
    tally() %>%
    group_by(cluster) %>% #temp
    mutate(freq.method = n/sum(n))
  
  
  T.group <- c("T1", "T2", "T3")
  df.cluster_comp$T.group <- NA
  for (j in 1:length(T.group)){
    df.cluster_comp$T.group[grepl(T.group[j], df.cluster_comp$groups)] <- T.group[j]
  }
  
  df.tally.group <- df.cluster_comp %>%
    group_by(cluster, T.group) %>%
    tally() %>%
     group_by(cluster) %>% #temp
    mutate(freq.Tumor = n/sum(n))
  
  
  # df.tally.group.batch <- df.cluster_comp %>%
  #   group_by(batch, T.group, cluster) %>%
  #   tally() %>%
  #   mutate(freq.all = n/sum(n))
  
  
    df.tally.group.batch <- df.cluster_comp %>%
    group_by(cluster, T.group, batch) %>%
    tally() %>% 
    group_by(cluster) %>%
    mutate(freq.all = n/sum(n))
  
  
  
  
  
  
  # 
  # p.batchc <- signif(summary(aov(freq.method.paired ~ cluster, df.tally.batch))[[1]][["Pr(>F)"]][1], 3)
  # p.tumorc <- signif(summary(aov(freq.Tumor.paired ~ cluster, df.tally.group))[[1]][["Pr(>F)"]][1], 3)
  
  plt.batch <- df.tally.batch %>%
    ggplot(aes(x = cluster, y = freq.method)) +
    geom_boxplot() +
    geom_point(aes(color = batch), position=position_dodge(width=0)) + 
    geom_hline(yintercept = mean(df.tally.batch$freq.method), color = "red", linetype = "dashed") + 
    theme_classic()  + 
    xlab("Cluster ID") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle("Composition, by cluster/method")
  
  
  plt.group <-df.tally.group %>%
    ggplot(aes(x = cluster, y = freq.Tumor)) +
    geom_boxplot() +
    geom_point(aes(color = T.group), position=position_dodge(width=0)) + 
    geom_hline(yintercept = mean(df.tally.group$freq.Tumor), color = "red", linetype = "dashed") + 
    theme_classic() + 
    xlab("Cluster ID") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle("Composition, by cluster/tumor")
  
  
  # statistical testing
  
  df.tally.batch <- df.tally.batch %>%
    group_by(cluster) %>%
    mutate(freq.method.paired = freq.method-mean(freq.method))
  
  df.tally.group <- df.tally.group %>%
    group_by(cluster) %>%
    mutate(freq.Tumor.paired = freq.Tumor-mean(freq.Tumor))
  
  # p.batch <- signif(kruskal.test(freq.method.paired ~ batch, df.tally.batch)[["p.value"]], 3)
  # p.tumor <- signif(kruskal.test(freq.Tumor.paired ~ T.group, df.tally.group)[["p.value"]], 3)
  
  p.batch <- signif(summary(aov(freq.method.paired ~ batch, df.tally.batch))[[1]][["Pr(>F)"]][1], 3)
  p.tumor <- signif(summary(aov(freq.Tumor.paired ~ T.group, df.tally.group))[[1]][["Pr(>F)"]][1], 3)
  
  # ANOVA
  aov.all <- aov(freq.all ~ n + batch*cluster +  cluster*T.group, df.tally.group.batch)
  
  aov.sum <- summary(aov.all)
  aov.sum <- aov.sum[[1]]
  aov.sum$`Sum Sq` <- signif(aov.sum$`Sum Sq`, 3)
  aov.sum$`Mean Sq` <- signif(aov.sum$`Mean Sq`, 3)
  aov.sum$`F value` <- signif(aov.sum$`F value`, 3)
  aov.sum$`Pr(>F)` <- signif(aov.sum$`Pr(>F)`, 3)
  aov.sum$var.prop <- signif(aov.sum$`Sum Sq` / sum(aov.sum$`Sum Sq`), 3)
  
  # datatable(aov.sum)
  # hist(aov.all[["residuals"]])
  # (summary(aov(freq.all ~ batch*cluster + n + T.group, df.tally.group.batch)))
  
  plt.batch.agg <- df.tally.batch %>%
    ggplot(aes(x = batch, y = freq.method)) +
    geom_boxplot() +
    geom_point(aes(color = batch), position=position_dodge(width=0)) + 
    geom_hline(yintercept = mean(df.tally.batch$freq.method), color = "red", linetype = "dashed") + 
    theme_classic() + 
    xlab("Method") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle("Composition, by method") + 
    ggtitle(paste("Composition, by method\nANOVA, p=", p.batch, sep ="")) + 
    theme(legend.position = "none") + 
    ylim(min(c(df.tally.batch$freq.method, df.tally.batch$freq.method)), max(c(df.tally.batch$freq.method, df.tally.batch$freq.method)))
  
  plt.group.agg <- df.tally.group %>%
    ggplot(aes(x = T.group, y = freq.Tumor)) +
    geom_boxplot() +
    geom_point(aes(color = T.group), position=position_dodge(width=0)) + 
    geom_hline(yintercept = mean(df.tally.group$freq.Tumor), color = "red", linetype = "dashed") + 
    theme_classic() + 
    xlab("Tumor") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle(paste("Composition, by tumor\nANOVA, p=", p.tumor, sep ="")) + 
    theme(legend.position = "none") + 
    ylim(min(c(df.tally.batch$freq.method, df.tally.batch$freq.method)), max(c(df.tally.batch$freq.method, df.tally.batch$freq.method)))
  
  plt.batch.group.agg <- df.tally.group.batch %>%
    ggplot(aes(x = T.group, y = freq.all, fill = batch)) +
    geom_boxplot(outlier.shape=NA) +
    geom_point(position=position_jitterdodge(jitter.width = 0.1),alpha=0.3) +
    geom_hline(yintercept =mean(df.tally.group.batch$freq.all), color = "red", linetype = "dashed") + 
    theme_classic() + 
    xlab("Tumor") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle("Composition, by tumor and method") + 
    ylim(min(c(df.tally.group.batch$freq.all, df.tally.group.batch$freq.all)), max(c(df.tally.group.batch$freq.all, df.tally.group.batch$freq.all)))
  
  # print(ggpubr::ggarrange(plt.batch, plt.group, ncol = 2, nrow = 1))
  
  plt.umap_by_cluster <- DimPlot(so.query, reduction = "umap", group.by = cur.cluster, label = TRUE)  + 
    ggtitle(label = paste("Resolution: ", cluster_resolution[i], sep = "")) + 
    xlab("UMAP 1") + 
    ylab("UMAP 2")
  

    
    
    plt.batch.group.strata <- df.tally.group.batch %>%
    ggplot(aes(x = cluster, y = freq.all)) +
    geom_boxplot(outlier.shape=NA) +
    geom_point(aes(shape = T.group, color = batch), alpha = 0.7) +
    geom_hline(yintercept =mean(df.tally.group.batch$freq.all), color = "red", linetype = "dashed") + 
    theme_classic() + 
    xlab("Cluster ID") + 
    ylab("Composition\nRel.Freq (within cluster)") + 
    ggtitle("Composition, by tumor and method") + 
    ylim(min(c(df.tally.group.batch$freq.all, df.tally.group.batch$freq.all)), max(c(df.tally.group.batch$freq.all, df.tally.group.batch$freq.all)))
    
    # plt.batch.group.strata
    
  

  
  if (print.inline){
    print(ggpubr::ggarrange( plt.umap_by_cluster ,plt.batch.group.strata, plt.group,plt.batch.group.agg, 
                             plt.batch.agg, plt.group.agg,  ncol =3, nrow = 2))
  }
  
  
  supp.analysis[[as.character(cluster_resolution[i])]] <- list(plt.umap_by_cluster, plt.batch.group.strata, 
                                                               plt.group, plt.batch.group.agg, 
                                                               plt.batch.agg, plt.group.agg)
  
  
  supp.anova.analysis[[as.character(cluster_resolution[i])]] <- aov.sum
  
  
  supp.comp.table[[as.character(cluster_resolution[i])]] <- df.tally.group.batch

  
}
  
}


```


```{r}


# datatable(df.chi,
#     filter = 'top',
#     extensions = 'Buttons',
#     options = list(pageLength = 50,
#     dom = 'Bfrtip',
#     buttons = c('copy', 'csv', 'pdf')))

# df.chi
```



UMAP
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

### UMAP (Grouped)
```{r umapgroup}
print(plt.umap_group) 
```

### UMAP (Group Membership)
```{r umap group membership, fig.width=15, fig.height=5}
print(plt.umap_membership)
```



Composition
===================================== 

Row {.tabset}
-------------------------------------

```{r ph3,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}


out_heat <- lapply(seq_along(comp.res), function(i) {
  
  s1 <- paste("res = ",  names(comp.res)[i], sep = "")
  
  
  s2 <- paste( "print(ggpubr::ggarrange(comp.res[[" ,i , "]][[1]], comp.res[[" ,i , "]][[2]], comp.res[[" ,i , "]][[3]], 
                        comp.res[[" ,i , "]][[4]], comp.res[[" ,i , "]][[5]],comp.res[[" ,i , "]][[6]], ncol = 3, nrow = 2))", sep = "" )
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=17, fig.height = 10,  message=FALSE, warning=FALSE}", paste("hm", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`


Composition (supplementary 1)
===================================== 

Row {.tabset}
-------------------------------------

```{r out_heat2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat2 <- NULL

try({
  
  
  out_heat2 <- lapply(seq_along(supp.analysis), function(i) {
    
    s1 <- paste("res = ",  names(supp.analysis)[i], sep = "")
    
    
    s2 <- paste( "print(ggpubr::ggarrange(supp.analysis[[" ,i , "]][[1]], supp.analysis[[" ,i , "]][[2]], supp.analysis[[" ,i , "]][[3]], 
                        supp.analysis[[" ,i , "]][[4]], supp.analysis[[" ,i , "]][[5]],supp.analysis[[" ,i , "]][[6]], ncol = 3, nrow = 2))", sep = "" )
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.width=17, fig.height = 10,  message=FALSE, warning=FALSE}", paste("hm2", i, sep = "")))               # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n %s", s2)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
}, silent = T)

```

`r paste(knitr::knit(text = paste(out_heat2, collapse = '\n')))`

ANOVA Tables (supplement)
===================================== 

Row {.tabset}
-------------------------------------


```{r detailed table output v3,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat3 <- NULL

try({
  
  out_heat3 <- lapply(seq_along(supp.anova.analysis), function(i) {
    
    s1 <- paste("supp.anova.analysis[[", i, "]]", sep = "")
    
    table.name <- paste("res=", names(supp.anova.analysis)[i], "")
    
    # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
    
    s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
    
    a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
    a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v3", i, sep = "")))               # start r chunk
    a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
    a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
    
    paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
    
  })
  
}, silent = T)

```

`r paste(knitr::knit(text = paste(out_heat3, collapse = '\n')))`



Composition Tables
===================================== 

Row {.tabset}
-------------------------------------


```{r detailed table output v2,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(chi.res.list), function(i) {
  
  s1 <- paste("chi.res.list[[", i, "]]", sep = "")
  
  table.name <- paste("res=", names(chi.res.list)[i], "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v2", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`


Composition Tables
===================================== 

Row {.tabset}
-------------------------------------


```{r detailed table output v4,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat_compSup <- lapply(seq_along(supp.comp.table), function(i) {
  
  s1 <- paste("supp.comp.table[[", i, "]]", sep = "")
  
  table.name <- paste("res=", names(supp.comp.table)[i], "")
  
  # s4 <- paste("datatable(", s1, ", filter = 'top')", sep = "")
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab_v4", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat_compSup, collapse = '\n')))`







```{r save analysis log and Rdata results, message=FALSE, warning=FALSE}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_21 <- df.log



```

```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 21)
===================================== 

```{r table.log_current, message=FALSE, warning=FALSE}

knitr::kable(df.log_Module_21)

```

