---
title: "GBM Subtyping"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# load packages
packages2load <- c("scMiko", "Seurat", "plyr",  "dplyr", "tidyr", "reshape2", 
                   "DT", "flexdashboard", "ggpmisc", "future", "foreach", "doParallel",
                   "AnnotationDbi", "org.Mm.eg.db", "org.Hs.eg.db", "fgsea", "ggplot2", "reactome.db",
                   "schex", "RColorBrewer", "cowplot")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))





```


```{r parameter specifications}


# input.file <- "Module1_p9_GBM_PR_nololim_260620.Rdata"
# input.file <- "Module1_p9_GBM_PR_noFilter_270620.Rdata"
# input.file <- "M01_NM2_R1_test_300720.Rdata"
# input.file <- "Module1_p9_GBM_PR_noFilter_270620.Rdata"
input.file <- "M01_NM2_R1_test_300720.Rdata"

# cluster resolution
cluster.resolution <- 0.5

# print inline
print.inline <- F

# Data subsampling
subsample_factor <- 1 # OPTIONAL; range 0 to 1 (default = 1)

which.subset <- NULL
# which.subset <- data.frame(field = "Barcode", subgroups = c("invitro"))


# barcode recoding
# named list, with new barcodes in names and old barcode patterns in entries
barcode.recode <- "gbm_2"
barcode.recode <- NULL

# species
which.species <- "Mm"

save.pdf <- F

```

```{r load data, warning = FALSE}

# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load data
warning("Importing data...")
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""))


if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

if (!(exists("which.subset"))) which.subset <- "no.subset"
if (!(exists("barcode.recode"))) which.subset <- NULL

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                             species = which.species, resolution= cluster.resolution, subset.data = which.subset, 
                         barcode.recode = barcode.recode, subsample = subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                             terms2drop = c("ica", "tsne", "nmf", "gsva", "deg"), rmv.pattern = "so", 
                         scale.reprocessed = F, neighbors.reprocessed = F, keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list)
invisible({gc()})

```



```{r analysis log}

# Module
df.log <- initiateLog("28, GBM Subtype Spectra")
df.log <- addLogEntry("Query File (.Rdata)", (input.file), df.log, "input.file")
df.log <- addLogEntry("Default Assay", (current.assay), df.log, "current.assay")
df.log <- addLogEntry("Cluster Resolution", (cluster.resolution), df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample Factor", (subsample_factor), df.log, "subsample_factor")

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```



```{r generate umaps, fig.width=10, fig.height=4}

# get umap
plt.umap_by_cluster <- cluster.UMAP(
  so.query,
  group.by = "seurat_clusters",
  x.label = "UMAP 1",
  y.label = "UMAP 2",
  plot.name = "UMAP",
  include.labels = T,
  reduction = "umap"
) + labs(subtitle = paste0("Clusters (resolution = ", cluster.resolution ,")"))


plt.umap_by_barcode <- cluster.UMAP(
  so.query,
  group.by = "Barcode",
  x.label = "UMAP 1",
  y.label = "UMAP 2",
  plot.name = "UMAP",
  include.labels = F,
  reduction = "umap"
) + labs(subtitle = "Barcodes") + 
  ggthemes::scale_color_tableau()

plt.umap.overview <-   cowplot::plot_grid(plt.umap_by_cluster, plt.umap_by_barcode)

if (print.inline) plt.umap.overview


```


```{r get GBM meta module genes, include = FALSE}

# get GBM genes
gbm.genes <- data.frame(geneSets[["GBM_Hs_Neftel2019"]])

# convert to list
gbm.list <- list()
for (i in 1:ncol(gbm.genes)){
  
  # enforce correct species
  if (which.species == "Hs"){
    gbm.genes[ ,i] <- toupper(gbm.genes[,i])
  } else if (which.species == "Mm"){
    gbm.genes[ ,i] <- firstup(gbm.genes[,i])
  }
  
  # get module name
  module.name <- colnames(gbm.genes[i]) 
  
  # assign to list
  gbm.list[[module.name]] <- gbm.genes[!is.na(gbm.genes[ ,i]) ,i]
}

# compute jaccard similarity
j.mat <- jaccardSimilarityMatrix(gbm.genes, assert.unique = T)

 plt.jac.sim.mod <-  ggplotify::as.ggplot(pheatmap::pheatmap(j.mat, 
                   main = "GBM Meta-Module Similarities",
                   color  = viridis::inferno(20)))


# plot heatmap
if (print.inline){
print(plt.jac.sim.mod)
}


```

```{r compute module scores}


module.scores <- matrix(ncol = length(gbm.list), nrow = ncol(so.query))

for (i in 1:length(gbm.list)){
  current.list <- list(g1 = gbm.list[[i]])
  
  so.temp <- AddModuleScore(
    so.query,
    features = current.list,
    pool = NULL,
    nbin = 17,
    ctrl = 100,
    k = FALSE,
    assay = current.assay,
    name = "ModuleScore",
    seed = 1,
    search = FALSE
  )
  
  module.scores[ ,i] <- so.temp@meta.data[["ModuleScore1"]]
}

colnames(module.scores) <- names(gbm.list)
rownames(module.scores) <- rownames(so.query@meta.data)
rm(so.temp)



MES.score <- apply(module.scores[ ,c("MES1", "MES2")], 1, mean)
NPC.score <- apply(module.scores[ ,c("NPC1", "NPC2")], 1, mean)

pooled.scores <- cbind(MES.score, NPC.score)
colnames(pooled.scores) <- c("MES", "NPC")
module.scores <- cbind(module.scores, pooled.scores)

```

```{r plot module scores, fig.width=15, fig.height=7}

# heatmap
if (print.inline){
  pheatmap::pheatmap(module.scores, show_rownames = F)
}


# UMAP
umap.x <- so.query@reductions[["umap"]]@cell.embeddings[ ,1]
umap.y <- so.query@reductions[["umap"]]@cell.embeddings[ ,2]

plt.umap.list <- list()

for (i in 1:length(gbm.list)){
  
  module.name <- names(gbm.list)[i]
  
  plt.umap.list[[module.name]] <- pseudotime.UMAP(
    x = umap.x,
    y = umap.y,
    module.scores[ ,i],
    pt.size = 0.9,
    pt.alpha = 1,
    x.lab = "UMAP 1",
    y.lab = "UMAP 2") + 
    theme_miko(legend = F) + 
    viridis::scale_color_viridis(module.name, option = "B") + 
    ggtitle(module.name) + 
    theme(panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank(),
          panel.background = element_blank(),
          axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.title.y=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks.y=element_blank())
  
}

if (print.inline){
  cowplot::plot_grid(plotlist = plt.umap.list, ncol = 4)
}



```

```{r}

cellCycleScores <- function(so, which.species = "Hs", override.existing.scores = F){
  
  
  do.scoring <- F
  if (!("Phase" %in% colnames(so.query@meta.data))){
    do.scoring <- T
  } else {
    if (override.existing.scores) do.scoring <- T
  }
  
  if (do.scoring){
    
    warning("Scoring cell cycle...\n")
    
    # get cell cycle genes
    s.genes <- cc.genes$s.genes
    g2m.genes <- cc.genes$g2m.genes
    
    # ensure correct species
    if (which.species == "Mm"){
      s.genes <-  firstup(s.genes)
      g2m.genes <-  firstup(g2m.genes)
    } else if (which.species == "Hs"){
      s.genes <-  toupper(s.genes)
      g2m.genes <-  toupper(g2m.genes)
    }
    
    # score cell cycle
    so <- CellCycleScoring(so, s.features = s.genes, g2m.features = g2m.genes, set.ident = F)
    
  } else {
    warning("Cell cycle scores found in existing seurat object...\n")
  }
  
  
  # return seurat object
  return(so)
}


  
```

```{r 2D representation of malignant cell states, fig.width=6, fig.height=5}

# Note: 
# for hybrid scoring, create variable in module.scores object and specify subset using class.names list. 

# subset module scores
class.names <- list(
  OPC = "OPC",
  NPC = "NPC",
  AC = "AC",
  MES = "MES"
)


ms <- module.scores[ ,unlist(class.names)]
opc_npc.subset <- c(class.names$OPC, class.names$NPC)
ac_mes.subset <- c(class.names$AC, class.names$MES)

# define y-axis
SC_opc_npc_max <- apply(ms[,opc_npc.subset], 1, function(x) max(x))
SC_ac_mes_max <- apply(ms[,ac_mes.subset], 1, function(x) max(x))

# y-axis value
D.y <- SC_opc_npc_max-SC_ac_mes_max

# define y axis
# x-axis sign class
D.y.sign <- sign(D.y)

# D > 0 class
Dpos.x <- log((abs(ms[,class.names$NPC] - ms[,class.names$OPC]) + 1), base = 2)
Dpos.x.class <- Dpos.x.dif <- ms[,class.names$NPC] - ms[,class.names$OPC]
Dpos.x.class[Dpos.x.dif > 0] <- 1  #NPC
Dpos.x.class[Dpos.x.dif < 0] <- -1 #OPC
Dpos.x <- Dpos.x*Dpos.x.class

# D < 0 class
Dneg.x <- log((abs(ms[,class.names$MES] - ms[,class.names$AC]) + 1), base = 2) 
Dneg.x.class <- Dneg.x.dif <- ms[,class.names$MES] - ms[,class.names$AC]
Dneg.x.class[Dneg.x.dif > 0] <- 1   #MES
Dneg.x.class[Dneg.x.dif < 0] <- -1  #AC
Dneg.x <- Dneg.x*Dneg.x.class


# check if cell cycle scores exist - if not, score. 
so.query <- cellCycleScores(so.query, which.species = which.species)

df.state <- data.frame(D.y, 
                       Dpos.x, 
                       Dneg.x, 
                       D.y.sign, 
                       barcode = so.query@meta.data[["Barcode"]],
                       cluster = so.query@meta.data[["seurat_clusters"]],
                       cell.cycle = so.query@meta.data[["Phase"]])

df.state$y <- df.state$D.y
df.state$x <- df.state$Dpos.x
df.state$x[df.state$y < 0] <- df.state$Dneg.x[df.state$y < 0]

# df.state$PRclass <- "P"
# df.state$PRclass[grepl("R", df.state$barcode)] <- "R"

scale.max <- max(c(abs(df.state$x), abs(df.state$y))) * 1.1
# 
# df.state %>%
#   ggplot(aes(x, y)) + 
#   geom_point(size = 0.9) + 
#   xlab("Relative meta-module score\n[log(|SC1-SC2|+1)]") + 
#   ylab("Relative meta-module score\n[log(|SC1-SC2|+1)]") + 
#   geom_hline(yintercept = 0, linetype = "dashed") + 
#   geom_vline(xintercept = 0, linetype = "dashed") + 
#   labs(title = "Meta-module Scores") + 
#   xlim(-scale.max, scale.max) + 
#   ylim(-scale.max, scale.max) + 
#   theme_miko() 

```


```{r, fig.width=6, fig.height=5}

df.labels <- data.frame(x = c(scale.max*0.9,-scale.max*0.9,-scale.max*0.9,scale.max*0.9),
                        y = c(scale.max,scale.max,-scale.max,-scale.max),
                        label = c("NPC", "OPC", "AC", "MES"))

color.pal <- "slategray" # lightgrey

plt.metascores <- df.state %>%
  ggplot(aes(x, y)) + 
  xlab("Relative meta-module score\n[log(|SC1-SC2|+1)]") + 
  ylab("Relative meta-module score\n[log(|SC1-SC2|+1)]") + 
  labs(title = "GBM Subtypes", subtitle = "2D Representation (Neftel 2019)") + 
  theme_miko() + 
  theme(panel.border = element_rect(colour = color.pal, fill=NA, size=4)) + 
  annotate("rect", xmin = -scale.max, xmax = 0, ymin = -scale.max, ymax = scale.max, fill= "white")  + 
  annotate("rect", xmin = 0, xmax = scale.max, ymin = 0, ymax = scale.max , fill= "white") + 
  annotate("rect", xmin = 0, xmax = scale.max, ymin = -scale.max, ymax = scale.max, fill= "white") + 
  annotate("rect", xmin = -scale.max, xmax = 0, ymin = 0, ymax = scale.max, fill= "white") + 
  geom_hline(yintercept=0, color = color.pal, size=1.5) + 
  geom_vline(xintercept=0, color = color.pal, size=1.5) + 
  geom_point(size = 0.9, alpha = 1.0)  + 
  geom_label(data = df.labels, aes(x = x, y = y, label = label), fill = color.pal, color="white") 

```


```{r GBM state stratified by groups}

# SPECIFY GBM SUBTYPE
df.state$GBMstate <- NA
df.state$GBMstate[df.state$x > 0 & df.state$y > 0] <- "NPC"
df.state$GBMstate[df.state$x > 0 & df.state$y < 0] <- "MES"
df.state$GBMstate[df.state$x < 0 & df.state$y > 0] <- "OPC"
df.state$GBMstate[df.state$x < 0 & df.state$y < 0] <- "AC"

# assign states to seurat object
so.query$GBMstate <- df.state$GBMstate

# BARPLOTS ################################

plt.cell.cycle.bar <- df.state %>%
  group_by(GBMstate, cell.cycle) %>%
  tally() %>%
  ggplot(aes(x = GBMstate, y = n, fill = cell.cycle)) + 
  geom_bar(stat = "identity", position = "fill") + 
  theme_miko(legend = T) + 
  xlab("GBM State") + 
  ylab("Relative Frequency") + 
  labs(title = "Cell Cycle Phase",
       subtitle = "Distribution") + 
  ggthemes::scale_fill_tableau()


plt.cluster.bar <- df.state %>%
  group_by(GBMstate, cluster) %>%
  tally() %>%
  ggplot(aes(x = cluster, y = n, fill = GBMstate)) + 
  geom_bar(stat = "identity", position = "fill") + 
  theme_miko(legend = T) + 
  xlab("Cluster ID") + 
  ylab("Relative Frequency") + 
  labs(title = "GBM Subtype Characteristics",
       subtitle = "Cluster by GBM Subtype") +
  ggthemes::scale_fill_ptol()

plt.barcode.bar <- df.state %>%
  group_by(GBMstate, barcode) %>%
  tally() %>%
  ggplot(aes(x = barcode, y = n, fill = GBMstate)) + 
  geom_bar(stat = "identity", position = "fill") + 
  theme_miko(legend = T) + 
  xlab("Barcode/Sample") + 
  ylab("Relative Frequency") + 
  labs(title = "GBM Subtype Characteristics",
       subtitle = "Barcode by GBM Subtype") + 
  ggthemes::scale_fill_ptol() + 
  theme(axis.text.x = element_text(angle = 35, vjust = 1, hjust=1))

# UMAPs ################################
plt.umap_by_state <- cluster.UMAP(
  so.query,
  group.by = "GBMstate",
  x.label = "UMAP 1",
  y.label = "UMAP 2",
  plot.name = "GBM Subtypes",
  include.labels = F,
  reduction = "umap"
) + labs(subtitle = "UMAP") + 
  ggthemes::scale_color_ptol() + 
  theme_miko(legend = T)

plt.umap_by_cc <- cluster.UMAP(
  so.query,
  group.by = "Phase",
  x.label = "UMAP 1",
  y.label = "UMAP 2",
  plot.name = "Cell Cycle Phase",
  include.labels = F,
  reduction = "umap"
) + labs(subtitle = "UMAP") + 
  ggthemes::scale_color_tableau() + 
  theme_miko(legend = F)

# COMBINE PLOTS  ################################

plt.cc.combo <-   cowplot::plot_grid(plt.umap_by_cc, plt.cell.cycle.bar)
plt.bc.combo <-   cowplot::plot_grid(plt.umap_by_barcode, plt.barcode.bar)


plt.metastate.combo1 <- cowplot::plot_grid(plt.umap_by_state, plt.metascores)

plt.metastate.combo2 <- cowplot::plot_grid(plt.umap_by_cluster + theme_miko(legend = F),
                                           plt.umap_by_state + theme_miko(legend = T)
                                          )
plt.metastate.combo2 <- cowplot::plot_grid(plt.metastate.combo2, plt.cluster.bar, ncol = 1)


```


```{r explore additional queries}

e.mat <- getExpressionMatrix(so.query, which.data = "data")
which.genes <- c("EGFR", "PDGFRA", "CDK4", "NF1")

if (which.species == "Mm"){
  which.genes <- firstup(which.genes)
}
e.mat.sub <- t(e.mat[rownames(e.mat) %in% which.genes, ])


df.state <- bind_cols(df.state, data.frame(e.mat.sub))

which.available <- which.genes[which.genes %in% colnames(df.state)]
if (length(which.available) > 0){
  df.state.long <- pivot_longer(df.state, cols = which.available)
  
  plt.expression <- df.state.long %>%
    group_by(GBMstate) %>%
    ggplot(aes(x = GBMstate, y = value, fill = GBMstate)) +
    geom_boxplot() +
    theme_miko()+ 
    ggthemes::scale_fill_ptol() + 
    facet_wrap(~name) + 
    xlab("GBM Subtype") + ylab("Expression") + 
    labs(title= "Markers of Interest", subtitle = "GBM subtype-stratified expression")
} else {
  plt.expression <- NULL
}

if (print.inline){
  print(plt.expression)
}

```


```{r central log}

# update central log
run.id <- NULL
if (!exists("user")) user <- "guest"

clog.update.success <- F
try({
  run.id <-  updateCentralLog(Module = "M28", input.data = input.file, input.subset = NA, pdf.flag = save.pdf)
  clog.update.success <-  T
}, silent = F)
if (is.null(run.id))  {
  warning("Central log update was unsuccessful :(\n")
  run.id <- paste("M28_", user, "_r", paste0(format(Sys.time(), '%s')), sep = "", collapse = "")
}

```


```{r setup output directories}

# output path
if (!exists("data.path")) data.path = ""
output.path <- paste0(data.path, "Module_Outputs/", paste0(run.id,"_",format(Sys.time(), '%d%m%y'), "/"))

# create output directories
dir.create(output.path)
dir.create(paste0(output.path, "Tables/"))
if (save.pdf) dir.create(paste0(output.path, "PDF/"))

```


1) cluster UMAP
===================================== 

### UMAP

```{r overview map, fig.width=10, fig.height=4}

  print(plt.umap.overview)

savePDF(file.name = paste0(output.path, "PDF/", "M28_umap_cluster.pdf"), plot.handle = plt.umap.overview, 
        fig.width = 12, fig.height = 5, save.flag = save.pdf)

```

2) Meta-Modules
===================================== 

Row {.tabset}
-------------------------------------

### Subtype Classification

```{r, fig.width=9, fig.height=4}

print(plt.metastate.combo1)

savePDF(file.name = paste0(output.path, "PDF/", "M28_subtype_classification.pdf"), plot.handle = plt.metastate.combo1, 
        fig.width = 9, fig.height = 4, save.flag = save.pdf)

```

### Modular Activity

```{r,  fig.width=15, fig.height=7}

plt.mod.activity <- cowplot::plot_grid(plotlist = plt.umap.list, ncol = 4)
print(plt.mod.activity)

savePDF(file.name = paste0(output.path, "PDF/", "M28_subtype_modular_activity_umap.pdf"), plot.handle = plt.mod.activity, 
        fig.width =15, fig.height = 7, save.flag = save.pdf)
  
```

### Jaccard Similarity

```{r js map}

print(plt.jac.sim.mod)

savePDF(file.name = paste0(output.path, "PDF/", "M28_genelist_jaccardsimilarity_heatmap.pdf"), plot.handle = plt.jac.sim.mod, fig.width =7, fig.height = 7, save.flag = save.pdf)
```

3) Stratified Analyses
===================================== 

Row {.tabset}
-------------------------------------

### Cell Cycle

```{r, fig.width=9, fig.height=4}

print(plt.cc.combo)

savePDF(file.name = paste0(output.path, "PDF/", "M28_cellcycle_by_subtype.pdf"), plot.handle = plt.cc.combo, fig.width =9, fig.height = 4, save.flag = save.pdf)

```

### Clusters

```{r, fig.width=9, fig.height=7}

print(plt.metastate.combo2)

savePDF(file.name = paste0(output.path, "PDF/", "M28_subtype_by_cluster.pdf"), plot.handle = plt.cc.combo, fig.width =9, fig.height = 7, save.flag = save.pdf)

```

### Barcodes

```{r, fig.width=11, fig.height=4}


print(plt.bc.combo)

savePDF(file.name = paste0(output.path, "PDF/", "M28_subtype_by_barcode.pdf"), plot.handle = plt.bc.combo, fig.width =11, fig.height = 4, save.flag = save.pdf)

```

4) Expression Plots
===================================== 

### Markers of Interest

```{r markers of interest plots}

print(plt.expression)

savePDF(file.name = paste0(output.path, "PDF/", "M28_subtype_markers.pdf"), 
        plot.handle = plt.expression, save.flag = save.pdf)



```

```{r finalize log}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)

df.log <- addLogEntry("User", user, df.log, "user")
df.log <- addLogEntry("Central Log Updated", clog.update.success, df.log, "clog.update.success")
df.log <- addLogEntry("Run Time (s)", elapsed.time, df.log, "elapsed.time")

df.log_Module_28 <- df.log

```

```{r ph10,  echo = FALSE, eval = TRUE}

try({
  out1 <- flex.multiTabLogs(module.logs)
}, silent = T)
```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`

Log (Module 28)
===================================== 

```{r table.log_current}
knitr::kable(df.log_Module_28)
```

```{r save analysis log as csv}

try({
  write.csv(df.log_Module_28, file = paste0(output.path, "Tables/", "analysisLog.csv"), 
    row.names = F)  
}, silent = T)

```


```{r merge pdfs, include = FALSE}

# combine pdfs into single binder
if (save.pdf){
  try({
    pdf.list <- list.files (path = paste0(output.path, "PDF/") )
    pdf.list <- paste0( paste0(output.path, "PDF/"), pdf.list[grepl(".pdf", pdf.list)])
    
    pdftools::pdf_combine(pdf.list, output =  paste0(output.path, "PDF/merged_binder.pdf"))
  }, silent = T)
}


```
