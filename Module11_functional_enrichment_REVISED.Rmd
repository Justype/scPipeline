---
title: "Module11_functional_enrichment"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---


```{r setup, include=FALSE}

# TODO: ensure that top differetnially expressed markers are SIGNIFICANT (i.e., p <0.05)


rm(list = ls())
#options(pkgType = "source")

start.time <- proc.time()

# LOAD LIBRARIES

# scRNAseq libraries
library(Seurat)
library(sctransform)
# library(sigPathway)
library(SCINA)

# Data wrangling libraries
library(plyr)
library(dplyr)
library(tidyr)
library(reshape2)


# Data visualization libraries
library(RColorBrewer)
library(ggplot2)
library(gridExtra)
library(DT)
library(flexdashboard)
library(ggpmisc)
library(ggExtra)
library(grid)
library(ggrepel)
library(GOplot)
# library(Rgraphviz)
library(DT)
library(enrichplot)

# Other Libraries
library(future)
try(library(xlsx), silent = TRUE)
library(AnnotationDbi)
library(org.Mm.eg.db)
library(org.Hs.eg.db)
library(ddpcr)
library(topGO)
# library(ViSEAGO)
library(clusterProfiler)
library(ReactomePA)
library(DOSE)
library(GO.db)

```



```{r check available input files}

show.available.files <- FALSE
if (show.available.files){
  list.files("Marker Datasets/")
  }

```

```{r input_data}

# query input (Requires Module 8 output)
input.file <- "Module8_markers_p3_p5_renca_tumor_270120.Rdata"

# Module8_Markers_lung_EVLP_599_CIT_171219

# Specify data directories
dir.markers <- "Marker Datasets/"

# specify cluster resolution (e.g., c(0.15, 0.5, 1, 5))
cluster_resolution <- c(0.15)


# print inline
print.inline <- FALSE

species <- "Mm"
mapping.db <- "org.Mm.eg.db" # org.Mm.eg.db (mouse) or org.Hs.eg.db (human)

annotation.functions <- c("enrichGO", "enrichKEGG", "enrichDO", "enrichPathway")
# annotation.functions <- c("enrichPathway")


# threshold parameters
enrich.p_threshold <- 0.05
enrich.p_adjust <- "BH"
DEG.LFC_threshold <- 1
DEG.p_threshold <- 0.01

# specify save flag (saves .RData and .xlsx files)
# save.Rdata.flag <- TRUE
# Rdata.filename <- "Module8_Markers_Lung_0_15res_allMarkers_151219"

# save.xlsx.flag <- TRUE
# xlsx.filename <- "Module8_Markers_Lung"
# xlsx.filename <- Rdata.filename


```

```{r load data}
# load data
load(paste(dir.markers, input.file, sep = ""))
so.query <- so
rm(so)

```


```{r}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

# check available cluster resolutions
available.res <- names(query_markers.list)
split.prefix <- paste(DefaultAssay(so.query), "_snn_res.", sep = "")
available.res <- unlist(strsplit(available.res, split.prefix))
available.res <- as.numeric(available.res[available.res >0])

# ensure that requested resolutions have been preprocessed in module 8
stopifnot(length(cluster_resolution) == 1)
stopifnot((cluster_resolution %in% available.res))


```


```{r plt umap}

cluster.field <- paste(DefaultAssay(so.query), "_snn_res.", cluster_resolution, sep = "")

plt.umap_1 <- DimPlot(so.query, reduction = "umap", 
                    label = T, 
                    group.by = cluster.field)  + 
  xlab("UMAP 1") + ylab("UMAP 2") 

if (print.inline){
  print(plt.umap_1)
}

```


```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("")
df.log[nrow(df.log), 3] <- as.character("11, Functional Enrichment")
colnames(df.log) <- c("Description", "Variable Name", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character("Sys.getenv('USERDOMAIN')")
df.log[nrow(df.log), 3] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character("Sys.time()")
df.log[nrow(df.log), 3] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Input File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character("input.file")
df.log[nrow(df.log), 3] <- as.character(input.file)


# Cluster Resolution
df.log[nrow(df.log)+1, 1] <- as.character("Queried Cluster Resolution(s)")
 df.log[nrow(df.log), 2] <- as.character("cluster_resolution")
if (length(cluster_resolution) > 1){
  df.log[nrow(df.log), 3] <- paste(cluster_resolution, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(cluster_resolution)
}

# Available Cluster Resolutions
df.log[nrow(df.log)+1, 1] <- as.character("Available Cluster Resolution(s)")
 df.log[nrow(df.log), 2] <- as.character("available.res")
if (length(available.res) > 1){
  df.log[nrow(df.log), 3] <- paste(available.res, collapse=", ")
} else {
  df.log[nrow(df.log), 3] <- as.character(available.res)
}

# species
df.log[nrow(df.log)+1, 1] <- as.character("Species")
df.log[nrow(df.log), 2] <-  as.character("species")
df.log[nrow(df.log), 3] <-  as.character(species)

# mapping.db
df.log[nrow(df.log)+1, 1] <- as.character("Reference Database")
df.log[nrow(df.log), 2] <-  as.character("mapping.db")
df.log[nrow(df.log), 3] <-  as.character(mapping.db)

# annotation functions
df.log[nrow(df.log)+1, 1] <- as.character("Annotaiton Functions")
 df.log[nrow(df.log), 2] <- as.character("annotation.functions")
if (length(annotation.functions) > 1){
  df.log[nrow(df.log), 3] <- paste(annotation.functions, collapse = ", ")
} else if (length(annotation.functions) == 1){
  df.log[nrow(df.log), 3] <- annotation.functions
}


# Output file
# if (save_flag){
#   df.log[nrow(df.log)+1, 1] <- as.character("Output File")
#   df.log[nrow(df.log), 2] <- as.character(save_filename)
# }

```



```{r define processing functions}

# specifies-specific gene symbols
genes4species <- function(x, species) {
  # if murine, upper case first letter, lower case remainder
  if (species == "Mm"){
    x <- tolower(x)
    substr(x, 1, 1) <- toupper(substr(x, 1, 1))
    # if human, upper case all letters
  } else if (species == "Hs"){
    x <- toupper(x)
  }
  return (x)
}

# gene selection function
topDiffGenes <- function(allScore, sig.threshold = 0.01) { 
  x <- allScore < sig.threshold
  return(x)
}

```



```{r define symbol to entrez function}

# library(org.Hs.eg.db)


sym2entrez <- function(my.symbols, my.species){
  
my.symbols <- as.vector(my.symbols)
if (my.species == "Hs"){
  db <- org.Hs.eg.db
} else if (my.species == "Mm"){
db <- org.Mm.eg.db
}

my.entrez <- select(db, 
       keys = my.symbols,
       columns = c("ENTREZID", "SYMBOL"),
       keytype = "SYMBOL")

return(my.entrez)
}
```


```{r define get DEG function}

 # cur_set <- names(df.res.list)[i]
 # df.res <- df.res.list[[cur_set]]

get.DEG <- function(df.res, species = "Hs", DEG.LFC_threshold = 2, DEG.p_threshold = 0.001){
  
    # get genes of interest
    df.res$genes <- as.vector(df.res$genes)
    df.res$genes <- genes4species(df.res$genes , species)
    df.res$p.adj[is.na(df.res$p.adj)] <- 1
    
    # define dataframe of gene names in 1st col and scores (range 0 to 1) in 2nd col
    genes.interest <- data.frame(genes = as.vector(df.res$genes), score = df.res$p.adj, logFC = df.res$y)
    # genes.interest <- unique(genes.interest)
    
    genes_entrez <- sym2entrez(genes.interest$genes, my.species = species)
    
    match.ind <- match(genes.interest$genes, genes_entrez$SYMBOL)
    
    genes.interest$entrez <-   genes_entrez$ENTREZID[match.ind]
    genes.interest$symbol <-   genes_entrez$SYMBOL[match.ind]
    
    geneList_p <- as.numeric(genes.interest$score)
    names(geneList_p) <- genes.interest$entrez
    
    geneList_logFC <- as.numeric(genes.interest$logFC)
    names(geneList_logFC) <- genes.interest$entrez
    
    geneList_p_clean <- as.numeric(geneList_p[!is.na(geneList_p)])
    names(geneList_p_clean) <- names(geneList_p)[!is.na(geneList_p)]
    
    geneList_logFC_clean <- as.numeric(geneList_logFC[!is.na(geneList_logFC)])
    names(geneList_logFC_clean) <- names(geneList_logFC)[!is.na(geneList_logFC)]
    
    deg <- names(geneList_p_clean)[as.vector(geneList_p_clean) < DEG.p_threshold & abs(as.vector(geneList_logFC_clean)) > DEG.LFC_threshold] 
    
    
    output <- list(deg, geneList_logFC_clean, geneList_p_clean)
    
    return(output)
}
    

```


```{r define reactomePA-based function}

run.reactomePA <- function(df.res.list, annotation.functions, mapping.db = NULL, species = "Hs", enrich.p_threshold = 0.05, enrich.p_adjust = "BH", DEG.LFC_threshold = 2, DEG.p_threshold = 0.001, ontology.type = NULL, so.gene_universe = NULL){
  
  x.list <- list()
  df.reactome.list <- list()
  gene.FC.list <- list()
  gene.p.list <- list()
  
  for (i in 1:length(names(df.res.list))){
    
    # get group name (comparison groups)
    cur_set <- names(df.res.list)[i]
    
    # get genes of interest
    output.deg <- get.DEG(df.res.list[[cur_set]], species = species, DEG.LFC_threshold = DEG.LFC_threshold, DEG.p_threshold = DEG.p_threshold)
    
    deg <- output.deg[[1]]
    geneList_logFC_clean <- output.deg[[2]]
    geneList_p_clean <- output.deg[[3]]
    
    # df.res$genes <- as.vector(df.res$genes)
    # df.res$genes <- genes4species(df.res$genes , species)
    # df.res$p.adj[is.na(df.res$p.adj)] <- 1
    # 
    # # define dataframe of gene names in 1st col and scores (range 0 to 1) in 2nd col
    # genes.interest <- data.frame(genes = as.vector(df.res$genes), score = df.res$p.adj, logFC = df.res$y)
    # # genes.interest <- unique(genes.interest)
    # 
    # genes_entrez <- sym2entrez(genes.interest$genes, my.species = species)
    # 
    # match.ind <- match(genes.interest$genes, genes_entrez$SYMBOL)
    # 
    # genes.interest$entrez <-   genes_entrez$ENTREZID[match.ind]
    # genes.interest$symbol <-   genes_entrez$SYMBOL[match.ind]
    # 
    # geneList_p <- as.numeric(genes.interest$score)
    # names(geneList_p) <- genes.interest$entrez
    # 
    # geneList_logFC <- as.numeric(genes.interest$logFC)
    # names(geneList_logFC) <- genes.interest$entrez
    # 
    # geneList_p_clean <- as.numeric(geneList_p[!is.na(geneList_p)])
    # names(geneList_p_clean) <- names(geneList_p)[!is.na(geneList_p)]
    # 
    # geneList_logFC_clean <- as.numeric(geneList_logFC[!is.na(geneList_logFC)])
    # names(geneList_logFC_clean) <- names(geneList_logFC)[!is.na(geneList_logFC)]
    # 
    # deg <- names(geneList_p_clean)[as.vector(geneList_p_clean) < DEG.p_threshold & abs(as.vector(geneList_logFC_clean)) > DEG.LFC_threshold] # abs(log10(0.01)) = 2
    
    
    
    if (!is.null(so.gene_universe)){
      gene.universe <- so.gene_universe
    } else {
      gene.universe <- names(geneList_p_clean)
    }
    
    
    if ("enrichGO" %in% annotation.functions & length(deg)>0){
      x <- enrichGO(gene=deg,
                    pvalueCutoff=enrich.p_threshold, 
                    pAdjustMethod = enrich.p_adjust, 
                    readable=T, 
                    universe =  names(geneList_p_clean), 
                    OrgDb = mapping.db, ont = ontology.type)
      
      x <- clusterProfiler::simplify(x)
      # mapping.db
    }
    if ("enrichKEGG" %in% annotation.functions & length(deg)>0){
      x <- enrichKEGG(gene=deg,pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust, universe =  names(geneList_p_clean))
    }
    if ("enrichDO" %in% annotation.functions & length(deg)>0){
      x <- DOSE::enrichDO(gene=deg,pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust, readable=T, universe =  names(geneList_p_clean))
    }
    if ("enrichPathway" %in% annotation.functions & length(deg)>0){
      x <- ReactomePA::enrichPathway(gene=deg,pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust, readable=T, universe =  names(geneList_p_clean))
    }
    
    
    if (!is.null(x)){
    # datatable(reactom.results, filter = 'top')
    x.list[[names(df.res.list)[i]]] <- x
    df.reactome.list[[names(df.res.list)[i]]] <- x@result
    gene.FC.list[[names(df.res.list)[i]]] <- geneList_logFC_clean
    gene.p.list[[names(df.res.list)[i]]] <- geneList_p_clean
    }
  }
  
  output <- list(x.list, df.reactome.list, gene.FC.list, gene.p.list)
  return(output)
}


```


```{r define function to prep marker list}


prep.marker.list <- function(df.stager){

  df.res.list <- list()
  u.clusters <- as.vector(unique(df.stager$cluster))
  
  for (i in 1:length(u.clusters)){
    
    list.label <- paste("c", u.clusters[i], sep = "")
    df.subset <- df.stager[df.stager$cluster == u.clusters[i], ]
    df.res.list[[list.label]] <- data.frame(genes = df.subset$gene,
                                            p.adj = df.subset$p_val_adj,
                                            p = df.subset$p_val,
                                            y = df.subset$avg_logFC,
                                            cluster = df.subset$cluster)
  }
  return(df.res.list)
}

```

```{r genes of interest & gene universe}

ontology.types <- c("BP", "CC", "MF")

df.res.list <- prep.marker.list(query_markers.list[[which(available.res %in% cluster_resolution[1])]])
so.gene_universe <- as.vector(so.query@assays[[DefaultAssay(so.query)]]@var.features)

```


```{r run reactomePA, message=FALSE, warning=FALSE}




do.single_enrich <- FALSE

if (do.single_enrich){
  
  # initiate output lists
reactomePA_ouput.list <- list()
x_output.list <- list()
df.reactome_output.list <- list()
gene.FC_output.list <- list()
gene.p_output.list <- list()

for (i in 1:length(annotation.functions)){
  
  # run ReactomePA
  # try({
    annot.fun <- annotation.functions[i]
    if (annot.fun == "enrichGO"){
      for (j in 1:length(ontology.types)){
        
        annot.label <- paste(annot.fun,  "_", ontology.types[j], sep = "")
        
        reactomePA_ouput.list[[annot.label]] <- run.reactomePA(df.res.list, 
                                                               annotation.functions = annot.fun,
                                                               species = species,
                                                               mapping.db = mapping.db, 
                                                               enrich.p_threshold = enrich.p_threshold, 
                                                               enrich.p_adjust = enrich.p_adjust,
                                                               DEG.LFC_threshold = DEG.LFC_threshold,
                                                               DEG.p_threshold = DEG.p_threshold,
                                                               ontology.type = ontology.types[j], 
                                                               so.gene_universe = so.gene_universe)
        
        # store results
        x_output.list[[annot.label]] <- reactomePA_ouput.list[[annot.label]][[1]]
        df.reactome_output.list[[annot.label]] <- reactomePA_ouput.list[[annot.label]][[2]]
        gene.FC_output.list[[annot.label]] <- reactomePA_ouput.list[[annot.label]][[3]]
        gene.p_output.list[[annot.label]] <- reactomePA_ouput.list[[annot.label]][[4]]
        
        
      }
      
    }
    else {
      
      reactomePA_ouput.list[[annot.fun]] <- run.reactomePA(df.res.list, 
                                                             annotation.functions = annot.fun,
                                                             species = species,
                                                             mapping.db = mapping.db, 
                                                             enrich.p_threshold = enrich.p_threshold, 
                                                             enrich.p_adjust = enrich.p_adjust,
                                                             DEG.LFC_threshold = DEG.LFC_threshold,
                                                             DEG.p_threshold = DEG.p_threshold,
                                                             ontology.type = NULL, 
                                                            so.gene_universe = so.gene_universe)
      
      # store results
      x_output.list[[annot.fun]] <- reactomePA_ouput.list[[annot.fun]][[1]]
      df.reactome_output.list[[annot.fun]] <- reactomePA_ouput.list[[annot.fun]][[2]]
      gene.FC_output.list[[annot.fun]] <- reactomePA_ouput.list[[annot.fun]][[3]]
      gene.p_output.list[[annot.fun]] <- reactomePA_ouput.list[[annot.fun]][[4]]
      
      
    }
  # }, silent = TRUE)
  
}
  
}

```

```{r visualize dotplots, fig.height=8, fig.width=13}

do.dot_single <- FALSE

if (do.dot_single){

for (i in 1:length(x_output.list)){
  # annot.fun <- annotation.functions[i]
  x.list <- x_output.list[[i]]
  for (j in 1:length(x.list)){
    if (print.inline & (dim(x.list[[j]])[1] > 0)){
      print(dotplot(x.list[[j]], showCategory=15,title = paste(names(x_output.list)[i], ": ", names(x.list)[j], sep = "")))
    }
  }
}
  
}

```



```{r visualize emap, fig.height=20, fig.width=13}

do.umap <- FALSE

if (do.umap){

plt.emap_all <- list()

for (i in 1:length(x_output.list)){
  annot.fun <- names(x_output.list)[i]
  x.list <- x_output.list[[annot.fun]]
  df.reactome.list <- df.reactome_output.list[[annot.fun]]
  
  if (!is.null(x.list) & !is.null(df.reactome.list)) {
    
    n.sig <- c()
    plt.emap <- list()
    for (j in 1:length(x.list)){
      n.sig[j] <- sum(df.reactome.list[[j]]$p.adjust < enrich.p_threshold)
      if (n.sig[j] > 0){
        try({
          plt.emap[[names(x.list)[j]]] <- emapplot(x.list[[j]], showCategory =  n.sig[j])
          # print(plt.emap[[names(x.list)[j]]])
        }, silent = TRUE)
      }
    }
    
    if ((length(plt.emap) > 0)) {
      if (print.inline){
        cowplot::plot_grid(plotlist = plt.emap, ncol = 1, labels = names(plt.emap))
      }
      plt.emap_all[[annot.fun]] <- plt.emap
      
    }
  }
}

}

```



```{r visualize cnet, fig.height=8, fig.width=20}
do.cnet <- FALSE

if (do.cnet){

plt.cnet_all <- list()
for (i in 1:length(x_output.list)){
  annot.fun <- names(x_output.list)[i]
  x.list <- x_output.list[[annot.fun]]
  df.reactome.list <- df.reactome_output.list[[annot.fun]]
  gene.FC.list <- gene.FC_output.list[[annot.fun]]
  
  
  if (!is.null(x.list) & !is.null(df.reactome.list) & !is.null(gene.FC.list)) {
    n.sig <- c()
    plt.cnet <- list()
    for (j in 1:length(x.list)){
      n.sig[j] <- sum(df.reactome.list[[j]]$p.adjust < enrich.p_threshold)
      if (n.sig[j] > 0){
        try({
          plt.cnet[[names(x.list)[j]]] <- cnetplot(x.list[[j]], 
                                                   showCategory = n.sig[j], 
                                                   foldChange=gene.FC.list[[j]] , 
                                                   node_label="category",
                                                   font.size = 5)
          plt.cnet[[names(x.list)[j]]][["data"]][["size"]] <- plt.cnet[[names(x.list)[j]]][["data"]][["size"]] * 0.75
          
        }, silent = TRUE)
      }
      
    }
    
    if (length(plt.cnet)> 0) {
      if (print.inline){
        cowplot::plot_grid(plotlist = plt.cnet, ncol = 3, labels = names(plt.cnet))
      }
      plt.cnet_all[[annot.fun]] <- plt.cnet
      
    }
    
  }
}
}

```


```{r upset plots, fig.height=8, fig.width=13}

do.upset <- FALSE

if (do.upset){
  

plt.upset_all <- list()
for (i in 1:length(x_output.list)){
  annot.fun <- names(x_output.list)[i]
  x.list <- x_output.list[[annot.fun]]
  
  if (!is.null(x.list)) {
    n.sig <- c()
    plt.upset <- list()
    for (j in 1:length(x.list)){
      n.sig[j] <- sum(df.reactome.list[[j]]$p.adjust < enrich.p_threshold)
      if (n.sig[j] > 0){
        try({
          plt.upset[[names(x.list)[j]]] <- upsetplot(x.list[[j]], n = n.sig[j])
          if (print.inline){
            print(plt.upset[[names(x.list)[j]]])
          }
        }, silent = TRUE)
      }
      
    }
    
    if (!is.null(plt.upset)) {
      plt.upset_all[[annot.fun]] <- plt.upset
    }
  }
}
}


```



```{r compare experiments, fig.height=15, fig.width=10}


deg.list <- list()
# gene.p.list <- gene.p_output.list[[1]]
for(i in 1:length(df.res.list)){

  # get genes of interest
  output.deg <- get.DEG(df.res.list[[i]], species = species, DEG.LFC_threshold = DEG.LFC_threshold, DEG.p_threshold = DEG.p_threshold)
  
  deg <- output.deg[[1]]
  genes.LFC <- output.deg[[2]]
  genes.p <- output.deg[[3]]
  
  # genes.p <- gene.p.list[[i]]
  # genes.LFC <- gene.FC.list[[i]]
  deg.list[[names(df.res.list)[i]]] <- names(genes.p)[genes.p < DEG.p_threshold & abs(genes.LFC) > DEG.LFC_threshold]
  deg.list[[names(df.res.list)[i]]] <-  deg.list[[names(df.res.list)[i]]][!is.na( deg.list[[names(df.res.list)[i]]])]
  
}

none.null_deg <-c()
for(i in 1:length(deg.list)){
  none.null_deg[i] <-  length(deg.list[[i]]) > 0
}
deg.list <- deg.list[none.null_deg]

# enrich.fun <- c("groupGO", "enrichGO", "enrichKEGG", "enrichDO", "enrichPathway")

comparison.list <- list()
if ("enrichGO" %in% annotation.functions){
  try({
    comparison.list[["enrichGO_BP"]] <- compareCluster(geneCluster = deg.list, 
                                                    pvalueCutoff=enrich.p_threshold, 
                                                    pAdjustMethod = enrich.p_adjust,
                                                    ont = "BP",
                                                    fun = "enrichGO",
                                                    OrgDb = mapping.db)
    
    comparison.list[["enrichGO_BP"]] <- clusterProfiler::simplify(comparison.list[["enrichGO_BP"]])
  }, silent = TRUE)
}
if ("enrichGO" %in% annotation.functions){
  try({
    comparison.list[["enrichGO_CC"]] <- compareCluster(geneCluster = deg.list, 
                                                    pvalueCutoff=enrich.p_threshold, 
                                                    pAdjustMethod = enrich.p_adjust,
                                                    ont = "CC",
                                                    fun = "enrichGO",
                                                    OrgDb = mapping.db)
    
    comparison.list[["enrichGO_CC"]] <- clusterProfiler::simplify(comparison.list[["enrichGO_CC"]])
  }, silent = TRUE)
}
if ("enrichGO" %in% annotation.functions){
  try({
    comparison.list[["enrichGO_MF"]] <- compareCluster(geneCluster = deg.list, 
                                                    pvalueCutoff=enrich.p_threshold, 
                                                    pAdjustMethod = enrich.p_adjust,
                                                    ont = "MF",
                                                    fun = "enrichGO",
                                                    OrgDb = mapping.db)
    
    comparison.list[["enrichGO_MF"]] <- clusterProfiler::simplify(comparison.list[["enrichGO_MF"]])
  }, silent = TRUE)
}
if ("enrichKEGG" %in% annotation.functions){
  try({
    comparison.list[["enrichKEGG"]] <- compareCluster(geneCluster = deg.list, 
                                                      fun = "enrichKEGG",
                                                      pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust)
  }, silent = TRUE)
}
if ("enrichDO" %in% annotation.functions){
  try({
    comparison.list[["enrichDO"]] <- compareCluster(geneCluster = deg.list, 
                                                    fun = "enrichDO",
                                                    pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust)
  }, silent = TRUE)
}
if ("enrichPathway" %in% annotation.functions){
  try({
    comparison.list[["enrichPathway"]] <- compareCluster(geneCluster = deg.list, 
                                                         fun = "enrichPathway",
                                                         pvalueCutoff=enrich.p_threshold, pAdjustMethod = enrich.p_adjust)
  }, silent = TRUE)
}


n.show <- 30
for (i in 1:length(comparison.list)){
  if (print.inline){
    print(dotplot(comparison.list[[i]], showCategory = n.show, title = names(comparison.list)[i], font.size = 8))
  }
}


```



```{r define entrez to symbol function}

# library(org.Hs.eg.db)


entrez2sym <- function(my.entrez, my.species){
  
my.entrez <- as.vector(my.entrez)
if (my.species == "Hs"){
  db <- org.Hs.eg.db
} else if (my.species == "Mm"){
db <- org.Mm.eg.db
}

my.symbols <- select(db,
       keys = my.entrez,
       columns = c("SYMBOL", "ENTREZID"),
       keytype = "ENTREZID")

return(my.symbols)
}
```





```{r convert entrez to symbols in final summary table}

for ( i in 1:length(comparison.list)){
  
  a <- comparison.list[[i]]@compareClusterResult
  my.entrez <- a$geneID
  my.entrez_split <- strsplit(my.entrez, "/")
  
  my.symbols_split_vec <- c()
  for (j in 1:length(my.entrez_split)){
    
    my.symbols_split <- entrez2sym(my.entrez_split[[j]], species)
    
    my.symbols_split_vec[j] <- paste(as.vector(my.symbols_split$SYMBOL), collapse = ", ")
    
  }
  a$geneSymbol <- my.symbols_split_vec
  
  comparison.list[[i]]@compareClusterResult <- dplyr::select(a, -c("geneID"))
}








```


Dotplots
===================================== 

Row {.tabset}
-------------------------------------

```{r ph_dotnet,  echo = FALSE, eval = TRUE}

none.null_comp <-c()
for(i in 1:length(comparison.list)){
  none.null_comp[i] <-  length(comparison.list[[i]]) > 0
}
comparison.list <- comparison.list[none.null_comp]

out <- lapply(seq_along(comparison.list), function(i) {
  
  s1 <- paste("Dot Plot | ", names(comparison.list)[i], sep = "")

  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1)) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, , fig.height=20, fig.width=20}", 
                                          paste("dotnet_", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n print(dotplot(comparison.list[[%d]], 
                                          showCategory = 20, 
                                          title = names(comparison.list)[%d]))", i,i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


Functional Enrichment Table(s)
===================================== 

Row {.tabset}
-------------------------------------

```{r detailed table output,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out_heat <- lapply(seq_along(comparison.list), function(i) {
  
  s1 <- paste("comparison.list[[", i, "]]@compareClusterResult", sep = "")
  
  table.name <- names(comparison.list)[i]
  
  # s4 <- paste("datatable(", s1, ", filter = 'top', options = list(pageLength = 50))", sep = "")
  
  s4 <- paste("datatable(", s1, ", 
    filter = 'top',
    extensions = 'Buttons',
    options = list(pageLength = 50,
    dom = 'Bfrtip', 
    buttons = c('copy', 'csv', 'pdf')))", sep = "")

  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", table.name))  # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("detailed_tab", i, sep = "")))               # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n %s",s4)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

```

`r paste(knitr::knit(text = paste(out_heat, collapse = '\n')))`



UMAP Clusters
===================================== 


### UMAP

```{r plt.umap_1}
print(plt.umap_1)
```


```{r ph10,  echo = FALSE, eval = TRUE, message=FALSE, warning=FALSE}

out1 <- lapply(seq_along(module.logs), function(i) {
  
  module.n <- as.numeric(gsub("[^\\d]+", "", module.logs[i], perl=TRUE))
  
  a1 <- knitr::knit_expand(text = sprintf("\nLog (Module %s)", paste(module.n)))
  a2 <- knitr::knit_expand(text = "\n=====================================")
  a3 <- knitr::knit_expand(text = sprintf("\n```{r %s}", paste("mod_", i, sep = ""))) # start r chunk
  a4<- knitr::knit_expand(text = sprintf("\nknitr::kable(%s)",module.logs[i])) 
  a5 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, a5, collapse = '\n') # collapse together all lines with newline separator
  
})


```

`r paste(knitr::knit(text = paste(out1, collapse = '\n')))`


```{r analysis log update}
# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character("elapsed.time")
df.log[nrow(df.log), 3] <- as.character(elapsed.time)

df.log_Module_11 <- df.log
```


Log (Module 11)
===================================== 

```{r df.log_Module_11}

knitr::kable(df.log_Module_11)

```




