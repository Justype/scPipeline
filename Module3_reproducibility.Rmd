---
title: "scRNAseq: Reproducibility"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
rm(list = ls())

start.time <- proc.time()

# LOAD LIBRARIES

# scRNAseq libraries
library(Seurat)
library(sctransform)

# Data wrangling libraries
library(plyr)
library(dplyr)
library(tidyr)
library(reshape2)
library(arrangements)

# Data visualization libraries
library(RColorBrewer)
library(ggplot2)
library(gridExtra)
library(DT)
library(flexdashboard)
library(ggpmisc)
library(ggExtra)
library(grid)
library(cowplot)
```


```{r input_data}

# note. this module has two modes: co


input.type  <- 1 # 1: integrated dataset (1 input); 2: independent datasets (>1 inputs);
# provide integrated datasets (e.g., pilot 1 and pilot 2)
# input.file <- "Integrated_Data_071119_pilot12_CCA_Mm.RData"
# input.file <- "Integrated_Data_261119_pilot35_CCA_dif.Rdata"

# input.file <- c("Module1_1_celsius_renca_nucseq_filtered.Rdata", "Module1_4_celsius_renca_10x_filtered.Rdata", "Module1_pilot5_tumor_041219.Rdata")
input.file <- "Module2_integrated_pilo4GBM_Suva2019_2000anchors_161219.Rdata"
# input.file <- "Integrated_Data_071119_pilot12_Mm_rPCA.Rdata"
# input.file <- 'Integrated_Data_071119_pilot12_CCA_Hs.Rdata'

dir <- "Preprocessed Datasets/"

cell_types_known <- FALSE # specify whether cell types in query are known

intra_cluster_batch_comparison <- TRUE # specify whether to compare batches within each cluster. 

all_input_same <- FALSE # TRUE only if all input cells expected to be the same/similar
true_cell_label <- "" # if all_input_same, provide cell type name

aggregation.function <- "median" # mean or median

print.inline <- FALSE

```


```{r function to rename CellTypes to Barcode (fix artefact of earlier analysis pipeline) PACKAGE}

fix.barcode.label <- function (so){
  # merge CellType and Barcode, if necessary
  meta.data.names <- names(so@meta.data)
  
  if (("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)){
    if (DefaultAssay(so) == "integrated"){
      barcode <- so@meta.data[["Barcode"]]
      celltype <- so@meta.data[["CellType"]]
      barcode[is.na(barcode)] <- celltype[is.na(barcode)] 
    } else {
      barcode <- so@meta.data[["CellType"]]
    }
  } else if (!("CellType" %in% meta.data.names) & ("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["Barcode"]]
  } else if (("CellType" %in% meta.data.names) & !("Barcode" %in% meta.data.names)) {
    barcode <- so@meta.data[["CellType"]]
    
  } else {stop("Problem with CellType/Barcode metadata detected. Troubleshooting required")}
  
  so@meta.data[["Barcode"]] <- barcode
  
  return(so)
}

```

```{r load data}

# so.list <- list()
# g.list <- list()
# if (input.type == 2){
#   for (i in 1:length(input.file)){
#      load(input.file[i])
#     so.list[[i]] <- so; rm(so)
#     g.list[[i]] <- gNames.list; rm(gNames.list)
#   }
#   
# } else if (input.type == 1){
#   load(input.file)
# }


if (!exists("dir")) {dir <- ""}
load(paste(dir, input.file, sep = ""))
so <- fix.barcode.label(so)

```




```{r analysis log}

# Module
df.log <- data.frame()
df.log[nrow(df.log)+1, 1] <- as.character("Module")
df.log[nrow(df.log), 2] <- as.character("3, Reproducibility")
colnames(df.log) <- c("Parameter", "Value")

# User 
df.log[nrow(df.log)+1, 1] <- as.character("User")
df.log[nrow(df.log), 2] <- as.character(Sys.getenv("USERDOMAIN"))

# Date
df.log[nrow(df.log)+1, 1] <- as.character("Date")
df.log[nrow(df.log), 2] <- as.character(Sys.time())

# Query
df.log[nrow(df.log)+1, 1] <- as.character("Query File (.Rdata)")
df.log[nrow(df.log), 2] <- as.character(input.file)

# cell types known
df.log[nrow(df.log)+1, 1] <- as.character("Sample cell-types known")
df.log[nrow(df.log), 2] <- as.character(cell_types_known)

# Aggregation Function
df.log[nrow(df.log)+1, 1] <- as.character("Aggregation Function")
df.log[nrow(df.log), 2] <- as.character(aggregation.function)

if (cell_types_known){
  # sample composition
  df.log[nrow(df.log)+1, 1] <- as.character("Sample composed of single cell-type")
  df.log[nrow(df.log), 2] <- as.character(all_input_same)
  
  df.log[nrow(df.log)+1, 1] <- as.character("Cell types")
  if (length(true_cell_label) > 1){
    df.log[nrow(df.log), 2] <- paste(true_cell_label, collapse=", ")
  } else {
    df.log[nrow(df.log), 2] <- as.character(true_cell_label)
  }
  
}


```


```{r TYPE II INPUT compare independent datasets}

# so.list <- SplitObject(so, split.by = "batch")

# cells_by_batch <- list()

# Find cells that are shared between batches
if (input.type == 2) {
  
  genes_by_batch <- list()
  
  for (i in 1:length(so.list)){
    genes_by_batch[[i]] <- unique(rownames(so.list[[i]]@assays[["SCT"]]@scale.data))
  }
  
  genes_shared <- Reduce(intersect, genes_by_batch) 
  pattern <- paste(genes_shared, collapse="|")
  
  g2keep.list <- list()
  expression.list <- list()
  df.avg_exp <- data.frame()
  
  for (i in 1:length(so.list)){
    g2keep.list[[i]] <- grepl(pattern, genes_by_batch[[i]], fixed = TRUE)
    expression.list[[i]] <- so.list[[i]]@assays[["SCT"]]@scale.data[ g2keep.list[[i]]]
    n_genes <-length(expression.list[[i]])
    df.avg_exp[seq(1, n_genes), dim(df.avg_exp)[2]] <- rowMeans(so.list[[i]]@assays[["SCT"]]@scale.data) 
  }
  
  # Error in x[[jj]] : 
  #   attempt to select less than one element in integerOneIndex
  
  
  n_combo <- choose(length(so.list),2)
  possible_combo <- combn(length(so.list), 2)
  
  plt.comparisons <- list()
  
  for (i in 1:n_combo){
    # define a, b combo (col numbers)
    # define plt.title (string)
    plt.title[i] <- ""
    
    df.sct_expression_by_batch <- data.frame(x = df.avg_exp[ ,a], y = df.avg_exp[, b])
    
    
    plt.sct_by_batch_comparisons[[plt.title[i]]] <- ggplot(df.sct_expression_by_batch, aes(x, y)) +  
      geom_point() +
      geom_smooth(method='lm',formula=y~x) + ggtitle(plt.title[i]) + 
      stat_poly_eq(formula = y~x, aes(label = paste(..rr.label.., sep = "~~~")), parse = TRUE) +        
      geom_smooth(method='lm',formula=y~x, col=rgb(.5,0,0,alpha=.8)) + 
      geom_abline(slope=1, intercept=0, linetype = "dashed") + 
      ggtitle(plt.title[i])
    plt.sct_by_batch_comparisons[[plt.title[i]]]  <- ggMarginal(plt.sct_by_batch_comparisons[[plt.title[i]]] , type = "histogram")
    
    if (print.inline){
      print(plt.sct_by_batch_comparisons)
    }
    
  }
  
  
}




```




```{r annotate known labels}

# This chunk must be customized depending on input (currently setup for pilot 1 and 2)


if (all_input_same == FALSE  && cell_types_known == TRUE){ # custom 'true' labels required
  
  organisms <- c("Hs", "Mm")
  cells_Hs <- c("HAP1", "293T")
  cells_Mm <- c("3T3", "CGR8", "Renca", "N2A")
  
  cells_shared <- c("HAP1", "293T", "Renca")
  cells_all <- c(cells_Hs, cells_Mm)
  cells_Mm_shared <- intersect(cells_Mm, cells_shared)
  cells_Hs_shared <- intersect(cells_Hs, cells_shared)
  
  df.identity <- data.frame(so@meta.data[["CellType"]], so@meta.data[["Organism"]])
  colnames(df.identity) <- c("cell", "organism")
  
  for (i in 1:dim(df.identity)[1]){
    for (k in 1:length(cells_all)){
      if (is.element(cells_all[k], cells_Hs)){
        current_org <- "Hs"
      } else if (is.element(cells_all[k], cells_Mm)) {
        current_org <- "Mm"
      }
      if (grepl(cells_all[k], as.vector(df.identity[i,"cell"])) & (as.vector(df.identity[i,"organism"]) == current_org)){
        df.identity[i,"cell_true"] <- cells_all[k]
      }
    }
  }
  
  so@meta.data[["CellType_True"]] <- df.identity$cell_true
} else if (all_input_same == TRUE) {
  
  cells_shared <- true_cell_label
  so@meta.data[["CellType_True"]] <- cells_shared
  
  
}



```


```{r TYPE I INPUT compare common cell types}





so.list <- SplitObject(so, split.by = "batch")

if (input.type == 1 & cell_types_known == TRUE){
  
  cells_by_batch <- list()
  
  # Find cells that are shared between batches
  for (i in 1:length(so.list)){
    cells_by_batch[[i]] <- unique(so.list[[i]]@meta.data[["CellType_True"]])
  }
  
  cells_shared <- Reduce(intersect, cells_by_batch) 
  
  # compare average expression of each genes for each cell in each batch
  n_batches <- length(so.list)
  batch.comparisons <- list()
  plt.sct_by_batch_comparisons <- list()
  plt.int_by_batch_comparisons <- list()
  batch_names <- unique(so@meta.data[["batch"]])
  
  plt.comparison <- list()
  
  
  if (length(cells_shared) > 0 && intra_cluster_batch_comparison == FALSE) {
    
    for (i in 1:length(cells_shared)){
      
      df.sct_expression_by_batch <- data.frame()
      df.int_expression_by_batch <- data.frame()
      df.genes_by_batch <- data.frame()
      for (j in 1:n_batches){
        batch_so <- so.list[[j]]
        
        # for batch j get average gene expression
        cur_cell_idx <- which(batch_so@meta.data[["CellType_True"]] == cells_shared[i])
        
        gene_symbol <- rownames(batch_so@assays[["integrated"]]@scale.data)
        avg_sct_exp <- rowMeans(batch_so@assays[["SCT"]]@scale.data[, cur_cell_idx]) 
        avg_int_exp <- rowMeans(batch_so@assays[["integrated"]]@scale.data[, cur_cell_idx])
        
        n_entries <- length(avg_int_exp)
        df.sct_expression_by_batch[seq(1,n_entries), ncol(df.sct_expression_by_batch)+1] <- avg_sct_exp
        df.int_expression_by_batch[seq(1,n_entries), ncol(df.int_expression_by_batch)+1] <- avg_int_exp
        df.genes_by_batch[seq(1,n_entries), ncol(df.genes_by_batch)+1] <- gene_symbol
      }
      # colnames(df.sct_expression_by_batch) <- batch_names
      # colnames(df.int_expression_by_batch) <- batch_names
      # colnames(df.genes_by_batch) <- batch_names
      
      colnames(df.sct_expression_by_batch) <- c("Pilot1", "Pilot2")
      colnames(df.int_expression_by_batch) <- c("Pilot1", "Pilot2")
      colnames(df.genes_by_batch) <- c("Pilot1", "Pilot2")
      
      batch.comparisons[[cells_shared[i]]] <- df.int_expression_by_batch
      
      # generate plots
      # plt.sct_by_batch_comparisons[[cells_shared[i]]] <- ggplot(df.sct_expression_by_batch, aes(Pilot1, Pilot2)) +  
      plt.sct_by_batch_comparisons[[cells_shared[i]]] <- ggplot(df.sct_expression_by_batch, aes(Pilot1, Pilot2)) +  
        geom_point() +
        geom_smooth(method='lm',formula=y~x) + ggtitle(cells_shared[i]) + 
        stat_poly_eq(formula = y~x, aes(label = paste(..rr.label.., sep = "~~~")), parse = TRUE) +        
        geom_smooth(method='lm',formula=y~x, col=rgb(.5,0,0,alpha=.8)) + 
        geom_abline(slope=1, intercept=0, linetype = "dashed") + 
        ggtitle(paste(cells_shared[i], ": Pre-Integration", sep = ""))
      plt.sct_by_batch_comparisons[[cells_shared[i]]]  <- ggMarginal(plt.sct_by_batch_comparisons[[cells_shared[i]]] , type = "histogram")
      
      # plt.int_by_batch_comparisons[[cells_shared[i]]] <- ggplot(df.int_expression_by_batch, aes(Pilot1, Pilot2)) +  
      plt.int_by_batch_comparisons[[cells_shared[i]]] <- ggplot(df.int_expression_by_batch, aes(Pilot1, Pilot2)) +  
        geom_point() +
        geom_smooth(method='lm',formula=y~x, col=rgb(.5,0,0,alpha=.8)) + ggtitle(cells_shared[i]) + 
        stat_poly_eq(formula = y~x, aes(label = paste(..rr.label.., sep = "~~~")), parse = TRUE) +  
        geom_abline(slope=1, intercept=0, linetype = "dashed") +
        ggtitle(paste(cells_shared[i], ": Post-Integration", sep = "")) 
      plt.int_by_batch_comparisons[[cells_shared[i]]]  <- ggMarginal(plt.int_by_batch_comparisons[[cells_shared[i]]] , type = "histogram")
      
      plt.comparison[[i]] <- arrangeGrob(plt.sct_by_batch_comparisons[[cells_shared[i]]], plt.int_by_batch_comparisons[[cells_shared[i]]], ncol=2)
      
      # geom_rug(col=rgb(.5,0,0,alpha=.2)) + 
    }
    
    # assertion ensuring that genes are matched properly across batches
    stopifnot(sum(df.genes_by_batch$Pilot1 == df.genes_by_batch$Pilot2) == dim(df.genes_by_batch)[1])
    
    plt.umap <- DimPlot(so, reduction = "umap", label = F, split.by	= "batch", group.by = "CellType_True", label.size = 4)  + xlab("UMAP 1") + ylab("UMAP 2") 
    
    
    if (print.inline){
      plt.umap 
    }
    
  }
}


```


```{r reproducibility all cells}

# initiate lists, dataframes, and vectors to store results
batch.comparisons <- list()
plt.sct_comparisons <- list()
plt.int_comparisons <- list()
plt.comparison_complete <- list()
df.sct_expression <- data.frame()
df.int_expression <- data.frame()
df.genes <- data.frame()
df.cluster <- data.frame()
gene.count_pre <- c()
cell.count_pre <- c()
gene.count_post <- c()
cell.count_post <- c()

# get unique batches and count
u_batches <- names(so.list)
n_batches <- length(u_batches)

# get dataset-level (batch) aggregate expression
for (i in 1:n_batches){
  
  # get batch seurat object
  batch_so <- so.list[[i]]
  
  # gene names
  gene_symbol_sct <- rownames(batch_so@assays[["SCT"]]@scale.data)
  gene_symbol_int <- rownames(batch_so@assays[["integrated"]]@scale.data)
  
  cluster.membership <- batch_so@meta.data[["seurat_clusters"]]
  
  # ensure that SCT and integrated datasets are matched
  row_match.ind <- match(gene_symbol_int, gene_symbol_sct)
  
  # compute aggregate expression
  if (aggregation.function == "median"){
    avg_sct_exp <- apply(batch_so@assays[["SCT"]]@scale.data[row_match.ind, ], 1, median)
    avg_int_exp <- apply(batch_so@assays[["integrated"]]@scale.data, 1, median)
  } else if (aggregation.function == "mean"){
    avg_sct_exp <- rowMeans(batch_so@assays[["SCT"]]@scale.data[row_match.ind, ])
    avg_int_exp <- rowMeans(batch_so@assays[["integrated"]]@scale.data)
    
  } 
  
  # assertion to enfore proper matching
  stopifnot(names(avg_sct_exp) == names(avg_int_exp))
  
  # get gene and cell counts
  gene.count_pre[i] <- nrow(batch_so@assays[["SCT"]]@scale.data)
  cell.count_pre[i] <- ncol(batch_so@assays[["SCT"]]@scale.data)
  gene.count_post[i] <- nrow(batch_so@assays[["integrated"]]@scale.data)
  cell.count_post[i] <- ncol(batch_so@assays[["integrated"]]@scale.data)
  
  # store results
  df.sct_expression[seq(1,length(avg_sct_exp)), ncol(df.sct_expression)+1] <- avg_sct_exp
  df.int_expression[seq(1,length(avg_int_exp)), ncol(df.int_expression)+1] <- avg_int_exp
  df.cluster[seq(1,length(cluster.membership)), ncol(df.cluster)+1] <- cluster.membership
}

# assign column names
colnames(df.sct_expression) <- u_batches
colnames(df.int_expression) <- u_batches

# get unique combinations for pairwise comparisons
contrast.combinations <- combinations(as.vector(u_batches), 2)
contrast.combinations_num <- combinations(seq(1,length(u_batches)), 2)
plt.label <- c()

# generate pairwise correlation plots for each possible combination
for (j in 1:nrow(contrast.combinations)){
  
  # get cell and gene count in single character 
  cell.gene.count <- paste(cell.count_pre[i], " cells, ", gene.count_pre[j], " genes")
  
  # get plot label
  plt.label[j] <- paste(contrast.combinations[j, 1], " vs. ", contrast.combinations[j, 2], sep = "")
  
  # generate plots
  df.simple_pre <- data.frame(x = df.sct_expression[ ,contrast.combinations_num[j,1]], y = df.sct_expression[ ,contrast.combinations_num[j,2]])
  
  plt.sct_comparisons[[j]] <- ggplot(df.simple_pre, aes(x, y)) +  geom_point(alpha=0.3) + 
    geom_smooth(method='lm',formula=y~x) +
    stat_poly_eq(formula = y~x, aes(label = paste(..rr.label.., sep = "~~~")), parse = TRUE) +
    geom_smooth(method='lm',formula=y~x, col=rgb(.5,0,0,alpha=.8)) +
    geom_abline(slope=1, intercept=0, linetype = "dashed") +
    ggtitle(paste("Pre-Integration: ", cell.gene.count,   sep = ""))+
    xlab(contrast.combinations[j,1]) + ylab(contrast.combinations[j,2])
  plt.sct_comparisons[[j]]  <- ggMarginal(plt.sct_comparisons[[j]] , type = "histogram")
  
  
  
  df.simple_post <- data.frame(x = df.int_expression[ ,contrast.combinations_num[j,1]], y = df.int_expression[ ,contrast.combinations_num[j,2]])
  
  plt.int_comparisons[[j]] <- ggplot(df.simple_post, aes(x, y)) + geom_point(alpha=0.3) + 
    geom_smooth(method='lm',formula=y~x, col=rgb(.5,0,0,alpha=.8))  + 
    stat_poly_eq(formula = y~x, aes(label = paste(..rr.label.., sep = "~~~")), parse = TRUE) +  
    geom_abline(slope=1, intercept=0, linetype = "dashed") +
    ggtitle(paste("Post-Integration", sep = ""))  + 
    xlab(contrast.combinations[j,1]) + ylab(contrast.combinations[j,2])
  plt.int_comparisons[[j]]  <- ggMarginal( plt.int_comparisons[[j]] , type = "histogram")
  
  plt.comparison_complete[[plt.label[j]]] <- arrangeGrob(plt.sct_comparisons[[j]], plt.int_comparisons[[j]], ncol=2)
  
  
  if (print.inline){
    print(plt.sct_comparisons[[j]])
    print(plt.int_comparisons[[j]])
    
  }
}



```


```{r plt.umap for each batch, fig.height=5, fig.width=10}

plt.umap_1 <- DimPlot(so, reduction = "umap", 
                    label = T, 
                    group.by = "seurat_clusters")  + 
  xlab("UMAP 1") + ylab("UMAP 2") 

plt.umap_2 <- DimPlot(so, reduction = "umap", 
                    label = F, 
                    split.by	= "batch", 
                    group.by = "seurat_clusters", 
                    label.size = 4)  + 
  xlab("UMAP 1") + ylab("UMAP 2") 


if (print.inline){
  print(plt.umap_1) 
  print(plt.umap_2) 
}

```



```{r TYPE I INPUT cluster reproducibility}

# NOTE: requires integrated object as input

if (input.type == 1){
  
  # compare average expression of each genes for each cluster in each batch
  n_batches <- length(so.list)
  batch.comparisons_pre <- list()
  batch.comparisons_post <- list()
  plt.sct_by_batch_comparisons <- list()
  plt.int_by_batch_comparisons <- list()
  batch_names <- unique(so@meta.data[["batch"]])
  
  plt.comparison <- list()
  
  u_batches <- unique(so@meta.data[["batch"]])
  
  if (intra_cluster_batch_comparison){
    
    so.list <- SplitObject(so, split.by = "batch")
    clusters_by_batch <- list()
    
    # Find clusters that are shared between batches
    for (i in 1:length(so.list)){
      clusters_by_batch[[i]] <- unique(so.list[[i]]@meta.data[["seurat_clusters"]])
    }
    
    clusters_shared <- Reduce(intersect, clusters_by_batch) 
    n_batches <- length(so.list)
    
    gene.count_pre <- matrix(0, nrow = length(clusters_shared), ncol = n_batches)
    cell.count_pre <- matrix(0, nrow = length(clusters_shared), ncol = n_batches)
    gene.count_post <- matrix(0, nrow = length(clusters_shared), ncol = n_batches)
    cell.count_post <- matrix(0, nrow = length(clusters_shared), ncol = n_batches)
    
    for (i in 1:length(clusters_shared)){
      
      df.sct_expression_by_batch <- data.frame()
      df.int_expression_by_batch <- data.frame()
      df.genes_by_batch <- data.frame()
      
      for (j in 1:n_batches){
        batch_so <- so.list[[j]]
        
        # for batch j get average gene expression
        cur_clust_idx <- which(batch_so@meta.data[["seurat_clusters"]] == clusters_shared[i])
        
        # gene_symbol <- rownames(batch_so@assays[["integrated"]]@scale.data)
        
        gene_symbol_sct <- rownames(batch_so@assays[["SCT"]]@scale.data)
        gene_symbol_int <- rownames(batch_so@assays[["integrated"]]@scale.data)
        match.ind <- match(gene_symbol_int, gene_symbol_sct)
        gene_symbol <- gene_symbol_int
        
        # avg_sct_exp <- rowMeans(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx]) 
        # avg_int_exp <- rowMeans(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx])
        
        if (aggregation.function == "median"){
          avg_sct_exp <- apply(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx], 1, median)
          avg_int_exp <- apply(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx], 1, median)
        } else if (aggregation.function == "mean"){
          avg_sct_exp <- rowMeans(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx])
          avg_int_exp <- rowMeans(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx])
          
        } 
        
        #       
        #         avg_sct_exp <- apply(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx], 1, median)
        # avg_int_exp <- apply(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx], 1, median)
        avg_sct_exp <- avg_sct_exp[match.ind]
        stopifnot(names(avg_sct_exp) == names(avg_int_exp))
        
        
        # gene.count_pre[i,j] <- nrow(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx])
        cell.count_pre[i,j] <- ncol(batch_so@assays[["SCT"]]@scale.data[, cur_clust_idx])
        # gene.count_post[i,j] <- nrow(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx])
        cell.count_post[i,j] <- ncol(batch_so@assays[["integrated"]]@scale.data[, cur_clust_idx])
        
        n_entries <- length(avg_int_exp)
        df.sct_expression_by_batch[seq(1,n_entries), ncol(df.sct_expression_by_batch)+1] <- avg_sct_exp
        df.int_expression_by_batch[seq(1,n_entries), ncol(df.int_expression_by_batch)+1] <- avg_int_exp
        df.genes_by_batch[seq(1,n_entries), ncol(df.genes_by_batch)+1] <- gene_symbol
      }
      
      colnames(df.sct_expression_by_batch) <- u_batches
      colnames(df.int_expression_by_batch) <- u_batches
      colnames(df.genes_by_batch) <- u_batches
      
      batch.comparisons_pre[[clusters_shared[i]]] <- df.sct_expression_by_batch
      batch.comparisons_post[[clusters_shared[i]]] <- df.int_expression_by_batch
      
    }
    
    # reorder list 
    batch.clusters <- as.numeric(names(batch.comparisons_pre))
    order.ind <- order(batch.clusters)
    batch.comparisons_pre <- batch.comparisons_pre[order.ind]
    cell.count_pre <- cell.count_pre[order.ind ,]
    
    batch.clusters <- as.numeric(names(batch.comparisons_post))
    order.ind <- order(batch.clusters)
    batch.comparisons_post <- batch.comparisons_post[order.ind]
    cell.count_post <- cell.count_post[order.ind ,]
    
    
  }
  
}

```

```{r TYPE I INPUT intrabatch correlations}

# NOTE: requires integrated object as input
if (input.type == 1){
  # generate correlation matrix (intrabatch correlations)
  
  plt.cluster_intracor_heatmap_pre <- list()
  plt.cluster_intracor_heatmap_post <- list()
  
  plt.cluster_intracor_heatmap_cow <- list()
  # k <- 1
  for (k in 1:length(u_batches)){
    
    A <- matrix(0, nrow = length(batch.comparisons_pre), ncol = length(batch.comparisons_pre))
    B <- A
    for(i in 1:length(batch.comparisons_pre)){
      for (j in 1:length(batch.comparisons_pre)){
        A[i,j] <- cor(batch.comparisons_pre[[i]][ ,u_batches[k]], batch.comparisons_pre[[j]][ ,u_batches[k]])
        B[i,j] <- cor(batch.comparisons_post[[i]][ ,u_batches[k]], batch.comparisons_post[[j]][ ,u_batches[k]])
      }
    }
    
    # specify row and column names
    rownames(A) <- paste("Cluster ", names(batch.comparisons_pre), sep = "")
    colnames(A) <- paste("Cluster ", names(batch.comparisons_pre), sep = "")
    rownames(B) <- paste("Cluster ", names(batch.comparisons_post), sep = "")
    colnames(B) <- paste("Cluster ", names(batch.comparisons_post), sep = "")
    
    # cluster matrix
    row.order <- hclust(dist(A))$order # clustering
    col.order <- hclust(dist(t(A)))$order
    A_clustered <- A[row.order, col.order] # re-order matrix accoring to clustering
    A_molten <- melt(as.matrix(A_clustered)) # reshape into dataframe
    names(A_molten)[c(1:3)] <- c("ClusterA", "ClusterB", "pearson.r")
    
    row.order <- hclust(dist(B))$order # clustering
    col.order <- hclust(dist(t(B)))$order
    B_clustered <- B[row.order, col.order] # re-order matrix accoring to clustering
    B_molten <- melt(as.matrix(B_clustered)) # reshape into dataframe
    names(B_molten)[c(1:3)] <- c("ClusterA", "ClusterB", "pearson.r")
    
    # generate heat map
    plt.cluster_intracor_heatmap_pre[[u_batches[k]]] <- ggplot(data = A_molten,
                                                               aes(x = ClusterA, y = ClusterB, fill = pearson.r)) + 
      geom_raster() +
      scale_fill_distiller(palette = "RdYlBu", limits = c(-1,1)) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            axis.text.y = element_text(angle = 0, hjust = 1)) + 
      ggtitle(paste("Pre: ", u_batches[k], " (intrabatch clustering)", sep = "") ) + 
      xlab("Cluster ID") + ylab("Cluster ID")
    
    plt.cluster_intracor_heatmap_post[[u_batches[k]]] <- ggplot(data = B_molten,
                                                                aes(x = ClusterA, y = ClusterB, fill = pearson.r)) + 
      geom_raster() +
      scale_fill_distiller(palette = "RdYlBu", limits = c(-1,1)) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            axis.text.y = element_text(angle = 0, hjust = 1)) + 
      ggtitle(paste("Post: ", u_batches[k], " (intrabatch clustering)", sep = "") ) + 
      xlab("Cluster ID") + ylab("Cluster ID")
    
    
    plt.cluster_intracor_heatmap_cow[[u_batches[k]]] <- list(pre = plt.cluster_intracor_heatmap_pre[[u_batches[k]]], 
                                                             post = plt.cluster_intracor_heatmap_post[[u_batches[k]]])
    
    if (print.inline){ 
      print(plt.cluster_intracor_heatmap_pre[[u_batches[k]]])
      print(plt.cluster_intracor_heatmap_post[[u_batches[k]]])
    }
  }
}

```



```{r TYPE I INPUT interbatch correlations}
# NOTE: requires integrated object as input
if (input.type == 1){
  # generate correlation matrix (interbatch correlations)
  
  plt.cluster_intercor_heatmap_pre <- list()
  plt.cluster_intercor_heatmap_post <- list()
  plt.cluster_intercor_heatmap_cow <- list()
  for (k in 1:dim(contrast.combinations)[1]){
    
    plt.label[k] <- paste(contrast.combinations[k, 1], " vs. ", contrast.combinations[k, 2], sep = "")
    A <- matrix(0, nrow = length(batch.comparisons_pre), ncol = length(batch.comparisons_pre))
    B <- A
    for(i in 1:length(batch.comparisons_pre)){
      for (j in 1:length(batch.comparisons_pre)){
        A[i,j] <- cor(batch.comparisons_pre[[i]][ ,contrast.combinations[k,1]], batch.comparisons_pre[[j]][ ,contrast.combinations[k,2]])
        B[i,j] <- cor(batch.comparisons_post[[i]][ ,contrast.combinations[k,1]], batch.comparisons_post[[j]][ ,contrast.combinations[k,2]])
      }
    }
    
    # specify row and column names
    rownames(A) <- paste("Cluster ", names(batch.comparisons_pre), sep = "")
    colnames(A) <- paste("Cluster ", names(batch.comparisons_pre), sep = "")
    rownames(B) <- paste("Cluster ", names(batch.comparisons_post), sep = "")
    colnames(B) <- paste("Cluster ", names(batch.comparisons_post), sep = "")
    
    A_molten <- melt(as.matrix(A))
    names(A_molten)[c(1:3)] <- c("ClusterA", "ClusterB", "pearson.r")
    B_molten <- melt(as.matrix(B))
    names(B_molten)[c(1:3)] <- c("ClusterA", "ClusterB", "pearson.r")
    
    # generate heat map
    plt.cluster_intercor_heatmap_pre[[plt.label[k]]] <- ggplot(data = A_molten,
                                                               aes(x = ClusterA, y = ClusterB, fill = pearson.r)) + 
      geom_raster() +
      scale_fill_distiller(palette = "RdYlBu", limits = c(-1,1)) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            axis.text.y = element_text(angle = 0, hjust = 1)) + 
      ggtitle(paste("Pre: ",contrast.combinations[k,1], " vs. ", contrast.combinations[k,2], sep = "") ) + 
      xlab("Cluster ID") + ylab("Cluster ID")
    
    
    plt.cluster_intercor_heatmap_post[[plt.label[k]]] <- ggplot(data = B_molten,
                                                                aes(x = ClusterA, y = ClusterB, fill = pearson.r)) + 
      geom_raster() +
      scale_fill_distiller(palette = "RdYlBu", limits = c(-1,1)) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1),
            axis.text.y = element_text(angle = 0, hjust = 1)) + 
      ggtitle(paste("Post: ", contrast.combinations[k,1], " vs. ", contrast.combinations[k,2], sep = "") ) + 
      xlab("Cluster ID") + ylab("Cluster ID")
    
    plt.cluster_intercor_heatmap_cow[[plt.label[k]]] <- list(pre = plt.cluster_intercor_heatmap_pre[[plt.label[k]]], 
                                                             post = plt.cluster_intercor_heatmap_post[[plt.label[k]]])
    
    
    if (print.inline){ 
      print(plt.cluster_intercor_heatmap_pre[[plt.label[k]]])
      print(plt.cluster_intercor_heatmap_post[[plt.label[k]]])
    }
    
  }
}
```


```{r TYPE I INPUT interbatch cluster correlation, fig.height= 5, fig.width=5}
if (input.type == 1){
  # NOTE: requires integrated object as input

  A <- matrix(0, nrow = length(batch.comparisons_pre), ncol = dim(contrast.combinations)[1])
  B <- A
  
  for(i in 1:length(batch.comparisons_pre)){
    for (j in 1:dim(contrast.combinations)[1]){
      A[i,j] <- cor(batch.comparisons_pre[[i]][ ,contrast.combinations[j,1]], batch.comparisons_pre[[i]][ ,contrast.combinations[j,2]])
      B[i,j] <- cor(batch.comparisons_post[[i]][ ,contrast.combinations[j,1]], batch.comparisons_post[[i]][ ,contrast.combinations[j,2]])
    }
  }
  
  # specify row and column names
  rownames(A) <- paste("Cluster ", names(batch.comparisons_pre), sep = "")
  colnames(A) <- paste(contrast.combinations[,1], " vs. ", contrast.combinations[,2], sep = "")
  rownames(B) <- paste("Cluster ", names(batch.comparisons_post), sep = "")
  colnames(B) <- paste(contrast.combinations[,1], " vs. ", contrast.combinations[,2], sep = "")
  
  A_molten <- melt(as.matrix(A))
  names(A_molten)[c(1:3)] <- c("Cluster", "Comparison", "pearson.r")
  B_molten <- melt(as.matrix(B))
  names(B_molten)[c(1:3)] <- c("Cluster", "Comparison", "pearson.r")
  
  # generate heat map
  plt.cluster_match_heatmap_pre <- ggplot(data = A_molten,
                                          aes(x = Comparison, y = Cluster, fill = pearson.r)) + 
    geom_raster() +
    scale_fill_distiller(palette = "RdYlBu", limit = c(0,1)) +
    theme(axis.text.x = element_text(angle = 25, hjust = 1),
          axis.text.y = element_text(angle = 0, hjust = 1)) + 
    ggtitle("Pre: Interbatch Cluster Correlations" ) + 
    xlab("Batch Comparison") + ylab("Cluster ID")
  
  plt.cluster_match_heatmap_post <- ggplot(data = B_molten,
                                           aes(x = Comparison, y = Cluster, fill = pearson.r)) + 
    geom_raster() +
    scale_fill_distiller(palette = "RdYlBu", limit = c(0,1)) +
    theme(axis.text.x = element_text(angle = 25, hjust = 1),
          axis.text.y = element_text(angle = 0, hjust = 1)) + 
    ggtitle("Post: Interbatch Cluster Correlations" ) + 
    xlab("Batch Comparison") + ylab("Cluster ID")
  
  plt.cluster_match_heatmap_cow <- list(pre = plt.cluster_match_heatmap_pre,
                                        post = plt.cluster_match_heatmap_post)
  
  
  if (print.inline){ 
    print(plt.cluster_match_heatmap_pre)
    print(plt.cluster_match_heatmap_post)
  }
  
}

```
```{r TYPE I INPUT cor cell number vs batch}

if (input.type == 1){
  n.cell_pre <- rowSums(cell.count_pre)
  n.cell_post <- rowSums(cell.count_post)
  n.cell <- rowMeans(cbind(n.cell_pre, n.cell_post))
  
  df.cell_cor_pre <- as.data.frame(rowMeans(A))
  df.cell_cor_pre <- cbind(n.cell, df.cell_cor_pre)
  df.cell_cor_pre$integration <- "Pre"
  
  df.cell_cor_post <- as.data.frame(rowMeans(B))
  df.cell_cor_post <- cbind(n.cell, df.cell_cor_post)
  df.cell_cor_pre$integration <- "Post"
  
  colnames(df.cell_cor_pre)[1:2] <- c("x", "y")
  colnames(df.cell_cor_post)[1:2] <- c("x", "y")
  
  df.cell_cor <- rbind(df.cell_cor_pre, df.cell_cor_pre)
  
  min.val <- min(df.cell_cor$y)
  max.val <- max(df.cell_cor$y)
  
  df.pre_post_cluster_cor <- data.frame(pre = df.cell_cor_pre$y, post = df.cell_cor_post$y)
  
  plt.pre_post_cluster_cor <- ggplot(data = df.pre_post_cluster_cor, aes(x = pre, y = post)) +
    geom_point() + geom_abline(slope=1, intercept=0, linetype = "dashed") +
    xlim(min.val, 1) + ylim(min.val, 1) + 
    xlab("Pre-Integration") + 
    ylab("Post-Integration") + 
    ggtitle("Interbatch-Intracluster Pearson's Correlation (r)")
  
  if (print.inline){ 
    print(plt.pre_post_cluster_cor)
  }
}
```




```{r transfer labels}


transfer_labels <- function(so_ref, so_query, cells_shared){
  
  so_ref@assays[["SCT"]]@var.features <- so_ref@assays[["integrated"]]@var.features
  so_query@assays[["SCT"]]@var.features <- so_query@assays[["integrated"]]@var.features
  
  
  so_transferAnchors <- FindTransferAnchors(reference = so_ref, 
                                            query = so_query, 
                                            normalization.method = "SCT", 
                                            reduction = "cca",
                                            k.filter = 50)
  predictions <- TransferData(anchorset = so_transferAnchors, 
                              refdata = so_ref$CellType_True, 
                              weight.reduction = "cca")
  so_query <- AddMetaData(so_query, metadata = predictions)
  
  
  df.predall <- data.frame()
  for (i in 1:length(cells_shared)){
    prediction.match<- (so_query$predicted.id[so_query$CellType_True == cells_shared[i]] == so_query$CellType_True[so_query$CellType_True == cells_shared[i]] )
    df.pred <- as.data.frame(table(prediction.match))
    df.pred$Freq <- round(df.pred$Freq/ sum(df.pred$Freq), 3)
    df.pred$cellType <- cells_shared[i]
    df.predall <- rbind(df.predall, df.pred)
  }
  
  return(df.predall)
}

if (exists("cells_shared")){
  
  
  so_sct <- so
  DefaultAssay(so_sct) <- "SCT"
  so_sct.list <- SplitObject(so_sct, split.by = "batch")
  
  so_ref_1 <- so_sct.list[[1]]; so_query_1 <- so_sct.list[[2]]
  so_ref_2 <- so_sct.list[[2]]; so_query_2 <- so_sct.list[[1]]
  
  
  if (length(cells_shared) > 0) {
    df.predall_1 <- transfer_labels(so_ref_1, so_query_1, cells_shared)
    df.predall_2 <- transfer_labels(so_ref_2, so_query_2, cells_shared)
    
    
    plt.label_transfers_1 <- ggplot(data = df.predall_1, aes(y = Freq, x = cellType, fill = prediction.match, label = (Freq))) + 
      geom_bar(stat="identity") +
      geom_text(size = 3, position = position_stack(vjust = 0.5)) + 
      ggtitle("Pilot 1 reference, Pilot 2 query")
    
    plt.label_transfers_2 <- ggplot(data = df.predall_2, aes(y = Freq, x = cellType, fill = prediction.match, label = (Freq))) + 
      geom_bar(stat="identity") +
      geom_text(size = 3, position = position_stack(vjust = 0.5)) + 
      ggtitle("Pilot 2 reference, Pilot 1 query")
    
  }
}


```


Reproducibility (bulk)
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

<!-- ### Gene Expression: Reproducibility pre- and post-integration -->


```{r, echo = FALSE, eval = TRUE}

out <- lapply(seq_along(plt.comparison_complete), function(i) {
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", names(plt.comparison_complete)[i])) # tab header
  a2 <- knitr::knit_expand(text = "\n```{r, fig.width=13, fig.height=4}") # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\ngrid.draw(plt.comparison_complete[[%d]])", i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
})

# {.tabset}

```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`


Reproducibility (intrabatch)
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

```{r co1}

out <- lapply(seq_along(plt.cluster_intracor_heatmap_cow), function(i) {
  
  
  s1 <- paste("Intrabatch | ", names(plt.cluster_intracor_heatmap_pre)[i], sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1)) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.height=8, fig.width=20}", 
                                          paste("cnet_", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n cowplot::plot_grid(plotlist = plt.cluster_intracor_heatmap_cow[[%d]], 
                                          labels = names(plt.cluster_intracor_heatmap_cow[[%d]]), ncol = 2)", i, i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
  # }
})
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`



Reproducibility (interbatch)
===================================== 

Row {.tabset}
-----------------------------------------------------------------------

```{r co2}

out <- lapply(seq_along(plt.cluster_intercor_heatmap_cow), function(i) {
  
  s1 <- paste("Interbatch | ", names(plt.cluster_intercor_heatmap_cow)[i], sep = "")
  
  a1 <- knitr::knit_expand(text = sprintf("### %s\n", s1)) # tab header
  a2 <- knitr::knit_expand(text = sprintf("\n```{r %s, fig.height=8, fig.width=20}", 
                                          paste("intercor_heat_", i, sep = ""))) # start r chunk
  a3 <- knitr::knit_expand(text = sprintf("\n cowplot::plot_grid(plotlist = plt.cluster_intercor_heatmap_cow[[%d]], 
                                          ncol = 2, 
                                          labels = names(plt.cluster_intercor_heatmap_cow[[%d]]))", i,i)) 
  a4 <- knitr::knit_expand(text = "\n```\n") # end r chunk
  
  paste(a1, a2, a3, a4, collapse = '\n') # collapse together all lines with newline separator
  
  # }
})
```

`r paste(knitr::knit(text = paste(out, collapse = '\n')))`

Reproducibility (intracluster interbatch)
===================================== 

Row {.tabset}
-----------------------------------------------------------------------


### Intrabatch, Intracluster

```{r co3, fig.height=8, fig.width=20}

cowplot::plot_grid(plotlist = plt.cluster_match_heatmap_cow, 
                   ncol = 2,
                   labels = names(plt.cluster_match_heatmap_cow))

```

### pre vs post intracluster correlation

```{r plt.pre_post_cluster_cor}

print(plt.pre_post_cluster_cor)

```


UMAP Clusters
===================================== 


Row {.tabset}
-----------------------------------------------------------------------

### UMAP

```{r plt.umap_1}
print(plt.umap_1)
```


### UMAP by Batch

```{r plt.umap_2, fig.width=10, fig.height=5}
  print(plt.umap_2)

```




<!-- ### Experiments compared -->
<!-- ```{r valuebox1} -->
<!-- valueBox(n_batches) -->
<!-- ``` -->

<!-- ### Common groups between experiments -->
<!-- ```{r valuebox2} -->

<!-- if (length(cells_shared) > 0){ -->
<!--   valueBox(length(cells_shared)) -->
<!-- } else if (intra_cluster_batch_comparison) { -->
<!--   valueBox(length(clusters_shared)) -->
<!-- } -->
<!-- ``` -->

Label Transfer (known celltypes only)
===================================== 
### Label Transfer

```{r label.transfer}
try (grid.arrange(plt.label_transfers_1, plt.label_transfers_2, ncol=2), silent = TRUE)

```


```{r save analysis log and Rdata results}

# Run time
end.time <- proc.time()
elapsed.time <- round((end.time - start.time)[[3]], 2)
df.log[nrow(df.log)+1, 1] <- as.character("Run Time (s)")
df.log[nrow(df.log), 2] <- as.character(elapsed.time)

df.log_Module_3 <- df.log


```


Log (Module 3)
===================================== 

```{r table.log_current}

knitr::kable(df.log_Module_3)

```


