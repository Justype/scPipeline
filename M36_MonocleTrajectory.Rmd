---
title: "Variance Decomposition"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
editor_options: 
  chunk_output_type: inline
knit: (function(inputFile, encoding) {
    rmarkdown::render(input = inputFile,
      encoding = encoding,
      output_file = if (exists("user")){paste0(
        xfun::sans_ext(inputFile), '_',user, "_", format(Sys.Date(), "%d%m%y"), '.html'
      )} else {paste0(xfun::sans_ext(inputFile), '_',"Guest", "_", format(Sys.Date(), "%d%m%y"), '.html')},
      output_dir = if (exists("data.path")) paste0(data.path, "/HTML_Reports") else NULL
    )
  })
---



```{r setup, include=FALSE}

# clear global enviroment
rm(list = setdiff(ls(), c("data.path", "user")))
invisible({gc()})

# initiate timer
start.time <- proc.time()

# List of packages to load
packages2load <- c("Seurat", "scMiko", "DT", "lme4", "variancePartition",
                   "dplyr", "tidyr", "RColorBrewer", "ggplot2", 
                   "flexdashboard", "future", "BiocParallel",
                   "parallel", "doParallel", "foreach")

# load packages
invisible(lapply(packages2load, library, character.only = TRUE))

```



```{r analysis specifications}

# parameter specification
parameter.list <- list(
  # input.file = "M01_NM2_R1_test_300720.Rdata",
  # input.file = "Module16_UHN_0238_filtered_aggr_labledv2_300120.Rdata",
   input.file = "R304_M27_NM2_M02_BC2_allGBM_tumorStringent_tier1_251120.Rdata",
  cluster.resolution = 1,
  subsample_factor = 1,
  subset.data = data.frame(field = "Barcode", subgroups = "CT2A"),
  # subset.data = NA,
  species = "Mm"
)

barcode.list = list(
GL261 = "GL261",
CT2A = "CT2A"
)

filter.parameters <- list(
  include = NULL,
  omit = c(21, 22)
  # omit = c(9,12)    # e.g., c(19, 2) c(6,8,13) c(8,10)
)


# print inline
print.inline <- FALSE # OPTIONAL; TRUE/FALSE

# save PDF
save.pdf <- T
update.log <- T


```




```{r load data, warning = FALSE}

message("Importing data...")


# Specify data directories
dir.preprocessed <- "Preprocessed_Datasets/"

if (!exists("data.path") & !exists("user")) {
  stop("data.path and user variables do not exist in global enviroment. Ensure that these are specified in .Rprofile. If specified, try restarting Rstudio.")
}

# load query dataset
message("Importing data...")
input.file <- parameter.list$input.file
if (!grepl(".Rdata|.RData", input.file)) input.file <- paste0(input.file, ".Rdata")
load(paste(data.path, dir.preprocessed, input.file, sep = ""));

if (!exists("gNames.list")) gNames.list <- prepGeneList(so, objects())

t2d <- c("ica", "tsne", "nmf", "corr", "gsva", "deg", "integration.anchors")

# prep seurat object
prep.list <- prepSeurat2(so, e2s = gNames.list, 
                         species =  parameter.list$species, resolution= parameter.list$cluster.resolution, 
                         subset.data = parameter.list$subset.data, 
                         subsample = parameter.list$subsample_factor, M00_subgroup.path = "M00_subgroups.csv",
                         terms2drop = t2d, rmv.pattern = "so", keep.default.assay.only = T)

# unpack results
if (exists("so")) try({rm(so)}, silent = T)
so.query <- prep.list$so
current.assay <- prep.list$assay
n.cells <- prep.list$n.cell
rm(prep.list);
invisible({gc()})


```

```{r filter clusters}

if (exists("filter.parameters")){
  so.query <- clusterFilter(so.query, include = filter.parameters$include, omit = filter.parameters$omit)
  
  # TODO ensure that refactorization does not renumber values
  so.query@meta.data[["seurat_clusters"]] <- factor(as.character(so.query@meta.data[["seurat_clusters"]]))
  Idents(object = so.query) <- 'seurat_clusters'
}


```

```{r analysis log, include = FALSE}

message("Updating analysis log...")

# Initiate and fill analysis Log
df.log <- initiateLog("35, Clean Cluster")
df.log <- addLogEntry("PDF saved", save.pdf, df.log, "save.pdf")
df.log <- addLogEntry("Update Central Log", update.log, df.log, "update.log")
df.log <- addLogEntry("Print Inline", print.inline, df.log, "print.inline")

df.log <- addLogEntry("Input file", parameter.list$input.file, df.log, "input.file")
df.log <- addLogEntry("Cluster resolution", parameter.list$cluster.resolution, df.log, "cluster.resolution")
df.log <- addLogEntry("Subsample factor", parameter.list$subsample_factor, df.log, "subsample_factor")
df.log <- addLogEntry("data subset", parameter.list$subset.data, df.log, "subset.data")
df.log <- addLogEntry("species", parameter.list$species, df.log, "species")

```


```{r get past module logs, include = FALSE}
# determine prior log history
cur.env <- objects()
module.logs <- cur.env[grep("^df.log_Module",cur.env)]

```

```{r recode barcodes}


if (exists("barcode.list") && (length(barcode.list) > 0)){

df.meta <- so.query@meta.data

# relabel barcodes
bc.list <-barcode.list

df.meta$bc <- NA
for (i in 1:length(bc.list)){
  
  pattern <- bc.list[[i]]
  pattern.replace <- names(bc.list)[i]
  df.meta$bc[grepl(pattern, df.meta$Barcode)] <- pattern.replace
}

so.query@meta.data <- df.meta
  
} else {
  
  
  u.bc <- unique(so.query@meta.data[["Barcode"]])
  bc.list <- list()
  for (i in 1:length(u.bc)){
    bc.list[[i]] <- u.bc[i]
  }
  names(bc.list) <- u.bc
so.query@meta.data[["bc"]] <- so.query@meta.data[["Barcode"]]
}

```


```{r}

# jaccard_coeff2 <- function (R_idx, R_weight) 
# {
#   .Call(`_monocle3_jaccard_coeff`, R_idx, R_weight)
# }

calculateLW2 <- function (cds, k, neighbor_graph, reduction_method, verbose = FALSE) 
{
  if (verbose) {
    message("retrieve the matrices for Moran's I test...")
  }
  knn_res <- NULL
  principal_g <- NULL
  cell_coords <- reducedDims(cds)[[reduction_method]]
  if (neighbor_graph == "knn") {
    knn_res <- RANN::nn2(cell_coords, cell_coords, min(k + 
      1, nrow(cell_coords)), searchtype = "standard")[[1]]
  }
  else if (neighbor_graph == "principal_graph") {
    pr_graph_node_coords <- cds@principal_graph_aux[[reduction_method]]$dp_mst
    principal_g <- igraph::get.adjacency(cds@principal_graph[[reduction_method]])[colnames(pr_graph_node_coords), 
      colnames(pr_graph_node_coords)]
  }
  exprs_mat <- exprs(cds)
  if (neighbor_graph == "knn") {
    if (is.null(knn_res)) {
      knn_res <- RANN::nn2(cell_coords, cell_coords, min(k + 
        1, nrow(cell_coords)), searchtype = "standard")[[1]]
    }
    links <- jaccard_coeff(knn_res[, -1], F)
    links <- links[links[, 1] > 0, ]
    relations <- as.data.frame(links)
    colnames(relations) <- c("from", "to", "weight")
    knn_res_graph <- igraph::graph.data.frame(relations, 
      directed = T)
    knn_list <- lapply(1:nrow(knn_res), function(x) knn_res[x, 
      -1])
    region_id_names <- colnames(cds)
    id_map <- 1:ncol(cds)
    names(id_map) <- id_map
    points_selected <- 1:nrow(knn_res)
    knn_list <- lapply(points_selected, function(x) id_map[as.character(knn_res[x, 
      -1])])
  }
  else if (neighbor_graph == "principal_graph") {
    cell2pp_map <- cds@principal_graph_aux[[reduction_method]]$pr_graph_cell_proj_closest_vertex
    if (is.null(cell2pp_map)) {
      stop(paste("Error: projection matrix for each cell to principal", 
        "points doesn't exist, you may need to rerun learn_graph"))
    }
    cell2pp_map <- cell2pp_map[row.names(cell2pp_map) %in% 
      row.names(colData(cds)), , drop = FALSE]
    cell2pp_map <- cell2pp_map[colnames(cds), ]
    if (verbose) {
      message("Identify connecting principal point pairs ...")
    }
    knn_res <- RANN::nn2(cell_coords, cell_coords, min(k + 
      1, nrow(cell_coords)), searchtype = "standard")[[1]]
    principal_g_tmp <- principal_g
    diag(principal_g_tmp) <- 1
    cell_membership <- as.factor(cell2pp_map)
    uniq_member <- sort(unique(cell_membership))
    membership_matrix <- Matrix::sparse.model.matrix(~cell_membership + 
      0)
    colnames(membership_matrix) <- levels(uniq_member)
    feasible_space <- membership_matrix %*% Matrix::tcrossprod(principal_g_tmp[as.numeric(levels(uniq_member)), 
      as.numeric(levels(uniq_member))], membership_matrix)
    links <- jaccard_coeff(knn_res[, -1], F)
    links <- links[links[, 1] > 0, ]
    relations <- as.data.frame(links)
    colnames(relations) <- c("from", "to", "weight")
    knn_res_graph <- igraph::graph.data.frame(relations, 
      directed = T)
    tmp_a <- igraph::get.adjacency(knn_res_graph)
    block_size <- 10000
    num_blocks = ceiling(nrow(tmp_a)/block_size)
    if (verbose) {
      message("start calculating valid kNN graph ...")
    }
    tmp <- NULL
    for (j in 1:num_blocks) {
      if (j < num_blocks) {
        block_a <- tmp_a[((((j - 1) * block_size) + 
          1):(j * block_size)), ]
        block_b <- feasible_space[((((j - 1) * block_size) + 
          1):(j * block_size)), ]
      }
      else {
        block_a <- tmp_a[((((j - 1) * block_size) + 
          1):(nrow(tmp_a))), ]
        block_b <- feasible_space[((((j - 1) * block_size) + 
          1):(nrow(tmp_a))), ]
      }
      cur_tmp <- block_a * block_b
      if (is.null(tmp)) {
        tmp <- cur_tmp
      }
      else {
        tmp <- Matrix::rBind(tmp, cur_tmp)
      }
    }
    if (verbose) {
      message("Calculating valid kNN graph, done ...")
    }
    region_id_names <- colnames(cds)
    id_map <- 1:ncol(cds)
    names(id_map) <- id_map
    knn_list <- slam::rowapply_simple_triplet_matrix(slam::as.simple_triplet_matrix(tmp), 
      function(x) {
        res <- which(as.numeric(x) > 0)
        if (length(res) == 0) 
          res <- 0L
        res
      })
  }
  else {
    stop("Error: unrecognized neighbor_graph option")
  }
  names(knn_list) <- id_map[names(knn_list)]
  class(knn_list) <- "nb"
  attr(knn_list, "region.id") <- region_id_names
  attr(knn_list, "call") <- match.call()
  lw <- spdep::nb2listw(knn_list, zero.policy = TRUE)
  lw
}

# 
# rcpp_result_gen = Rcpp::wrap(jaccard_coeff(R_idx, R_weight))

# _monocle3_jaccard_coeff()
```
```{Rcpp firstChunk}
#include <Rcpp.h>
using namespace Rcpp;

// Compute jaccard coefficient between nearest-neighbor sets
//
// Weights of both i->j and j->i are recorded if they have intersection. In this case
// w(i->j) should be equal to w(j->i). In some case i->j has weights while j<-i has no
// intersections, only w(i->j) is recorded. This is determinded in code `if(u>0)`.
// The original method described in the phenograph paper is used to calculate the weight.
//
// Author: Chen Hao, Date: 25/09/2015; updated by Xiaojie Qiu Nov. 12, 2017

NumericMatrix jaccard_coeff_cpp(NumericMatrix idx, bool weight) {
  int nrow = idx.nrow(), ncol = idx.ncol(), r = 0;
  NumericMatrix weights(nrow*ncol, 3);

  for(int i = 0; i < nrow; i ++) {
    for(int j = 0; j < ncol; j ++) {
      int k = idx(i,j) - 1;

      weights(r, 0) = i + 1;
      weights(r, 1) = k + 1;
      weights(r, 2) = 1;

      if(weight == TRUE) {

        NumericVector nodei = idx(i, _);
        NumericVector nodej = idx(k, _);

        int u = intersect(nodei, nodej).size();  // count intersection number
        int v = 2 * ncol - u;  // count union number

        if(u>0) {
          // weights(r, 0) = i + 1;
          // weights(r, 1) = k + 1;
          // weights(r, 2) = u / (2.0 * ncol - u) / 2;  // symmetrize the graph

          weights(r, 2) = (double) u / (double) v;  // normalize the values
        }
      }

      r ++;

    }
  }

  weights(_, 2) = weights(_, 2) / max(weights(_, 2));

  return weights;
}

// [[Rcpp::export]]
NumericMatrix jaccard_coeff(SEXP R_idx, SEXP R_weight) {
  NumericMatrix idx(R_idx);
  bool weight = as<bool>(R_weight);

  return jaccard_coeff_cpp(idx, weight);
}
```


```{r}

my.moran.test2 <- function (x, listw, wc, alternative = "greater", randomisation = TRUE) 
{
  zero.policy = TRUE
  adjust.n = TRUE
  na.action = stats::na.fail
  drop.EI2 = FALSE
  xname <- deparse(substitute(x))
  wname <- deparse(substitute(listw))
  NAOK <- deparse(substitute(na.action)) == "na.pass"
  x <- na.action(x)
  na.act <- attr(x, "na.action")
  if (!is.null(na.act)) {
    subset <- !(1:length(listw$neighbours) %in% na.act)
    listw <- subset(listw, subset, zero.policy = zero.policy)
  }
  n <- length(listw$neighbours)
  if (n != length(x)) 
    stop("objects of different length")
  S02 <- wc$S0 * wc$S0
  res <- spdep::moran(x, listw, wc$n, wc$S0, zero.policy = zero.policy, 
    NAOK = NAOK)
  I <- res$I
  K <- res$K
  EI <- (-1)/wc$n1
  if (randomisation) {
    VI <- wc$n * (wc$S1 * (wc$nn - 3 * wc$n + 3) - wc$n * 
      wc$S2 + 3 * S02)
    tmp <- K * (wc$S1 * (wc$nn - wc$n) - 2 * wc$n * wc$S2 + 
      6 * S02)
    if (tmp > VI) 
      warning(paste0("Kurtosis overflow,\ndistribution of variable does ", 
        "not meet test assumptions"))
    VI <- (VI - tmp)/(wc$n1 * wc$n2 * wc$n3 * S02)
    if (!drop.EI2) 
      VI <- (VI - EI^2)
    if (VI < 0) 
      warning(paste0("Negative variance,\ndistribution of variable does ", 
        "not meet test assumptions"))
  }
  else {
    VI <- (wc$nn * wc$S1 - wc$n * wc$S2 + 3 * S02)/(S02 * 
      (wc$nn - 1))
    if (!drop.EI2) 
      VI <- (VI - EI^2)
    if (VI < 0) 
      warning(paste0("Negative variance,\ndistribution of variable does ", 
        "not meet test assumptions"))
  }
  ZI <- (I - EI)/sqrt(VI)
  statistic <- ZI
  names(statistic) <- "Moran I statistic standard deviate"
  if (alternative == "two.sided") 
    PrI <- 2 * stats::pnorm(abs(ZI), lower.tail = FALSE)
  else if (alternative == "greater") 
    PrI <- stats::pnorm(ZI, lower.tail = FALSE)
  else PrI <- stats::pnorm(ZI)
  if (!is.finite(PrI) || PrI < 0 || PrI > 1) 
    warning("Out-of-range p-value: reconsider test arguments")
  vec <- c(I, EI, VI)
  names(vec) <- c("Moran I statistic", "Expectation", "Variance")
  method <- paste("Moran I test under", ifelse(randomisation, 
    "randomisation", "normality"))
  res <- list(statistic = statistic, p.value = PrI, estimate = vec)
  if (!is.null(na.act)) 
    attr(res, "na.action") <- na.act
  class(res) <- "htest"
  res
}



my.geary.test2 <- function (x, listw, wc, randomisation = TRUE, alternative = "greater"){
  zero.policy = TRUE
  adjust.n = TRUE
  spChk = NULL
  alternative <- match.arg(alternative, c("less", "greater", 
    "two.sided"))
  if (!inherits(listw, "listw")) 
    stop(paste(deparse(substitute(listw)), "is not a listw object"))
  if (!is.numeric(x)) 
    stop(paste(deparse(substitute(x)), "is not a numeric vector"))
  if (any(is.na(x))) 
    stop("NA in X")
  n <- length(listw$neighbours)
  if (n != length(x)) 
    stop("objects of different length")
  if (is.null(spChk)) 
    spChk <- spdep::get.spChkOption()
  if (spChk && !spdep::chkIDs(x, listw)) 
    stop("Check of data and weights ID integrity failed")
  S02 <- wc$S0 * wc$S0
  res <- spdep::geary(x, listw, wc$n, wc$n1, wc$S0, zero.policy)
  C <- res$C
  if (is.na(C)) 
    stop("NAs generated in geary - check zero.policy")
  K <- res$K
  EC <- 1
  if (randomisation) {
    VC <- (wc$n1 * wc$S1 * (wc$nn - 3 * n + 3 - K * wc$n1))
    VC <- VC - ((1/4) * (wc$n1 * wc$S2 * (wc$nn + 3 * n - 
      6 - K * (wc$nn - n + 2))))
    VC <- VC + (S02 * (wc$nn - 3 - K * (wc$n1^2)))
    VC <- VC/(n * wc$n2 * wc$n3 * S02)
  }
  else {
    VC <- ((2 * wc$S1 + wc$S2) * wc$n1 - 4 * S02)/(2 * (n + 
      1) * S02)
  }
  ZC <- (EC - C)/sqrt(VC)
  statistic <- ZC
  names(statistic) <- "Geary C statistic standard deviate"
  PrC <- NA
  if (is.finite(ZC)) {
    if (alternative == "two.sided") 
      PrC <- 2 * stats::pnorm(abs(ZC), lower.tail = FALSE)
    else if (alternative == "greater") 
      PrC <- stats::pnorm(ZC, lower.tail = FALSE)
    else PrC <- stats::pnorm(ZC)
    if (!is.finite(PrC) || PrC < 0 || PrC > 1) 
      warning("Out-of-range p-value: reconsider test arguments")
  }
  vec <- c(C, EC, VC)
  names(vec) <- c("Geary C statistic", "Expectation", "Variance")
  method <- paste("Geary C test under", ifelse(randomisation, 
    "randomisation", "normality"))
  data.name <- paste(deparse(substitute(x)), "\nweights:", 
    deparse(substitute(listw)), "\n")
  res <- list(statistic = statistic, p.value = PrC, estimate = vec, 
    alternative = ifelse(alternative == "two.sided", alternative, 
      paste("Expectation", alternative, "than statistic")), 
    method = method, data.name = data.name)
  class(res) <- "htest"
  res
}

```


```{r}

# cds, neighbor_graph = c("knn", "principal_graph"), 
#   reduction_method = "UMAP", k = 25, method = c("Moran_I"), 
#   alternative = "greater", expression_family = "quasipoisson",  cores = 1, verbose = FALSE
# "knn", 
graph_test2 <- function(cds, method = "Moran_I",  neighbor_graph = c("principal_graph"), reduction_method = "UMAP",
                                        k = 25, alternative = "greater", expression_family = "quasipoisson", cores = 3, verbose = FALSE){
  
  # cds <- so.cds
  # neighbor_graph =  "principal_graph" #c("knn", "principal_graph")
  #   reduction_method = "UMAP"
  #   k = 25
  #   method = c("Moran_I")
  # 
  # alternative = "greater"
  # expression_family = "quasipoisson"
  # cores = 20
  # verbose = FALSE
  # 
  
  stopifnot(neighbor_graph %in% c("knn", "principal_graph"))
  if (length(neighbor_graph) > 1) neighbor_graph <- neighbor_graph[1]
  
  # neighbor_graph <- match.arg(neighbor_graph)
  lw <- calculateLW2(cds, k = k, verbose = verbose, neighbor_graph = neighbor_graph,  reduction_method = reduction_method)
  if (verbose)  message("Performing Moran's I test: ...")

  exprs_mat <- SingleCellExperiment::counts(cds)[, attr(lw, "region.id"), drop = FALSE]
  sz <- size_factors(cds)[attr(lw, "region.id")]
  wc <- spdep::spweights.constants(lw, zero.policy = TRUE,  adjust.n = TRUE)
  
  
  
  #############################################################################
  # x <- 20676
  
  # start cluster
  cl <- parallel::makeCluster(cores)
  doParallel::registerDoParallel(cl)
  
  
  # exprs_mat <- exprs_mat[1:100, ]
  
  # iterate through each gene signature list
  score.results <- foreach(i = 1:nrow(exprs_mat), .packages = c("scMiko", "Seurat", "dplyr"))  %dopar% {
    
    x <- i
    exprs_val <- exprs_mat[x, ]
    if (expression_family %in% c("uninormal", "binomialff")) {
      exprs_val <- exprs_val
    } else {
      exprs_val <- log10(exprs_val/sz + 0.1)
    }
    test_res <- tryCatch({
      if (method == "Moran_I") {
        mt <- suppressWarnings(my.moran.test2(exprs_val, lw, wc, alternative = alternative))
        data.frame(status = "OK", p_value = mt$p.value, 
                   morans_test_statistic = mt$statistic, 
                   morans_I = mt$estimate[["Moran I statistic"]])
      }
      else if (method == "Geary_C") {
        gt <- suppressWarnings(my.geary.test2(exprs_val, lw, wc, alternative = alternative))
        data.frame(status = "OK", p_value = gt$p.value, 
                   geary_test_statistic = gt$statistic, 
                   geary_C = gt$estimate[["Geary C statistic"]])
      }
    }, error = function(e) {
      data.frame(status = "FAIL", p_value = NA, morans_test_statistic = NA, morans_I = NA)
    })
    
    return(test_res)
    
  }
  stopCluster(cl)
  
  
  
  if (verbose) message("returning results: ...")
  score.results <- do.call(rbind.data.frame, score.results)
  row.names(score.results) <- row.names(exprs_mat)
  score.results <- merge(score.results, rowData(cds), by = "row.names")
  row.names(score.results) <- score.results[, 1]
  score.results[, 1] <- NULL
  score.results$q_value <- 1
  score.results$q_value[which(score.results$status == "OK")] <- stats::p.adjust(subset(score.results, 
                                                                             status == "OK")[, "p_value"], method = "BH")
  score.results$status = as.character(score.results$status)
  score.results[row.names(cds), ]
}


```


```{r}
# devtools::install_github('cole-trapnell-lab/monocle3')

library(monocle3)
library(SeuratWrappers)


# cds <- learn_graph(cds, verbose = FALSE, 
#                    learn_graph_control = list(minimal_branch_len = 7,
#                                               geodesic_distance_ratio = 0.5))

so.cds <- as.cell_data_set(so.query, assay = "RNA")
so.cds <- cluster_cells(cds = so.cds, reduction_method = "UMAP", partition_qval = 0.05)
# so.cds <- partitionCells(so.cds)
so.cds <- learn_graph(so.cds, use_partition = TRUE, learn_graph_control =list(minimal_branch_len = 7,
                                              geodesic_distance_ratio = 0.5))
so.cds <- order_cells(so.cds, reduction_method = "UMAP", root_cells = NULL)

plot_cells(
  cds = so.cds,
  color_cells_by = "pseudotime",
  show_trajectory_graph = TRUE
)


so.query <- AddMetaData(
  object = so.query,
  metadata = so.cds@principal_graph_aux@listData$UMAP$pseudotime,
  col.name = "pt"
)


FeaturePlot(so.query, c("pt"), pt.size = 0.1) & scale_color_viridis_c()

# RESUME HERE!!!!!
plot_cells(so.cds, color_cells_by = "partition")

# fData(so.cds)$gene_short_name <- rownames(so.cds)
cds_subset <- so.cds[rownames(so.cds) %in% so.query@assays[["RNA"]]@var.features,]

pr_graph_test_res <- graph_test2(cds = cds_subset, neighbor_graph="principal_graph", cores=20)

df.gt <- bind_cols(pr_graph_test_res@listData) 

df.gt$genes <- pr_graph_test_res@rownames


df.gt.top <- df.gt %>% dplyr::filter(q_value == 0)
# df.gt.top <- df.gt %>% dplyr::filter(morans_I > 0.1)
# df.mark <- graph_test(
#   so.cds,
#   neighbor_graph = c("knn", "principal_graph"),
#   reduction_method = "UMAP",
#   k = 25,
#   method = c("Moran_I"),
#   alternative = "greater",
#   expression_family = "quasipoisson",
#   cores = 10,
#   verbose = FALSE
# )

fData(so.cds)$gene_short_name <- rownames(so.cds)
genes_plt <- df.gt.top$genes[10:12]
plot_cells(so.cds, genes = genes_plt,
           show_trajectory_graph = T,
           label_cell_groups = T,
           label_leaves = T)


reduction_method <- "UMAP"
ica_space_df <- t(so.cds@principal_graph_aux[[reduction_method]]$dp_mst) %>% 
  as.data.frame() 
colnames(ica_space_df) <-c("prin_graph_dim_1", "prin_graph_dim_2")

ica_space_df <- ica_space_df %>% dplyr::mutate(sample_name = rownames(.),
                                               sample_state = rownames(.))

dp_mst <- cds@principal_graph[[reduction_method]]
edge_df <- dp_mst %>% igraph::as_data_frame() %>% 
  dplyr::select_(source = "from", target = "to") %>% 
  dplyr::left_join(ica_space_df %>% 
                     dplyr::select_(source = "sample_name", 
                                    source_prin_graph_dim_1 = "prin_graph_dim_1", 
                                    source_prin_graph_dim_2 = "prin_graph_dim_2"), by = "source") %>% 
  dplyr::left_join(ica_space_df %>% 
                     dplyr::select_(target = "sample_name", 
                                    target_prin_graph_dim_1 = "prin_graph_dim_1",  
                                    target_prin_graph_dim_2 = "prin_graph_dim_2"), by = "target")

g <- ggplot() + geom_segment(aes_string(x = "source_prin_graph_dim_1", 
                                        y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", 
                                        yend = "target_prin_graph_dim_2"), size = 1, 
                             color = I("grey28"), linetype = "solid", 
                             na.rm = TRUE, data = edge_df) + theme_miko()

plot(g) 


if (ncol(so.query)> 35000) {
  aps <- F
  pt.size <- autoPointSize(ncol(so.query))
} else {
  aps <- T
  pt.size <- 1
}

df.gt.top2 <- df.gt.top %>% dplyr::arrange(-morans_I)
genes_plt <-df.gt.top2$genes


for (i in 221:250){
  gene.ind <- i
  
  gene.of.interest <- "Ext1"
  plt.expression <- Nebulosa::plot_density(
            object = so.query,
            features = gene.of.interest,
            slot = "data",
            joint = FALSE,
            reduction = "umap",
            dims = c(1, 2),
            method = c("ks", "wkde"),
            adjust = 1,
            size = pt.size,
            shape = 16,
            combine = TRUE,
            pal = "viridis"
          )  +
            theme_miko(legend = T) +
            # viridis::scale_color_viridis(option = "A") +
            labs(title = "", subtitle =gene.of.interest)

plt.this <- plt.expression  + geom_segment(aes_string(x = "source_prin_graph_dim_1", 
                                        y = "source_prin_graph_dim_2", xend = "target_prin_graph_dim_1", 
                                        yend = "target_prin_graph_dim_2"), size = 1, 
                             color = I("tomato"), linetype = "solid", 
                             na.rm = TRUE, data = edge_df) + theme_miko()

print(plt.this)

plt.expression
}

# Dlc1, Plcb1, Zbtb20, Kif26b, Top2a, Robo2, Cped1, Lama4, Gpr149, Mki67, Ebf1, Robo1, Itga1, Vcan, Prrx1, Postn, Col3a1, Tanc1, Rora, Ect2, Pct1, Pvt1, Ankrd44, Gm26917, Pcdh9, Knl1, Adam12, Plcl1, Fap, Fbxl7
```


```{r gene modules}

module.df  <- find_gene_modules(so.cds, resolution=1e-2)

module.df %>%
  ggplot(aes(x = dim_1, y = dim_2, color = module)) + 
  geom_point() + 
  xlab("UMAP 1") + ylab("UMAP 2") + 
  labs(title = "Gene Network", subtitle = "UMAP") + 
  theme_miko(legend = T)

cell.df <- tibble::tibble(cell=row.names(colData(so.cds)), 
                                cell_group=clusters(so.cds)[colnames(so.cds)])
agg_mat <- aggregate_gene_expression(so.cds, module.df, cell.df)
row.names(agg_mat) <- stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) <- stringr::str_c("Partition ", colnames(agg_mat))

pheatmap::pheatmap(agg_mat, cluster_rows=F, cluster_cols=F,
                   scale="column", clustering_method="ward.D2",
                   fontsize=6)


# plot_cells(so.cds,
#            genes=module.df,
#            # group_cells_by="cluster",
#            # color_cells_by="cluster",
#            show_trajectory_graph=FALSE)

```

```{r}
# scale_color_d3(palette = "category20b")

AFD_genes <- c("Cald1")
AFD_lineage_cds <- so.cds[rownames(rowData(so.cds)) %in% AFD_genes, ]

plot_genes_in_pseudotime(AFD_lineage_cds,
                         # color_cells_by="embryo.time.bin",
                         label_by_short_name = F,
                         min_expr=0)
# a <- 
```

